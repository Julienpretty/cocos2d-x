diff --git a/cocos2d/cocos/2d/CCActionCamera.cpp b/cocos2d/cocos/2d/CCActionCamera.cpp
index 8e85211440..d84198cab1 100644
--- a/cocos2d/cocos/2d/CCActionCamera.cpp
+++ b/cocos2d/cocos/2d/CCActionCamera.cpp
@@ -106,7 +106,7 @@ void ActionCamera::setUp(const Vec3& up)
 void ActionCamera::updateTransform()
 {
     Mat4 lookupMatrix;
-    Mat4::createLookAt(_eye.x, _eye.y, _eye.z, _center.x, _center.y, _center.z, _up.x, _up.y, _up.z, lookupMatrix);
+    Mat4::createLookAt(_eye.x, _eye.y, _eye.z, _center.x, _center.y, _center.z, _up.x, _up.y, _up.z, &lookupMatrix);
 
     Vec2 anchorPoint = _target->getAnchorPointInPoints();
 
@@ -117,7 +117,7 @@ void ActionCamera::updateTransform()
     if (needsTranslation)
     {
         Mat4 t;
-        Mat4::createTranslation(anchorPoint.x, anchorPoint.y, 0, t);
+        Mat4::createTranslation(anchorPoint.x, anchorPoint.y, 0, &t);
         mv = mv * t;
     }
 
@@ -126,7 +126,7 @@ void ActionCamera::updateTransform()
     if (needsTranslation)
     {
         Mat4 t;
-        Mat4::createTranslation(-anchorPoint.x, -anchorPoint.y, 0, t);
+        Mat4::createTranslation(-anchorPoint.x, -anchorPoint.y, 0, &t);
         mv = mv * t;
     }
 
diff --git a/cocos2d/cocos/2d/CCActionInstant.h b/cocos2d/cocos/2d/CCActionInstant.h
index ac1eac3493..6933a43459 100644
--- a/cocos2d/cocos/2d/CCActionInstant.h
+++ b/cocos2d/cocos/2d/CCActionInstant.h
@@ -353,8 +353,8 @@ public:
     {
         if (sel != _selectorTarget)
         {
-            CC_SAFE_RETAIN(sel)
-            CC_SAFE_RELEASE(_selectorTarget)
+            CC_SAFE_RETAIN(sel);
+            CC_SAFE_RELEASE(_selectorTarget);
             _selectorTarget = sel;
         }
     }
diff --git a/cocos2d/cocos/2d/CCActionInterval.cpp b/cocos2d/cocos/2d/CCActionInterval.cpp
index 0bd7d2a8dd..d45fe4b01c 100644
--- a/cocos2d/cocos/2d/CCActionInterval.cpp
+++ b/cocos2d/cocos/2d/CCActionInterval.cpp
@@ -52,6 +52,7 @@
 #include <cstddef>
 #include <new>
 #include <type_traits>
+#include <chrono>
 
 using namespace std::chrono_literals;
 
diff --git a/cocos2d/cocos/2d/CCActionInterval.h b/cocos2d/cocos/2d/CCActionInterval.h
index 04adab0725..7d910896de 100644
--- a/cocos2d/cocos/2d/CCActionInterval.h
+++ b/cocos2d/cocos/2d/CCActionInterval.h
@@ -176,8 +176,8 @@ public:
     {
         if (_innerAction != action)
         {
-            CC_SAFE_RETAIN(action)
-            CC_SAFE_RELEASE(_innerAction)
+            CC_SAFE_RETAIN(action);
+            CC_SAFE_RELEASE(_innerAction);
             _innerAction = action;
         }
     }
@@ -1387,9 +1387,9 @@ public:
 
 protected:
     std::vector<float> _splitTimes;
-    int _nextFrame = 0;
+    std::size_t _nextFrame = 0;
     SpriteFrame* _origFrame = nullptr;
-    int _currFrameIndex = 0;
+    std::size_t _currFrameIndex = 0;
     unsigned int _executedLoops = 0;
     Animation* _animation = nullptr;
 
diff --git a/cocos2d/cocos/2d/CCAtlasNode.cpp b/cocos2d/cocos/2d/CCAtlasNode.cpp
index 6746d1579c..057c7adaf5 100644
--- a/cocos2d/cocos/2d/CCAtlasNode.cpp
+++ b/cocos2d/cocos/2d/CCAtlasNode.cpp
@@ -3,7 +3,8 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -26,23 +27,13 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCAtlasNode.h>
-
-#include <cocos/2d/CCNode.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCQuadCommand.h>
-#include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTexture2D.h>
 #include <cocos/renderer/CCTextureAtlas.h>
+#include <cocos/base/CCDirector.h>
 #include <cocos/renderer/CCTextureCache.h>
-
-#include <new>
+#include <cocos/base/ccUtils.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/CCRenderer.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 
@@ -51,26 +42,45 @@ NS_CC_BEGIN
 // AtlasNode - Creation & Init
 
 AtlasNode::AtlasNode()
-: _itemsPerRow(0)
-, _itemsPerColumn(0)
-, _itemWidth(0)
-, _itemHeight(0)
-, _textureAtlas(nullptr)
-, _isOpacityModifyRGB(false)
-, _quadsToDraw(0)
-, _uniformColor(0)
-, _ignoreContentScaleFactor(false)
 {
+    auto& pipelineDescriptor = _quadCommand.getPipelineDescriptor();
+    _programState = new (std::nothrow) backend::ProgramState(positionTextureColor_vert, positionTextureColor_frag);
+    pipelineDescriptor.programState = _programState;
+    _mvpMatrixLocation = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    _textureLocation = pipelineDescriptor.programState->getUniformLocation("u_texture");
+  
+    auto vertexLayout = _programState->getVertexLayout();
+  //a_position
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_POSITION, 
+                               _programState->getAttributeLocation(backend::Attribute::POSITION), 
+                               backend::VertexFormat::FLOAT3, 
+                               0, 
+                               false);
+   
+    //a_texCoord
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_TEXCOORD, 
+                               _programState->getAttributeLocation(backend::Attribute::TEXCOORD), 
+                               backend::VertexFormat::FLOAT2, offsetof(V3F_C4B_T2F, texCoords), 
+                               false);
+   
+    //a_color
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_COLOR, 
+                               _programState->getAttributeLocation(backend::Attribute::COLOR),
+                               backend::VertexFormat::UBYTE4, offsetof(V3F_C4B_T2F, colors),
+                               true);
+    
+    vertexLayout->setLayout(sizeof(V3F_C4B_T2F));
 }
 
 AtlasNode::~AtlasNode()
 {
     CC_SAFE_RELEASE(_textureAtlas);
+    CC_SAFE_RELEASE(_programState);
 }
 
-AtlasNode* AtlasNode::create(const std::string& tile, int tileWidth, int tileHeight, int itemsToRender)
+AtlasNode * AtlasNode::create(const std::string& tile, int tileWidth, int tileHeight, int itemsToRender)
 {
-    AtlasNode* ret = new (std::nothrow) AtlasNode();
+    AtlasNode * ret = new (std::nothrow) AtlasNode();
     if (ret->initWithTileFile(tile, tileWidth, tileHeight, itemsToRender))
     {
         ret->autorelease();
@@ -83,13 +93,13 @@ AtlasNode* AtlasNode::create(const std::string& tile, int tileWidth, int tileHei
 bool AtlasNode::initWithTileFile(const std::string& tile, int tileWidth, int tileHeight, int itemsToRender)
 {
     CCASSERT(tile.size() > 0, "file size should not be empty");
-    Texture2D* texture = Director::getInstance()->getTextureCache()->addImage(tile);
+    Texture2D *texture = Director::getInstance()->getTextureCache()->addImage(tile);
     return initWithTexture(texture, tileWidth, tileHeight, itemsToRender);
 }
 
 bool AtlasNode::initWithTexture(Texture2D* texture, int tileWidth, int tileHeight, int itemsToRender)
 {
-    _itemWidth = tileWidth;
+    _itemWidth  = tileWidth;
     _itemHeight = tileHeight;
 
     _colorUnmodified = Color3B::WHITE;
@@ -98,13 +108,14 @@ bool AtlasNode::initWithTexture(Texture2D* texture, int tileWidth, int tileHeigh
     _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
 
     _textureAtlas = new (std::nothrow) TextureAtlas();
-    _textureAtlas->initWithTexture(texture, itemsToRender);
 
-    if (!_textureAtlas)
+    if (! _textureAtlas)
     {
         CCLOG("cocos2d: Could not initialize AtlasNode. Invalid Texture.");
         return false;
     }
+    
+    _textureAtlas->initWithTexture(texture, itemsToRender);
 
     this->updateBlendFunc();
     this->updateOpacityModifyRGB();
@@ -113,25 +124,23 @@ bool AtlasNode::initWithTexture(Texture2D* texture, int tileWidth, int tileHeigh
 
     _quadsToDraw = itemsToRender;
 
-    // shader stuff
-    setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP, texture));
-
     return true;
 }
 
+
 // AtlasNode - Atlas generation
 
 void AtlasNode::calculateMaxItems()
 {
     Size s = _textureAtlas->getTexture()->getContentSize();
-
+    
     if (_ignoreContentScaleFactor)
     {
         s = _textureAtlas->getTexture()->getContentSizeInPixels();
     }
-
-    _itemsPerColumn = static_cast<int>(s.height / _itemHeight);
-    _itemsPerRow = static_cast<int>(s.width / _itemWidth);
+    
+    _itemsPerColumn = (int)(s.height / _itemHeight);
+    _itemsPerRow = (int)(s.width / _itemWidth);
 }
 
 void AtlasNode::updateAtlasValues()
@@ -140,11 +149,18 @@ void AtlasNode::updateAtlasValues()
 }
 
 // AtlasNode - draw
-void AtlasNode::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
-{
-    // ETC1 ALPHA supports.
-    _quadCommand.init(_globalZOrder, _textureAtlas->getTexture(), getGLProgramState(), _blendFunc, _textureAtlas->getQuads(), _quadsToDraw, transform, flags);
-
+void AtlasNode::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
+{    
+    if( _textureAtlas->getTotalQuads() == 0 )
+        return;
+    
+    auto programState = _quadCommand.getPipelineDescriptor().programState;
+    programState->setTexture(_textureLocation, 0, _textureAtlas->getTexture()->getBackendTexture());
+    
+    const auto& projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    programState->setUniform(_mvpMatrixLocation, projectionMat.m, sizeof(projectionMat.m));
+    
+    _quadCommand.init(_globalZOrder, _textureAtlas->getTexture(), _blendFunc, _textureAtlas->getQuads(), _quadsToDraw, transform, flags);
     renderer->addCommand(&_quadCommand);
 }
 
@@ -152,7 +168,7 @@ void AtlasNode::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
 
 const Color3B& AtlasNode::getColor() const
 {
-    if (_isOpacityModifyRGB)
+    if(_isOpacityModifyRGB)
     {
         return _colorUnmodified;
     }
@@ -164,21 +180,21 @@ void AtlasNode::setColor(const Color3B& color3)
     Color3B tmp = color3;
     _colorUnmodified = color3;
 
-    if (_isOpacityModifyRGB)
+    if( _isOpacityModifyRGB )
     {
-        tmp.r = tmp.r * _displayedOpacity / 255;
-        tmp.g = tmp.g * _displayedOpacity / 255;
-        tmp.b = tmp.b * _displayedOpacity / 255;
+        tmp.r = tmp.r * _displayedOpacity/255;
+        tmp.g = tmp.g * _displayedOpacity/255;
+        tmp.b = tmp.b * _displayedOpacity/255;
     }
     Node::setColor(tmp);
 }
 
-void AtlasNode::setOpacity(GLubyte opacity)
+void AtlasNode::setOpacity(uint8_t opacity)
 {
     Node::setOpacity(opacity);
 
     // special opacity for premultiplied textures
-    if (_isOpacityModifyRGB)
+    if( _isOpacityModifyRGB )
         this->setColor(_colorUnmodified);
 }
 
@@ -211,14 +227,14 @@ const BlendFunc& AtlasNode::getBlendFunc() const
     return _blendFunc;
 }
 
-void AtlasNode::setBlendFunc(const BlendFunc& blendFunc)
+void AtlasNode::setBlendFunc(const BlendFunc &blendFunc)
 {
     _blendFunc = blendFunc;
 }
 
 void AtlasNode::updateBlendFunc()
 {
-    if (!_textureAtlas->getTexture()->hasPremultipliedAlpha())
+    if( ! _textureAtlas->getTexture()->hasPremultipliedAlpha() )
     {
         _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
         setOpacityModifyRGB(false);
@@ -230,14 +246,14 @@ void AtlasNode::updateBlendFunc()
     }
 }
 
-void AtlasNode::setTexture(Texture2D* texture)
+void AtlasNode::setTexture(Texture2D *texture)
 {
     _textureAtlas->setTexture(texture);
     this->updateBlendFunc();
     this->updateOpacityModifyRGB();
 }
 
-Texture2D* AtlasNode::getTexture() const
+Texture2D * AtlasNode::getTexture() const
 {
     return _textureAtlas->getTexture();
 }
@@ -249,17 +265,17 @@ void AtlasNode::setTextureAtlas(TextureAtlas* textureAtlas)
     _textureAtlas = textureAtlas;
 }
 
-TextureAtlas* AtlasNode::getTextureAtlas() const
+TextureAtlas * AtlasNode::getTextureAtlas() const
 {
     return _textureAtlas;
 }
 
-std::size_t AtlasNode::getQuadsToDraw() const
+size_t AtlasNode::getQuadsToDraw() const
 {
     return _quadsToDraw;
 }
 
-void AtlasNode::setQuadsToDraw(std::size_t quadsToDraw)
+void AtlasNode::setQuadsToDraw(ssize_t quadsToDraw)
 {
     _quadsToDraw = quadsToDraw;
 }
diff --git a/cocos2d/cocos/2d/CCAtlasNode.h b/cocos2d/cocos/2d/CCAtlasNode.h
index 86c93750e7..69a62d9e91 100644
--- a/cocos2d/cocos/2d/CCAtlasNode.h
+++ b/cocos2d/cocos/2d/CCAtlasNode.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,24 +25,13 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-
-#ifndef CC_2D_ATLASNODE_H
-#define CC_2D_ATLASNODE_H
+#pragma once
 
 #include <cocos/2d/CCNode.h>
 #include <cocos/base/CCProtocols.h>
-#include <cocos/base/ccConfig.h>
 #include <cocos/base/ccTypes.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 #include <cocos/renderer/CCQuadCommand.h>
 
-#include <cstddef>
-#include <cstdint>
-#include <iosfwd>
-
 NS_CC_BEGIN
 
 /**
@@ -49,8 +39,6 @@ NS_CC_BEGIN
  * @{
  */
 
-class Renderer;
-class Texture2D;
 class TextureAtlas;
 
 /** @brief AtlasNode is a subclass of Node that implements the RGBAProtocol and TextureProtocol protocol.
@@ -60,43 +48,32 @@ class TextureAtlas;
  * - opacity and RGB colors.
  */
 class CC_DLL AtlasNode : public Node, public TextureProtocol
-{
+{    
 public:
-    /** creates a AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render.
+	/** creates a AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render.
      *
      * @param filename The path of Atlas file.
      * @param tileWidth The width of the item.
      * @param tileHeight The height of the item.
      * @param itemsToRender The quantity of items to render.
      */
-    static AtlasNode* create(const std::string& filename, int tileWidth, int tileHeight, int itemsToRender);
+	static AtlasNode * create(const std::string& filename, int tileWidth, int tileHeight, int itemsToRender);
 
     /** updates the Atlas (indexed vertex array).
-     * Shall be overridden in subclasses.
-     */
+    * Shall be overridden in subclasses.
+    */
     virtual void updateAtlasValues();
-
-    /** Set an buffer manager of the texture vertex. */
-    void setTextureAtlas(TextureAtlas* textureAtlas);
-
-    /** Return the buffer manager of the texture vertex.
-     *
-     * @return Return A TextureAtlas.
-     */
-    TextureAtlas* getTextureAtlas() const;
-
-    void setQuadsToDraw(std::size_t quadsToDraw);
-    std::size_t getQuadsToDraw() const;
-
+    
     // Overrides
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
-    Texture2D* getTexture() const override;
-    void setTexture(Texture2D* texture) override;
-    bool isOpacityModifyRGB() const override;
-    void setOpacityModifyRGB(bool isOpacityModifyRGB) override;
-    const Color3B& getColor(void) const override;
-    void setColor(const Color3B& color) override;
-    void setOpacity(GLubyte opacity) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
+    virtual Texture2D* getTexture() const override;
+    virtual void setTexture(Texture2D *texture) override;
+    virtual bool isOpacityModifyRGB() const override;
+    virtual void setOpacityModifyRGB(bool isOpacityModifyRGB) override;
+    virtual const Color3B& getColor() const override;
+    virtual void setColor(const Color3B& color) override;
+    virtual void setOpacity(uint8_t opacity) override;
+    
     /**
      * @code
      * When this function bound into js or lua,the parameter will be changed
@@ -104,62 +81,76 @@ public:
      * @endcode
      * @lua NA
      */
-    void setBlendFunc(const BlendFunc& blendFunc) override;
+    virtual void setBlendFunc(const BlendFunc& blendFunc) override;
     /**
      * @lua NA
      */
-    const BlendFunc& getBlendFunc() const override;
+    virtual const BlendFunc& getBlendFunc() const override;
+    
+    /** Set an buffer manager of the texture vertex. */
+    void setTextureAtlas(TextureAtlas* textureAtlas);
+    
+    /** Return the buffer manager of the texture vertex. 
+     *
+     * @return Return A TextureAtlas.
+     */
+    TextureAtlas* getTextureAtlas() const;
+    
+    void setQuadsToDraw(ssize_t quadsToDraw);
+    size_t getQuadsToDraw() const;
 
-    CC_CONSTRUCTOR_ACCESS : AtlasNode();
-    ~AtlasNode() override;
+CC_CONSTRUCTOR_ACCESS:
+    AtlasNode();
+    virtual ~AtlasNode();
 
     /** Initializes an AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render*/
     bool initWithTileFile(const std::string& tile, int tileWidth, int tileHeight, int itemsToRender);
-
+    
     /** Initializes an AtlasNode  with a texture the width and height of each item measured in points and the quantity of items to render*/
     bool initWithTexture(Texture2D* texture, int tileWidth, int tileHeight, int itemsToRender);
 
 protected:
+    friend class Director;
+    
     void calculateMaxItems();
     void updateBlendFunc();
     void updateOpacityModifyRGB();
-
-    friend class Director;
     void setIgnoreContentScaleFactor(bool bIgnoreContentScaleFactor);
 
     /** Chars per row. */
-    int _itemsPerRow;
+    int    _itemsPerRow = 0;
     /** Chars per column. */
-    int _itemsPerColumn;
+    int    _itemsPerColumn = 0;
 
     /** Width of each char. */
-    int _itemWidth;
+    int    _itemWidth = 0;
     /** Height of each char. */
-    int _itemHeight;
-
-    Color3B _colorUnmodified;
-
-    TextureAtlas* _textureAtlas;
+    int    _itemHeight = 0;
+    
+    Color3B    _colorUnmodified;
+    
+    TextureAtlas* _textureAtlas = nullptr;
     /** Protocol variables. */
-    bool _isOpacityModifyRGB;
+    bool _isOpacityModifyRGB = false;
     BlendFunc _blendFunc;
 
     /** Quads to draw. */
-    std::size_t _quadsToDraw;
-    /** Color uniform. */
-    GLint _uniformColor;
+    size_t _quadsToDraw = 0;
+
     /** This variable is only used for LabelAtlas FPS display. So plz don't modify its value. */
-    bool _ignoreContentScaleFactor;
-    /** Quad command. */
+    bool _ignoreContentScaleFactor = false;
+    
     QuadCommand _quadCommand;
-
+    backend::UniformLocation _textureLocation;
+    backend::UniformLocation _mvpMatrixLocation;
+    backend::ProgramState* _programState = nullptr;
+    
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(AtlasNode)
+    CC_DISALLOW_COPY_AND_ASSIGN(AtlasNode);
+
 };
 
 // end of base_node group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_ATLASNODE_H
diff --git a/cocos2d/cocos/2d/CCAutoPolygon.cpp b/cocos2d/cocos/2d/CCAutoPolygon.cpp
index 1da0b62e19..b64705bf92 100644
--- a/cocos2d/cocos/2d/CCAutoPolygon.cpp
+++ b/cocos2d/cocos/2d/CCAutoPolygon.cpp
@@ -3,7 +3,8 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -26,41 +27,33 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCAutoPolygon.h>
-
-#include <cocos/base/CCConsole.h>
+#include "poly2tri/poly2tri.h"
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCImage.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCTexture2D.h>
-#include <cocos/renderer/CCTrianglesCommand.h>
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Weverything"
-#include <clipper/clipper.hpp>
-
-#include <poly2tri/common/shapes.h>
-#include <poly2tri/sweep/cdt.h>
-#pragma clang diagnostic pop
-
+#include <cocos/renderer/CCTextureCache.h>
+#include "clipper/clipper.hpp"
 #include <algorithm>
-#include <cmath>
-#include <cstring>
-#include <new>
+#include <math.h>
 
 USING_NS_CC;
 
-static unsigned short quadIndices[] = {0, 1, 2, 3, 2, 1};
+static unsigned short quadIndices9[]={
+    0+4*0,1+4*0,2+4*0, 3+4*0,2+4*0,1+4*0,
+    0+4*1,1+4*1,2+4*1, 3+4*1,2+4*1,1+4*1,
+    0+4*2,1+4*2,2+4*2, 3+4*2,2+4*2,1+4*2,
+    0+4*3,1+4*3,2+4*3, 3+4*3,2+4*3,1+4*3,
+    0+4*4,1+4*4,2+4*4, 3+4*4,2+4*4,1+4*4,
+    0+4*5,1+4*5,2+4*5, 3+4*5,2+4*5,1+4*5,
+    0+4*6,1+4*6,2+4*6, 3+4*6,2+4*6,1+4*6,
+    0+4*7,1+4*7,2+4*7, 3+4*7,2+4*7,1+4*7,
+    0+4*8,1+4*8,2+4*8, 3+4*8,2+4*8,1+4*8,
+};
+
 const static float PRECISION = 10.0f;
 
 PolygonInfo::PolygonInfo()
-: rect(cocos2d::Rect::ZERO)
-, filename("")
-, isVertsOwner(true)
+: _isVertsOwner(true)
+, _rect(Rect::ZERO)
+, _filename("")
 {
     triangles.verts = nullptr;
     triangles.indices = nullptr;
@@ -70,12 +63,12 @@ PolygonInfo::PolygonInfo()
 
 PolygonInfo::PolygonInfo(const PolygonInfo& other)
 : triangles()
-, rect()
-, isVertsOwner(true)
+, _isVertsOwner(true)
+, _rect()
 {
-    filename = other.filename;
-    isVertsOwner = true;
-    rect = other.rect;
+    _filename = other._filename;
+    _isVertsOwner = true;
+    _rect = other._rect;
     triangles.verts = new (std::nothrow) V3F_C4B_T2F[other.triangles.vertCount];
     triangles.indices = new (std::nothrow) unsigned short[other.triangles.indexCount];
     CCASSERT(triangles.verts && triangles.indices, "not enough memory");
@@ -85,14 +78,14 @@ PolygonInfo::PolygonInfo(const PolygonInfo& other)
     memcpy(triangles.indices, other.triangles.indices, other.triangles.indexCount * sizeof(other.triangles.indices[0]));
 };
 
-PolygonInfo& PolygonInfo::operator=(const PolygonInfo& other)
+PolygonInfo& PolygonInfo::operator= (const PolygonInfo& other)
 {
-    if (this != &other)
+    if(this != &other)
     {
         releaseVertsAndIndices();
-        filename = other.filename;
-        isVertsOwner = true;
-        rect = other.rect;
+        _filename = other._filename;
+        _isVertsOwner = true;
+        _rect = other._rect;
         triangles.verts = new (std::nothrow) V3F_C4B_T2F[other.triangles.vertCount];
         triangles.indices = new (std::nothrow) unsigned short[other.triangles.indexCount];
         CCASSERT(triangles.verts && triangles.indices, "not enough memory");
@@ -109,21 +102,33 @@ PolygonInfo::~PolygonInfo()
     releaseVertsAndIndices();
 }
 
-void PolygonInfo::setQuad(V3F_C4B_T2F_Quad* quad)
+void PolygonInfo::setQuad(V3F_C4B_T2F_Quad *quad)
 {
     releaseVertsAndIndices();
-    isVertsOwner = false;
-    triangles.indices = quadIndices;
+    _isVertsOwner = false;
+    triangles.indices = quadIndices9;
     triangles.vertCount = 4;
     triangles.indexCount = 6;
     triangles.verts = (V3F_C4B_T2F*)quad;
 }
 
+void PolygonInfo::setQuads(V3F_C4B_T2F_Quad *quad, int numberOfQuads)
+{
+    CCASSERT(numberOfQuads >= 1 && numberOfQuads <= 9, "Invalid number of Quads");
+
+    releaseVertsAndIndices();
+    _isVertsOwner = false;
+    triangles.indices = quadIndices9;
+    triangles.vertCount = 4 * numberOfQuads;
+    triangles.indexCount = 6 * numberOfQuads;
+    triangles.verts = (V3F_C4B_T2F*)quad;
+}
+
 void PolygonInfo::setTriangles(const TrianglesCommand::Triangles& other)
 {
     this->releaseVertsAndIndices();
-    isVertsOwner = false;
-
+    _isVertsOwner = false;
+    
     this->triangles.vertCount = other.vertCount;
     this->triangles.indexCount = other.indexCount;
     this->triangles.verts = other.verts;
@@ -132,14 +137,14 @@ void PolygonInfo::setTriangles(const TrianglesCommand::Triangles& other)
 
 void PolygonInfo::releaseVertsAndIndices()
 {
-    if (isVertsOwner)
+    if(_isVertsOwner)
     {
-        if (nullptr != triangles.verts)
+        if(nullptr != triangles.verts)
         {
             CC_SAFE_DELETE_ARRAY(triangles.verts);
         }
-
-        if (nullptr != triangles.indices)
+        
+        if(nullptr != triangles.indices)
         {
             CC_SAFE_DELETE_ARRAY(triangles.indices);
         }
@@ -153,41 +158,36 @@ unsigned int PolygonInfo::getVertCount() const
 
 unsigned int PolygonInfo::getTrianglesCount() const
 {
-    return (unsigned int)triangles.indexCount / 3;
-}
-
-unsigned int PolygonInfo::getTriaglesCount() const
-{
-    return getTrianglesCount();
+    return (unsigned int)triangles.indexCount/3;
 }
 
 float PolygonInfo::getArea() const
 {
     float area = 0;
-    V3F_C4B_T2F* verts = triangles.verts;
-    unsigned short* indices = triangles.indices;
-    for (int i = 0; i < triangles.indexCount; i += 3)
+    V3F_C4B_T2F *verts = triangles.verts;
+    unsigned short *indices = triangles.indices;
+    for(unsigned int i = 0; i < triangles.indexCount; i+=3)
     {
         auto A = verts[indices[i]].vertices;
-        auto B = verts[indices[i + 1]].vertices;
-        auto C = verts[indices[i + 2]].vertices;
-        area += (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y)) / 2;
+        auto B = verts[indices[i+1]].vertices;
+        auto C = verts[indices[i+2]].vertices;
+        area += (A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y - B.y))/2;
     }
     return area;
 }
 
-AutoPolygon::AutoPolygon(const std::string& filename)
-: _image(nullptr)
-, _data(nullptr)
-, _filename("")
-, _width(0)
-, _height(0)
-, _scaleFactor(0)
+AutoPolygon::AutoPolygon(const std::string &filename)
+:_image(nullptr)
+,_data(nullptr)
+,_filename("")
+,_width(0)
+,_height(0)
+,_scaleFactor(0)
 {
     _filename = filename;
     _image = new (std::nothrow) Image();
     _image->initWithImageFile(filename);
-    CCASSERT(_image->getRenderFormat() == Texture2D::PixelFormat::RGBA8888, "unsupported format, currently only supports rgba8888");
+    CCASSERT(_image->getPixelFormat()==backend::PixelFormat::RGBA8888, "unsupported format, currently only supports rgba8888");
     _data = _image->getData();
     _width = _image->getWidth();
     _height = _image->getHeight();
@@ -199,24 +199,23 @@ AutoPolygon::~AutoPolygon()
     CC_SAFE_DELETE(_image);
 }
 
-std::vector<Vec2> AutoPolygon::trace(const Rect& rect, const float& threshold)
+std::vector<Vec2> AutoPolygon::trace(const Rect& rect, float threshold)
 {
     Vec2 first = findFirstNoneTransparentPixel(rect, threshold);
     return marchSquare(rect, first, threshold);
 }
 
-Vec2 AutoPolygon::findFirstNoneTransparentPixel(const Rect& rect, const float& threshold)
+Vec2 AutoPolygon::findFirstNoneTransparentPixel(const Rect& rect, float threshold)
 {
-    bool found = false;
+	bool found = false;
     Vec2 i;
-    for (i.y = rect.origin.y; i.y < rect.origin.y + rect.size.height; i.y++)
+    for(i.y = rect.origin.y; i.y < rect.origin.y+rect.size.height; i.y++)
     {
-        if (found)
-            break;
-        for (i.x = rect.origin.x; i.x < rect.origin.x + rect.size.width; i.x++)
+        if(found)break;
+        for(i.x = rect.origin.x; i.x < rect.origin.x+rect.size.width; i.x++)
         {
             auto alpha = getAlphaByPos(i);
-            if (alpha > threshold)
+            if(alpha>threshold)
             {
                 found = true;
                 break;
@@ -227,16 +226,16 @@ Vec2 AutoPolygon::findFirstNoneTransparentPixel(const Rect& rect, const float& t
     return i;
 }
 
-unsigned char AutoPolygon::getAlphaByIndex(const unsigned int& i)
+unsigned char AutoPolygon::getAlphaByIndex(unsigned int i)
 {
-    return *(_data + i * 4 + 3);
+    return *(_data+i*4+3);
 }
 unsigned char AutoPolygon::getAlphaByPos(const Vec2& pos)
 {
-    return *(_data + ((int)pos.y * _width + (int)pos.x) * 4 + 3);
+    return *(_data+((int)pos.y*_width+(int)pos.x)*4+3);
 }
 
-unsigned int AutoPolygon::getSquareValue(const unsigned int& x, const unsigned int& y, const Rect& rect, const float& threshold)
+unsigned int AutoPolygon::getSquareValue(unsigned int x, unsigned int y, const Rect& rect, float threshold)
 {
     /*
      checking the 2x2 pixel grid, assigning these values to each pixel, if not transparent
@@ -247,58 +246,57 @@ unsigned int AutoPolygon::getSquareValue(const unsigned int& x, const unsigned i
      +---+---+
      */
     unsigned int sv = 0;
-    // NOTE: due to the way we pick points from texture, rect needs to be smaller, otherwise it goes outside 1 pixel
-    auto fixedRect = Rect(rect.origin, rect.size - Size(2, 2));
-
-    Vec2 tl = Vec2(x - 1, y - 1);
-    sv += (fixedRect.containsPoint(tl) && getAlphaByPos(tl) > threshold) ? 1 : 0;
-    Vec2 tr = Vec2(x, y - 1);
-    sv += (fixedRect.containsPoint(tr) && getAlphaByPos(tr) > threshold) ? 2 : 0;
-    Vec2 bl = Vec2(x - 1, y);
-    sv += (fixedRect.containsPoint(bl) && getAlphaByPos(bl) > threshold) ? 4 : 0;
-    Vec2 br = Vec2(x, y);
-    sv += (fixedRect.containsPoint(br) && getAlphaByPos(br) > threshold) ? 8 : 0;
+    //NOTE: due to the way we pick points from texture, rect needs to be smaller, otherwise it goes outside 1 pixel
+    auto fixedRect = Rect(rect.origin, rect.size-Size(2,2));
+    
+    Vec2 tl = Vec2(x-1.0f, y-1.0f);
+    sv += (fixedRect.containsPoint(tl) && getAlphaByPos(tl) > threshold)? 1 : 0;
+    Vec2 tr = Vec2(x-0.0f, y-1.0f);
+    sv += (fixedRect.containsPoint(tr) && getAlphaByPos(tr) > threshold)? 2 : 0;
+    Vec2 bl = Vec2(x-1.0f, y-0.0f);
+    sv += (fixedRect.containsPoint(bl) && getAlphaByPos(bl) > threshold)? 4 : 0;
+    Vec2 br = Vec2(x-0.0f, y-0.0f);
+    sv += (fixedRect.containsPoint(br) && getAlphaByPos(br) > threshold)? 8 : 0;
     CCASSERT(sv != 0 && sv != 15, "square value should not be 0, or 15");
     return sv;
 }
 
-std::vector<cocos2d::Vec2> AutoPolygon::marchSquare(const Rect& rect, const Vec2& start, const float& threshold)
+std::vector<cocos2d::Vec2> AutoPolygon::marchSquare(const Rect& rect, const Vec2& start, float threshold)
 {
     int stepx = 0;
     int stepy = 0;
     int prevx = 0;
     int prevy = 0;
-    int startx = start.x;
-    int starty = start.y;
+    int startx = (int)start.x;
+    int starty = (int)start.y;
     int curx = startx;
     int cury = starty;
     unsigned int count = 0;
-    bool problem = false;
     std::vector<int> case9s;
     std::vector<int> case6s;
     int i;
     std::vector<int>::iterator it;
     std::vector<cocos2d::Vec2> _points;
-    do
-    {
+    do{
         int sv = getSquareValue(curx, cury, rect, threshold);
-        switch (sv)
-        {
+        switch(sv){
+
             case 1:
             case 5:
             case 13:
                 /* going UP with these cases:
                  1          5           13
-                 +---+---+  +---+---+  +---+---+
-                 | 1 |   |  | 1 |   |  | 1 |   |
-                 +---+---+  +---+---+  +---+---+
-                 |   |   |  | 4 |   |  | 4 | 8 |
+                 +---+---+  +---+---+  +---+---+ 
+                 | 1 |   |  | 1 |   |  | 1 |   | 
+                 +---+---+  +---+---+  +---+---+ 
+                 |   |   |  | 4 |   |  | 4 | 8 | 
                  +---+---+  +---+---+  +---+---+
                  */
                 stepx = 0;
                 stepy = -1;
                 break;
 
+                
             case 8:
             case 10:
             case 11:
@@ -314,6 +312,7 @@ std::vector<cocos2d::Vec2> AutoPolygon::marchSquare(const Rect& rect, const Vec2
                 stepy = 1;
                 break;
 
+                
             case 4:
             case 12:
             case 14:
@@ -328,22 +327,23 @@ std::vector<cocos2d::Vec2> AutoPolygon::marchSquare(const Rect& rect, const Vec2
                 stepx = -1;
                 stepy = 0;
                 break;
-
-            case 2:
-            case 3:
-            case 7:
+                
+                
+            case 2 :
+            case 3 :
+            case 7 :
                 /* going RIGHT with these cases:
-                 2          3           7
+                 2          3           7        
                  +---+---+  +---+---+   +---+---+
                  |   | 2 |  | 1 | 2 |   | 1 | 2 |
                  +---+---+  +---+---+   +---+---+
                  |   |   |  |   |   |   | 4 |   |
                  +---+---+  +---+---+  	+---+---+
                  */
-                stepx = 1;
-                stepy = 0;
+                stepx=1;
+                stepy=0;
                 break;
-            case 9:
+            case 9 :
                 /*
                  +---+---+
                  | 1 |   |
@@ -352,26 +352,25 @@ std::vector<cocos2d::Vec2> AutoPolygon::marchSquare(const Rect& rect, const Vec2
                  +---+---+
                  this should normally go UP, but if we already been here, we go down
                 */
-                // find index from xy;
+                //find index from xy;
                 i = getIndexFromPos(curx, cury);
-                it = find(case9s.begin(), case9s.end(), i);
+                it = find (case9s.begin(), case9s.end(), i);
                 if (it != case9s.end())
                 {
-                    // found, so we go down, and delete from case9s;
+                    //found, so we go down, and delete from case9s;
                     stepx = 0;
                     stepy = 1;
                     case9s.erase(it);
-                    problem = true;
                 }
                 else
                 {
-                    // not found, we go up, and add to case9s;
+                    //not found, we go up, and add to case9s;
                     stepx = 0;
                     stepy = -1;
                     case9s.push_back(i);
                 }
                 break;
-            case 6:
+            case 6 :
                 /*
                  6
                  +---+---+
@@ -382,18 +381,16 @@ std::vector<cocos2d::Vec2> AutoPolygon::marchSquare(const Rect& rect, const Vec2
                  this normally go RIGHT, but if its coming from UP, it should go LEFT
                  */
                 i = getIndexFromPos(curx, cury);
-                it = find(case6s.begin(), case6s.end(), i);
+                it = find (case6s.begin(), case6s.end(), i);
                 if (it != case6s.end())
                 {
-                    // found, so we go down, and delete from case9s;
+                    //found, so we go down, and delete from case9s;
                     stepx = -1;
                     stepy = 0;
                     case6s.erase(it);
-                    problem = true;
                 }
-                else
-                {
-                    // not found, we go up, and add to case9s;
+                else{
+                    //not found, we go up, and add to case9s;
                     stepx = 1;
                     stepy = 0;
                     case6s.push_back(i);
@@ -402,22 +399,16 @@ std::vector<cocos2d::Vec2> AutoPolygon::marchSquare(const Rect& rect, const Vec2
             default:
                 CCLOG("this shouldn't happen.");
         }
-        // little optimization
+        //little optimization
         // if previous direction is same as current direction,
         // then we should modify the last vec to current
         curx += stepx;
         cury += stepy;
-        if (stepx == prevx && stepy == prevy)
+        if(stepx == prevx && stepy == prevy)
         {
-            _points.back().x = (float)(curx - rect.origin.x) / _scaleFactor;
+            _points.back().x = (float)(curx-rect.origin.x) / _scaleFactor;
             _points.back().y = (float)(rect.size.height - cury + rect.origin.y) / _scaleFactor;
         }
-        else if (problem)
-        {
-            // TODO: we triangulation cannot work collinear points, so we need to modify same point a little
-            // TODO: maybe we can detect if we go into a hole and coming back the hole, we should extract those points and remove them
-            _points.push_back(Vec2((float)(curx - rect.origin.x) / _scaleFactor, (float)(rect.size.height - cury + rect.origin.y) / _scaleFactor));
-        }
         else
         {
             _points.push_back(Vec2((float)(curx - rect.origin.x) / _scaleFactor, (float)(rect.size.height - cury + rect.origin.y) / _scaleFactor));
@@ -426,13 +417,12 @@ std::vector<cocos2d::Vec2> AutoPolygon::marchSquare(const Rect& rect, const Vec2
         count++;
         prevx = stepx;
         prevy = stepy;
-        problem = false;
 
 #if defined(COCOS2D_DEBUG) && (COCOS2D_DEBUG > 0)
         const auto totalPixel = _width * _height;
         CCASSERT(count <= totalPixel, "oh no, marching square cannot find starting position");
 #endif
-    } while (curx != startx || cury != starty);
+    } while(curx != startx || cury != starty);
     return _points;
 }
 
@@ -441,66 +431,64 @@ float AutoPolygon::perpendicularDistance(const cocos2d::Vec2& i, const cocos2d::
     float res;
     float slope;
     float intercept;
-
-    if (start.x == end.x)
+    
+    if(start.x == end.x)
     {
-        res = fabsf(i.x - end.x);
+        res = fabsf(i.x- end.x);
     }
     else if (start.y == end.y)
     {
         res = fabsf(i.y - end.y);
     }
-    else
-    {
+    else{
         slope = (end.y - start.y) / (end.x - start.x);
-        intercept = start.y - (slope * start.x);
-        res = fabsf(slope * i.x - i.y + intercept) / sqrtf(powf(slope, 2) + 1);
+        intercept = start.y - (slope*start.x);
+        res = fabsf(slope * i.x - i.y + intercept) / sqrtf(powf(slope, 2)+1);
     }
     return res;
 }
 std::vector<cocos2d::Vec2> AutoPolygon::rdp(const std::vector<cocos2d::Vec2>& v, float optimization)
 {
-    if (v.size() < 3)
+    if(v.size() < 3)
         return v;
-
+    
     int index = -1;
     float dist = 0;
-    // not looping first and last point
-    for (size_t i = 1; i < v.size() - 1; i++)
+    //not looping first and last point
+    for(size_t i = 1, size = v.size(); i < size-1; ++i)
     {
         float cdist = perpendicularDistance(v[i], v.front(), v.back());
-        if (cdist > dist)
+        if(cdist > dist)
         {
             dist = cdist;
             index = static_cast<int>(i);
         }
     }
-    if (dist > optimization)
+    if (dist>optimization)
     {
         std::vector<Vec2>::const_iterator begin = v.begin();
-        std::vector<Vec2>::const_iterator end = v.end();
-        std::vector<Vec2> l1(begin, begin + index + 1);
-        std::vector<Vec2> l2(begin + index, end);
-
+        std::vector<Vec2>::const_iterator end   = v.end();
+        std::vector<Vec2> l1(begin, begin+index+1);
+        std::vector<Vec2> l2(begin+index, end);
+        
         std::vector<Vec2> r1 = rdp(l1, optimization);
         std::vector<Vec2> r2 = rdp(l2, optimization);
-
-        r1.insert(r1.end(), r2.begin() + 1, r2.end());
+        
+        r1.insert(r1.end(), r2.begin()+1, r2.end());
         return r1;
     }
-    else
-    {
+    else {
         std::vector<Vec2> ret;
         ret.push_back(v.front());
         ret.push_back(v.back());
         return ret;
     }
 }
-std::vector<Vec2> AutoPolygon::reduce(const std::vector<Vec2>& points, const Rect& rect, const float& epsilon)
+std::vector<Vec2> AutoPolygon::reduce(const std::vector<Vec2>& points, const Rect& rect, float epsilon)
 {
     auto size = points.size();
     // if there are less than 3 points, then we have nothing
-    if (size < 3)
+    if(size<3)
     {
         log("AUTOPOLYGON: cannot reduce points for %s that has less than 3 points in input, e: %f", _filename.c_str(), epsilon);
         return std::vector<Vec2>();
@@ -508,13 +496,13 @@ std::vector<Vec2> AutoPolygon::reduce(const std::vector<Vec2>& points, const Rec
     // if there are less than 9 points (but more than 3), then we don't need to reduce it
     else if (size < 9)
     {
-        log("AUTOPOLYGON: cannot reduce points for %s e: %f", _filename.c_str(), epsilon);
+        log("AUTOPOLYGON: cannot reduce points for %s e: %f",_filename.c_str(), epsilon);
         return points;
     }
     float maxEp = MIN(rect.size.width, rect.size.height);
-    float ep = clampf(epsilon, 0.0, maxEp / _scaleFactor / 2);
+    float ep = clampf(epsilon, 0.0, maxEp/_scaleFactor/2);
     std::vector<Vec2> result = rdp(points, ep);
-
+    
     auto last = result.back();
     if (last.y > result.front().y && last.getDistance(result.front()) < ep * 0.5f)
     {
@@ -524,11 +512,11 @@ std::vector<Vec2> AutoPolygon::reduce(const std::vector<Vec2>& points, const Rec
     return result;
 }
 
-std::vector<Vec2> AutoPolygon::expand(const std::vector<Vec2>& points, const cocos2d::Rect& rect, const float& epsilon)
+std::vector<Vec2> AutoPolygon::expand(const std::vector<Vec2>& points, const cocos2d::Rect &rect, float epsilon)
 {
     auto size = points.size();
     // if there are less than 3 points, then we have nothing
-    if (size < 3)
+    if(size<3)
     {
         log("AUTOPOLYGON: cannot expand points for %s with less than 3 points, e: %f", _filename.c_str(), epsilon);
         return std::vector<Vec2>();
@@ -536,50 +524,48 @@ std::vector<Vec2> AutoPolygon::expand(const std::vector<Vec2>& points, const coc
     ClipperLib::Path subj;
     ClipperLib::PolyTree solution;
     ClipperLib::PolyTree out;
-    for (std::vector<Vec2>::const_iterator it = points.begin(); it < points.end(); it++)
+    for(const auto& pt : points)
     {
-        subj << ClipperLib::IntPoint(it->x * PRECISION, it->y * PRECISION);
+        subj << ClipperLib::IntPoint(static_cast<ClipperLib::cInt>(pt.x* PRECISION), static_cast<ClipperLib::cInt>(pt.y * PRECISION));
     }
     ClipperLib::ClipperOffset co;
     co.AddPath(subj, ClipperLib::jtMiter, ClipperLib::etClosedPolygon);
     co.Execute(solution, epsilon * PRECISION);
-
+    
     ClipperLib::PolyNode* p = solution.GetFirst();
-    if (!p)
+    if(!p)
     {
         log("AUTOPOLYGON: Clipper failed to expand the points");
         return points;
     }
-    while (p->IsHole())
-    {
+    while(p->IsHole()){
         p = p->GetNext();
     }
 
-    // turn the result into simply polygon (AKA, fix overlap)
-
-    // clamp into the specified rect
+    //turn the result into simply polygon (AKA, fix overlap)
+    
+    //clamp into the specified rect
     ClipperLib::Clipper cl;
     cl.StrictlySimple(true);
     cl.AddPath(p->Contour, ClipperLib::ptSubject, true);
-    // create the clipping rect
+    //create the clipping rect
     ClipperLib::Path clamp;
     clamp.push_back(ClipperLib::IntPoint(0, 0));
-    clamp.push_back(ClipperLib::IntPoint(rect.size.width / _scaleFactor * PRECISION, 0));
-    clamp.push_back(ClipperLib::IntPoint(rect.size.width / _scaleFactor * PRECISION, rect.size.height / _scaleFactor * PRECISION));
-    clamp.push_back(ClipperLib::IntPoint(0, rect.size.height / _scaleFactor * PRECISION));
+    clamp.push_back(ClipperLib::IntPoint(static_cast<ClipperLib::cInt>(rect.size.width/_scaleFactor * PRECISION), 0));
+    clamp.push_back(ClipperLib::IntPoint(static_cast<ClipperLib::cInt>(rect.size.width/_scaleFactor * PRECISION), 
+                                         static_cast<ClipperLib::cInt>(rect.size.height/_scaleFactor * PRECISION)));
+    clamp.push_back(ClipperLib::IntPoint(0, static_cast<ClipperLib::cInt>(rect.size.height/_scaleFactor * PRECISION)));
     cl.AddPath(clamp, ClipperLib::ptClip, true);
     cl.Execute(ClipperLib::ctIntersection, out);
-
+    
     std::vector<Vec2> outPoints;
     ClipperLib::PolyNode* p2 = out.GetFirst();
-    while (p2->IsHole())
-    {
+    while(p2->IsHole()){
         p2 = p2->GetNext();
     }
-    auto end = p2->Contour.end();
-    for (std::vector<ClipperLib::IntPoint>::const_iterator pt = p2->Contour.begin(); pt < end; pt++)
+    for(const auto& pt : p2->Contour)
     {
-        outPoints.push_back(Vec2(pt->X / PRECISION, pt->Y / PRECISION));
+        outPoints.push_back(Vec2(pt.X/PRECISION, pt.Y/PRECISION));
     }
     return outPoints;
 }
@@ -587,21 +573,21 @@ std::vector<Vec2> AutoPolygon::expand(const std::vector<Vec2>& points, const coc
 TrianglesCommand::Triangles AutoPolygon::triangulate(const std::vector<Vec2>& points)
 {
     // if there are less than 3 points, then we can't triangulate
-    if (points.size() < 3)
+    if(points.size()<3)
     {
         log("AUTOPOLYGON: cannot triangulate %s with less than 3 points", _filename.c_str());
         return TrianglesCommand::Triangles();
     }
     std::vector<p2t::Point*> p2points;
-    for (std::vector<Vec2>::const_iterator it = points.begin(); it < points.end(); it++)
+    for(const auto& pt : points)
     {
-        p2t::Point* p = new (std::nothrow) p2t::Point(it->x, it->y);
+        p2t::Point * p = new (std::nothrow) p2t::Point(pt.x, pt.y);
         p2points.push_back(p);
     }
     p2t::CDT cdt(p2points);
     cdt.Triangulate();
     std::vector<p2t::Triangle*> tris = cdt.GetTriangles();
-
+    
     // we won't know the size of verts and indices until we process all of the triangles!
     std::vector<V3F_C4B_T2F> verts;
     std::vector<unsigned short> indices;
@@ -609,35 +595,35 @@ TrianglesCommand::Triangles AutoPolygon::triangulate(const std::vector<Vec2>& po
     unsigned short idx = 0;
     unsigned short vdx = 0;
 
-    for (std::vector<p2t::Triangle*>::const_iterator ite = tris.begin(); ite != tris.end(); ite++)
+    for(const auto& ite : tris)
     {
-        for (int i = 0; i < 3; i++)
+        for(int i = 0; i < 3; ++i)
         {
-            auto p = (*ite)->GetPoint(i);
-            auto v3 = Vec3(p->x, p->y, 0);
+            auto p = ite->GetPoint(i);
+            auto v3 = Vec3((float)p->x, (float)p->y, 0);
             bool found = false;
-            size_t j;
-            size_t length = vdx;
-            for (j = 0; j < length; j++)
+            unsigned short j;
+            auto length = vdx;
+            for(j = 0; j < length; j++)
             {
-                if (verts[j].vertices == v3)
+                if(verts[j].vertices == v3)
                 {
                     found = true;
                     break;
                 }
             }
-            if (found)
+            if(found)
             {
-                // if we found the same vertex, don't add to verts, but use the same vertex with indices
+                //if we found the same vertex, don't add to verts, but use the same vertex with indices
                 indices.push_back(j);
                 idx++;
             }
             else
             {
-                // vert does not exist yet, so we need to create a new one,
+                //vert does not exist yet, so we need to create a new one,
                 auto c4b = Color4B::WHITE;
-                auto t2f = Tex2F(0, 0); // don't worry about tex coords now, we calculate that later
-                V3F_C4B_T2F vert = {v3, c4b, t2f};
+                auto t2f = Tex2F(0,0); // don't worry about tex coords now, we calculate that later
+                V3F_C4B_T2F vert = {v3,c4b,t2f};
                 verts.push_back(vert);
                 indices.push_back(vdx);
                 idx++;
@@ -645,7 +631,7 @@ TrianglesCommand::Triangles AutoPolygon::triangulate(const std::vector<Vec2>& po
             }
         }
     }
-    for (auto j : p2points)
+    for(auto j : p2points)
     {
         delete j;
     };
@@ -657,13 +643,13 @@ TrianglesCommand::Triangles AutoPolygon::triangulate(const std::vector<Vec2>& po
     unsigned short* indicesBuf = new (std::nothrow) unsigned short[indices.size()];
     memcpy(indicesBuf, indices.data(), indices.size() * sizeof(short));
 
-    // Triangles should really use std::vector and not arrays for verts and indices.
+    // Triangles should really use std::vector and not arrays for verts and indices. 
     // Then the above memcpy would not be necessary
-    TrianglesCommand::Triangles triangles = {vertsBuf, indicesBuf, static_cast<int>(verts.size()), static_cast<int>(indices.size())};
+    TrianglesCommand::Triangles triangles = { vertsBuf, indicesBuf, (unsigned int)verts.size(), (unsigned int)indices.size() };
     return triangles;
 }
 
-void AutoPolygon::calculateUV(const Rect& rect, V3F_C4B_T2F* verts, const std::size_t& count)
+void AutoPolygon::calculateUV(const Rect& rect, V3F_C4B_T2F* verts, ssize_t count)
 {
     /*
      whole texture UV coordination
@@ -681,17 +667,17 @@ void AutoPolygon::calculateUV(const Rect& rect, V3F_C4B_T2F* verts, const std::s
      +---------------------+
      0,1                  1,1
      */
-
+    
     CCASSERT(_width && _height, "please specify width and height for this AutoPolygon instance");
-    float texWidth = _width;
-    float texHeight = _height;
+    auto texWidth  = _width;
+    auto texHeight = _height;
 
     auto end = &verts[count];
-    for (auto i = verts; i != end; i++)
+    for(auto i = verts; i != end; ++i)
     {
         // for every point, offset with the center point
-        float u = (i->vertices.x * _scaleFactor + rect.origin.x) / texWidth;
-        float v = (rect.origin.y + rect.size.height - i->vertices.y * _scaleFactor) / texHeight;
+        float u = (i->vertices.x*_scaleFactor + rect.origin.x) / texWidth;
+        float v = (rect.origin.y+rect.size.height - i->vertices.y*_scaleFactor) / texHeight;
         i->texCoords.u = u;
         i->texCoords.v = v;
     }
@@ -700,22 +686,21 @@ void AutoPolygon::calculateUV(const Rect& rect, V3F_C4B_T2F* verts, const std::s
 Rect AutoPolygon::getRealRect(const Rect& rect)
 {
     Rect realRect = rect;
-    // check rect to see if its zero
-    if (realRect.equals(Rect::ZERO))
+    //check rect to see if its zero
+    if(realRect.equals(Rect::ZERO))
     {
-        // if the instance doesn't have width and height, then the whole operation is kaput
+        //if the instance doesn't have width and height, then the whole operation is kaput
         CCASSERT(_height && _width, "Please specify a width and height for this instance before using its functions");
-        realRect = Rect(0, 0, _width, _height);
+        realRect = Rect(0,0, (float)_width, (float)_height);
     }
-    else
-    {
-        // rect is specified, so convert to real rect
+    else{
+        //rect is specified, so convert to real rect
         realRect = CC_RECT_POINTS_TO_PIXELS(rect);
     }
     return realRect;
 }
 
-PolygonInfo AutoPolygon::generateTriangles(const Rect& rect, const float& epsilon, const float& threshold)
+PolygonInfo AutoPolygon::generateTriangles(const Rect& rect, float epsilon, float threshold)
 {
     Rect realRect = getRealRect(rect);
     auto p = trace(realRect, threshold);
@@ -725,11 +710,12 @@ PolygonInfo AutoPolygon::generateTriangles(const Rect& rect, const float& epsilo
     calculateUV(realRect, tri.verts, tri.vertCount);
     PolygonInfo ret;
     ret.triangles = tri;
-    ret.filename = _filename;
-    ret.rect = realRect;
+    ret.setFilename(_filename);
+    ret.setRect(realRect);
     return ret;
 }
-PolygonInfo AutoPolygon::generatePolygon(const std::string& filename, const Rect& rect, const float epsilon, const float threshold)
+
+PolygonInfo AutoPolygon::generatePolygon(const std::string& filename, const Rect& rect, float epsilon, float threshold)
 {
     AutoPolygon ap(filename);
     return ap.generateTriangles(rect, epsilon, threshold);
diff --git a/cocos2d/cocos/2d/CCAutoPolygon.h b/cocos2d/cocos/2d/CCAutoPolygon.h
index 97c22951a4..a31dddfbe8 100644
--- a/cocos2d/cocos/2d/CCAutoPolygon.h
+++ b/cocos2d/cocos/2d/CCAutoPolygon.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,25 +26,16 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_AUTOPOLYGON_H
-#define CC_2D_AUTOPOLYGON_H
+#ifndef COCOS_2D_CCAUTOPOLYGON_H__
+#define COCOS_2D_CCAUTOPOLYGON_H__
 
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCTrianglesCommand.h>
-
-#include <cstddef>
-#include <iosfwd>
+#include <string>
 #include <vector>
+#include <cocos/platform/CCImage.h>
+#include <cocos/renderer/CCTrianglesCommand.h>
 
 NS_CC_BEGIN
 
-class Image;
-struct V3F_C4B_T2F;
-struct V3F_C4B_T2F_Quad;
-
 /**
  * @addtogroup _2d
  * @{
@@ -73,21 +65,30 @@ public:
     PolygonInfo(const PolygonInfo& other);
     //  end of creators group
     /// @}
-
+    
     /**
      * Copy the member of the other PolygonInfo
      * @param other     another PolygonInfo to be copied
      */
-    PolygonInfo& operator=(const PolygonInfo& other);
+    PolygonInfo& operator= (const PolygonInfo &other);
     ~PolygonInfo();
-
+    
     /**
      * set the data to be a pointer to a quad
      * the member verts will not be released when this PolygonInfo destructs
      * as the verts memory are managed by other objects
      * @param quad  a pointer to the V3F_C4B_T2F_Quad object
      */
-    void setQuad(V3F_C4B_T2F_Quad* quad);
+    void setQuad(V3F_C4B_T2F_Quad *quad);
+
+    /**
+     * set the data to be a pointer to a number of Quads
+     * the member verts will not be released when this PolygonInfo destructs
+     * as the verts memory are managed by other objects
+     * @param quad  a pointer to the V3F_C4B_T2F_Quad quads
+     */
+    void setQuads(V3F_C4B_T2F_Quad *quads, int numberOfQuads);
+
 
     /**
      * set the data to be a pointer to a triangles
@@ -102,33 +103,37 @@ public:
      * @return number of vertices
      */
     unsigned int getVertCount() const;
-
+    
     /**
      * get triangles count
      * @return number of triangles
      */
     unsigned int getTrianglesCount() const;
-
-    /** @deprecated Use method getTrianglesCount() instead */
-    CC_DEPRECATED_ATTRIBUTE unsigned int getTriaglesCount() const;
-
+    
     /**
      * get sum of all triangle area size
      * @return sum of all triangle area size
      */
     float getArea() const;
 
-    Rect rect;
-    std::string filename;
+    const Rect& getRect() const { return _rect; }
+    void setRect(const Rect& rect) { _rect = rect; }
+    const std::string& getFilename() const { return _filename; }
+    void setFilename(const std::string& filename ) { _filename = filename; }
+
+    // FIXME: this should be a property, not a public ivar
     TrianglesCommand::Triangles triangles;
 
 protected:
-    bool isVertsOwner;
+    bool _isVertsOwner;
+    Rect _rect;
+    std::string _filename;
 
 private:
     void releaseVertsAndIndices();
 };
 
+
 /**
  * AutoPolygon is a helper Object
  * AutoPolygon's purpose is to process an image into 2d polygon mesh in runtime
@@ -144,15 +149,15 @@ public:
      * @param   filename    a path to image file, e.g., "scene1/monster.png".
      * @return  an AutoPolygon object;
      */
-    AutoPolygon(const std::string& filename);
-
+    AutoPolygon(const std::string &filename);
+    
     /**
      * Destructor of AutoPolygon.
      */
     ~AutoPolygon();
-
+    
     /**
-     * trace all the points along the outline of the image,
+     * trace all the points along the outline of the image, 
      * @warning must create AutoPolygon with filename to use this function
      * @param   rect    a texture rect for specify an area of the image
      * @param   threshold   the value when alpha is greater than this value will be counted as opaque, default to 0.0
@@ -163,11 +168,11 @@ public:
      * std::vector<Vec2> points = ap.trace(rect);//default threshold is 0.0
      * @endcode
      */
-    std::vector<Vec2> trace(const cocos2d::Rect& rect, const float& threshold = 0.0);
-
+     std::vector<Vec2> trace(const cocos2d::Rect& rect, float threshold = 0.0f);
+    
     /**
      * reduce the amount of points so its faster for GPU to process and draw
-     * based on Ramer-Douglas-Puecker algorithm
+     * based on Ramer-Douglas-Peucker algorithm
      * @param   points  a vector of Vec2 points as input
      * @param   rect    a texture rect for specify an area of the image to avoid over reduction
      * @param   epsilon the perpendicular distance where points smaller than this value will be discarded
@@ -177,14 +182,13 @@ public:
      * std::vector<Vec2> reduced = ap.reduce(inputPoints, rect);//default epsilon is 2
      * @endcode
      */
-    std::vector<Vec2> reduce(const std::vector<Vec2>& points, const Rect& rect, const float& epsilon = 2.0);
-
+    std::vector<Vec2> reduce(const std::vector<Vec2>& points, const Rect& rect, float epsilon = 2.0f);
+    
     /**
      * expand the points along their edge, useful after you reduce the points that cuts into the sprite
      * using ClipperLib
      * @param   points  a vector of Vec2 points as input
-     * @param   rect    a texture rect for specify an area of the image, the expanded points will be clamped in this rect, ultimately resulting in a quad if the
-     * expansion is too great
+     * @param   rect    a texture rect for specify an area of the image, the expanded points will be clamped in this rect, ultimately resulting in a quad if the expansion is too great
      * @param   epsilon the distance which the edges will expand
      * @return  a vector of Vec2 as the result of the expansion
      * @code
@@ -192,8 +196,8 @@ public:
      * std::vector<Vec2> expanded = ap.expand(inputPoints, rect, 2.0);
      * @endcode
      */
-    std::vector<Vec2> expand(const std::vector<Vec2>& points, const Rect& rect, const float& epsilon);
-
+    std::vector<Vec2> expand(const std::vector<Vec2>& points, const Rect& rect, float epsilon);
+    
     /**
      * Triangulate the input points into triangles for rendering
      * using poly2tri
@@ -206,7 +210,7 @@ public:
      * @endcode
      */
     TrianglesCommand::Triangles triangulate(const std::vector<Vec2>& points);
-
+    
     /**
      * calculate the UV coordinates for each points based on a texture rect
      * @warning This method requires the AutoPolygon object to know the texture file dimension
@@ -219,8 +223,8 @@ public:
      * ap.calculateUV(rect, myPolygons.verts, 20);
      * @endcode
      */
-    void calculateUV(const Rect& rect, V3F_C4B_T2F* verts, const std::size_t& count);
-
+    void calculateUV(const Rect& rect, V3F_C4B_T2F* verts, ssize_t count);
+    
     /**
      * a helper function, packing trace, reduce, expand, triangulate and calculate uv in one function
      * @param   rect    texture rect, use Rect::ZERO for the size of the texture, default is Rect::ZERO
@@ -235,12 +239,11 @@ public:
      * auto sp2 = Sprite::create(myInfo2);
      * @endcode
      */
-    PolygonInfo generateTriangles(const Rect& rect = Rect::ZERO, const float& epsilon = 2.0, const float& threshold = 0.05);
-
+    PolygonInfo generateTriangles(const Rect& rect = Rect::ZERO, float epsilon = 2.0f, float threshold = 0.05f);
+    
     /**
      * a helper function, packing autoPolygon creation, trace, reduce, expand, triangulate and calculate uv in one function
-     * @warning if you want to repetitively generate polygons, consider create an AutoPolygon object, and use generateTriangles function, as it only reads the
-     * file once
+     * @warning if you want to repetitively generate polygons, consider create an AutoPolygon object, and use generateTriangles function, as it only reads the file once
      * @param   filename     A path to image file, e.g., "scene1/monster.png".
      * @param   rect    texture rect, use Rect::ZERO for the size of the texture, default is Rect::ZERO
      * @param   epsilon the value used to reduce and expand, default to 2.0
@@ -250,27 +253,26 @@ public:
      * auto sp = Sprite::create(AutoPolygon::generatePolygon("grossini.png"));
      * @endcode
      */
-    static PolygonInfo generatePolygon(const std::string& filename, const Rect& rect = Rect::ZERO, const float epsilon = 2.0, const float threshold = 0.05);
-
+    static PolygonInfo generatePolygon(const std::string& filename, const Rect& rect = Rect::ZERO, float epsilon = 2.0f, float threshold = 0.05f);
 protected:
-    Vec2 findFirstNoneTransparentPixel(const Rect& rect, const float& threshold);
-    std::vector<cocos2d::Vec2> marchSquare(const Rect& rect, const Vec2& first, const float& threshold);
-    unsigned int getSquareValue(const unsigned int& x, const unsigned int& y, const Rect& rect, const float& threshold);
+    Vec2 findFirstNoneTransparentPixel(const Rect& rect, float threshold);
+    std::vector<cocos2d::Vec2> marchSquare(const Rect& rect, const Vec2& first, float threshold);
+    unsigned int getSquareValue(unsigned int x, unsigned int y, const Rect& rect, float threshold);
 
-    unsigned char getAlphaByIndex(const unsigned int& i);
+    unsigned char getAlphaByIndex(unsigned int i);
     unsigned char getAlphaByPos(const Vec2& pos);
 
-    int getIndexFromPos(const unsigned int& x, const unsigned int& y) { return y * _width + x; }
-    cocos2d::Vec2 getPosFromIndex(const unsigned int& i) { return cocos2d::Vec2(i % _width, i / _width); }
+    int getIndexFromPos(unsigned int x, unsigned int y) { return y*_width+x; }
+    cocos2d::Vec2 getPosFromIndex(unsigned int i) { return cocos2d::Vec2(static_cast<float>(i%_width), static_cast<float>(i/_width)); }
 
     std::vector<cocos2d::Vec2> rdp(const std::vector<cocos2d::Vec2>& v, float optimization);
     float perpendicularDistance(const cocos2d::Vec2& i, const cocos2d::Vec2& start, const cocos2d::Vec2& end);
 
-    // real rect is the size that is in scale with the texture file
+    //real rect is the size that is in scale with the texture file
     Rect getRealRect(const Rect& rect);
-
+    
     Image* _image;
-    unsigned char* _data;
+    unsigned char * _data;
     std::string _filename;
     unsigned int _width;
     unsigned int _height;
@@ -280,4 +282,4 @@ protected:
 
 NS_CC_END
 
-#endif // CC_2D_AUTOPOLYGON_H
+#endif // #ifndef COCOS_2D_CCAUTOPOLYGON_H__
diff --git a/cocos2d/cocos/2d/CCCamera.cpp b/cocos2d/cocos/2d/CCCamera.cpp
index d0bfb65b9e..05bc351877 100644
--- a/cocos2d/cocos/2d/CCCamera.cpp
+++ b/cocos2d/cocos/2d/CCCamera.cpp
@@ -1,18 +1,19 @@
 /****************************************************************************
- Copyright (c) 2014 Chukong Technologies Inc.
-
+ Copyright (c) 2014-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2019 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -25,32 +26,17 @@
 
  ****************************************************************************/
 #include <cocos/2d/CCCamera.h>
-
 #include <cocos/2d/CCCameraBackgroundBrush.h>
-#include <cocos/2d/CCNode.h>
-#include <cocos/2d/CCScene.h>
-#include <cocos/3d/CCFrustum.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Quaternion.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/math/Vec4.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCFrameBuffer.h>
-
-#include <algorithm>
-#include <cstring>
-#include <new>
-#include <vector>
+#include <cocos/platform/CCGLView.h>
+#include <cocos/2d/CCScene.h>
+#include <cocos/renderer/CCRenderer.h>
+#include <cocos/renderer/CCQuadCommand.h>
 
 NS_CC_BEGIN
 
 Camera* Camera::_visitingCamera = nullptr;
-experimental::Viewport Camera::_defaultViewport;
+Viewport Camera::_defaultViewport;
 
 // start static methods
 
@@ -59,8 +45,8 @@ Camera* Camera::create()
     Camera* camera = new (std::nothrow) Camera();
     camera->initDefault();
     camera->autorelease();
-    camera->setDepth(0.f);
-
+    camera->setDepth(0);
+    
     return camera;
 }
 
@@ -93,7 +79,7 @@ Camera* Camera::createOrthographic(float zoomX, float zoomY, float nearPlane, fl
 Camera* Camera::getDefaultCamera()
 {
     auto scene = Director::getInstance()->getRunningScene();
-    if (scene)
+    if(scene)
     {
         return scene->getDefaultCamera();
     }
@@ -101,11 +87,11 @@ Camera* Camera::getDefaultCamera()
     return nullptr;
 }
 
-const experimental::Viewport& Camera::getDefaultViewport()
+const Viewport& Camera::getDefaultViewport()
 {
     return _defaultViewport;
 }
-void Camera::setDefaultViewport(const experimental::Viewport& vp)
+void Camera::setDefaultViewport(const Viewport& vp)
 {
     _defaultViewport = vp;
 }
@@ -118,22 +104,13 @@ const Camera* Camera::getVisitingCamera()
 // end static methods
 
 Camera::Camera()
-: _scene(nullptr)
-, _viewProjectionDirty(true)
-, _cameraFlag(1)
-, _frustumDirty(true)
-, _viewProjectionUpdated(false)
-, _depth(-1)
-, _fbo(nullptr)
 {
-    _frustum.setClipZ(true);
-    _clearBrush = CameraBackgroundBrush::createDepthBrush(1.f);
-    _clearBrush->retain();
+    // minggo comment
+    // _frustum.setClipZ(true);
 }
 
 Camera::~Camera()
 {
-    CC_SAFE_RELEASE_NULL(_fbo);
     CC_SAFE_RELEASE(_clearBrush);
 }
 
@@ -159,22 +136,22 @@ void Camera::lookAt(const Vec3& lookAtPos, const Vec3& up)
     Vec3 upv = up;
     upv.normalize();
     Vec3 zaxis;
-    Vec3::subtract(this->getPosition3D(), lookAtPos, zaxis);
+    Vec3::subtract(this->getPosition3D(), lookAtPos, &zaxis);
     zaxis.normalize();
-
+    
     Vec3 xaxis;
-    Vec3::cross(upv, zaxis, xaxis);
+    Vec3::cross(upv, zaxis, &xaxis);
     xaxis.normalize();
-
+    
     Vec3 yaxis;
-    Vec3::cross(zaxis, xaxis, yaxis);
+    Vec3::cross(zaxis, xaxis, &yaxis);
     yaxis.normalize();
-    Mat4 rotation;
+    Mat4  rotation;
     rotation.m[0] = xaxis.x;
     rotation.m[1] = xaxis.y;
     rotation.m[2] = xaxis.z;
     rotation.m[3] = 0;
-
+    
     rotation.m[4] = yaxis.x;
     rotation.m[5] = yaxis.y;
     rotation.m[6] = yaxis.z;
@@ -183,9 +160,9 @@ void Camera::lookAt(const Vec3& lookAtPos, const Vec3& up)
     rotation.m[9] = zaxis.y;
     rotation.m[10] = zaxis.z;
     rotation.m[11] = 0;
-
-    Quaternion quaternion;
-    Quaternion::createFromRotationMatrix(rotation, quaternion);
+    
+    Quaternion  quaternion;
+    Quaternion::createFromRotationMatrix(rotation,&quaternion);
     quaternion.normalize();
     setRotationQuat(quaternion);
 }
@@ -196,9 +173,9 @@ const Mat4& Camera::getViewProjectionMatrix() const
     if (_viewProjectionDirty)
     {
         _viewProjectionDirty = false;
-        Mat4::multiply(_projection, _view, _viewProjection);
+        Mat4::multiply(_projection, _view, &_viewProjection);
     }
-
+    
     return _viewProjection;
 }
 
@@ -211,7 +188,7 @@ void Camera::setAdditionalProjection(const Mat4& mat)
 bool Camera::initDefault()
 {
     auto size = Director::getInstance()->getWinSize();
-    // create default camera
+    //create default camera
     auto projection = Director::getInstance()->getProjection();
     switch (projection)
     {
@@ -225,13 +202,13 @@ bool Camera::initDefault()
         case Director::Projection::_3D:
         {
             float zeye = Director::getInstance()->getZEye();
-            initPerspective(60, static_cast<GLfloat>(size.width) / size.height, 10, zeye + size.height / 2.0f);
-            Vec3 eye(size.width / 2, size.height / 2.0f, zeye), center(size.width / 2, size.height / 2, 0.0f), up(0.0f, 1.0f, 0.0f);
+            initPerspective(60, (float)size.width / size.height, 10, zeye + size.height / 2.0f);
+            Vec3 eye(size.width/2, size.height/2.0f, zeye), center(size.width/2, size.height/2, 0.0f), up(0.0f, 1.0f, 0.0f);
             setPosition3D(eye);
             lookAt(center, up);
             break;
         }
-        case Director::Projection::CUSTOM:
+        default:
             CCLOG("unrecognized projection");
             break;
     }
@@ -244,10 +221,11 @@ bool Camera::initPerspective(float fieldOfView, float aspectRatio, float nearPla
     _aspectRatio = aspectRatio;
     _nearPlane = nearPlane;
     _farPlane = farPlane;
-    Mat4::createPerspective(_fieldOfView, _aspectRatio, _nearPlane, _farPlane, _projection);
+    Mat4::createPerspective(_fieldOfView, _aspectRatio, _nearPlane, _farPlane, &_projection);
     _viewProjectionDirty = true;
     _frustumDirty = true;
-
+    _type = Type::PERSPECTIVE;
+    
     return true;
 }
 
@@ -257,25 +235,26 @@ bool Camera::initOrthographic(float zoomX, float zoomY, float nearPlane, float f
     _zoom[1] = zoomY;
     _nearPlane = nearPlane;
     _farPlane = farPlane;
-    Mat4::createOrthographicOffCenter(0, _zoom[0], 0, _zoom[1], _nearPlane, _farPlane, _projection);
+    Mat4::createOrthographicOffCenter(0, _zoom[0], 0, _zoom[1], _nearPlane, _farPlane, &_projection);
     _viewProjectionDirty = true;
     _frustumDirty = true;
-
+    _type = Type::ORTHOGRAPHIC;
+    
     return true;
 }
 
 Vec2 Camera::project(const Vec3& src) const
 {
     Vec2 screenPos;
-
+    
     auto viewport = Director::getInstance()->getWinSize();
     Vec4 clipPos;
-    getViewProjectionMatrix().transformVector(Vec4(src.x, src.y, src.z, 1.0f), clipPos);
-
+    getViewProjectionMatrix().transformVector(Vec4(src.x, src.y, src.z, 1.0f), &clipPos);
+    
     CCASSERT(clipPos.w != 0.0f, "clipPos.w can't be 0.0f!");
     float ndcX = clipPos.x / clipPos.w;
     float ndcY = clipPos.y / clipPos.w;
-
+    
     screenPos.x = (ndcX + 1.0f) * 0.5f * viewport.width;
     screenPos.y = (1.0f - (ndcY + 1.0f) * 0.5f) * viewport.height;
     return screenPos;
@@ -284,15 +263,15 @@ Vec2 Camera::project(const Vec3& src) const
 Vec2 Camera::projectGL(const Vec3& src) const
 {
     Vec2 screenPos;
-
+    
     auto viewport = Director::getInstance()->getWinSize();
     Vec4 clipPos;
-    getViewProjectionMatrix().transformVector(Vec4(src.x, src.y, src.z, 1.0f), clipPos);
-
+    getViewProjectionMatrix().transformVector(Vec4(src.x, src.y, src.z, 1.0f), &clipPos);
+    
     CCASSERT(clipPos.w != 0.0f, "clipPos.w can't be 0.0f!");
     float ndcX = clipPos.x / clipPos.w;
     float ndcY = clipPos.y / clipPos.w;
-
+    
     screenPos.x = (ndcX + 1.0f) * 0.5f * viewport.width;
     screenPos.y = (ndcY + 1.0f) * 0.5f * viewport.height;
     return screenPos;
@@ -315,57 +294,57 @@ Vec3 Camera::unprojectGL(const Vec3& src) const
 void Camera::unproject(const Size& viewport, const Vec3* src, Vec3* dst) const
 {
     CCASSERT(src && dst, "vec3 can not be null");
-
+    
     Vec4 screen(src->x / viewport.width, ((viewport.height - src->y)) / viewport.height, src->z, 1.0f);
     screen.x = screen.x * 2.0f - 1.0f;
     screen.y = screen.y * 2.0f - 1.0f;
     screen.z = screen.z * 2.0f - 1.0f;
-
-    getViewProjectionMatrix().getInversed().transformVector(screen, screen);
+    
+    getViewProjectionMatrix().getInversed().transformVector(screen, &screen);
     if (screen.w != 0.0f)
     {
         screen.x /= screen.w;
         screen.y /= screen.w;
         screen.z /= screen.w;
     }
-
+    
     dst->set(screen.x, screen.y, screen.z);
 }
 
 void Camera::unprojectGL(const Size& viewport, const Vec3* src, Vec3* dst) const
 {
     CCASSERT(src && dst, "vec3 can not be null");
-
+    
     Vec4 screen(src->x / viewport.width, src->y / viewport.height, src->z, 1.0f);
     screen.x = screen.x * 2.0f - 1.0f;
     screen.y = screen.y * 2.0f - 1.0f;
     screen.z = screen.z * 2.0f - 1.0f;
-
-    getViewProjectionMatrix().getInversed().transformVector(screen, screen);
+    
+    getViewProjectionMatrix().getInversed().transformVector(screen, &screen);
     if (screen.w != 0.0f)
     {
         screen.x /= screen.w;
         screen.y /= screen.w;
         screen.z /= screen.w;
     }
-
+    
     dst->set(screen.x, screen.y, screen.z);
 }
 
-bool Camera::isVisibleInFrustum(const AABB* aabb) const
-{
-    if (_frustumDirty)
-    {
-        _frustum.initFrustum(this);
-        _frustumDirty = false;
-    }
-    return !_frustum.isOutOfFrustum(*aabb);
-}
+ bool Camera::isVisibleInFrustum(const AABB* aabb) const
+ {
+     if (_frustumDirty)
+     {
+         _frustum.initFrustum(this);
+         _frustumDirty = false;
+     }
+     return !_frustum.isOutOfFrustum(*aabb);
+ }
 
 float Camera::getDepthInView(const Mat4& transform) const
 {
     Mat4 camWorldMat = getNodeToWorldTransform();
-    const Mat4& viewMat = camWorldMat.getInversed();
+    const Mat4 &viewMat = camWorldMat.getInversed();
     float depth = -(viewMat.m[2] * transform.m[12] + viewMat.m[6] * transform.m[13] + viewMat.m[10] * transform.m[14] + viewMat.m[14]);
     return depth;
 }
@@ -377,7 +356,7 @@ void Camera::setDepth(int8_t depth)
         _depth = depth;
         if (_scene)
         {
-            // notify scene that the camera order is dirty
+            //notify scene that the camera order is dirty
             _scene->setCameraOrderDirty();
         }
     }
@@ -407,7 +386,7 @@ void Camera::setScene(Scene* scene)
 {
     if (_scene != scene)
     {
-        // remove old scene
+        //remove old scene
         if (_scene)
         {
             auto& cameras = _scene->_cameras;
@@ -416,7 +395,7 @@ void Camera::setScene(Scene* scene)
                 cameras.erase(it);
             _scene = nullptr;
         }
-        // set new scene
+        //set new scene
         if (scene)
         {
             _scene = scene;
@@ -425,7 +404,7 @@ void Camera::setScene(Scene* scene)
             if (it == cameras.end())
             {
                 _scene->_cameras.push_back(this);
-                // notify scene that the camera order is dirty
+                //notify scene that the camera order is dirty
                 _scene->setCameraOrderDirty();
             }
         }
@@ -440,99 +419,26 @@ void Camera::clearBackground()
     }
 }
 
-void Camera::setFrameBufferObject(experimental::FrameBuffer* fbo)
-{
-    CC_SAFE_RETAIN(fbo);
-    CC_SAFE_RELEASE_NULL(_fbo);
-    _fbo = fbo;
-    if (_scene)
-    {
-        _scene->setCameraOrderDirty();
-    }
-}
-
 void Camera::apply()
 {
     _viewProjectionUpdated = _transformUpdated;
-    applyFrameBufferObject();
     applyViewport();
 }
 
-void Camera::applyFrameBufferObject()
-{
-    if (nullptr == _fbo)
-    {
-        // inherit from context if it doesn't have a FBO
-        // don't call apply the default one
-        //        experimental::FrameBuffer::applyDefaultFBO();
-    }
-    else
-    {
-        _fbo->applyFBO();
-    }
-}
-
 void Camera::applyViewport()
 {
-    glGetIntegerv(GL_VIEWPORT, _oldViewport);
-
-    if (nullptr == _fbo)
-    {
-        glViewport(getDefaultViewport()._left, getDefaultViewport()._bottom, getDefaultViewport()._width, getDefaultViewport()._height);
-    }
-    else
-    {
-        glViewport(_viewport._left * _fbo->getWidth(), _viewport._bottom * _fbo->getHeight(), _viewport._width * _fbo->getWidth(),
-                   _viewport._height * _fbo->getHeight());
-    }
-}
-
-void Camera::setViewport(const experimental::Viewport& vp)
-{
-    _viewport = vp;
-}
-
-void Camera::restore()
-{
-    restoreFrameBufferObject();
-    restoreViewport();
-}
-
-void Camera::restoreFrameBufferObject()
-{
-    if (nullptr == _fbo)
-    {
-        // it was inherited from context if it doesn't have a FBO
-        // don't call restore the default one... just keep using the previous one
-        //        experimental::FrameBuffer::applyDefaultFBO();
-    }
-    else
-    {
-        _fbo->restoreFBO();
-    }
-}
-
-void Camera::restoreViewport()
-{
-    glViewport(_oldViewport[0], _oldViewport[1], _oldViewport[2], _oldViewport[3]);
+    Director::getInstance()->getRenderer()->setViewPort(_defaultViewport.x, _defaultViewport.y, _defaultViewport.w, _defaultViewport.h);
 }
 
 int Camera::getRenderOrder() const
 {
     int result(0);
-    if (_fbo)
-    {
-        result = _fbo->getFID() << 8;
-    }
-    else
-    {
-        result = 127 << 8;
-    }
+    result = 127 <<8;
     result += _depth;
     return result;
 }
 
-void Camera::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void Camera::visit(Renderer* renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     _viewProjectionUpdated = _transformUpdated;
     return Node::visit(renderer, parentTransform, parentFlags);
diff --git a/cocos2d/cocos/2d/CCCamera.h b/cocos2d/cocos/2d/CCCamera.h
index e8c7a999c8..fe49cc074d 100644
--- a/cocos2d/cocos/2d/CCCamera.h
+++ b/cocos2d/cocos/2d/CCCamera.h
@@ -1,5 +1,6 @@
 /****************************************************************************
-Copyright (c) 2014 Chukong Technologies Inc.
+Copyright (c) 2014-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2019 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,39 +25,28 @@ THE SOFTWARE.
  Code based GamePlay3D's Camera: http://gameplay3d.org
 
  ****************************************************************************/
-#ifndef CC_2D_CAMERA_H
-#define CC_2D_CAMERA_H
+#pragma once
 
 #include <cocos/2d/CCNode.h>
 #include <cocos/3d/CCFrustum.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCFrameBuffer.h>
-
-#include <cstdint>
+#include <cocos/renderer/CCQuadCommand.h>
+#include <cocos/renderer/CCCustomCommand.h>
 
 NS_CC_BEGIN
 
-class AABB;
-class CameraBackgroundBrush;
-class Renderer;
 class Scene;
-class Size;
+class CameraBackgroundBrush;
 
 /**
- * Note:
+ * Note: 
  * Scene creates a default camera. And the default camera mask of Node is 1, therefore it can be seen by the default camera.
- * During rendering the scene, it draws the objects seen by each camera in the added order except default camera. The default camera is the last one being drawn
- * with. It's usually a good idea to render 3D objects in a separate camera. And set the 3d camera flag to CameraFlag::USER1 or anything else except DEFAULT.
- * Dedicate The DEFAULT camera for UI, because it is rendered at last. You can change the camera order to get different result when depth test is not enabled.
+ * During rendering the scene, it draws the objects seen by each camera in the added order except default camera. The default camera is the last one being drawn with.
+ * It's usually a good idea to render 3D objects in a separate camera.
+ * And set the 3d camera flag to CameraFlag::USER1 or anything else except DEFAULT. Dedicate The DEFAULT camera for UI, because it is rendered at last.
+ * You can change the camera order to get different result when depth test is not enabled.
  * For each camera, transparent 3d sprite is rendered after opaque 3d sprite and other 2d objects.
  */
-enum struct CameraFlag : std::uint16_t
+enum class CameraFlag
 {
     DEFAULT = 1,
     USER1 = 1 << 1,
@@ -71,40 +61,38 @@ enum struct CameraFlag : std::uint16_t
 /**
  * Defines a camera .
  */
-class CC_DLL Camera : public Node
+class CC_DLL Camera :public Node
 {
     friend class Scene;
     friend class Director;
     friend class EventDispatcher;
-
 public:
     /**
-     * The type of camera.
-     */
+    * The type of camera.
+    */
     enum class Type
     {
         PERSPECTIVE = 1,
         ORTHOGRAPHIC = 2
     };
-
 public:
     /**
-     * Creates a perspective camera.
-     *
-     * @param fieldOfView The field of view for the perspective camera (normally in the range of 40-60 degrees).
-     * @param aspectRatio The aspect ratio of the camera (normally the width of the viewport divided by the height of the viewport).
-     * @param nearPlane The near plane distance.
-     * @param farPlane The far plane distance.
-     */
+    * Creates a perspective camera.
+    *
+    * @param fieldOfView The field of view for the perspective camera (normally in the range of 40-60 degrees).
+    * @param aspectRatio The aspect ratio of the camera (normally the width of the viewport divided by the height of the viewport).
+    * @param nearPlane The near plane distance.
+    * @param farPlane The far plane distance.
+    */
     static Camera* createPerspective(float fieldOfView, float aspectRatio, float nearPlane, float farPlane);
     /**
-     * Creates an orthographic camera.
-     *
-     * @param zoomX The zoom factor along the X-axis of the orthographic projection (the width of the ortho projection).
-     * @param zoomY The zoom factor along the Y-axis of the orthographic projection (the height of the ortho projection).
-     * @param nearPlane The near plane distance.
-     * @param farPlane The far plane distance.
-     */
+    * Creates an orthographic camera.
+    *
+    * @param zoomX The zoom factor along the X-axis of the orthographic projection (the width of the ortho projection).
+    * @param zoomY The zoom factor along the Y-axis of the orthographic projection (the height of the ortho projection).
+    * @param nearPlane The near plane distance.
+    * @param farPlane The far plane distance.
+    */
     static Camera* createOrthographic(float zoomX, float zoomY, float nearPlane, float farPlane);
 
     /** create default camera, the camera type depends on Director::getProjection, the depth of the default camera is 0 */
@@ -115,8 +103,8 @@ public:
      */
     static const Camera* getVisitingCamera();
 
-    static const experimental::Viewport& getDefaultViewport();
-    static void setDefaultViewport(const experimental::Viewport& vp);
+    static const Viewport& getDefaultViewport();
+    static void setDefaultViewport(const Viewport& vp);
 
     /**
      * Get the default camera of the current running scene.
@@ -124,40 +112,40 @@ public:
     static Camera* getDefaultCamera();
 
     /**
-     * Gets the type of camera.
-     *
-     * @return The camera type.
-     */
+    * Gets the type of camera.
+    *
+    * @return The camera type.
+    */
     Camera::Type getType() const { return _type; }
 
     /**get & set Camera flag*/
-    CameraFlag getCameraFlag() const { return static_cast<CameraFlag>(_cameraFlag); }
-    void setCameraFlag(CameraFlag flag) { _cameraFlag = static_cast<unsigned short>(flag); }
+    CameraFlag getCameraFlag() const { return _cameraFlag; }
+    void setCameraFlag(CameraFlag flag) { _cameraFlag = flag; }
 
     /**
-     * Make Camera looks at target
-     *
-     * @param target The target camera is point at
-     * @param up The up vector, usually it's Y axis
-     */
+    * Make Camera looks at target
+    *
+    * @param target The target camera is point at
+    * @param up The up vector, usually it's Y axis
+    */
     virtual void lookAt(const Vec3& target, const Vec3& up = Vec3::UNIT_Y);
 
     /**
-     * Gets the camera's projection matrix.
-     *
-     * @return The camera projection matrix.
-     */
+    * Gets the camera's projection matrix.
+    *
+    * @return The camera projection matrix.
+    */
     const Mat4& getProjectionMatrix() const;
     /**
-     * Gets the camera's view matrix.
-     *
-     * @return The camera view matrix.
-     */
+    * Gets the camera's view matrix.
+    *
+    * @return The camera view matrix.
+    */
     const Mat4& getViewMatrix() const;
 
     /**get view projection matrix*/
     const Mat4& getViewProjectionMatrix() const;
-
+    
     /* convert the specified point in 3D world-space coordinates into the screen-space coordinates.
      *
      * Origin point at left top corner in screen-space.
@@ -165,7 +153,7 @@ public:
      * @return The screen-space position.
      */
     Vec2 project(const Vec3& src) const;
-
+    
     /* convert the specified point in 3D world-space coordinates into the GL-screen-space coordinates.
      *
      * Origin point at left bottom corner in GL-screen-space.
@@ -173,7 +161,7 @@ public:
      * @return The GL-screen-space position.
      */
     Vec2 projectGL(const Vec3& src) const;
-
+    
     /**
      * Convert the specified point of screen-space coordinate into the 3D world-space coordinate.
      *
@@ -182,7 +170,7 @@ public:
      * @return The 3D world-space position.
      */
     Vec3 unproject(const Vec3& src) const;
-
+    
     /**
      * Convert the specified point of GL-screen-space coordinate into the 3D world-space coordinate.
      *
@@ -191,7 +179,7 @@ public:
      * @return The 3D world-space position.
      */
     Vec3 unprojectGL(const Vec3& src) const;
-
+    
     /**
      * Convert the specified point of screen-space coordinate into the 3D world-space coordinate.
      *
@@ -201,7 +189,7 @@ public:
      * @param dst  The 3D world-space position.
      */
     void unproject(const Size& size, const Vec3* src, Vec3* dst) const;
-
+    
     /**
      * Convert the specified point of GL-screen-space coordinate into the 3D world-space coordinate.
      *
@@ -216,29 +204,27 @@ public:
      * Is this aabb visible in frustum
      */
     bool isVisibleInFrustum(const AABB* aabb) const;
-
+    
     /**
      * Get object depth towards camera
      */
     float getDepthInView(const Mat4& transform) const;
-
+    
     /**
-     * set depth, camera with larger depth is drawn on top of camera with smaller depth, the depth of camera with CameraFlag::DEFAULT is 0, user defined camera
-     * is -1 by default
+     * set depth, camera with larger depth is drawn on top of camera with smaller depth, the depth of camera with CameraFlag::DEFAULT is 0, user defined camera is -1 by default
      */
-    void setDepth(std::int8_t depth);
-
+    void setDepth(int8_t depth);
+    
     /**
-     * get depth, camera with larger depth is drawn on top of camera with smaller depth, the depth of camera with CameraFlag::DEFAULT is 0, user defined camera
-     * is -1 by default
+     * get depth, camera with larger depth is drawn on top of camera with smaller depth, the depth of camera with CameraFlag::DEFAULT is 0, user defined camera is -1 by default
      */
-    std::int8_t getDepth() const { return _depth; }
-
+    int8_t getDepth() const { return _depth; }
+    
     /**
      get rendered order
      */
     int getRenderOrder() const;
-
+    
     /**
      * Get the frustum's far plane.
      */
@@ -248,39 +234,25 @@ public:
      * Get the frustum's near plane.
      */
     float getNearPlane() const { return _nearPlane; }
-
-    // override
+    
+    //override
     virtual void onEnter() override;
     virtual void onExit() override;
 
     /**
-     Before rendering scene with this camera, the background need to be cleared. It clears the depth buffer with max depth by default. Use setBackgroundBrush to
-     modify the default behavior
+     Before rendering scene with this camera, the background need to be cleared. It clears the depth buffer with max depth by default. Use setBackgroundBrush to modify the default behavior
      */
     void clearBackground();
     /**
      Apply the FBO, RenderTargets and viewport.
      */
     void apply();
-    /**
-     Restore the FBO, RenderTargets and viewport.
-     */
-    void restore();
-
-    /**
-     Set FBO, which will attach several render target for the rendered result.
-     */
-    void setFrameBufferObject(experimental::FrameBuffer* fbo);
-    /**
-     Set Viewport for camera.
-     */
-    void setViewport(const experimental::Viewport& vp);
 
     /**
      * Whether or not the viewprojection matrix was updated since the last frame.
      * @return True if the viewprojection matrix was updated since the last frame.
      */
-    bool isViewProjectionUpdated() const { return _viewProjectionUpdated; }
+    bool isViewProjectionUpdated() const {return _viewProjectionUpdated;}
 
     /**
      * set the background brush. See CameraBackgroundBrush for more information.
@@ -293,12 +265,13 @@ public:
      */
     CameraBackgroundBrush* getBackgroundBrush() const { return _clearBrush; }
 
-    void visit(Renderer* renderer, const Mat4& parentTransform, std::uint32_t parentFlags) override;
+    virtual void visit(Renderer* renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
 
     bool isBrushValid();
 
-    CC_CONSTRUCTOR_ACCESS : Camera();
-    ~Camera() override;
+CC_CONSTRUCTOR_ACCESS:
+    Camera();
+    ~Camera();
 
     /**
      * Set the scene,this method shall not be invoke manually
@@ -312,16 +285,13 @@ public:
     bool initDefault();
     bool initPerspective(float fieldOfView, float aspectRatio, float nearPlane, float farPlane);
     bool initOrthographic(float zoomX, float zoomY, float nearPlane, float farPlane);
-    void applyFrameBufferObject();
     void applyViewport();
-    void restoreFrameBufferObject();
-    void restoreViewport();
 
 protected:
     static Camera* _visitingCamera;
-    static experimental::Viewport _defaultViewport;
+    static Viewport _defaultViewport;
 
-    Scene* _scene; // Scene camera belongs to
+    Scene* _scene = nullptr; //Scene camera belongs to
     Mat4 _projection;
     mutable Mat4 _view;
     mutable Mat4 _viewInv;
@@ -329,26 +299,19 @@ protected:
 
     Vec3 _up;
     Camera::Type _type;
-    float _fieldOfView;
-    float _zoom[2];
-    float _aspectRatio;
-    float _nearPlane;
-    float _farPlane;
-    mutable bool _viewProjectionDirty;
-    bool _viewProjectionUpdated; // Whether or not the viewprojection matrix was updated since the last frame.
-    unsigned short _cameraFlag; // camera flag
-    mutable Frustum _frustum; // camera frustum
-    mutable bool _frustumDirty;
-    std::int8_t _depth; // camera depth, the depth of camera with CameraFlag::DEFAULT flag is 0 by default, a camera with larger depth is drawn on top of camera
-                        // with smaller depth
-
-    CameraBackgroundBrush* _clearBrush; // brush used to clear the back ground
-
-    experimental::Viewport _viewport;
-    experimental::FrameBuffer* _fbo;
-    GLint _oldViewport[4];
+    float _fieldOfView = 0.f;
+    float _zoom[2] = {0.f};
+    float _aspectRatio = 0.f;
+    float _nearPlane = 0.f;
+    float _farPlane = 0.f;
+    mutable bool  _viewProjectionDirty = true;
+    bool _viewProjectionUpdated = false; //Whether or not the viewprojection matrix was updated since the last frame.
+    CameraFlag _cameraFlag = CameraFlag::DEFAULT; // camera flag
+    mutable Frustum _frustum;   // camera frustum
+    mutable bool _frustumDirty = true;
+    int8_t  _depth = -1;                 //camera depth, the depth of camera with CameraFlag::DEFAULT flag is 0 by default, a camera with larger depth is drawn on top of camera with smaller depth
+
+    CameraBackgroundBrush* _clearBrush = nullptr; //brush used to clear the back ground
 };
 
 NS_CC_END
-
-#endif // CC_2D_CAMERA_H
diff --git a/cocos2d/cocos/2d/CCCameraBackgroundBrush.cpp b/cocos2d/cocos/2d/CCCameraBackgroundBrush.cpp
index 109a5be853..1bf485f165 100644
--- a/cocos2d/cocos/2d/CCCameraBackgroundBrush.cpp
+++ b/cocos2d/cocos/2d/CCCameraBackgroundBrush.cpp
@@ -1,18 +1,19 @@
 /****************************************************************************
- Copyright (c) 2015-2017 Chukong Technologies Inc.
-
+ Copyright (c) 2015-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -23,54 +24,40 @@
 
  ****************************************************************************/
 #include <cocos/2d/CCCameraBackgroundBrush.h>
-
 #include <cocos/2d/CCCamera.h>
+#include <cocos/base/ccMacros.h>
+#include <cocos/base/ccUtils.h>
 #include <cocos/base/CCConfiguration.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/math/Vec4.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformConfig.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramCache.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCRenderState.h>
 #include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTexture2D.h>
+#include <cocos/renderer/CCRenderState.h>
 #include <cocos/renderer/CCTextureCube.h>
-#include <cocos/renderer/ccGLStateCache.h>
-
-#include <cstddef>
-#include <new>
+#include <cocos/renderer/ccShaders.h>
 
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID || CC_TARGET_PLATFORM == CC_PLATFORM_WINRT || CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN)
-#    include <cocos/base/CCEventCustom.h>
-#    include <cocos/base/CCEventDispatcher.h>
-#    include <cocos/base/CCEventListenerCustom.h>
-#    include <cocos/base/CCEventType.h>
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+#include <cocos/base/CCEventCustom.h>
+#include <cocos/base/CCEventListenerCustom.h>
+#include <cocos/base/CCEventType.h>
+#include <cocos/base/CCEventDispatcher.h>
 #endif
 
 NS_CC_BEGIN
 
 CameraBackgroundBrush::CameraBackgroundBrush()
-: _glProgramState(nullptr)
 {
+    
 }
 
 CameraBackgroundBrush::~CameraBackgroundBrush()
 {
-    CC_SAFE_RELEASE(_glProgramState);
+    CC_SAFE_RELEASE_NULL(_programState);
 }
 
 CameraBackgroundBrush* CameraBackgroundBrush::createNoneBrush()
 {
     auto ret = new (std::nothrow) CameraBackgroundBrush();
     ret->init();
-
+    
     ret->autorelease();
     return ret;
 }
@@ -85,8 +72,7 @@ CameraBackgroundDepthBrush* CameraBackgroundBrush::createDepthBrush(float depth)
     return CameraBackgroundDepthBrush::create(depth);
 }
 
-CameraBackgroundSkyBoxBrush* CameraBackgroundBrush::createSkyboxBrush(const std::string& positive_x, const std::string& negative_x, const std::string& positive_y,
-                                                                      const std::string& negative_y, const std::string& positive_z, const std::string& negative_z)
+CameraBackgroundSkyBoxBrush* CameraBackgroundBrush::createSkyboxBrush(const std::string& positive_x, const std::string& negative_x, const std::string& positive_y, const std::string& negative_y, const std::string& positive_z, const std::string& negative_z)
 {
     return CameraBackgroundSkyBoxBrush::create(positive_x, negative_x, positive_y, negative_y, positive_z, negative_z);
 }
@@ -95,32 +81,31 @@ CameraBackgroundSkyBoxBrush* CameraBackgroundBrush::createSkyboxBrush(const std:
 
 CameraBackgroundDepthBrush::CameraBackgroundDepthBrush()
 : _depth(0.f)
-, _clearColor(GL_FALSE)
-, _vao(0)
-, _vertexBuffer(0)
-, _indexBuffer(0)
+, _clearColor(false)
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+    , _backToForegroundListener(nullptr)
+#endif
 {
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+    _backToForegroundListener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, [this](EventCustom*)
+        {
+            initBuffer();
+        }
+    );
+    Director::getInstance()->getEventDispatcher()->addEventListenerWithFixedPriority(_backToForegroundListener, -1);
+#endif
 }
 CameraBackgroundDepthBrush::~CameraBackgroundDepthBrush()
 {
-    glDeleteBuffers(1, &_vertexBuffer);
-    glDeleteBuffers(1, &_indexBuffer);
-
-    _vertexBuffer = 0;
-    _indexBuffer = 0;
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        glDeleteVertexArrays(1, &_vao);
-        GL::bindVAO(0);
-        _vao = 0;
-    }
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+    Director::getInstance()->getEventDispatcher()->removeEventListener(_backToForegroundListener);
+#endif
 }
 
 CameraBackgroundDepthBrush* CameraBackgroundDepthBrush::create(float depth)
 {
     auto ret = new (std::nothrow) CameraBackgroundDepthBrush();
-
+    
     if (nullptr != ret && ret->init())
     {
         ret->_depth = depth;
@@ -136,141 +121,104 @@ CameraBackgroundDepthBrush* CameraBackgroundDepthBrush::create(float depth)
 
 bool CameraBackgroundDepthBrush::init()
 {
-    auto shader = GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_CAMERA_CLEAR);
-    _glProgramState = GLProgramState::getOrCreateWithGLProgram(shader);
-    _glProgramState->retain();
-
-    _quad.bl.vertices = Vec3(-1, -1, 0);
-    _quad.br.vertices = Vec3(1, -1, 0);
-    _quad.tl.vertices = Vec3(-1, 1, 0);
-    _quad.tr.vertices = Vec3(1, 1, 0);
+    CC_SAFE_RELEASE_NULL(_programState);
+    _programState = new backend::ProgramState(cameraClear_vert, cameraClear_frag);
 
-    _quad.bl.colors = _quad.br.colors = _quad.tl.colors = _quad.tr.colors = Color4B(0, 0, 0, 1);
+    _locDepth = _programState->getUniformLocation("dpeth");
 
-    _quad.bl.texCoords = Tex2F(0, 0);
-    _quad.br.texCoords = Tex2F(1, 0);
-    _quad.tl.texCoords = Tex2F(0, 1);
-    _quad.tr.texCoords = Tex2F(1, 1);
+    auto &pipelineDescriptor = _customCommand.getPipelineDescriptor();
+    pipelineDescriptor.programState = _programState;
 
-    auto supportVAO = Configuration::getInstance()->supportsShareableVAO();
-    if (supportVAO)
+    auto layout = _programState->getVertexLayout();
+    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
     {
-        glGenVertexArrays(1, &_vao);
-        GL::bindVAO(_vao);
+        layout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT3, offsetof(V3F_C4B_T2F, vertices), false);
     }
-
-    glGenBuffers(1, &_vertexBuffer);
-    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);
-    glBufferData(GL_ARRAY_BUFFER, sizeof(_quad), &_quad, GL_STATIC_DRAW);
-
-    GLshort indices[6] = {0, 1, 2, 3, 2, 1};
-    glGenBuffers(1, &_indexBuffer);
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer);
-    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
-
-    if (supportVAO)
+    iter = attributeInfo.find("a_color");
+    if(iter != attributeInfo.end())
     {
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX, _vao);
-        // vertices
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof(V3F_C4B_T2F),
-                              reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, vertices)));
-
-        // colors
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V3F_C4B_T2F),
-                              reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, colors)));
-
-        // tex coords
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(V3F_C4B_T2F),
-                              reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, texCoords)));
+        layout->setAttribute("a_color", iter->second.location, backend::VertexFormat::UBYTE4, offsetof(V3F_C4B_T2F, colors), true);
     }
-
-    if (supportVAO)
-        GL::bindVAO(0);
-
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-    return true;
-}
-
-void CameraBackgroundDepthBrush::drawBackground(Camera* /*camera*/)
-{
-    GLboolean oldDepthTest;
-    GLint oldDepthFunc;
-    GLboolean oldDepthMask;
+    iter = attributeInfo.find("a_texCoord");
+    if(iter != attributeInfo.end())
     {
-        glColorMask(_clearColor, _clearColor, _clearColor, _clearColor);
-        glStencilMask(0);
+        layout->setAttribute("a_texCoord", iter->second.location, backend::VertexFormat::FLOAT2, offsetof(V3F_C4B_T2F, texCoords), true);
+    }
+    layout->setLayout(sizeof(_vertices[0]));
 
-        oldDepthTest = glIsEnabled(GL_DEPTH_TEST);
-        glGetIntegerv(GL_DEPTH_FUNC, &oldDepthFunc);
-        glGetBooleanv(GL_DEPTH_WRITEMASK, &oldDepthMask);
+    _vertices.resize(4);
+    _vertices[0].vertices = Vec3(-1, -1, 0);
+    _vertices[1].vertices = Vec3(1, -1, 0);
+    _vertices[2].vertices = Vec3(1, 1, 0);
+    _vertices[3].vertices = Vec3(-1, 1, 0);
 
-        glDepthMask(GL_TRUE);
-        glEnable(GL_DEPTH_TEST);
-        glDepthFunc(GL_ALWAYS);
-    }
+    _vertices[0].colors = _vertices[1].colors = _vertices[2].colors = _vertices[3].colors = Color4B(0, 0, 0, 1);
 
-    // draw
+    _vertices[0].texCoords = Tex2F(0, 0);
+    _vertices[1].texCoords = Tex2F(1, 0);
+    _vertices[2].texCoords = Tex2F(1, 1);
+    _vertices[3].texCoords = Tex2F(0, 1);
 
-    _glProgramState->setUniformFloat("depth", _depth);
-    _glProgramState->apply(Mat4::IDENTITY);
+    _customCommand.setBeforeCallback(CC_CALLBACK_0(CameraBackgroundDepthBrush::onBeforeDraw, this));
+    _customCommand.setAfterCallback(CC_CALLBACK_0(CameraBackgroundDepthBrush::onAfterDraw, this));
 
-    auto supportVAO = Configuration::getInstance()->supportsShareableVAO();
-    if (supportVAO)
-        GL::bindVAO(_vao);
-    else
-    {
-        glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
+    initBuffer();
+    return true;
+}
 
-        // vertices
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof(V3F_C4B_T2F),
-                              reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, vertices)));
+void CameraBackgroundDepthBrush::initBuffer()
+{
+    uint16_t indices[6] = { 0, 1, 2, 2, 3, 0 };
+    _customCommand.createVertexBuffer(sizeof(_vertices[0]), _vertices.size(), CustomCommand::BufferUsage::STATIC);
+    _customCommand.createIndexBuffer(CustomCommand::IndexFormat::U_SHORT, sizeof(indices) / sizeof(indices[0]), CustomCommand::BufferUsage::STATIC);
 
-        // colors
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V3F_C4B_T2F),
-                              reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, colors)));
+    _customCommand.updateVertexBuffer(_vertices.data(), sizeof(_vertices[0]) * _vertices.size());
+    _customCommand.updateIndexBuffer(indices, sizeof(indices));
+}
 
-        // tex coords
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(V3F_C4B_T2F),
-                              reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, texCoords)));
+void CameraBackgroundDepthBrush::drawBackground(Camera* /*camera*/)
+{
+    // `clear screen` should be executed before other commands
+    _groupCommand.init(-1.0f);
+    _customCommand.init(0.0f);
 
-        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer);
-    }
+    auto *renderer = Director::getInstance()->getRenderer();
 
-    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, nullptr);
+    renderer->addCommand(&_groupCommand);
+    renderer->pushGroup(_groupCommand.getRenderQueueID());
 
-    if (supportVAO)
-        GL::bindVAO(0);
-    else
-    {
-        glBindBuffer(GL_ARRAY_BUFFER, 0);
-        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-    }
+    auto &pipelineDescriptor    = _customCommand.getPipelineDescriptor();
+    auto &blend                 = pipelineDescriptor.blendDescriptor;
+    blend.writeMask             = _clearColor ? backend::ColorWriteMask::ALL : backend::ColorWriteMask::NONE;
 
-    {
-        if (GL_FALSE == oldDepthTest)
-        {
-            glDisable(GL_DEPTH_TEST);
-        }
-        glDepthFunc(oldDepthFunc);
+    //draw
+    _programState->setUniform(_locDepth, &_depth, sizeof(_depth));
+    
+    renderer->addCommand(&_customCommand);
 
-        if (GL_FALSE == oldDepthMask)
-        {
-            glDepthMask(GL_FALSE);
-        }
+    renderer->popGroup();
+}
 
-        /* IMPORTANT: We only need to update the states that are not restored.
-         Since we don't know what was the previous value of the mask, we update the RenderState
-         after setting it.
-         The other values don't need to be updated since they were restored to their original values
-         */
-        glStencilMask(0xFFFFF);
-        //        RenderState::StateBlock::_defaultState->setStencilWrite(0xFFFFF);
+void CameraBackgroundDepthBrush::onBeforeDraw()
+{
+    auto *renderer = Director::getInstance()->getRenderer();
+    _stateBlock.stencilWriteMask    = renderer->getStencilWriteMask();
+    _stateBlock.depthTest           = renderer->getDepthTest();
+    _stateBlock.compareFunc         = renderer->getDepthCompareFunction();
+
+    renderer->setStencilWriteMask(0);
+    renderer->setDepthTest(true);
+    renderer->setDepthCompareFunction(backend::CompareFunction::ALWAYS);
+}
 
-        /* BUG: RenderState does not support glColorMask yet. */
-        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
-    }
+void CameraBackgroundDepthBrush::onAfterDraw()
+{
+    auto *renderer = Director::getInstance()->getRenderer();
+    renderer->setStencilWriteMask(_stateBlock.stencilWriteMask);
+    renderer->setDepthTest(_stateBlock.depthTest);
+    renderer->setDepthCompareFunction(_stateBlock.compareFunc);
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
@@ -278,29 +226,40 @@ void CameraBackgroundDepthBrush::drawBackground(Camera* /*camera*/)
 CameraBackgroundColorBrush::CameraBackgroundColorBrush()
 : _color(0.f, 0.f, 0.f, 0.f)
 {
+    
 }
 
 CameraBackgroundColorBrush::~CameraBackgroundColorBrush()
 {
+    
 }
 
 bool CameraBackgroundColorBrush::init()
 {
     CameraBackgroundDepthBrush::init();
-    this->_clearColor = GL_TRUE;
+    this->_clearColor = true;
     return true;
 }
 
-void CameraBackgroundColorBrush::setColor(const Color4F& color)
+void CameraBackgroundColorBrush::drawBackground(Camera* camera)
 {
-    _quad.bl.colors = _quad.br.colors = _quad.tl.colors = _quad.tr.colors = Color4B(color);
+    BlendFunc op = { BlendFunc::ALPHA_NON_PREMULTIPLIED.src, BlendFunc::ALPHA_NON_PREMULTIPLIED.dst };
 
-    if (_vertexBuffer)
+    auto &blend = _customCommand.getPipelineDescriptor().blendDescriptor;
+    blend.sourceRGBBlendFactor      = blend.sourceAlphaBlendFactor = op.src;
+    blend.destinationRGBBlendFactor = blend.destinationAlphaBlendFactor = op.dst;
+    blend.blendEnabled              = true;
+
+    CameraBackgroundDepthBrush::drawBackground(camera);
+}
+
+void CameraBackgroundColorBrush::setColor(const Color4F& color)
+{
+    for (auto &vert : _vertices)
     {
-        glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(_quad), &_quad, GL_STATIC_DRAW);
-        glBindBuffer(GL_ARRAY_BUFFER, 0);
+        vert.colors = Color4B(color);
     }
+    _customCommand.updateVertexBuffer(_vertices.data(), sizeof(_vertices[0]) * _vertices.size());
 }
 
 CameraBackgroundColorBrush* CameraBackgroundColorBrush::create(const Color4F& color, float depth)
@@ -323,15 +282,20 @@ CameraBackgroundColorBrush* CameraBackgroundColorBrush::create(const Color4F& co
 
 /////////////////////////////////////////////////////////////////////////////////////////////
 CameraBackgroundSkyBoxBrush::CameraBackgroundSkyBoxBrush()
-: _vao(0)
-, _vertexBuffer(0)
-, _indexBuffer(0)
-, _texture(nullptr)
+: _texture(nullptr)
 , _actived(true)
 , _textureValid(true)
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+, _backToForegroundListener(nullptr)
+#endif
 {
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID || CC_TARGET_PLATFORM == CC_PLATFORM_WINRT || CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN)
-    _backToForegroundListener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, [this](EventCustom*) { initBuffer(); });
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+    _backToForegroundListener = EventListenerCustom::create(EVENT_RENDERER_RECREATED,
+                                                            [this](EventCustom*)
+                                                            {
+                                                                initBuffer();
+                                                            }
+                                                            );
     Director::getInstance()->getEventDispatcher()->addEventListenerWithFixedPriority(_backToForegroundListener, -1);
 #endif
 }
@@ -339,35 +303,37 @@ CameraBackgroundSkyBoxBrush::CameraBackgroundSkyBoxBrush()
 CameraBackgroundSkyBoxBrush::~CameraBackgroundSkyBoxBrush()
 {
     CC_SAFE_RELEASE(_texture);
-
-    glDeleteBuffers(1, &_vertexBuffer);
-    glDeleteBuffers(1, &_indexBuffer);
-
-    _vertexBuffer = 0;
-    _indexBuffer = 0;
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        glDeleteVertexArrays(1, &_vao);
-        GL::bindVAO(0);
-        _vao = 0;
-    }
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+    Director::getInstance()->getEventDispatcher()->removeEventListener(_backToForegroundListener);
+#endif
 }
 
-CameraBackgroundSkyBoxBrush* CameraBackgroundSkyBoxBrush::create(const std::string& positive_x, const std::string& negative_x, const std::string& positive_y,
-                                                                 const std::string& negative_y, const std::string& positive_z, const std::string& negative_z)
+CameraBackgroundSkyBoxBrush* CameraBackgroundSkyBoxBrush::create(
+    const std::string& positive_x,
+    const std::string& negative_x,
+    const std::string& positive_y,
+    const std::string& negative_y,
+    const std::string& positive_z,
+    const std::string& negative_z
+    )
 {
     CameraBackgroundSkyBoxBrush* ret = nullptr;
 
-    auto texture = TextureCube::create(positive_x, negative_x, positive_y, negative_y, positive_z, negative_z);
+    auto texture = TextureCube::create(positive_x,
+                                       negative_x,
+                                       positive_y,
+                                       negative_y,
+                                       positive_z,
+                                       negative_z);
 
     if (texture != nullptr)
     {
+
         Texture2D::TexParams tRepeatParams;
-        tRepeatParams.magFilter = GL_LINEAR;
-        tRepeatParams.minFilter = GL_LINEAR;
-        tRepeatParams.wrapS = GL_CLAMP_TO_EDGE;
-        tRepeatParams.wrapT = GL_CLAMP_TO_EDGE;
+        tRepeatParams.magFilter = backend::SamplerFilter::LINEAR;
+        tRepeatParams.minFilter = backend::SamplerFilter::LINEAR;
+        tRepeatParams.sAddressMode = backend::SamplerAddressMode::CLAMP_TO_EDGE;
+        tRepeatParams.tAddressMode = backend::SamplerAddressMode::CLAMP_TO_EDGE;
         texture->setTexParameters(tRepeatParams);
 
         ret = new (std::nothrow) CameraBackgroundSkyBoxBrush;
@@ -390,7 +356,7 @@ CameraBackgroundSkyBoxBrush* CameraBackgroundSkyBoxBrush::create(const std::stri
 CameraBackgroundSkyBoxBrush* CameraBackgroundSkyBoxBrush::create()
 {
     auto ret = new (std::nothrow) CameraBackgroundSkyBoxBrush();
-
+    
     if (nullptr != ret && ret->init())
     {
         ret->autorelease();
@@ -405,73 +371,58 @@ CameraBackgroundSkyBoxBrush* CameraBackgroundSkyBoxBrush::create()
 
 void CameraBackgroundSkyBoxBrush::drawBackground(Camera* camera)
 {
+    // `clear screen` should be executed before other commands
+    _groupCommand.init(-1.0f);
+    _customCommand.init(0.0f);
+
     if (!_actived)
         return;
 
     Mat4 cameraModelMat = camera->getNodeToWorldTransform();
 
+    auto &pipelineDescriptor = _customCommand.getPipelineDescriptor();
+    pipelineDescriptor.blendDescriptor.blendEnabled = false;
+
     Vec4 color(1.f, 1.f, 1.f, 1.f);
-    _glProgramState->setUniformVec4("u_color", color);
     cameraModelMat.m[12] = cameraModelMat.m[13] = cameraModelMat.m[14] = 0;
-    _glProgramState->setUniformMat4("u_cameraRot", cameraModelMat);
-
-    _glProgramState->apply(Mat4::IDENTITY);
-
-    glEnable(GL_DEPTH_TEST);
-    RenderState::StateBlock::_defaultState->setDepthTest(true);
-
-    glDepthMask(GL_TRUE);
-    RenderState::StateBlock::_defaultState->setDepthWrite(true);
 
-    glDepthFunc(GL_ALWAYS);
-    RenderState::StateBlock::_defaultState->setDepthFunction(RenderState::DEPTH_ALWAYS);
+    _programState->setUniform(_uniformColorLoc, &color, sizeof(color));
+    _programState->setUniform(_uniformCameraRotLoc, cameraModelMat.m, sizeof(cameraModelMat.m));
 
-    glEnable(GL_CULL_FACE);
-    RenderState::StateBlock::_defaultState->setCullFace(true);
+    auto *renderer = Director::getInstance()->getRenderer();
 
-    glCullFace(GL_BACK);
-    RenderState::StateBlock::_defaultState->setCullFaceSide(RenderState::CULL_FACE_SIDE_BACK);
+    renderer->addCommand(&_groupCommand);
+    renderer->pushGroup(_groupCommand.getRenderQueueID());
 
-    glDisable(GL_BLEND);
-    RenderState::StateBlock::_defaultState->setBlend(false);
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        GL::bindVAO(_vao);
-    }
-    else
-    {
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POSITION);
+    renderer->addCommand(&_customCommand);
 
-        glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof(Vec3), nullptr);
+    renderer->popGroup();
+   
+    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, 8);
+    
+}
 
-        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer);
-    }
+bool CameraBackgroundSkyBoxBrush::init()
+{
 
-    glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(36), GL_UNSIGNED_BYTE, nullptr);
+    _customCommand.setBeforeCallback(CC_CALLBACK_0(CameraBackgroundSkyBoxBrush::onBeforeDraw, this));
+    _customCommand.setAfterCallback(CC_CALLBACK_0(CameraBackgroundSkyBoxBrush::onAfterDraw, this));
 
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        GL::bindVAO(0);
-    }
-    else
-    {
-        glBindBuffer(GL_ARRAY_BUFFER, 0);
-        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-    }
+    CC_SAFE_RELEASE_NULL(_programState);
+    _programState           = new backend::ProgramState(CC3D_skybox_vert, CC3D_skybox_frag);
+    _uniformColorLoc        = _programState->getUniformLocation("u_color");
+    _uniformCameraRotLoc    = _programState->getUniformLocation("u_cameraRot");
+    _uniformEnvLoc          = _programState->getUniformLocation("u_Env");
 
-    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, 8);
 
-    CHECK_GL_ERROR_DEBUG();
-}
+    auto &pipelineDescriptor                            = _customCommand.getPipelineDescriptor();
+    auto layout                                         = _programState->getVertexLayout();
+    pipelineDescriptor.programState                     = _programState;
+    // disable blend
+    pipelineDescriptor.blendDescriptor.blendEnabled     = false;
 
-bool CameraBackgroundSkyBoxBrush::init()
-{
-    auto shader = GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_3D_SKYBOX);
-    _glProgramState = GLProgramState::create(shader);
-    _glProgramState->setVertexAttribPointer(GLProgram::ATTRIBUTE_NAME_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof(Vec3), nullptr);
-    _glProgramState->retain();
+    layout->setAttribute(shaderinfos::attribute::ATTRIBUTE_NAME_POSITION, 0, backend::VertexFormat::FLOAT3, 0, false);
+    layout->setLayout(sizeof(Vec3));
 
     initBuffer();
 
@@ -480,60 +431,35 @@ bool CameraBackgroundSkyBoxBrush::init()
 
 void CameraBackgroundSkyBoxBrush::initBuffer()
 {
-    if (_vertexBuffer)
-        glDeleteBuffers(1, &_vertexBuffer);
-    if (_indexBuffer)
-        glDeleteBuffers(1, &_indexBuffer);
-
-    if (Configuration::getInstance()->supportsShareableVAO() && _vao)
-    {
-        glDeleteVertexArrays(1, &_vao);
-        GL::bindVAO(0);
-        _vao = 0;
-    }
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        glGenVertexArrays(1, &_vao);
-        GL::bindVAO(_vao);
-    }
-
     // init vertex buffer object
-    Vec3 vexBuf[] = {Vec3(1, -1, 1), Vec3(1, 1, 1), Vec3(-1, 1, 1), Vec3(-1, -1, 1), Vec3(1, -1, -1), Vec3(1, 1, -1), Vec3(-1, 1, -1), Vec3(-1, -1, -1)};
+    Vec3 vexBuf[] =
+    {
+        Vec3(1, -1, 1),  Vec3(1, 1, 1),  Vec3(-1, 1, 1),  Vec3(-1, -1, 1),
+        Vec3(1, -1, -1), Vec3(1, 1, -1), Vec3(-1, 1, -1), Vec3(-1, -1, -1)
+    };
 
-    glGenBuffers(1, &_vertexBuffer);
-    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);
-    glBufferData(GL_ARRAY_BUFFER, sizeof(vexBuf), vexBuf, GL_STATIC_DRAW);
+    _customCommand.createVertexBuffer(sizeof(vexBuf[0]), sizeof(vexBuf) / sizeof(vexBuf[0]), CustomCommand::BufferUsage::STATIC);
+    _customCommand.updateVertexBuffer(vexBuf, sizeof(vexBuf));
 
     // init index buffer object
-    const unsigned char idxBuf[] = {
+    uint16_t idxBuf[] = { 
         2, 1, 0, 3, 2, 0, // font
         1, 5, 4, 1, 4, 0, // right
         4, 5, 6, 4, 6, 7, // back
         7, 6, 2, 7, 2, 3, // left
         2, 6, 5, 2, 5, 1, // up
-        3, 0, 4, 3, 4, 7 // down
+        3, 0, 4, 3, 4, 7  // down
     };
-
-    glGenBuffers(1, &_indexBuffer);
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer);
-    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(idxBuf), idxBuf, GL_STATIC_DRAW);
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POSITION, _vao);
-        _glProgramState->applyAttributes(false);
-
-        GL::bindVAO(0);
-    }
+    _customCommand.createIndexBuffer(CustomCommand::IndexFormat::U_SHORT, sizeof(idxBuf) / sizeof(idxBuf[0]), CustomCommand::BufferUsage::STATIC);
+    _customCommand.updateIndexBuffer(idxBuf, sizeof(idxBuf));
 }
 
-void CameraBackgroundSkyBoxBrush::setTexture(TextureCube* texture)
+void CameraBackgroundSkyBoxBrush::setTexture(TextureCube*  texture)
 {
     CC_SAFE_RETAIN(texture);
     CC_SAFE_RELEASE(_texture);
     _texture = texture;
-    _glProgramState->setUniformTexture("u_Env", _texture);
+    _programState->setTexture(_uniformEnvLoc, 0, _texture->getBackendTexture());
 }
 
 bool CameraBackgroundSkyBoxBrush::isActived() const
@@ -542,12 +468,12 @@ bool CameraBackgroundSkyBoxBrush::isActived() const
 }
 void CameraBackgroundSkyBoxBrush::setActived(bool actived)
 {
-    _actived = actived;
+    _actived        = actived;
 }
 
 void CameraBackgroundSkyBoxBrush::setTextureValid(bool valid)
 {
-    _textureValid = valid;
+    _textureValid   = valid;
 }
 
 bool CameraBackgroundSkyBoxBrush::isValid()
@@ -555,4 +481,22 @@ bool CameraBackgroundSkyBoxBrush::isValid()
     return _actived;
 }
 
+void CameraBackgroundSkyBoxBrush::onBeforeDraw()
+{
+    auto *renderer = Director::getInstance()->getRenderer();
+    _stateBlock.depthTest   = renderer->getDepthTest();
+    _stateBlock.depthWrite  = renderer->getDepthWrite();
+    _stateBlock.depthFunc   = renderer->getDepthCompareFunction();
+    _stateBlock.cullMode    = renderer->getCullMode();
+}
+
+void CameraBackgroundSkyBoxBrush::onAfterDraw()
+{
+    auto *renderer = Director::getInstance()->getRenderer();
+    renderer->setDepthTest(_stateBlock.depthTest);
+    renderer->setDepthWrite(_stateBlock.depthWrite);
+    renderer->setDepthCompareFunction(_stateBlock.depthFunc);
+    renderer->setCullMode(_stateBlock.cullMode);
+}
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCCameraBackgroundBrush.h b/cocos2d/cocos/2d/CCCameraBackgroundBrush.h
index 1f987672fd..8b5f3e36e9 100644
--- a/cocos2d/cocos/2d/CCCameraBackgroundBrush.h
+++ b/cocos2d/cocos/2d/CCCameraBackgroundBrush.h
@@ -1,18 +1,19 @@
 /****************************************************************************
- Copyright (c) 2015-2017 Chukong Technologies Inc.
-
+ Copyright (c) 2015-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -20,38 +21,35 @@
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
-
+ 
  ****************************************************************************/
-#ifndef CC_2D_CAMERABACKGROUNDBRUSH_H
-#define CC_2D_CAMERABACKGROUNDBRUSH_H
+#pragma once
 
-#include <cocos/base/CCRef.h>
-#include <cocos/base/ccConfig.h>
 #include <cocos/base/ccTypes.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformConfig.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
+#include <cocos/base/CCRef.h>
+#include <cocos/base/CCEventListenerCustom.h>
+#include <cocos/3d/CCFrustum.h>
+#include <cocos/renderer/CCQuadCommand.h>
+#include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/renderer/CCGroupCommand.h>
+#include <cocos/renderer/backend/Types.h>
+#include <vector>
 
 NS_CC_BEGIN
 
-class Camera;
 class CameraBackgroundColorBrush;
 class CameraBackgroundDepthBrush;
 class CameraBackgroundSkyBoxBrush;
-class GLProgramState;
-class TextureCube;
+class Camera;
 
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID || CC_TARGET_PLATFORM == CC_PLATFORM_WINRT || CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN)
-class EventListenerCustom;
-#endif
+namespace backend {
+    class ProgramState;
+    class Buffer;
+}
 
 /**
  * Defines a brush to clear the background of camera.
- * There are 4 types of brush. None brush do nothing, Depth brush clear background with given depth, Color brush clear background with given color and depth,
- * Skybox brush clear the background with a skybox. Camera uses depth brush by default.
+ * There are 4 types of brush. None brush do nothing, Depth brush clear background with given depth, Color brush clear background with given color and depth, Skybox brush clear the background with a skybox. Camera uses depth brush by default.
  */
 class CC_DLL CameraBackgroundBrush : public Ref
 {
@@ -61,31 +59,31 @@ public:
      */
     enum class BrushType
     {
-        NONE, // none brush
+        NONE, //none brush
         DEPTH, // depth brush. See CameraBackgroundDepthBrush
         COLOR, // color brush. See CameraBackgroundColorBrush
         SKYBOX, // skybox brush. See CameraBackgroundSkyBoxBrush
     };
-
+    
     /**
      * get brush type
      * @return BrushType
      */
     virtual BrushType getBrushType() const { return BrushType::NONE; }
-
+    
     /**
      * Creates a none brush, it does nothing when clear the background
      * @return Created brush.
      */
     static CameraBackgroundBrush* createNoneBrush();
-
+    
     /**
      * Creates a depth brush, which clears depth buffer with a given depth.
      * @param depth Depth used to clear depth buffer
      * @return Created brush
      */
     static CameraBackgroundDepthBrush* createDepthBrush(float depth = 1.f);
-
+    
     /**
      * Creates a color brush
      * @param color Color of brush
@@ -93,7 +91,8 @@ public:
      * @return Created brush
      */
     static CameraBackgroundColorBrush* createColorBrush(const Color4F& color, float depth);
-
+    
+    
     /** Creates a Skybox brush with 6 textures.
      @param positive_x texture for the right side of the texture cube face.
      @param negative_x texture for the up side of the texture cube face.
@@ -103,8 +102,9 @@ public:
      @param negative_z texture for the rear side of the texture cube face.
      @return  A new brush inited with given parameters.
      */
-    static CameraBackgroundSkyBoxBrush* createSkyboxBrush(const std::string& positive_x, const std::string& negative_x, const std::string& positive_y,
-                                                          const std::string& negative_y, const std::string& positive_z, const std::string& negative_z);
+    static CameraBackgroundSkyBoxBrush* createSkyboxBrush(const std::string& positive_x, const std::string& negative_x,
+                                                          const std::string& positive_y, const std::string& negative_y,
+                                                          const std::string& positive_z, const std::string& negative_z);
     /**
      * draw the background
      */
@@ -112,13 +112,14 @@ public:
 
     virtual bool isValid() { return true; }
 
-    CC_CONSTRUCTOR_ACCESS : CameraBackgroundBrush();
-    ~CameraBackgroundBrush() override;
+CC_CONSTRUCTOR_ACCESS :
+    CameraBackgroundBrush();
+    virtual ~CameraBackgroundBrush();
 
     virtual bool init() { return true; }
-
+    
 protected:
-    GLProgramState* _glProgramState;
+    backend::ProgramState* _programState = nullptr;
 };
 
 /**
@@ -133,38 +134,52 @@ public:
      * @return Created brush
      */
     static CameraBackgroundDepthBrush* create(float depth);
-
+    
     /**
      * Get brush type. Should be BrushType::DEPTH
      * @return brush type
      */
-    BrushType getBrushType() const override { return BrushType::DEPTH; }
-
+    virtual BrushType getBrushType() const override { return BrushType::DEPTH; }
+    
     /**
      * Draw background
      */
-    void drawBackground(Camera* camera) override;
-
+    virtual void drawBackground(Camera* camera) override;
+    
     /**
      * Set depth
      * @param depth Depth used to clear depth buffer
      */
     void setDepth(float depth) { _depth = depth; }
+    
+CC_CONSTRUCTOR_ACCESS:
+    CameraBackgroundDepthBrush();
+    virtual ~CameraBackgroundDepthBrush();
 
-    CC_CONSTRUCTOR_ACCESS : CameraBackgroundDepthBrush();
-    ~CameraBackgroundDepthBrush() override;
-
-    bool init() override;
+    virtual bool init() override;
+private:
+    void onBeforeDraw();
+    void onAfterDraw();
+protected:
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+    EventListenerCustom* _backToForegroundListener;
+#endif
+    void initBuffer();
 
 protected:
     float _depth;
+    backend::UniformLocation _locDepth;
+    CustomCommand _customCommand;
+    GroupCommand _groupCommand;
+
+    bool _clearColor;
+    std::vector<V3F_C4B_T2F> _vertices;
+    struct {
+        uint32_t stencilWriteMask = 0;
+        bool depthTest = true;
+        backend::CompareFunction compareFunc = backend::CompareFunction::ALWAYS;
+    } _stateBlock;
 
-    GLboolean _clearColor;
-
-    V3F_C4B_T2F_Quad _quad;
-    GLuint _vao;
-    GLuint _vertexBuffer;
-    GLuint _indexBuffer;
 };
 
 /**
@@ -178,7 +193,7 @@ public:
      * @return brush type
      */
     virtual BrushType getBrushType() const override { return BrushType::COLOR; }
-
+    
     /**
      * Create a color brush
      * @param color Color used to clear the color buffer
@@ -186,22 +201,32 @@ public:
      * @return Created brush
      */
     static CameraBackgroundColorBrush* create(const Color4F& color, float depth);
-
+    
+    /**
+     * Draw background
+     */
+    virtual void drawBackground(Camera* camera) override;
+    
     /**
      * Set clear color
      * @param color Color used to clear the color buffer
      */
     void setColor(const Color4F& color);
 
-    CC_CONSTRUCTOR_ACCESS : CameraBackgroundColorBrush();
-    ~CameraBackgroundColorBrush() override;
-
-    bool init() override;
+CC_CONSTRUCTOR_ACCESS:
+    CameraBackgroundColorBrush();
+    virtual ~CameraBackgroundColorBrush();
 
+    virtual bool init() override;
+    
 protected:
     Color4F _color;
 };
 
+class TextureCube;
+class GLProgramState;
+class EventListenerCustom;
+
 /**
  * Skybox brush clear buffer with a skybox
  */
@@ -213,7 +238,7 @@ public:
      * @return brush type
      */
     virtual BrushType getBrushType() const override { return BrushType::SKYBOX; }
-
+    
     /** Creates a Skybox brush with 6 textures.
      @param positive_x texture for the right side of the texture cube face.
      @param negative_x texture for the up side of the texture cube face.
@@ -223,18 +248,19 @@ public:
      @param negative_z texture for the rear side of the texture cube face.
      @return  A new brush inited with given parameters.
      */
-    static CameraBackgroundSkyBoxBrush* create(const std::string& positive_x, const std::string& negative_x, const std::string& positive_y,
-                                               const std::string& negative_y, const std::string& positive_z, const std::string& negative_z);
-
+    static CameraBackgroundSkyBoxBrush* create(const std::string& positive_x, const std::string& negative_x,
+                                        const std::string& positive_y, const std::string& negative_y,
+                                        const std::string& positive_z, const std::string& negative_z);
+    
     /** Creates a Skybox brush with 6 textures.
      */
     static CameraBackgroundSkyBoxBrush* create();
     /**
-     * Set skybox texture
+     * Set skybox texture 
      * @param texture Skybox texture
      */
-    void setTexture(TextureCube* texture);
-
+    void setTexture(TextureCube*  texture);
+    
     /**
      * Draw background
      */
@@ -243,34 +269,48 @@ public:
     bool isActived() const;
     void setActived(bool actived);
     virtual void setTextureValid(bool valid);
-    bool isValid() override;
-
-    CC_CONSTRUCTOR_ACCESS : CameraBackgroundSkyBoxBrush();
-    ~CameraBackgroundSkyBoxBrush() override;
+    virtual bool isValid()override;
 
+CC_CONSTRUCTOR_ACCESS :
+    CameraBackgroundSkyBoxBrush();
+    virtual ~CameraBackgroundSkyBoxBrush();
+    
     /**
      * init Skybox.
      */
-    bool init() override;
+    virtual bool init() override;
+
+private:
+    void onBeforeDraw();
+    void onAfterDraw();
 
 protected:
     void initBuffer();
-
-    GLuint _vao;
-    GLuint _vertexBuffer;
-    GLuint _indexBuffer;
-
-    TextureCube* _texture;
-
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID || CC_TARGET_PLATFORM == CC_PLATFORM_WINRT || CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN)
+    
+    TextureCube*  _texture;
+    
+#if CC_ENABLE_CACHE_TEXTURE_DATA
     EventListenerCustom* _backToForegroundListener;
 #endif
 
 private:
     bool _actived;
     bool _textureValid;
+
+    CustomCommand _customCommand;
+    GroupCommand _groupCommand;
+
+    backend::UniformLocation _uniformColorLoc;
+    backend::UniformLocation _uniformCameraRotLoc;
+    backend::UniformLocation _uniformEnvLoc;
+
+    struct {
+        bool depthTest = true;
+        bool depthWrite = true;
+        backend::CompareFunction depthFunc = backend::CompareFunction::ALWAYS;
+        backend::CullMode cullMode = backend::CullMode::BACK;
+    }_stateBlock;
 };
 
 NS_CC_END
 
-#endif // CC_2D_CAMERABACKGROUNDBRUSH_H
diff --git a/cocos2d/cocos/2d/CCClippingNode.cpp b/cocos2d/cocos/2d/CCClippingNode.cpp
index 97930c9f67..adfe8a76cf 100644
--- a/cocos2d/cocos/2d/CCClippingNode.cpp
+++ b/cocos2d/cocos/2d/CCClippingNode.cpp
@@ -2,6 +2,7 @@
  * Copyright (c) 2012      Pierre-David Bélanger
  * Copyright (c) 2012      cocos2d-x.org
  * Copyright (c) 2013-2016 Chukong Technologies Inc.
+ * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
  *
  * cocos2d-x: http://www.cocos2d-x.org
  *
@@ -24,39 +25,15 @@
  * THE SOFTWARE.
  *
  */
-
 #include <cocos/2d/CCClippingNode.h>
-
-#include <cocos/2d/CCDrawingPrimitives.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/CCStencilStateManager.hpp>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramCache.h>
-#include <cocos/renderer/CCRenderState.h>
 #include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/ccGLStateCache.h>
-
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_MAC || CC_TARGET_PLATFORM == CC_PLATFORM_WIN32 || CC_TARGET_PLATFORM == CC_PLATFORM_LINUX)
-#    define CC_CLIPPING_NODE_OPENGLES 0
-#else
-#    define CC_CLIPPING_NODE_OPENGLES 1
-#endif
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/base/CCStencilStateManager.h>
 
 NS_CC_BEGIN
 
-#if CC_CLIPPING_NODE_OPENGLES
-static void setProgram(Node* n, GLProgram* p)
-{
-    n->setGLProgram(p);
-
-    auto& children = n->getChildren();
-    for (const auto& child : children)
-    {
-        setProgram(child, p);
-    }
-}
-#endif
-
 ClippingNode::ClippingNode()
 : _stencil(nullptr)
 , _stencilStateManager(new StencilStateManager())
@@ -75,7 +52,7 @@ ClippingNode::~ClippingNode()
 
 ClippingNode* ClippingNode::create()
 {
-    ClippingNode* ret = new (std::nothrow) ClippingNode();
+    ClippingNode *ret = new (std::nothrow) ClippingNode();
     if (ret && ret->init())
     {
         ret->autorelease();
@@ -84,13 +61,13 @@ ClippingNode* ClippingNode::create()
     {
         CC_SAFE_DELETE(ret);
     }
-
+    
     return ret;
 }
 
-ClippingNode* ClippingNode::create(Node* pStencil)
+ClippingNode* ClippingNode::create(Node *pStencil)
 {
-    ClippingNode* ret = new (std::nothrow) ClippingNode();
+    ClippingNode *ret = new (std::nothrow) ClippingNode();
     if (ret && ret->init(pStencil))
     {
         ret->autorelease();
@@ -99,7 +76,7 @@ ClippingNode* ClippingNode::create(Node* pStencil)
     {
         CC_SAFE_DELETE(ret);
     }
-
+    
     return ret;
 }
 
@@ -108,7 +85,7 @@ bool ClippingNode::init()
     return init(nullptr);
 }
 
-bool ClippingNode::init(Node* stencil)
+bool ClippingNode::init(Node *stencil)
 {
     setStencil(stencil);
     return true;
@@ -123,9 +100,9 @@ void ClippingNode::onEnter()
             return;
     }
 #endif
-
+    
     Node::onEnter();
-
+    
     if (_stencil != nullptr)
     {
         _stencil->onEnter();
@@ -145,9 +122,9 @@ void ClippingNode::onEnterTransitionDidFinish()
             return;
     }
 #endif
-
+    
     Node::onEnterTransitionDidFinish();
-
+    
     if (_stencil != nullptr)
     {
         _stencil->onEnterTransitionDidFinish();
@@ -163,12 +140,12 @@ void ClippingNode::onExitTransitionDidStart()
             return;
     }
 #endif
-
+    
     if (_stencil != nullptr)
     {
         _stencil->onExitTransitionDidStart();
     }
-
+   
     Node::onExitTransitionDidStart();
 }
 
@@ -181,20 +158,21 @@ void ClippingNode::onExit()
             return;
     }
 #endif
-
+    
     if (_stencil != nullptr)
     {
         _stencil->onExit();
     }
-
+    
     Node::onExit();
 }
 
-void ClippingNode::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+
+void ClippingNode::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     if (!_visible || !hasContent())
         return;
-
+    
     uint32_t flags = processParentFlags(parentTransform, parentFlags);
 
     // IMPORTANT:
@@ -205,52 +183,54 @@ void ClippingNode::visit(Renderer* renderer, const Mat4& parentTransform, uint32
     director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
     director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform);
 
-    // Add group command
-
-    _groupCommand.init(_globalZOrder);
-    renderer->addCommand(&_groupCommand);
+    //Add group command
+        
+    _groupCommandStencil.init(_globalZOrder);
+    renderer->addCommand(&_groupCommandStencil);
 
-    renderer->pushGroup(_groupCommand.getRenderQueueID());
-
-    _beforeVisitCmd.init(_globalZOrder);
-    _beforeVisitCmd.setFunc([this]() { _stencilStateManager->onBeforeVisit(); });
-    renderer->addCommand(&_beforeVisitCmd);
+    renderer->pushGroup(_groupCommandStencil.getRenderQueueID());
 
+    // _beforeVisitCmd.init(_globalZOrder);
+    // _beforeVisitCmd.func = CC_CALLBACK_0(StencilStateManager::onBeforeVisit, _stencilStateManager);
+    // renderer->addCommand(&_beforeVisitCmd);
+    _stencilStateManager->onBeforeVisit(_globalZOrder);
+    
     auto alphaThreshold = this->getAlphaThreshold();
     if (alphaThreshold < 1)
     {
-#if CC_CLIPPING_NODE_OPENGLES
-        // since glAlphaTest do not exists in OES, use a shader that writes
-        // pixel only if greater than an alpha threshold
-        GLProgram* program = GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST_NO_MV);
-        GLint alphaValueLocation = glGetUniformLocation(program->getProgram(), GLProgram::UNIFORM_NAME_ALPHA_TEST_VALUE);
-        // set our alphaThreshold
-        program->use();
-        program->setUniformLocationWith1f(alphaValueLocation, alphaThreshold);
-        // we need to recursively apply this shader to all the nodes in the stencil node
-        // FIXME: we should have a way to apply shader to all nodes without having to do this
-        setProgram(_stencil, program);
+        auto programState = new (std::nothrow) backend::ProgramState(positionTextureColor_vert, positionTextureColorAlphaTest_frag);
+        auto alphaLocation = programState->getUniformLocation("u_alpha_value");
+        programState->setUniform(alphaLocation, &alphaThreshold, sizeof(alphaThreshold));
+        setProgramStateRecursively(_stencil, programState);
 
-#endif
+        CC_SAFE_RELEASE_NULL(programState);
     }
     _stencil->visit(renderer, _modelViewTransform, flags);
 
     _afterDrawStencilCmd.init(_globalZOrder);
-    _afterDrawStencilCmd.setFunc([this]() { _stencilStateManager->onAfterDrawStencil(); });
+    _afterDrawStencilCmd.func = CC_CALLBACK_0(StencilStateManager::onAfterDrawStencil, _stencilStateManager);
     renderer->addCommand(&_afterDrawStencilCmd);
 
     int i = 0;
     bool visibleByCamera = isVisitableByVisitingCamera();
+    
+
+    // `_groupCommandChildren` is used as a barrier
+    // to ensure commands above be executed before children nodes
+    _groupCommandChildren.init(_globalZOrder);
+    renderer->addCommand(&_groupCommandChildren);
 
-    if (!_children.empty())
+    renderer->pushGroup(_groupCommandChildren.getRenderQueueID());
+
+    if(!_children.empty())
     {
         sortAllChildren();
         // draw children zOrder < 0
-        for (; i < _children.size(); i++)
+        for(auto size = _children.size(); i < size; ++i)
         {
             auto node = _children.at(i);
-
-            if (node && node->getLocalZOrder() < 0)
+            
+            if ( node && node->getLocalZOrder() < 0 )
                 node->visit(renderer, _modelViewTransform, flags);
             else
                 break;
@@ -259,7 +239,7 @@ void ClippingNode::visit(Renderer* renderer, const Mat4& parentTransform, uint32
         if (visibleByCamera)
             this->draw(renderer, _modelViewTransform, flags);
 
-        for (auto it = _children.cbegin() + i; it != _children.cend(); ++it)
+        for(auto it=_children.cbegin()+i, itCend = _children.cend(); it != itCend; ++it)
             (*it)->visit(renderer, _modelViewTransform, flags);
     }
     else if (visibleByCamera)
@@ -267,19 +247,22 @@ void ClippingNode::visit(Renderer* renderer, const Mat4& parentTransform, uint32
         this->draw(renderer, _modelViewTransform, flags);
     }
 
+
+    renderer->popGroup();
+
     _afterVisitCmd.init(_globalZOrder);
-    _afterVisitCmd.setFunc([this]() { _stencilStateManager->onAfterVisit(); });
+    _afterVisitCmd.func = CC_CALLBACK_0(StencilStateManager::onAfterVisit, _stencilStateManager);
     renderer->addCommand(&_afterVisitCmd);
 
     renderer->popGroup();
-
+    
     director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
 }
 
 void ClippingNode::setCameraMask(unsigned short mask, bool applyChildren)
 {
     Node::setCameraMask(mask, applyChildren);
-
+    
     if (_stencil)
         _stencil->setCameraMask(mask, applyChildren);
 }
@@ -289,12 +272,12 @@ Node* ClippingNode::getStencil() const
     return _stencil;
 }
 
-void ClippingNode::setStencil(Node* stencil)
+void ClippingNode::setStencil(Node *stencil)
 {
-    // early out if the stencil is already set
+    //early out if the stencil is already set
     if (_stencil == stencil)
         return;
-
+    
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
     auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
     if (sEngine)
@@ -305,26 +288,35 @@ void ClippingNode::setStencil(Node* stencil)
             sEngine->retainScriptObject(this, stencil);
     }
 #endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
-
-    // cleanup current stencil
-    if (_stencil != nullptr && _stencil->isRunning())
+    
+    //cleanup current stencil
+    if(_stencil != nullptr && _stencil->isRunning())
     {
         _stencil->onExitTransitionDidStart();
         _stencil->onExit();
     }
     CC_SAFE_RELEASE_NULL(_stencil);
-
-    // initialise new stencil
+    
+    //initialise new stencil
     _stencil = stencil;
     CC_SAFE_RETAIN(_stencil);
-    if (_stencil != nullptr && this->isRunning())
+    if(_stencil != nullptr && this->isRunning())
     {
         _stencil->onEnter();
-        if (this->_isTransitionFinished)
+        if(this->_isTransitionFinished)
         {
             _stencil->onEnterTransitionDidFinish();
         }
     }
+
+    if (_stencil != nullptr)
+    {
+        _originalStencilProgramState[_stencil] = _stencil->getProgramState();
+        auto& children = _stencil->getChildren();
+        for (const auto &child : children) {
+            _originalStencilProgramState[child] = child->getProgramState();
+        }
+    }
 }
 
 bool ClippingNode::hasContent() const
@@ -332,13 +324,19 @@ bool ClippingNode::hasContent() const
     return _children.size() > 0;
 }
 
-GLfloat ClippingNode::getAlphaThreshold() const
+float ClippingNode::getAlphaThreshold() const
 {
     return _stencilStateManager->getAlphaThreshold();
 }
 
-void ClippingNode::setAlphaThreshold(GLfloat alphaThreshold)
+void ClippingNode::setAlphaThreshold(float alphaThreshold)
 {
+    if (alphaThreshold == 1 && alphaThreshold != _stencilStateManager->getAlphaThreshold())
+    {
+        // should reset program used by _stencil
+        if (_stencil)
+            restoreAllProgramStates();
+    }
     _stencilStateManager->setAlphaThreshold(alphaThreshold);
 }
 
@@ -352,4 +350,26 @@ void ClippingNode::setInverted(bool inverted)
     _stencilStateManager->setInverted(inverted);
 }
 
+void ClippingNode::setProgramStateRecursively(Node* node, backend::ProgramState* programState)
+{
+    _originalStencilProgramState[node] = node->getProgramState();
+    node->setProgramState(programState);
+
+    auto& children = node->getChildren();
+    for (const auto &child : children) {
+        setProgramStateRecursively(child, programState);
+    }
+}
+
+void ClippingNode::restoreAllProgramStates()
+{
+    for (auto item : _originalStencilProgramState)
+    {
+        auto node = item.first;
+        auto programState = item.second;
+        node->setProgramState(programState);
+    }
+}
+
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCClippingNode.h b/cocos2d/cocos/2d/CCClippingNode.h
index 29c7d088b6..733aba9a49 100644
--- a/cocos2d/cocos/2d/CCClippingNode.h
+++ b/cocos2d/cocos/2d/CCClippingNode.h
@@ -2,6 +2,7 @@
  * Copyright (c) 2012      Pierre-David Bélanger
  * Copyright (c) 2012      cocos2d-x.org
  * Copyright (c) 2013-2016 Chukong Technologies Inc.
+ * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
  *
  * http://www.cocos2d-x.org
  *
@@ -24,15 +25,13 @@
  * THE SOFTWARE.
  *
  */
-
-#ifndef CC_2D_CLIPPINGNODE_H
-#define CC_2D_CLIPPINGNODE_H
+#pragma once
 
 #include <cocos/2d/CCNode.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/renderer/CCCustomCommand.h>
 #include <cocos/renderer/CCGroupCommand.h>
-
+#include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/renderer/CCCallbackCommand.h>
+#include <unordered_map>
 NS_CC_BEGIN
 
 class StencilStateManager;
@@ -53,12 +52,12 @@ public:
      * @return An autorelease ClippingNode.
      */
     static ClippingNode* create();
-
+    
     /** Creates and initializes a clipping node with an other node as its stencil.
      * The stencil node will be retained.
      * @param stencil The stencil node.
      */
-    static ClippingNode* create(Node* stencil);
+    static ClippingNode* create(Node *stencil);
 
     /** The Node to use as a stencil to do the clipping.
      * The stencil node will be retained.
@@ -67,12 +66,12 @@ public:
      * @return The stencil node.
      */
     Node* getStencil() const;
-
+    
     /** Set the Node to use as a stencil to do the clipping.
      *
      * @param stencil The Node to use as a stencil to do the clipping.
      */
-    void setStencil(Node* stencil);
+    void setStencil(Node *stencil);
 
     /** If stencil has no children it will not be drawn.
      * If you have custom stencil-based node with stencil drawing mechanics other then children-based,
@@ -93,14 +92,14 @@ public:
      *
      * @return The alpha threshold value,Should be a float between 0 and 1.
      */
-    GLfloat getAlphaThreshold() const;
-
-    /** Set the alpha threshold.
-     *
+    float getAlphaThreshold() const;
+    
+    /** Set the alpha threshold. 
+     * 
      * @param alphaThreshold The alpha threshold.
      */
-    void setAlphaThreshold(GLfloat alphaThreshold);
-
+    void setAlphaThreshold(float alphaThreshold);
+    
     /** Inverted. If this is set to true,
      * the stencil is inverted, so the content is drawn where the stencil is NOT drawn.
      * This default to false.
@@ -108,7 +107,7 @@ public:
      * @return If the clippingNode is Inverted, it will be return true.
      */
     bool isInverted() const;
-
+    
     /** Set the ClippingNode whether or not invert.
      *
      * @param inverted A bool Type,to set the ClippingNode whether or not invert.
@@ -119,54 +118,56 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
     /**
      * @lua NA
      */
-    void onEnterTransitionDidFinish() override;
+    virtual void onEnterTransitionDidFinish() override;
     /**
      * @lua NA
      */
-    void onExitTransitionDidStart() override;
+    virtual void onExitTransitionDidStart() override;
     /**
      * @lua NA
      */
-    void onExit() override;
-    void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
-
-    void setCameraMask(unsigned short mask, bool applyChildren = true) override;
-
-    CC_CONSTRUCTOR_ACCESS : ClippingNode();
-
+    virtual void onExit() override;
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
+    
+    virtual void setCameraMask(unsigned short mask, bool applyChildren = true) override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    ClippingNode();
+    
     /**
      * @js NA
      * @lua NA
      */
-    ~ClippingNode() override;
+    virtual ~ClippingNode();
 
     /** Initializes a clipping node without a stencil.
      */
-    bool init() override;
-
+    virtual bool init() override;
+    
     /** Initializes a clipping node with an other node as its stencil.
      The stencil node will be retained, and its parent will be set to this clipping node.
      */
-    virtual bool init(Node* stencil);
+    virtual bool init(Node *stencil);
 
 protected:
-    Node* _stencil;
-
-    StencilStateManager* _stencilStateManager;
-
-    GroupCommand _groupCommand;
-    CustomCommand _beforeVisitCmd;
-    CustomCommand _afterDrawStencilCmd;
-    CustomCommand _afterVisitCmd;
+    void setProgramStateRecursively(Node* node, backend::ProgramState* programState);
+    void restoreAllProgramStates();
+
+    Node* _stencil                              = nullptr;
+    StencilStateManager* _stencilStateManager   = nullptr;
+    
+    GroupCommand _groupCommandStencil;
+    GroupCommand _groupCommandChildren;
+    CallbackCommand _afterDrawStencilCmd;
+    CallbackCommand _afterVisitCmd;
+    std::unordered_map<Node*, backend::ProgramState*> _originalStencilProgramState;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ClippingNode)
+    CC_DISALLOW_COPY_AND_ASSIGN(ClippingNode);
 };
 /** @} */
 NS_CC_END
-
-#endif // CC_2D_CLIPPINGNODE_H
diff --git a/cocos2d/cocos/2d/CCClippingRectangleNode.cpp b/cocos2d/cocos/2d/CCClippingRectangleNode.cpp
index 03a05ac942..3c75f488e4 100644
--- a/cocos2d/cocos/2d/CCClippingRectangleNode.cpp
+++ b/cocos2d/cocos/2d/CCClippingRectangleNode.cpp
@@ -1,10 +1,31 @@
-
+/****************************************************************************
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
+ http://www.cocos2d-x.org
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ THE SOFTWARE.
+ ****************************************************************************/
 #include <cocos/2d/CCClippingRectangleNode.h>
-
 #include <cocos/base/CCDirector.h>
+#include <cocos/renderer/CCRenderer.h>
 #include <cocos/math/Vec2.h>
 #include <cocos/platform/CCGLView.h>
-#include <cocos/renderer/CCRenderer.h>
 
 NS_CC_BEGIN
 
@@ -15,11 +36,8 @@ ClippingRectangleNode* ClippingRectangleNode::create(const Rect& clippingRegion)
     {
         node->setClippingRegion(clippingRegion);
         node->autorelease();
-    }
-    else
-    {
+    } else
         CC_SAFE_DELETE(node);
-    }
 
     return node;
 }
@@ -28,18 +46,14 @@ ClippingRectangleNode* ClippingRectangleNode::create()
 {
     ClippingRectangleNode* node = new (std::nothrow) ClippingRectangleNode();
     if (node && node->init())
-    {
         node->autorelease();
-    }
     else
-    {
         CC_SAFE_DELETE(node);
-    }
 
     return node;
 }
 
-void ClippingRectangleNode::setClippingRegion(const Rect& clippingRegion)
+void ClippingRectangleNode::setClippingRegion(const Rect &clippingRegion)
 {
     _clippingRegion = clippingRegion;
 }
@@ -48,94 +62,44 @@ void ClippingRectangleNode::onBeforeVisitScissor()
 {
     if (_clippingEnabled)
     {
-        glEnable(GL_SCISSOR_TEST);
-
-        GLint currentFBO;
-        glGetIntegerv(GL_FRAMEBUFFER_BINDING, &currentFBO);
-
-        if (currentFBO != 0)
-        {
-            GLint params;
-            glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &params);
-
-            if (params == GL_TEXTURE)
-            {
-                /* FIX to make compatible ClippingRectangleNode with the Newyork filter system */
+        auto renderer = Director::getInstance()->getRenderer();
+        _oldScissorTest = renderer->getScissorTest();
+        renderer->setScissorTest(true);
 
-                // We are rendering in a RT
-                Vec4 BL = Vec4(_clippingRegion.origin.x, _clippingRegion.origin.y, 0.0f, 1.0f);
-                Vec4 TR = Vec4(_clippingRegion.origin.x + _clippingRegion.size.width, _clippingRegion.origin.y + _clippingRegion.size.height, 0.0f, 1.0f);
-
-                // retrieve current viewport (mapped to the Rt)
-                GLint currentVP[4];
-                glGetIntegerv(GL_VIEWPORT, currentVP);
-
-                // retrieve current transforms
-                Mat4 curXForm = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION) *
-                    Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW) * getNodeToParentTransform();
-
-                // transform coordinates to clip space
-                curXForm.transformVector(BL);
-                curXForm.transformVector(TR);
-
-                // w divide
-                BL.x = ((BL.x / BL.w) + 1.0f) * 0.5f;
-                BL.y = ((BL.y / BL.w) + 1.0f) * 0.5f;
-                TR.x = ((TR.x / TR.w) + 1.0f) * 0.5f;
-                TR.y = ((TR.y / TR.w) + 1.0f) * 0.5f;
-
-                // apply the RT viewport
-                BL.x = (BL.x * currentVP[2]) + currentVP[0];
-                BL.y = (BL.y * currentVP[3]) + currentVP[1];
-                TR.x = (TR.x * currentVP[2]) + currentVP[0];
-                TR.y = (TR.y * currentVP[3]) + currentVP[1];
-
-                // clip origin negative coordinates
-                BL.x = std::max(0.0f, BL.x);
-                BL.y = std::max(0.0f, BL.y);
-
-                // apply scissor
-                glScissor((GLint)BL.x, (GLint)BL.y, (GLsizei)(TR.x - BL.x), (GLsizei)(TR.y - BL.y));
-
-                return;
-            }
-        }
-
-        // Standard COCOS implementation (FrameBuffer)
         float scaleX = _scaleX;
         float scaleY = _scaleY;
-        Node* parent = this->getParent();
-        while (parent)
-        {
+        Node *parent = this->getParent();
+        while (parent) {
             scaleX *= parent->getScaleX();
             scaleY *= parent->getScaleY();
             parent = parent->getParent();
         }
-
+        
         const Point pos = convertToWorldSpace(Point(_clippingRegion.origin.x, _clippingRegion.origin.y));
         GLView* glView = Director::getInstance()->getOpenGLView();
-        glView->setScissorInPoints(pos.x, pos.y, _clippingRegion.size.width * scaleX, _clippingRegion.size.height * scaleY);
+        glView->setScissorInPoints(pos.x,
+                                   pos.y,
+                                   _clippingRegion.size.width * scaleX,
+                                   _clippingRegion.size.height * scaleY);
     }
 }
 
 void ClippingRectangleNode::onAfterVisitScissor()
 {
     if (_clippingEnabled)
-    {
-        glDisable(GL_SCISSOR_TEST);
-    }
+        Director::getInstance()->getRenderer()->setScissorTest(_oldScissorTest);
 }
 
-void ClippingRectangleNode::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void ClippingRectangleNode::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     _beforeVisitCmdScissor.init(_globalZOrder);
-    _beforeVisitCmdScissor.setFunc([this]() { onBeforeVisitScissor(); });
+    _beforeVisitCmdScissor.func = CC_CALLBACK_0(ClippingRectangleNode::onBeforeVisitScissor, this);
     renderer->addCommand(&_beforeVisitCmdScissor);
-
+    
     Node::visit(renderer, parentTransform, parentFlags);
-
+    
     _afterVisitCmdScissor.init(_globalZOrder);
-    _afterVisitCmdScissor.setFunc([this]() { onAfterVisitScissor(); });
+    _afterVisitCmdScissor.func = CC_CALLBACK_0(ClippingRectangleNode::onAfterVisitScissor, this);
     renderer->addCommand(&_afterVisitCmdScissor);
 }
 
diff --git a/cocos2d/cocos/2d/CCClippingRectangleNode.h b/cocos2d/cocos/2d/CCClippingRectangleNode.h
index 859358bf10..c5e3b1fe8c 100644
--- a/cocos2d/cocos/2d/CCClippingRectangleNode.h
+++ b/cocos2d/cocos/2d/CCClippingRectangleNode.h
@@ -4,6 +4,7 @@
  *
  * Copyright (c) 2012 Pierre-David Bélanger
  * Copyright (c) 2012 cocos2d-x.org
+ * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -24,13 +25,10 @@
  * THE SOFTWARE.
  *
  */
-
-#ifndef CC_2D_CLIPPINGRECTANGLENODE_H
-#define CC_2D_CLIPPINGRECTANGLENODE_H
+#pragma once
 
 #include <cocos/2d/CCNode.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/renderer/CCCallbackCommand.h>
 
 NS_CC_BEGIN
 
@@ -46,7 +44,7 @@ NS_CC_BEGIN
 @js NA
 */
 class CC_DLL ClippingRectangleNode : public Node
-{
+{    
 public:
     /**
     @brief Create node with specified clipping region.
@@ -59,52 +57,55 @@ public:
     @return If the creation success, return a pointer of ClippingRectangleNode; otherwise return nil.
     */
     static ClippingRectangleNode* create();
-
+    
     /**
     @brief Get the clipping rectangle.
     @return The clipping rectangle.
     */
-    const Rect& getClippingRegion() const { return _clippingRegion; }
+    const Rect& getClippingRegion() const {
+        return _clippingRegion;
+    }
     /**
     @brief Set the clipping rectangle.
     @param clippingRegion Specify the clipping rectangle.
     */
     void setClippingRegion(const Rect& clippingRegion);
-
+    
     /**
     @brief Get whether the clipping is enabled or not.
     @return Whether the clipping is enabled or not. Default is true.
     */
-    bool isClippingEnabled() const { return _clippingEnabled; }
+    bool isClippingEnabled() const {
+        return _clippingEnabled;
+    }
 
     /**
     @brief Enable/Disable the clipping.
     @param enabled Pass true to enable clipping. Pass false to disable clipping.
     */
-    void setClippingEnabled(bool enabled) { _clippingEnabled = enabled; }
+    void setClippingEnabled(bool enabled) {
+        _clippingEnabled = enabled;
+    }
 
-    // virtual void draw(Renderer* renderer, const Mat4 &transform, uint32_t flags) override;
-    virtual void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
+    //virtual void draw(Renderer* renderer, const Mat4 &transform, uint32_t flags) override;
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
 
 protected:
-    ClippingRectangleNode()
-    : _clippingEnabled(true)
-    {
-    }
-
+    ClippingRectangleNode() = default;
+    
     void onBeforeVisitScissor();
     void onAfterVisitScissor();
-
+    
     Rect _clippingRegion;
-    bool _clippingEnabled;
+    bool _clippingEnabled = true;
 
-    CustomCommand _beforeVisitCmdScissor;
-    CustomCommand _afterVisitCmdScissor;
+    bool _oldScissorTest = false;
+    
+    CallbackCommand _beforeVisitCmdScissor;
+    CallbackCommand _afterVisitCmdScissor;
 };
 
 // end of _2d group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_CLIPPINGRECTANGLENODE_H
diff --git a/cocos2d/cocos/2d/CCComponent.cpp b/cocos2d/cocos/2d/CCComponent.cpp
index 3735b7ec65..bd3893e962 100644
--- a/cocos2d/cocos/2d/CCComponent.cpp
+++ b/cocos2d/cocos/2d/CCComponent.cpp
@@ -1,5 +1,6 @@
 /****************************************************************************
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,10 +25,6 @@ THE SOFTWARE.
 
 #include <cocos/2d/CCComponent.h>
 
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <new>
-
 NS_CC_BEGIN
 
 Component::Component()
@@ -54,19 +51,19 @@ bool Component::init()
 static bool sendComponentEventToJS(Component* node, int action)
 {
     auto scriptEngine = ScriptEngineManager::getInstance()->getScriptEngine();
-
+    
     if (scriptEngine->isCalledFromScript())
     {
         scriptEngine->setCalledFromScript(false);
     }
     else
     {
-        BasicScriptData data(node, (void*)&action);
-        ScriptEvent scriptEvent(kComponentEvent, (void*)&data);
+        BasicScriptData data(node,(void*)&action);
+        ScriptEvent scriptEvent(kComponentEvent,(void*)&data);
         if (scriptEngine->sendEvent(&scriptEvent))
             return true;
     }
-
+    
     return false;
 }
 
@@ -112,7 +109,7 @@ void Component::onRemove()
 #endif
 }
 
-void Component::update(float delta)
+void Component::update(float /*delta*/)
 {
 #if CC_ENABLE_SCRIPT_BINDING
     if (_scriptType == kScriptTypeJavascript)
@@ -122,14 +119,14 @@ void Component::update(float delta)
 #endif
 }
 
-bool Component::serialize(void* ar)
+bool Component::serialize(void* /*ar*/)
 {
     return true;
 }
 
 Component* Component::create()
 {
-    Component* ret = new (std::nothrow) Component();
+    Component * ret = new (std::nothrow) Component();
 
     if (ret && ret->init())
     {
@@ -143,7 +140,7 @@ Component* Component::create()
     return ret;
 }
 
-void Component::setOwner(Node* owner)
+void Component::setOwner(Node *owner)
 {
     _owner = owner;
 }
diff --git a/cocos2d/cocos/2d/CCComponent.h b/cocos2d/cocos/2d/CCComponent.h
index 80f7925e95..d601ab2f96 100644
--- a/cocos2d/cocos/2d/CCComponent.h
+++ b/cocos2d/cocos/2d/CCComponent.h
@@ -1,5 +1,6 @@
 /****************************************************************************
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -22,24 +23,19 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_COMPONENT_H
-#define CC_2D_COMPONENT_H
+#ifndef __CC_FRAMEWORK_COMPONENT_H__
+#define __CC_FRAMEWORK_COMPONENT_H__
 
 /// @cond DO_NOT_SHOW
-
-#include <cocos/base/CCRef.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
 #include <string>
+#include <cocos/base/CCRef.h>
+#include <cocos/base/CCScriptSupport.h>
 
 NS_CC_BEGIN
 
 class Node;
 
-enum
-{
+enum {
     kComponentOnEnter,
     kComponentOnExit,
     kComponentOnAdd,
@@ -56,18 +52,18 @@ public:
      * @js NA
      * @lua NA
      */
-    ~Component() override;
+    virtual ~Component();
 
     virtual bool init();
 
     bool isEnabled() const { return _enabled; }
     virtual void setEnabled(bool enabled);
-
+    
     const std::string& getName() const { return _name; }
     virtual void setName(const std::string& name) { _name = name; }
-
+    
     Node* getOwner() const { return _owner; }
-    virtual void setOwner(Node* owner);
+    virtual void setOwner(Node *owner);
 
     virtual void update(float delta);
     virtual bool serialize(void* r);
@@ -77,23 +73,23 @@ public:
     virtual void onAdd();
     virtual void onRemove();
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        Component();
+CC_CONSTRUCTOR_ACCESS:
+    /**
+    * @js ctor
+    */
+    Component();
 
 protected:
     Node* _owner;
     std::string _name;
     bool _enabled;
-
+    
 #if CC_ENABLE_SCRIPT_BINDING
-    ccScriptType _scriptType; ///< type of script binding, lua or javascript
+    ccScriptType _scriptType;         ///< type of script binding, lua or javascript
 #endif
 };
 
 NS_CC_END
 
 /// @endcond
-#endif // CC_2D_COMPONENT_H
+#endif  // __CC_FRAMEWORK_COMPONENT_H__
diff --git a/cocos2d/cocos/2d/CCComponentContainer.cpp b/cocos2d/cocos/2d/CCComponentContainer.cpp
index d749830069..aedcc074b3 100644
--- a/cocos2d/cocos/2d/CCComponentContainer.cpp
+++ b/cocos2d/cocos/2d/CCComponentContainer.cpp
@@ -1,5 +1,6 @@
 /****************************************************************************
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -22,8 +23,8 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#include <cocos/2d/CCComponentContainer.h>
 
+#include <cocos/2d/CCComponentContainer.h>
 #include <cocos/2d/CCComponent.h>
 #include <cocos/2d/CCNode.h>
 
@@ -35,7 +36,7 @@ ComponentContainer::ComponentContainer(Node* node)
 }
 
 ComponentContainer::~ComponentContainer()
-{
+{  
 }
 
 Component* ComponentContainer::get(const std::string& name) const
@@ -51,7 +52,7 @@ Component* ComponentContainer::get(const std::string& name) const
     return ret;
 }
 
-bool ComponentContainer::add(Component* com)
+bool ComponentContainer::add(Component *com)
 {
     bool ret = false;
     CCASSERT(com != nullptr, "Component must be non-nil");
@@ -71,17 +72,17 @@ bool ComponentContainer::add(Component* com)
         com->onAdd();
 
         ret = true;
-    } while (0);
+    } while(0);
     return ret;
 }
 
 bool ComponentContainer::remove(const std::string& componentName)
 {
     bool ret = false;
-    do
-    {
+    do 
+    {        
         auto iter = _componentMap.find(componentName);
-        CC_BREAK_IF(iter == _componentMap.end());
+        CC_SAFE_DELETE_ARRAY(iter == _componentMap.end(););
 
         auto component = iter->second;
         _componentMap.erase(componentName);
@@ -91,12 +92,12 @@ bool ComponentContainer::remove(const std::string& componentName)
         component->release();
 
         ret = true;
-    } while (0);
+    } while(0);
 
     return ret;
-}
+ }
 
-bool ComponentContainer::remove(Component* com)
+bool ComponentContainer::remove(Component *com)
 {
     return remove(com->getName());
 }
@@ -105,14 +106,13 @@ void ComponentContainer::removeAll()
 {
     if (!_componentMap.empty())
     {
-        for (auto iter = _componentMap.begin(); iter != _componentMap.end(); ++iter)
+        for (auto& iter : _componentMap)
         {
-            auto component = iter->second;
-            component->onRemove();
-            component->setOwner(nullptr);
-            component->release();
+            iter.second->onRemove();
+            iter.second->setOwner(nullptr);
+            iter.second->release();
         }
-
+        
         _componentMap.clear();
         _owner->unscheduleUpdate();
     }
@@ -123,10 +123,9 @@ void ComponentContainer::visit(float delta)
     if (!_componentMap.empty())
     {
         CC_SAFE_RETAIN(_owner);
-        auto iterEnd = _componentMap.end();
-        for (auto iter = _componentMap.begin(); iter != iterEnd; ++iter)
+        for (auto& iter : _componentMap)
         {
-            iter->second->update(delta);
+            iter.second->update(delta);
         }
         CC_SAFE_RELEASE(_owner);
     }
@@ -134,17 +133,17 @@ void ComponentContainer::visit(float delta)
 
 void ComponentContainer::onEnter()
 {
-    for (auto iter = _componentMap.begin(); iter != _componentMap.end(); ++iter)
+    for (auto& iter : _componentMap)
     {
-        iter->second->onEnter();
+        iter.second->onEnter();
     }
 }
 
 void ComponentContainer::onExit()
 {
-    for (auto iter = _componentMap.begin(); iter != _componentMap.end(); ++iter)
+    for (auto& iter : _componentMap)
     {
-        iter->second->onExit();
+        iter.second->onExit();
     }
 }
 
diff --git a/cocos2d/cocos/2d/CCComponentContainer.h b/cocos2d/cocos/2d/CCComponentContainer.h
index 7849ebb780..fa6621fd27 100644
--- a/cocos2d/cocos/2d/CCComponentContainer.h
+++ b/cocos2d/cocos/2d/CCComponentContainer.h
@@ -1,5 +1,6 @@
 /****************************************************************************
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -22,13 +23,12 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_COMPONENTCONTAINER_H
-#define CC_2D_COMPONENTCONTAINER_H
+#ifndef __CC_FRAMEWORK_COMCONTAINER_H__
+#define __CC_FRAMEWORK_COMCONTAINER_H__
 
 /// @cond DO_NOT_SHOW
 
 #include <cocos/base/CCMap.h>
-
 #include <string>
 
 NS_CC_BEGIN
@@ -43,38 +43,37 @@ protected:
      * @js ctor
      */
     ComponentContainer(Node* node);
-
+    
 public:
     /**
      * @js NA
      * @lua NA
      */
     ~ComponentContainer();
-
-    /**
+    
+	/**
      * @js getComponent
      */
-    Component* get(const std::string& name) const;
+	Component* get(const std::string& name) const;
 
-    bool add(Component* com);
+    bool add(Component *com);
     bool remove(const std::string& name);
-    bool remove(Component* com);
+    bool remove(Component *com);
     void removeAll();
     void visit(float delta);
-
+    
     void onEnter();
     void onExit();
-
-    bool isEmpty() const { return _componentMap.empty(); }
-
+    
+    bool isEmpty() const { return _componentMap.empty(); } 
 private:
     std::unordered_map<std::string, Component*> _componentMap;
-    Node* _owner;
-
+    Node *_owner;
+    
     friend class Node;
 };
 
 NS_CC_END
 
 /// @endcond
-#endif // CC_2D_COMPONENTCONTAINER_H
+#endif  // __CC_FRAMEWORK_COMCONTAINER_H__
diff --git a/cocos2d/cocos/2d/CCDrawNode.cpp b/cocos2d/cocos/2d/CCDrawNode.cpp
index 59e3bd22f9..39e71e4a16 100644
--- a/cocos2d/cocos/2d/CCDrawNode.cpp
+++ b/cocos2d/cocos/2d/CCDrawNode.cpp
@@ -1,6 +1,7 @@
 /* Copyright (c) 2012 Scott Lembcke and Howling Moon Software
  * Copyright (c) 2012 cocos2d-x.org
  * Copyright (c) 2013-2016 Chukong Technologies Inc.
+ * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -22,113 +23,42 @@
  */
 
 #include <cocos/2d/CCDrawNode.h>
-
-#include <cocos/2d/CCActionCatmullRom.h>
+#include <cocos/base/CCEventType.h>
 #include <cocos/base/CCConfiguration.h>
+#include <cocos/renderer/CCRenderer.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/CCEventListenerCustom.h>
-#include <cocos/base/CCEventType.h>
+#include <cocos/base/CCEventDispatcher.h>
+#include <cocos/2d/CCActionCatmullRom.h>
 #include <cocos/platform/CCGL.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramCache.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/ccGLStateCache.h>
+#include <cocos/base/ccUtils.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 
-// Vec2 == CGPoint in 32-bits, but not in 64-bits (OS X)
-// that's why the "v2f" functions are needed
-static Vec2 v2fzero(0.0f, 0.0f);
-
-static inline Vec2 v2f(float x, float y)
-{
-    Vec2 ret(x, y);
-    return ret;
-}
-
-static inline Vec2 v2fadd(const Vec2& v0, const Vec2& v1)
-{
-    return v2f(v0.x + v1.x, v0.y + v1.y);
-}
-
-static inline Vec2 v2fsub(const Vec2& v0, const Vec2& v1)
-{
-    return v2f(v0.x - v1.x, v0.y - v1.y);
-}
-
-static inline Vec2 v2fmult(const Vec2& v, float s)
-{
-    return v2f(v.x * s, v.y * s);
-}
-
-static inline Vec2 v2fperp(const Vec2& p0)
-{
-    return v2f(-p0.y, p0.x);
-}
-
-static inline Vec2 v2fneg(const Vec2& p0)
-{
-    return v2f(-p0.x, -p0.y);
-}
-
-static inline float v2fdot(const Vec2& p0, const Vec2& p1)
-{
-    return p0.x * p1.x + p0.y * p1.y;
-}
-
-static inline Vec2 v2fforangle(float _a_)
-{
-    return v2f(cosf(_a_), sinf(_a_));
-}
-
-static inline Vec2 v2fnormalize(const Vec2& p)
-{
-    Vec2 r(p.x, p.y);
-    r.normalize();
-    return v2f(r.x, r.y);
-}
-
-static inline Vec2 __v2f(const Vec2& v)
+static inline Tex2F v2ToTex2F(const Vec2 &v)
 {
-    //#ifdef __LP64__
-    return v2f(v.x, v.y);
-    // #else
-    //     return * ((Vec2*) &v);
-    // #endif
-}
-
-static inline Tex2F __t(const Vec2& v)
-{
-    return *(Tex2F*)&v;
+    return {v.x, v.y};
 }
 
 // implementation of DrawNode
 
-DrawNode::DrawNode(int lineWidth)
-: _vao(0)
-, _vbo(0)
-, _vaoGLPoint(0)
-, _vboGLPoint(0)
-, _vaoGLLine(0)
-, _vboGLLine(0)
-, _bufferCapacity(0)
-, _bufferCount(0)
-, _buffer(nullptr)
-, _bufferCapacityGLPoint(0)
-, _bufferCountGLPoint(0)
-, _bufferGLPoint(nullptr)
-, _bufferCapacityGLLine(0)
-, _bufferCountGLLine(0)
-, _bufferGLLine(nullptr)
-, _dirty(false)
-, _dirtyGLPoint(false)
-, _dirtyGLLine(false)
-, _lineWidth(lineWidth)
-, _defaultLineWidth(lineWidth)
+DrawNode::DrawNode(float lineWidth)
+: _lineWidth(lineWidth)
 {
     _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
+#if CC_ENABLE_CACHE_TEXTURE_DATA
+    //TODO new-renderer: interface setupBuffer removal
+
+    // Need to listen the event only when not use batchnode, because it will use VBO
+//    auto listener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, [this](EventCustom* event){
+//        /** listen the event that renderer was recreated on Android/WP8 */
+//        this->setupBuffer();
+//    });
+
+//    _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);
+#endif
 }
 
 DrawNode::~DrawNode()
@@ -139,25 +69,13 @@ DrawNode::~DrawNode()
     _bufferGLPoint = nullptr;
     free(_bufferGLLine);
     _bufferGLLine = nullptr;
-
-    glDeleteBuffers(1, &_vbo);
-    glDeleteBuffers(1, &_vboGLLine);
-    glDeleteBuffers(1, &_vboGLPoint);
-    _vbo = 0;
-    _vboGLPoint = 0;
-    _vboGLLine = 0;
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        GL::bindVAO(0);
-        glDeleteVertexArrays(1, &_vao);
-        glDeleteVertexArrays(1, &_vaoGLLine);
-        glDeleteVertexArrays(1, &_vaoGLPoint);
-        _vao = _vaoGLLine = _vaoGLPoint = 0;
-    }
+    
+    CC_SAFE_RELEASE(_programState);
+    CC_SAFE_RELEASE(_programStatePoint);
+    CC_SAFE_RELEASE(_programStateLine);
 }
 
-DrawNode* DrawNode::create(int defaultLineWidth)
+DrawNode* DrawNode::create(float defaultLineWidth)
 {
     DrawNode* ret = new (std::nothrow) DrawNode(defaultLineWidth);
     if (ret && ret->init())
@@ -168,422 +86,311 @@ DrawNode* DrawNode::create(int defaultLineWidth)
     {
         CC_SAFE_DELETE(ret);
     }
-
+    
     return ret;
 }
 
 void DrawNode::ensureCapacity(int count)
 {
-    CCASSERT(count >= 0, "capacity must be >= 0");
-
-    if (_bufferCount + count > _bufferCapacity)
+    CCASSERT(count>=0, "capacity must be >= 0");
+    
+    if(_bufferCount + count > _bufferCapacity)
     {
         _bufferCapacity += MAX(_bufferCapacity, count);
-        _buffer = (V2F_C4B_T2F*)realloc(_buffer, _bufferCapacity * sizeof(V2F_C4B_T2F));
+        _buffer = (V2F_C4B_T2F*)realloc(_buffer, _bufferCapacity*sizeof(V2F_C4B_T2F));
+        
+        _customCommand.createVertexBuffer(sizeof(V2F_C4B_T2F), _bufferCapacity, CustomCommand::BufferUsage::STATIC);
+        _customCommand.updateVertexBuffer(_buffer, _bufferCapacity*sizeof(V2F_C4B_T2F));
     }
 }
 
 void DrawNode::ensureCapacityGLPoint(int count)
 {
-    CCASSERT(count >= 0, "capacity must be >= 0");
-
-    if (_bufferCountGLPoint + count > _bufferCapacityGLPoint)
+    CCASSERT(count>=0, "capacity must be >= 0");
+    
+    if(_bufferCountGLPoint + count > _bufferCapacityGLPoint)
     {
         _bufferCapacityGLPoint += MAX(_bufferCapacityGLPoint, count);
-        _bufferGLPoint = (V2F_C4B_T2F*)realloc(_bufferGLPoint, _bufferCapacityGLPoint * sizeof(V2F_C4B_T2F));
+        _bufferGLPoint = (V2F_C4B_T2F*)realloc(_bufferGLPoint, _bufferCapacityGLPoint*sizeof(V2F_C4B_T2F));
+        
+        _customCommandGLPoint.createVertexBuffer(sizeof(V2F_C4B_T2F), _bufferCapacityGLPoint, CustomCommand::BufferUsage::STATIC);
+        _customCommandGLPoint.updateVertexBuffer(_bufferGLPoint, _bufferCapacityGLPoint*sizeof(V2F_C4B_T2F));
     }
 }
 
 void DrawNode::ensureCapacityGLLine(int count)
 {
-    CCASSERT(count >= 0, "capacity must be >= 0");
-
-    if (_bufferCountGLLine + count > _bufferCapacityGLLine)
+    CCASSERT(count>=0, "capacity must be >= 0");
+    
+    if(_bufferCountGLLine + count > _bufferCapacityGLLine)
     {
         _bufferCapacityGLLine += MAX(_bufferCapacityGLLine, count);
-        _bufferGLLine = (V2F_C4B_T2F*)realloc(_bufferGLLine, _bufferCapacityGLLine * sizeof(V2F_C4B_T2F));
+        _bufferGLLine = (V2F_C4B_T2F*)realloc(_bufferGLLine, _bufferCapacityGLLine*sizeof(V2F_C4B_T2F));
+        
+        _customCommandGLLine.createVertexBuffer(sizeof(V2F_C4B_T2F), _bufferCapacityGLLine, CustomCommand::BufferUsage::STATIC);
+        _customCommandGLLine.updateVertexBuffer(_bufferGLLine, _bufferCapacityGLLine*sizeof(V2F_C4B_T2F));
     }
 }
 
 bool DrawNode::init()
 {
     _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
-
-    setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_LENGTH_TEXTURE_COLOR));
-
+    updateShader();
     ensureCapacity(512);
     ensureCapacityGLPoint(64);
     ensureCapacityGLLine(256);
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        glGenVertexArrays(1, &_vao);
-        GL::bindVAO(_vao);
-        glGenBuffers(1, &_vbo);
-        glBindBuffer(GL_ARRAY_BUFFER, _vbo);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacity, _buffer, GL_STREAM_DRAW);
-
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX, _vao);
-        // vertex
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, vertices));
-        // color
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, colors));
-        // texcood
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, texCoords));
-
-        glGenVertexArrays(1, &_vaoGLLine);
-        GL::bindVAO(_vaoGLLine);
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX, _vaoGLLine);
-        glGenBuffers(1, &_vboGLLine);
-        glBindBuffer(GL_ARRAY_BUFFER, _vboGLLine);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacityGLLine, _bufferGLLine, GL_STREAM_DRAW);
-        // vertex
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, vertices));
-        // color
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, colors));
-        // texcood
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, texCoords));
-        glGenVertexArrays(1, &_vaoGLPoint);
-        GL::bindVAO(_vaoGLPoint);
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX, _vaoGLPoint);
-        glGenBuffers(1, &_vboGLPoint);
-        glBindBuffer(GL_ARRAY_BUFFER, _vboGLPoint);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacityGLPoint, _bufferGLPoint, GL_STREAM_DRAW);
-        // vertex
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, vertices));
-        // color
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, colors));
-        // Texture coord as pointsize
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, texCoords));
-
-        GL::bindVAO(0);
-        glBindBuffer(GL_ARRAY_BUFFER, 0);
-    }
-    else
-    {
-        glGenBuffers(1, &_vbo);
-        glBindBuffer(GL_ARRAY_BUFFER, _vbo);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacity, _buffer, GL_STREAM_DRAW);
-
-        glGenBuffers(1, &_vboGLLine);
-        glBindBuffer(GL_ARRAY_BUFFER, _vboGLLine);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacityGLLine, _bufferGLLine, GL_STREAM_DRAW);
-
-        glGenBuffers(1, &_vboGLPoint);
-        glBindBuffer(GL_ARRAY_BUFFER, _vboGLPoint);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacityGLPoint, _bufferGLPoint, GL_STREAM_DRAW);
-
-        glBindBuffer(GL_ARRAY_BUFFER, 0);
-    }
-
-    CHECK_GL_ERROR_DEBUG();
-
+    
     _dirty = true;
     _dirtyGLLine = true;
     _dirtyGLPoint = true;
-
-#if CC_ENABLE_CACHE_TEXTURE_DATA
-    // Need to listen the event only when not use batchnode, because it will use VBO
-    auto listener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, [this](EventCustom* event) {
-        /** listen the event that renderer was recreated on Android/WP8 */
-        this->init();
-    });
-
-    _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);
-#endif
-
     return true;
 }
 
-void DrawNode::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void DrawNode::updateShader()
 {
-    if (_bufferCount)
-    {
-        _customCommand.init(_globalZOrder, transform, flags);
-        _customCommand.setFunc([this, transform, flags]() { onDraw(transform, flags); });
-        renderer->addCommand(&_customCommand);
-    }
+    CC_SAFE_RELEASE(_programState);
+    _programState = new (std::nothrow) backend::ProgramState(positionColorLengthTexture_vert, positionColorLengthTexture_frag);
+    _customCommand.getPipelineDescriptor().programState = _programState;
+    setVertexLayout(_customCommand);
+    _customCommand.setDrawType(CustomCommand::DrawType::ARRAY);
+    _customCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE);
 
-    if (_bufferCountGLPoint)
-    {
-        _customCommandGLPoint.init(_globalZOrder, transform, flags);
-        _customCommandGLPoint.setFunc([this, transform, flags]() { onDrawGLPoint(transform, flags); });
-        renderer->addCommand(&_customCommandGLPoint);
-    }
+    CC_SAFE_RELEASE(_programStatePoint);
+    _programStatePoint = new (std::nothrow) backend::ProgramState(positionColorTextureAsPointsize_vert, positionColor_frag);
+    _customCommandGLPoint.getPipelineDescriptor().programState = _programStatePoint;
+    setVertexLayout(_customCommandGLPoint);
+    _customCommandGLPoint.setDrawType(CustomCommand::DrawType::ARRAY);
+    _customCommandGLPoint.setPrimitiveType(CustomCommand::PrimitiveType::POINT);
 
-    if (_bufferCountGLLine)
-    {
-        _customCommandGLLine.init(_globalZOrder, transform, flags);
-        _customCommandGLLine.setFunc([this, transform, flags]() { onDrawGLLine(transform, flags); });
-        renderer->addCommand(&_customCommandGLLine);
-    }
+    CC_SAFE_RELEASE(_programStateLine);
+    _programStateLine = new (std::nothrow) backend::ProgramState(positionColorLengthTexture_vert, positionColorLengthTexture_frag);
+    _customCommandGLLine.getPipelineDescriptor().programState = _programStateLine;
+    setVertexLayout(_customCommandGLLine);
+    _customCommandGLLine.setDrawType(CustomCommand::DrawType::ARRAY);
+    _customCommandGLLine.setPrimitiveType(CustomCommand::PrimitiveType::LINE);
 }
 
-void DrawNode::onDraw(const Mat4& transform, uint32_t flags)
+void DrawNode::setVertexLayout(CustomCommand& cmd)
 {
-    getGLProgramState()->apply(transform);
-
-    GL::blendFunc(_blendFunc.src, _blendFunc.dst);
-
-    if (_dirty)
+    auto* programState = cmd.getPipelineDescriptor().programState;
+    auto layout = programState->getVertexLayout();
+    const auto& attributeInfo = programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
     {
-        glBindBuffer(GL_ARRAY_BUFFER, _vbo);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacity, _buffer, GL_STREAM_DRAW);
-
-        _dirty = false;
+        layout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT2, 0, false);
     }
-    if (Configuration::getInstance()->supportsShareableVAO())
+    
+    iter = attributeInfo.find("a_texCoord");
+    if(iter != attributeInfo.end())
     {
-        GL::bindVAO(_vao);
+        layout->setAttribute("a_texCoord", iter->second.location, backend::VertexFormat::FLOAT2, offsetof(V2F_C4B_T2F, texCoords), false);
     }
-    else
+    
+    iter = attributeInfo.find("a_color");
+    if(iter != attributeInfo.end())
     {
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
-
-        glBindBuffer(GL_ARRAY_BUFFER, _vbo);
-        // vertex
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, vertices));
-        // color
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, colors));
-        // texcood
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, texCoords));
+        layout->setAttribute("a_color", iter->second.location, backend::VertexFormat::UBYTE4, offsetof(V2F_C4B_T2F, colors), true);
     }
-
-    glDrawArrays(GL_TRIANGLES, 0, _bufferCount);
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        GL::bindVAO(0);
-    }
-
-    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, _bufferCount);
-    CHECK_GL_ERROR_DEBUG();
+    layout->setLayout(sizeof(V2F_C4B_T2F));
 }
 
-void DrawNode::onDrawGLLine(const Mat4& transform, uint32_t flags)
+void DrawNode::updateBlendState(CustomCommand& cmd)
 {
-    auto glProgram = GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_NAME_POSITION_LENGTH_TEXTURE_COLOR);
-    glProgram->use();
-    glProgram->setUniformsForBuiltins(transform);
-
-    GL::blendFunc(_blendFunc.src, _blendFunc.dst);
-
-    if (_dirtyGLLine)
-    {
-        glBindBuffer(GL_ARRAY_BUFFER, _vboGLLine);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacityGLLine, _bufferGLLine, GL_STREAM_DRAW);
-        _dirtyGLLine = false;
-    }
-    if (Configuration::getInstance()->supportsShareableVAO())
+    backend::BlendDescriptor& blendDescriptor = cmd.getPipelineDescriptor().blendDescriptor;
+    blendDescriptor.blendEnabled = true;
+    if (_blendFunc == BlendFunc::ALPHA_NON_PREMULTIPLIED)
     {
-        GL::bindVAO(_vaoGLLine);
+        blendDescriptor.sourceRGBBlendFactor = backend::BlendFactor::SRC_ALPHA;
+        blendDescriptor.destinationRGBBlendFactor = backend::BlendFactor::ONE_MINUS_SRC_ALPHA;
+        blendDescriptor.sourceAlphaBlendFactor = backend::BlendFactor::SRC_ALPHA;
+        blendDescriptor.destinationAlphaBlendFactor = backend::BlendFactor::ONE_MINUS_SRC_ALPHA;
+        setOpacityModifyRGB(false);
     }
     else
     {
-        glBindBuffer(GL_ARRAY_BUFFER, _vboGLLine);
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
-        // vertex
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, vertices));
-        // color
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, colors));
-        // texcood
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, texCoords));
-    }
-
-    glLineWidth(_lineWidth);
-    glDrawArrays(GL_LINES, 0, _bufferCountGLLine);
-
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        GL::bindVAO(0);
+        blendDescriptor.sourceRGBBlendFactor = backend::BlendFactor::ONE;
+        blendDescriptor.destinationRGBBlendFactor = backend::BlendFactor::ONE_MINUS_SRC_ALPHA;
+        blendDescriptor.sourceAlphaBlendFactor = backend::BlendFactor::ONE;
+        blendDescriptor.destinationAlphaBlendFactor = backend::BlendFactor::ONE_MINUS_SRC_ALPHA;
+        setOpacityModifyRGB(true);
     }
-
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, _bufferCountGLLine);
-
-    CHECK_GL_ERROR_DEBUG();
 }
 
-void DrawNode::onDrawGLPoint(const Mat4& transform, uint32_t flags)
+void DrawNode::updateUniforms(const Mat4 &transform, CustomCommand& cmd)
 {
-    auto glProgram = GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_NAME_POSITION_COLOR_TEXASPOINTSIZE);
-    glProgram->use();
-    glProgram->setUniformsForBuiltins(transform);
-
-    GL::blendFunc(_blendFunc.src, _blendFunc.dst);
-
-    if (_dirtyGLPoint)
-    {
-        glBindBuffer(GL_ARRAY_BUFFER, _vboGLPoint);
-        glBufferData(GL_ARRAY_BUFFER, sizeof(V2F_C4B_T2F) * _bufferCapacityGLPoint, _bufferGLPoint, GL_STREAM_DRAW);
+    auto& pipelineDescriptor = cmd.getPipelineDescriptor();
+    const auto& matrixP = _director->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    Mat4 matrixMVP = matrixP * transform;
+    auto mvpLocation = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    pipelineDescriptor.programState->setUniform(mvpLocation, matrixMVP.m, sizeof(matrixMVP.m));
 
-        _dirtyGLPoint = false;
-    }
+    float alpha = _displayedOpacity / 255.0f;
+    auto alphaUniformLocation = pipelineDescriptor.programState->getUniformLocation("u_alpha");
+    pipelineDescriptor.programState->setUniform(alphaUniformLocation, &alpha, sizeof(alpha));
+}
 
-    if (Configuration::getInstance()->supportsShareableVAO())
+void DrawNode::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
+{
+    if(_bufferCount)
     {
-        GL::bindVAO(_vaoGLPoint);
+        updateBlendState(_customCommand);
+        updateUniforms(transform, _customCommand);
+        _customCommand.init(_globalZOrder);
+        renderer->addCommand(&_customCommand);
     }
-    else
+    
+    if(_bufferCountGLPoint)
     {
-        glBindBuffer(GL_ARRAY_BUFFER, _vboGLPoint);
-        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, vertices));
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, colors));
-        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(V2F_C4B_T2F), (GLvoid*)offsetof(V2F_C4B_T2F, texCoords));
+        updateBlendState(_customCommandGLPoint);
+        updateUniforms(transform, _customCommandGLPoint);
+        _customCommandGLPoint.init(_globalZOrder);
+        renderer->addCommand(&_customCommandGLPoint);
     }
-
-    glDrawArrays(GL_POINTS, 0, _bufferCountGLPoint);
-
-    if (Configuration::getInstance()->supportsShareableVAO())
+    
+    if(_bufferCountGLLine)
     {
-        GL::bindVAO(0);
+        updateBlendState(_customCommandGLLine);
+        updateUniforms(transform, _customCommandGLLine);
+        _customCommandGLLine.setLineWidth(_lineWidth);
+        _customCommandGLLine.init(_globalZOrder);
+        renderer->addCommand(&_customCommandGLLine);
     }
-
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-
-    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, _bufferCountGLPoint);
-    CHECK_GL_ERROR_DEBUG();
 }
 
-void DrawNode::drawPoint(const Vec2& position, const float pointSize, const Color4F& color)
+void DrawNode::drawPoint(const Vec2& position, const float pointSize, const Color4F &color)
 {
     ensureCapacityGLPoint(1);
-
-    V2F_C4B_T2F* point = (V2F_C4B_T2F*)(_bufferGLPoint + _bufferCountGLPoint);
-    V2F_C4B_T2F a = {position, Color4B(color), Tex2F(pointSize, 0)};
-    *point = a;
-
+    
+    V2F_C4B_T2F *point = _bufferGLPoint + _bufferCountGLPoint;
+    *point = {position, Color4B(color), Tex2F(pointSize,0)};
+    
+    _customCommandGLPoint.updateVertexBuffer(point, _bufferCountGLPoint*sizeof(V2F_C4B_T2F), sizeof(V2F_C4B_T2F));
     _bufferCountGLPoint += 1;
     _dirtyGLPoint = true;
+    _customCommandGLPoint.setVertexDrawInfo(0, _bufferCountGLPoint);
 }
 
-void DrawNode::drawPoints(const Vec2* position, unsigned int numberOfPoints, const Color4F& color)
+void DrawNode::drawPoints(const Vec2 *position, unsigned int numberOfPoints, const Color4F &color)
 {
     drawPoints(position, numberOfPoints, 1.0, color);
 }
 
-void DrawNode::drawPoints(const Vec2* position, unsigned int numberOfPoints, const float pointSize, const Color4F& color)
+void DrawNode::drawPoints(const Vec2 *position, unsigned int numberOfPoints, const float pointSize, const Color4F &color)
 {
     ensureCapacityGLPoint(numberOfPoints);
-
-    V2F_C4B_T2F* point = (V2F_C4B_T2F*)(_bufferGLPoint + _bufferCountGLPoint);
-
-    for (unsigned int i = 0; i < numberOfPoints; i++, point++)
+    
+    V2F_C4B_T2F *point = _bufferGLPoint + _bufferCountGLPoint;
+    for(unsigned int i=0; i < numberOfPoints; i++)
     {
-        V2F_C4B_T2F a = {position[i], Color4B(color), Tex2F(pointSize, 0)};
-        *point = a;
+        *(point + i) = {position[i], Color4B(color), Tex2F(pointSize,0)};
     }
-
+    
+    _customCommandGLPoint.updateVertexBuffer(point, _bufferCountGLPoint*sizeof(V2F_C4B_T2F), numberOfPoints*sizeof(V2F_C4B_T2F));
     _bufferCountGLPoint += numberOfPoints;
     _dirtyGLPoint = true;
+    _customCommandGLPoint.setVertexDrawInfo(0, _bufferCountGLPoint);
 }
 
-void DrawNode::drawLine(const Vec2& origin, const Vec2& destination, const Color4F& color)
+void DrawNode::drawLine(const Vec2 &origin, const Vec2 &destination, const Color4F &color)
 {
     ensureCapacityGLLine(2);
-
-    V2F_C4B_T2F* point = (V2F_C4B_T2F*)(_bufferGLLine + _bufferCountGLLine);
-
-    V2F_C4B_T2F a = {origin, Color4B(color), Tex2F(0.0, 0.0)};
-    V2F_C4B_T2F b = {destination, Color4B(color), Tex2F(0.0, 0.0)};
-
-    *point = a;
-    *(point + 1) = b;
-
+    
+    V2F_C4B_T2F *point = _bufferGLLine + _bufferCountGLLine;
+    
+    *point = {origin, Color4B(color), Tex2F(0.0, 0.0)};
+    *(point+1) = {destination, Color4B(color), Tex2F(0.0, 0.0)};
+    
+    _customCommandGLLine.updateVertexBuffer(point, _bufferCountGLLine*sizeof(V2F_C4B_T2F), 2*sizeof(V2F_C4B_T2F));
     _bufferCountGLLine += 2;
     _dirtyGLLine = true;
+    _customCommandGLLine.setVertexDrawInfo(0, _bufferCountGLLine);
 }
 
-void DrawNode::drawRect(const Vec2& origin, const Vec2& destination, const Color4F& color)
+void DrawNode::drawRect(const Vec2 &origin, const Vec2 &destination, const Color4F &color)
 {
-    drawLine(Vec2(origin.x, origin.y), Vec2(destination.x, origin.y), color);
-    drawLine(Vec2(destination.x, origin.y), Vec2(destination.x, destination.y), color);
-    drawLine(Vec2(destination.x, destination.y), Vec2(origin.x, destination.y), color);
-    drawLine(Vec2(origin.x, destination.y), Vec2(origin.x, origin.y), color);
+    drawLine(origin, Vec2(destination.x, origin.y), color);
+    drawLine(Vec2(destination.x, origin.y), destination, color);
+    drawLine(destination, Vec2(origin.x, destination.y), color);
+    drawLine(Vec2(origin.x, destination.y), origin, color);
 }
 
-void DrawNode::drawPoly(const Vec2* poli, unsigned int numberOfPoints, bool closePolygon, const Color4F& color)
+void DrawNode::drawPoly(const Vec2 *poli, unsigned int numberOfPoints, bool closePolygon, const Color4F &color)
 {
-    unsigned int vertext_count;
-    if (closePolygon)
+    unsigned int vertex_count;
+    if(closePolygon)
     {
-        vertext_count = 2 * numberOfPoints;
-        ensureCapacityGLLine(vertext_count);
+        vertex_count = 2 * numberOfPoints;
+        ensureCapacityGLLine(vertex_count);
     }
     else
     {
-        vertext_count = 2 * (numberOfPoints - 1);
-        ensureCapacityGLLine(vertext_count);
+        vertex_count = 2 * (numberOfPoints - 1);
+        ensureCapacityGLLine(vertex_count);
     }
-
-    V2F_C4B_T2F* point = (V2F_C4B_T2F*)(_bufferGLLine + _bufferCountGLLine);
-
+    
+    V2F_C4B_T2F *point = _bufferGLLine + _bufferCountGLLine;
+    V2F_C4B_T2F *cursor = point;
+    
     unsigned int i = 0;
-    for (; i < numberOfPoints - 1; i++)
+    for(; i < numberOfPoints - 1; i++)
     {
-        V2F_C4B_T2F a = {poli[i], Color4B(color), Tex2F(0.0, 0.0)};
-        V2F_C4B_T2F b = {poli[i + 1], Color4B(color), Tex2F(0.0, 0.0)};
-
-        *point = a;
-        *(point + 1) = b;
+        *point = {poli[i], Color4B(color), Tex2F(0.0, 0.0)};
+        *(point + 1) = {poli[i+1], Color4B(color), Tex2F(0.0, 0.0)};
         point += 2;
     }
-    if (closePolygon)
+    if(closePolygon)
     {
-        V2F_C4B_T2F a = {poli[i], Color4B(color), Tex2F(0.0, 0.0)};
-        V2F_C4B_T2F b = {poli[0], Color4B(color), Tex2F(0.0, 0.0)};
-        *point = a;
-        *(point + 1) = b;
+        *point = {poli[i], Color4B(color), Tex2F(0.0, 0.0)};
+        *(point + 1) = {poli[0], Color4B(color), Tex2F(0.0, 0.0)};
     }
-
-    _bufferCountGLLine += vertext_count;
+    
+    _customCommandGLLine.updateVertexBuffer(cursor, _bufferCountGLLine*sizeof(V2F_C4B_T2F), vertex_count*sizeof(V2F_C4B_T2F));
+    _bufferCountGLLine += vertex_count;
+    _customCommandGLLine.setVertexDrawInfo(0, _bufferCountGLLine);
 }
 
-void DrawNode::drawCircle(const Vec2& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, float scaleX, float scaleY,
-                          const Color4F& color)
+void DrawNode::drawCircle(const Vec2& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, float scaleX, float scaleY, const Color4F &color)
 {
-    const float coef = 2.0f * (float)M_PI / segments;
-
-    Vec2* vertices = new (std::nothrow) Vec2[segments + 2];
-    if (!vertices)
+    const float coef = 2.0f * (float)M_PI/segments;
+    
+    Vec2 *vertices = new (std::nothrow) Vec2[segments+2];
+    if( ! vertices )
         return;
-
-    for (unsigned int i = 0; i <= segments; i++)
-    {
-        float rads = i * coef;
-        GLfloat j = radius * cosf(rads + angle) * scaleX + center.x;
-        GLfloat k = radius * sinf(rads + angle) * scaleY + center.y;
-
+    
+    for(unsigned int i = 0;i <= segments; i++) {
+        float rads = i*coef;
+        float j = radius * cosf(rads + angle) * scaleX + center.x;
+        float k = radius * sinf(rads + angle) * scaleY + center.y;
+        
         vertices[i].x = j;
         vertices[i].y = k;
     }
-    if (drawLineToCenter)
+    if(drawLineToCenter)
     {
-        vertices[segments + 1].x = center.x;
-        vertices[segments + 1].y = center.y;
-        drawPoly(vertices, segments + 2, true, color);
+        vertices[segments+1].x = center.x;
+        vertices[segments+1].y = center.y;
+        drawPoly(vertices, segments+2, true, color);
     }
     else
-        drawPoly(vertices, segments + 1, true, color);
-
+        drawPoly(vertices, segments+1, true, color);
+    
     CC_SAFE_DELETE_ARRAY(vertices);
 }
 
-void DrawNode::drawCircle(const Vec2& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, const Color4F& color)
+void DrawNode::drawCircle(const Vec2 &center, float radius, float angle, unsigned int segments, bool drawLineToCenter, const Color4F &color)
 {
     drawCircle(center, radius, angle, segments, drawLineToCenter, 1.0f, 1.0f, color);
 }
 
-void DrawNode::drawQuadBezier(const Vec2& origin, const Vec2& control, const Vec2& destination, unsigned int segments, const Color4F& color)
+void DrawNode::drawQuadBezier(const Vec2 &origin, const Vec2 &control, const Vec2 &destination, unsigned int segments, const Color4F &color)
 {
     Vec2* vertices = new (std::nothrow) Vec2[segments + 1];
-    if (!vertices)
+    if( ! vertices )
         return;
-
+    
     float t = 0.0f;
-    for (unsigned int i = 0; i < segments; i++)
+    for(unsigned int i = 0; i < segments; i++)
     {
         vertices[i].x = powf(1 - t, 2) * origin.x + 2.0f * (1 - t) * t * control.x + t * t * destination.x;
         vertices[i].y = powf(1 - t, 2) * origin.y + 2.0f * (1 - t) * t * control.y + t * t * destination.y;
@@ -591,18 +398,18 @@ void DrawNode::drawQuadBezier(const Vec2& origin, const Vec2& control, const Vec
     }
     vertices[segments].x = destination.x;
     vertices[segments].y = destination.y;
-
-    drawPoly(vertices, segments + 1, false, color);
+    
+    drawPoly(vertices, segments+1, false, color);
 
     CC_SAFE_DELETE_ARRAY(vertices);
 }
 
-void DrawNode::drawCubicBezier(const Vec2& origin, const Vec2& control1, const Vec2& control2, const Vec2& destination, unsigned int segments, const Color4F& color)
+void DrawNode::drawCubicBezier(const Vec2 &origin, const Vec2 &control1, const Vec2 &control2, const Vec2 &destination, unsigned int segments, const Color4F &color)
 {
     Vec2* vertices = new (std::nothrow) Vec2[segments + 1];
-    if (!vertices)
+    if( ! vertices )
         return;
-
+    
     float t = 0;
     for (unsigned int i = 0; i < segments; i++)
     {
@@ -612,300 +419,305 @@ void DrawNode::drawCubicBezier(const Vec2& origin, const Vec2& control1, const V
     }
     vertices[segments].x = destination.x;
     vertices[segments].y = destination.y;
-
-    drawPoly(vertices, segments + 1, false, color);
+    
+    drawPoly(vertices, segments+1, false, color);
 
     CC_SAFE_DELETE_ARRAY(vertices);
 }
 
-void DrawNode::drawCardinalSpline(PointArray* config, float tension, unsigned int segments, const Color4F& color)
+void DrawNode::drawCardinalSpline(PointArray *config, float tension,  unsigned int segments, const Color4F &color)
 {
     Vec2* vertices = new (std::nothrow) Vec2[segments + 1];
-    if (!vertices)
+    if( ! vertices )
         return;
-
-    std::size_t p;
+    
+    ssize_t p;
     float lt;
     float deltaT = 1.0f / config->count();
-
-    for (unsigned int i = 0; i < segments + 1; i++)
-    {
+    
+    for( unsigned int i=0; i < segments+1;i++) {
+        
         float dt = (float)i / segments;
-
+        
         // border
-        if (dt == 1)
-        {
+        if( dt == 1 ) {
             p = config->count() - 1;
             lt = 1;
-        }
-        else
-        {
-            p = dt / deltaT;
+        } else {
+            p = static_cast<ssize_t>(dt / deltaT);
             lt = (dt - deltaT * (float)p) / deltaT;
         }
-
+        
         // Interpolate
-        Vec2 pp0 = config->getControlPointAtIndex(p - 1);
-        Vec2 pp1 = config->getControlPointAtIndex(p + 0);
-        Vec2 pp2 = config->getControlPointAtIndex(p + 1);
-        Vec2 pp3 = config->getControlPointAtIndex(p + 2);
-
-        Vec2 newPos = ccCardinalSplineAt(pp0, pp1, pp2, pp3, tension, lt);
+        Vec2 pp0 = config->getControlPointAtIndex(p-1);
+        Vec2 pp1 = config->getControlPointAtIndex(p+0);
+        Vec2 pp2 = config->getControlPointAtIndex(p+1);
+        Vec2 pp3 = config->getControlPointAtIndex(p+2);
+        
+        Vec2 newPos = ccCardinalSplineAt( pp0, pp1, pp2, pp3, tension, lt);
         vertices[i].x = newPos.x;
         vertices[i].y = newPos.y;
     }
-
-    drawPoly(vertices, segments + 1, false, color);
-
+    
+    drawPoly(vertices, segments+1, false, color);
+    
     CC_SAFE_DELETE_ARRAY(vertices);
 }
 
-void DrawNode::drawCatmullRom(PointArray* points, unsigned int segments, const Color4F& color)
+void DrawNode::drawCatmullRom(PointArray *points, unsigned int segments, const Color4F &color)
 {
-    drawCardinalSpline(points, 0.5f, segments, color);
+    drawCardinalSpline( points, 0.5f, segments, color);
 }
 
-void DrawNode::drawDot(const Vec2& pos, float radius, const Color4F& color)
+void DrawNode::drawDot(const Vec2 &pos, float radius, const Color4F &color)
 {
-    unsigned int vertex_count = 2 * 3;
+    unsigned int vertex_count = 2*3;
     ensureCapacity(vertex_count);
-
-    V2F_C4B_T2F a = {Vec2(pos.x - radius, pos.y - radius), Color4B(color), Tex2F(-1.0, -1.0)};
-    V2F_C4B_T2F b = {Vec2(pos.x - radius, pos.y + radius), Color4B(color), Tex2F(-1.0, 1.0)};
-    V2F_C4B_T2F c = {Vec2(pos.x + radius, pos.y + radius), Color4B(color), Tex2F(1.0, 1.0)};
-    V2F_C4B_T2F d = {Vec2(pos.x + radius, pos.y - radius), Color4B(color), Tex2F(1.0, -1.0)};
-
-    V2F_C4B_T2F_Triangle* triangles = (V2F_C4B_T2F_Triangle*)(_buffer + _bufferCount);
+    
+    V2F_C4B_T2F a = {Vec2(pos.x - radius, pos.y - radius), Color4B(color), Tex2F(-1.0, -1.0) };
+    V2F_C4B_T2F b = {Vec2(pos.x - radius, pos.y + radius), Color4B(color), Tex2F(-1.0,  1.0) };
+    V2F_C4B_T2F c = {Vec2(pos.x + radius, pos.y + radius), Color4B(color), Tex2F( 1.0,  1.0) };
+    V2F_C4B_T2F d = {Vec2(pos.x + radius, pos.y - radius), Color4B(color), Tex2F( 1.0, -1.0) };
+    
+    V2F_C4B_T2F_Triangle *triangles = (V2F_C4B_T2F_Triangle *)(_buffer + _bufferCount);
     V2F_C4B_T2F_Triangle triangle0 = {a, b, c};
     V2F_C4B_T2F_Triangle triangle1 = {a, c, d};
     triangles[0] = triangle0;
     triangles[1] = triangle1;
-
+    
+    _customCommand.updateVertexBuffer(triangles, _bufferCount*sizeof(V2F_C4B_T2F), vertex_count*sizeof(V2F_C4B_T2F));
     _bufferCount += vertex_count;
-
     _dirty = true;
+    _customCommand.setVertexDrawInfo(0, _bufferCount);
 }
 
-void DrawNode::drawRect(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color4F& color)
+void DrawNode::drawRect(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3, const Vec2& p4, const Color4F &color)
 {
-    drawLine(Vec2(p1.x, p1.y), Vec2(p2.x, p2.y), color);
-    drawLine(Vec2(p2.x, p2.y), Vec2(p3.x, p3.y), color);
-    drawLine(Vec2(p3.x, p3.y), Vec2(p4.x, p4.y), color);
-    drawLine(Vec2(p4.x, p4.y), Vec2(p1.x, p1.y), color);
+    drawLine(p1, p2, color);
+    drawLine(p2, p3, color);
+    drawLine(p3, p4, color);
+    drawLine(p4, p1, color);
 }
 
-void DrawNode::drawSegment(const Vec2& from, const Vec2& to, float radius, const Color4F& color)
+void DrawNode::drawSegment(const Vec2 &from, const Vec2 &to, float radius, const Color4F &color)
 {
-    unsigned int vertex_count = 6 * 3;
+    unsigned int vertex_count = 6*3;
     ensureCapacity(vertex_count);
-
-    Vec2 a = __v2f(from);
-    Vec2 b = __v2f(to);
-
-    Vec2 n = v2fnormalize(v2fperp(v2fsub(b, a)));
-    Vec2 t = v2fperp(n);
-
-    Vec2 nw = v2fmult(n, radius);
-    Vec2 tw = v2fmult(t, radius);
-    Vec2 v0 = v2fsub(b, v2fadd(nw, tw));
-    Vec2 v1 = v2fadd(b, v2fsub(nw, tw));
-    Vec2 v2 = v2fsub(b, nw);
-    Vec2 v3 = v2fadd(b, nw);
-    Vec2 v4 = v2fsub(a, nw);
-    Vec2 v5 = v2fadd(a, nw);
-    Vec2 v6 = v2fsub(a, v2fsub(nw, tw));
-    Vec2 v7 = v2fadd(a, v2fadd(nw, tw));
-
-    V2F_C4B_T2F_Triangle* triangles = (V2F_C4B_T2F_Triangle*)(_buffer + _bufferCount);
-
+    
+    Vec2 a = from;
+    Vec2 b = to;
+
+
+    Vec2 n = ((b - a).getPerp()).getNormalized();
+    Vec2 t = n.getPerp();
+
+    Vec2 nw = n * radius;
+    Vec2 tw = t * radius;
+    Vec2 v0 = b - (nw + tw);
+    Vec2 v1 = b + (nw - tw);
+    Vec2 v2 = b - nw;
+    Vec2 v3 = b + nw;
+    Vec2 v4 = a - nw;
+    Vec2 v5 = a + nw;
+    Vec2 v6 = a - (nw - tw);
+    Vec2 v7 = a + (nw + tw);
+    
+    
+    V2F_C4B_T2F_Triangle *triangles = (V2F_C4B_T2F_Triangle *)(_buffer + _bufferCount);
+    
     V2F_C4B_T2F_Triangle triangles0 = {
-        {v0, Color4B(color), __t(v2fneg(v2fadd(n, t)))},
-        {v1, Color4B(color), __t(v2fsub(n, t))},
-        {v2, Color4B(color), __t(v2fneg(n))},
+        {v0, Color4B(color), v2ToTex2F(-(n + t))},
+        {v1, Color4B(color), v2ToTex2F(n - t)},
+        {v2, Color4B(color), v2ToTex2F(-n)},
     };
     triangles[0] = triangles0;
 
     V2F_C4B_T2F_Triangle triangles1 = {
-        {v3, Color4B(color), __t(n)},
-        {v1, Color4B(color), __t(v2fsub(n, t))},
-        {v2, Color4B(color), __t(v2fneg(n))},
+        {v3, Color4B(color), v2ToTex2F(n)},
+        {v1, Color4B(color), v2ToTex2F(n - t)},
+        {v2, Color4B(color), v2ToTex2F(-n)},
     };
     triangles[1] = triangles1;
 
     V2F_C4B_T2F_Triangle triangles2 = {
-        {v3, Color4B(color), __t(n)},
-        {v4, Color4B(color), __t(v2fneg(n))},
-        {v2, Color4B(color), __t(v2fneg(n))},
+        {v3, Color4B(color), v2ToTex2F(n)},
+        {v4, Color4B(color), v2ToTex2F(-n)},
+        {v2, Color4B(color), v2ToTex2F(-n)},
     };
     triangles[2] = triangles2;
 
     V2F_C4B_T2F_Triangle triangles3 = {
-        {v3, Color4B(color), __t(n)},
-        {v4, Color4B(color), __t(v2fneg(n))},
-        {v5, Color4B(color), __t(n)},
+        {v3, Color4B(color), v2ToTex2F(n)},
+        {v4, Color4B(color), v2ToTex2F(-n)},
+        {v5, Color4B(color), v2ToTex2F(n) },
     };
     triangles[3] = triangles3;
 
     V2F_C4B_T2F_Triangle triangles4 = {
-        {v6, Color4B(color), __t(v2fsub(t, n))},
-        {v4, Color4B(color), __t(v2fneg(n))},
-        {v5, Color4B(color), __t(n)},
+        {v6, Color4B(color), v2ToTex2F(t - n)},
+        {v4, Color4B(color), v2ToTex2F(-n) },
+        {v5, Color4B(color), v2ToTex2F(n)},
     };
     triangles[4] = triangles4;
 
     V2F_C4B_T2F_Triangle triangles5 = {
-        {v6, Color4B(color), __t(v2fsub(t, n))},
-        {v7, Color4B(color), __t(v2fadd(n, t))},
-        {v5, Color4B(color), __t(n)},
+        {v6, Color4B(color), v2ToTex2F(t - n)},
+        {v7, Color4B(color), v2ToTex2F(t + n)},
+        {v5, Color4B(color), v2ToTex2F(n)},
     };
     triangles[5] = triangles5;
-
+    
+    _customCommand.updateVertexBuffer(triangles, _bufferCount*sizeof(V2F_C4B_T2F), vertex_count*sizeof(V2F_C4B_T2F));
     _bufferCount += vertex_count;
-
     _dirty = true;
+    _customCommand.setVertexDrawInfo(0, _bufferCount);
 }
 
-void DrawNode::drawPolygon(const Vec2* verts, int count, const Color4F& fillColor, float borderWidth, const Color4F& borderColor)
+void DrawNode::drawPolygon(const Vec2 *verts, int count, const Color4F &fillColor, float borderWidth, const Color4F &borderColor)
 {
     CCASSERT(count >= 0, "invalid count value");
-
+    
     bool outline = (borderColor.a > 0.0f && borderWidth > 0.0f);
-
-    auto triangle_count = outline ? (3 * count - 2) : (count - 2);
-    auto vertex_count = 3 * triangle_count;
+    
+    auto  triangle_count = outline ? (3*count - 2) : (count - 2);
+    auto vertex_count = 3*triangle_count;
     ensureCapacity(vertex_count);
-
-    V2F_C4B_T2F_Triangle* triangles = (V2F_C4B_T2F_Triangle*)(_buffer + _bufferCount);
-    V2F_C4B_T2F_Triangle* cursor = triangles;
-
-    for (int i = 0; i < count - 2; i++)
+    
+    V2F_C4B_T2F_Triangle *triangles = (V2F_C4B_T2F_Triangle *)(_buffer + _bufferCount);
+    V2F_C4B_T2F_Triangle *cursor = triangles;
+    
+    for (int i = 0; i < count-2; i++)
     {
         V2F_C4B_T2F_Triangle tmp = {
-            {verts[0], Color4B(fillColor), __t(v2fzero)},
-            {verts[i + 1], Color4B(fillColor), __t(v2fzero)},
-            {verts[i + 2], Color4B(fillColor), __t(v2fzero)},
+            {verts[0], Color4B(fillColor), v2ToTex2F(Vec2::ZERO)},
+            {verts[i+1], Color4B(fillColor), v2ToTex2F(Vec2::ZERO)},
+            {verts[i+2], Color4B(fillColor), v2ToTex2F(Vec2::ZERO)},
         };
-
+        
         *cursor++ = tmp;
     }
-
-    if (outline)
+    
+    if(outline)
     {
-        struct ExtrudeVerts
-        {
-            Vec2 offset, n;
-        };
+        struct ExtrudeVerts {Vec2 offset, n;};
         struct ExtrudeVerts* extrude = (struct ExtrudeVerts*)malloc(sizeof(struct ExtrudeVerts) * count);
-        memset(extrude, 0, sizeof(struct ExtrudeVerts) * count);
-
+        
         for (int i = 0; i < count; i++)
         {
-            Vec2 v0 = __v2f(verts[(i - 1 + count) % count]);
-            Vec2 v1 = __v2f(verts[i]);
-            Vec2 v2 = __v2f(verts[(i + 1) % count]);
-
-            Vec2 n1 = v2fnormalize(v2fperp(v2fsub(v1, v0)));
-            Vec2 n2 = v2fnormalize(v2fperp(v2fsub(v2, v1)));
-
-            Vec2 offset = v2fmult(v2fadd(n1, n2), 1.0f / (v2fdot(n1, n2) + 1.0f));
-            struct ExtrudeVerts tmp = {offset, n2};
-            extrude[i] = tmp;
+            Vec2 v0 = verts[(i-1+count)%count];
+            Vec2 v1 = verts[i];
+            Vec2 v2 = verts[(i+1)%count];
+            
+            Vec2 n1 = ((v1 - v0).getPerp()).getNormalized();
+            Vec2 n2 = ((v2 - v1).getPerp()).getNormalized();
+            
+            Vec2 offset = (n1 + n2) * (1.0f / (Vec2::dot(n1, n2) + 1.0f));
+            extrude[i] = {offset, n2};
         }
-
-        for (int i = 0; i < count; i++)
+        
+        for(int i = 0; i < count; i++)
         {
-            int j = (i + 1) % count;
-            Vec2 v0 = __v2f(verts[i]);
-            Vec2 v1 = __v2f(verts[j]);
-
+            int j = (i+1)%count;
+            Vec2 v0 = verts[i];
+            Vec2 v1 = verts[j];
+            
             Vec2 n0 = extrude[i].n;
-
+            
             Vec2 offset0 = extrude[i].offset;
             Vec2 offset1 = extrude[j].offset;
-
-            Vec2 inner0 = v2fsub(v0, v2fmult(offset0, borderWidth));
-            Vec2 inner1 = v2fsub(v1, v2fmult(offset1, borderWidth));
-            Vec2 outer0 = v2fadd(v0, v2fmult(offset0, borderWidth));
-            Vec2 outer1 = v2fadd(v1, v2fmult(offset1, borderWidth));
-
+            
+            Vec2 inner0 = v0 - offset0 * borderWidth;
+            Vec2 inner1 = v1 - offset1 * borderWidth;
+            Vec2 outer0 = v0 + offset0 * borderWidth;
+            Vec2 outer1 = v1 + offset1 * borderWidth;
+            
             V2F_C4B_T2F_Triangle tmp1 = {
-                {inner0, Color4B(borderColor), __t(v2fneg(n0))}, {inner1, Color4B(borderColor), __t(v2fneg(n0))}, {outer1, Color4B(borderColor), __t(n0)}};
+                {inner0, Color4B(borderColor), v2ToTex2F(-n0)},
+                {inner1, Color4B(borderColor), v2ToTex2F(-n0)},
+                {outer1, Color4B(borderColor), v2ToTex2F(n0)}
+            };
             *cursor++ = tmp1;
-
+            
             V2F_C4B_T2F_Triangle tmp2 = {
-                {inner0, Color4B(borderColor), __t(v2fneg(n0))}, {outer0, Color4B(borderColor), __t(n0)}, {outer1, Color4B(borderColor), __t(n0)}};
+                {inner0, Color4B(borderColor), v2ToTex2F(-n0)},
+                {outer0, Color4B(borderColor), v2ToTex2F(n0)},
+                {outer1, Color4B(borderColor), v2ToTex2F(n0)}
+            };
             *cursor++ = tmp2;
         }
-
+        
         free(extrude);
     }
-
+    
+    _customCommand.updateVertexBuffer(triangles, _bufferCount*sizeof(V2F_C4B_T2F), vertex_count*sizeof(V2F_C4B_T2F));
     _bufferCount += vertex_count;
-
+    _customCommand.setVertexDrawInfo(0, _bufferCount);
     _dirty = true;
 }
 
-void DrawNode::drawSolidRect(const Vec2& origin, const Vec2& destination, const Color4F& color)
+void DrawNode::drawSolidRect(const Vec2 &origin, const Vec2 &destination, const Color4F &color)
 {
-    Vec2 vertices[] = {origin, Vec2(destination.x, origin.y), destination, Vec2(origin.x, destination.y)};
-
+    Vec2 vertices[] = {
+        origin,
+        Vec2(destination.x, origin.y),
+        destination,
+        Vec2(origin.x, destination.y)
+    };
+    
     drawSolidPoly(vertices, 4, color);
 }
 
-void DrawNode::drawSolidPoly(const Vec2* poli, unsigned int numberOfPoints, const Color4F& color)
+void DrawNode::drawSolidPoly(const Vec2 *poli, unsigned int numberOfPoints, const Color4F &color)
 {
-    drawPolygon(poli, numberOfPoints, color, 0.0, Color4F(0.0, 0.0, 0.0, 0.0));
+    drawPolygon(poli, numberOfPoints, color, 0.0, Color4F());
 }
 
-void DrawNode::drawSolidCircle(const Vec2& center, float radius, float angle, unsigned int segments, float scaleX, float scaleY, const Color4F& color)
+void DrawNode::drawSolidCircle(const Vec2& center, float radius, float angle, unsigned int segments, float scaleX, float scaleY, const Color4F &color)
 {
-    const float coef = 2.0f * (float)M_PI / segments;
-
-    Vec2* vertices = new (std::nothrow) Vec2[segments];
-    if (!vertices)
+    const float coef = 2.0f * (float)M_PI/segments;
+    
+    Vec2 *vertices = new (std::nothrow) Vec2[segments];
+    if( ! vertices )
         return;
-
-    for (unsigned int i = 0; i < segments; i++)
+    
+    for(unsigned int i = 0;i < segments; i++)
     {
-        float rads = i * coef;
-        GLfloat j = radius * cosf(rads + angle) * scaleX + center.x;
-        GLfloat k = radius * sinf(rads + angle) * scaleY + center.y;
-
+        float rads = i*coef;
+        float j = radius * cosf(rads + angle) * scaleX + center.x;
+        float k = radius * sinf(rads + angle) * scaleY + center.y;
+        
         vertices[i].x = j;
         vertices[i].y = k;
     }
-
+    
     drawSolidPoly(vertices, segments, color);
-
+    
     CC_SAFE_DELETE_ARRAY(vertices);
 }
 
-void DrawNode::drawSolidCircle(const Vec2& center, float radius, float angle, unsigned int segments, const Color4F& color)
+void DrawNode::drawSolidCircle( const Vec2& center, float radius, float angle, unsigned int segments, const Color4F& color)
 {
     drawSolidCircle(center, radius, angle, segments, 1.0f, 1.0f, color);
 }
 
-void DrawNode::drawTriangle(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color4F& color)
+void DrawNode::drawTriangle(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3, const Color4F &color)
 {
     unsigned int vertex_count = 3;
     ensureCapacity(vertex_count);
 
     Color4B col = Color4B(color);
-    V2F_C4B_T2F a = {Vec2(p1.x, p1.y), col, Tex2F(0.0, 0.0)};
-    V2F_C4B_T2F b = {Vec2(p2.x, p2.y), col, Tex2F(0.0, 0.0)};
-    V2F_C4B_T2F c = {Vec2(p3.x, p3.y), col, Tex2F(0.0, 0.0)};
+    V2F_C4B_T2F a = {p1, col, Tex2F(0.0, 0.0) };
+    V2F_C4B_T2F b = {p2, col, Tex2F(0.0,  0.0) };
+    V2F_C4B_T2F c = {p3, col, Tex2F(0.0,  0.0) };
 
-    V2F_C4B_T2F_Triangle* triangles = (V2F_C4B_T2F_Triangle*)(_buffer + _bufferCount);
+    V2F_C4B_T2F_Triangle *triangles = (V2F_C4B_T2F_Triangle *)(_buffer + _bufferCount);
     V2F_C4B_T2F_Triangle triangle = {a, b, c};
     triangles[0] = triangle;
 
+    _customCommand.updateVertexBuffer(triangles, _bufferCount*sizeof(V2F_C4B_T2F), vertex_count*sizeof(V2F_C4B_T2F));
     _bufferCount += vertex_count;
     _dirty = true;
-}
-
-void DrawNode::drawQuadraticBezier(const Vec2& from, const Vec2& control, const Vec2& to, unsigned int segments, const Color4F& color)
-{
-    drawQuadBezier(from, control, to, segments, color);
+    _customCommand.setVertexDrawInfo(0, _bufferCount);
 }
 
 void DrawNode::clear()
@@ -916,7 +728,7 @@ void DrawNode::clear()
     _dirtyGLLine = true;
     _bufferCountGLPoint = 0;
     _dirtyGLPoint = true;
-    _lineWidth = _defaultLineWidth;
+    _lineWidth = 0;
 }
 
 const BlendFunc& DrawNode::getBlendFunc() const
@@ -924,12 +736,12 @@ const BlendFunc& DrawNode::getBlendFunc() const
     return _blendFunc;
 }
 
-void DrawNode::setBlendFunc(const BlendFunc& blendFunc)
+void DrawNode::setBlendFunc(const BlendFunc &blendFunc)
 {
     _blendFunc = blendFunc;
 }
 
-void DrawNode::setLineWidth(int lineWidth)
+void DrawNode::setLineWidth(float lineWidth)
 {
     _lineWidth = lineWidth;
 }
@@ -939,4 +751,17 @@ float DrawNode::getLineWidth()
     return this->_lineWidth;
 }
 
+void DrawNode::visit(Renderer* renderer, const Mat4 &parentTransform, uint32_t parentFlags)
+{
+    if (_isolated)
+    {
+        //ignore `parentTransform` from parent
+        Node::visit(renderer, Mat4::IDENTITY, parentFlags);
+    }
+    else
+    {
+        Node::visit(renderer, parentTransform, parentFlags);
+    }
+}
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCDrawNode.h b/cocos2d/cocos/2d/CCDrawNode.h
index 9c05906326..5222fc1017 100644
--- a/cocos2d/cocos/2d/CCDrawNode.h
+++ b/cocos2d/cocos/2d/CCDrawNode.h
@@ -1,6 +1,7 @@
 /* Copyright (c) 2012 Scott Lembcke and Howling Moon Software
  * Copyright (c) 2012 cocos2d-x.org
  * Copyright (c) 2013-2016 Chukong Technologies Inc.
+ * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -28,13 +29,13 @@
  *
  */
 
-#ifndef CC_2D_DRAWNODE_H
-#define CC_2D_DRAWNODE_H
+#ifndef __CCDRAWNODES_CCDRAW_NODE_H__
+#define __CCDRAWNODES_CCDRAW_NODE_H__
 
 #include <cocos/2d/CCNode.h>
 #include <cocos/base/ccTypes.h>
-#include <cocos/math/CCMath.h>
 #include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/math/CCMath.h>
 
 NS_CC_BEGIN
 
@@ -58,8 +59,8 @@ public:
      *
      * @return Return an autorelease object.
      */
-    static DrawNode* create(int defaultLineWidth = DEFAULT_LINE_WIDTH);
-
+    static DrawNode* create(float defaultLineWidth = DEFAULT_LINE_WIDTH);
+    
     /** Draw a point.
      *
      * @param point A Vec2 used to point.
@@ -67,8 +68,8 @@ public:
      * @param color The point color.
      * @js NA
      */
-    void drawPoint(const Vec2& point, const float pointSize, const Color4F& color);
-
+    void drawPoint(const Vec2& point, const float pointSize, const Color4F &color);
+    
     /** Draw a group point.
      *
      * @param position A Vec2 pointer.
@@ -76,8 +77,8 @@ public:
      * @param color The point color.
      * @js NA
      */
-    void drawPoints(const Vec2* position, unsigned int numberOfPoints, const Color4F& color);
-
+    void drawPoints(const Vec2 *position, unsigned int numberOfPoints, const Color4F &color);
+    
     /** Draw a group point.
      *
      * @param position A Vec2 pointer.
@@ -86,17 +87,17 @@ public:
      * @param color The point color.
      * @js NA
      */
-    void drawPoints(const Vec2* position, unsigned int numberOfPoints, const float pointSize, const Color4F& color);
-
-    /** Draw an line from origin to destination with color.
-     *
+    void drawPoints(const Vec2 *position, unsigned int numberOfPoints, const float pointSize, const Color4F &color);
+    
+    /** Draw an line from origin to destination with color. 
+     * 
      * @param origin The line origin.
      * @param destination The line destination.
      * @param color The line color.
      * @js NA
      */
-    void drawLine(const Vec2& origin, const Vec2& destination, const Color4F& color);
-
+    void drawLine(const Vec2 &origin, const Vec2 &destination, const Color4F &color);
+    
     /** Draws a rectangle given the origin and destination point measured in points.
      * The origin and the destination can not have the same x and y coordinate.
      *
@@ -104,8 +105,8 @@ public:
      * @param destination The rectangle destination.
      * @param color The rectangle color.
      */
-    void drawRect(const Vec2& origin, const Vec2& destination, const Color4F& color);
-
+    void drawRect(const Vec2 &origin, const Vec2 &destination, const Color4F &color);
+    
     /** Draws a polygon given a pointer to point coordinates and the number of vertices measured in points.
      * The polygon can be closed or open.
      *
@@ -114,8 +115,8 @@ public:
      * @param closePolygon The polygon can be closed or open.
      * @param color The polygon color.
      */
-    void drawPoly(const Vec2* poli, unsigned int numberOfPoints, bool closePolygon, const Color4F& color);
-
+    void drawPoly(const Vec2 *poli, unsigned int numberOfPoints, bool closePolygon, const Color4F &color);
+    
     /** Draws a circle given the center, radius and number of segments.
      *
      * @param center The circle center point.
@@ -127,8 +128,8 @@ public:
      * @param scaleY The scale value in y.
      * @param color Set the circle color.
      */
-    void drawCircle(const Vec2& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, float scaleX, float scaleY, const Color4F& color);
-
+    void drawCircle( const Vec2& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, float scaleX, float scaleY, const Color4F &color);
+    
     /** Draws a circle given the center, radius and number of segments.
      *
      * @param center The circle center point.
@@ -138,8 +139,8 @@ public:
      * @param drawLineToCenter Whether or not draw the line from the origin to center.
      * @param color Set the circle color.
      */
-    void drawCircle(const Vec2& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, const Color4F& color);
-
+    void drawCircle(const Vec2 &center, float radius, float angle, unsigned int segments, bool drawLineToCenter, const Color4F &color);
+    
     /** Draws a quad bezier path.
      *
      * @param origin The origin of the bezier path.
@@ -148,7 +149,7 @@ public:
      * @param segments The number of segments.
      * @param color Set the quad bezier color.
      */
-    void drawQuadBezier(const Vec2& origin, const Vec2& control, const Vec2& destination, unsigned int segments, const Color4F& color);
+    void drawQuadBezier(const Vec2 &origin, const Vec2 &control, const Vec2 &destination, unsigned int segments, const Color4F &color);
 
     /** Draw a cubic bezier curve with color and number of segments
      *
@@ -159,8 +160,8 @@ public:
      * @param segments The number of segments.
      * @param color Set the cubic bezier color.
      */
-    void drawCubicBezier(const Vec2& origin, const Vec2& control1, const Vec2& control2, const Vec2& destination, unsigned int segments, const Color4F& color);
-
+    void drawCubicBezier(const Vec2 &origin, const Vec2 &control1, const Vec2 &control2, const Vec2 &destination, unsigned int segments, const Color4F &color);
+    
     /** Draws a Cardinal Spline path.
      *
      * @param config A array point.
@@ -168,24 +169,24 @@ public:
      * @param segments The number of segments.
      * @param color Set the Spline color.
      */
-    void drawCardinalSpline(PointArray* config, float tension, unsigned int segments, const Color4F& color);
-
+    void drawCardinalSpline(PointArray *config, float tension,  unsigned int segments, const Color4F &color);
+    
     /** Draws a Catmull Rom path.
      *
      * @param points A point array  of control point.
      * @param segments The number of segments.
      * @param color The Catmull Rom color.
      */
-    void drawCatmullRom(PointArray* points, unsigned int segments, const Color4F& color);
-
-    /** draw a dot at a position, with a given radius and color.
+    void drawCatmullRom(PointArray *points, unsigned int segments, const Color4F &color);
+    
+    /** draw a dot at a position, with a given radius and color. 
      *
      * @param pos The dot center.
      * @param radius The dot radius.
      * @param color The dot color.
      */
-    void drawDot(const Vec2& pos, float radius, const Color4F& color);
-
+    void drawDot(const Vec2 &pos, float radius, const Color4F &color);
+    
     /** Draws a rectangle with 4 points.
      *
      * @param p1 The rectangle vertex point.
@@ -194,8 +195,8 @@ public:
      * @param p4 The rectangle vertex point.
      * @param color The rectangle color.
      */
-    void drawRect(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color4F& color);
-
+    void drawRect(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3, const Vec2& p4, const Color4F &color);
+    
     /** Draws a solid rectangle given the origin and destination point measured in points.
      * The origin and the destination can not have the same x and y coordinate.
      *
@@ -204,8 +205,8 @@ public:
      * @param color The rectangle color.
      * @js NA
      */
-    void drawSolidRect(const Vec2& origin, const Vec2& destination, const Color4F& color);
-
+    void drawSolidRect(const Vec2 &origin, const Vec2 &destination, const Color4F &color);
+    
     /** Draws a solid polygon given a pointer to CGPoint coordinates, the number of vertices measured in points, and a color.
      *
      * @param poli A solid polygon given a pointer to CGPoint coordinates.
@@ -213,8 +214,8 @@ public:
      * @param color The solid polygon color.
      * @js NA
      */
-    void drawSolidPoly(const Vec2* poli, unsigned int numberOfPoints, const Color4F& color);
-
+    void drawSolidPoly(const Vec2 *poli, unsigned int numberOfPoints, const Color4F &color);
+    
     /** Draws a solid circle given the center, radius and number of segments.
      * @param center The circle center point.
      * @param radius The circle rotate of radius.
@@ -225,8 +226,8 @@ public:
      * @param color The solid circle color.
      * @js NA
      */
-    void drawSolidCircle(const Vec2& center, float radius, float angle, unsigned int segments, float scaleX, float scaleY, const Color4F& color);
-
+    void drawSolidCircle(const Vec2& center, float radius, float angle, unsigned int segments, float scaleX, float scaleY, const Color4F &color);
+    
     /** Draws a solid circle given the center, radius and number of segments.
      * @param center The circle center point.
      * @param radius The circle rotate of radius.
@@ -236,32 +237,32 @@ public:
      * @js NA
      */
     void drawSolidCircle(const Vec2& center, float radius, float angle, unsigned int segments, const Color4F& color);
-
-    /** draw a segment with a radius and color.
+    
+    /** draw a segment with a radius and color. 
      *
      * @param from The segment origin.
      * @param to The segment destination.
      * @param radius The segment radius.
      * @param color The segment color.
      */
-    void drawSegment(const Vec2& from, const Vec2& to, float radius, const Color4F& color);
-
+    void drawSegment(const Vec2 &from, const Vec2 &to, float radius, const Color4F &color);
+    
     /** draw a polygon with a fill color and line color
-     * @code
-     * When this function bound into js or lua,the parameter will be changed
-     * In js: var drawPolygon(var Arrayofpoints, var fillColor, var width, var borderColor)
-     * In lua:local drawPolygon(local pointTable,local tableCount,local fillColor,local width,local borderColor)
-     * @endcode
-     * @param verts A pointer to point coordinates.
-     * @param count The number of verts measured in points.
-     * @param fillColor The color will fill in polygon.
-     * @param borderWidth The border of line width.
-     * @param borderColor The border of line color.
-     * @js NA
-     */
-    void drawPolygon(const Vec2* verts, int count, const Color4F& fillColor, float borderWidth, const Color4F& borderColor);
-
-    /** draw a triangle with color.
+    * @code
+    * When this function bound into js or lua,the parameter will be changed
+    * In js: var drawPolygon(var Arrayofpoints, var fillColor, var width, var borderColor)
+    * In lua:local drawPolygon(local pointTable,local tableCount,local fillColor,local width,local borderColor)
+    * @endcode
+    * @param verts A pointer to point coordinates.
+    * @param count The number of verts measured in points.
+    * @param fillColor The color will fill in polygon.
+    * @param borderWidth The border of line width.
+    * @param borderColor The border of line color.
+    * @js NA
+    */
+    void drawPolygon(const Vec2 *verts, int count, const Color4F &fillColor, float borderWidth, const Color4F &borderColor);
+	
+    /** draw a triangle with color. 
      *
      * @param p1 The triangle vertex point.
      * @param p2 The triangle vertex point.
@@ -269,102 +270,90 @@ public:
      * @param color The triangle color.
      * @js NA
      */
-    void drawTriangle(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color4F& color);
-
-    /** draw a quadratic bezier curve with color and number of segments, use drawQuadBezier instead.
-     *
-     * @param from The origin of the bezier path.
-     * @param control The control of the bezier path.
-     * @param to The destination of the bezier path.
-     * @param segments The number of segments.
-     * @param color The quadratic bezier color.
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE void drawQuadraticBezier(const Vec2& from, const Vec2& control, const Vec2& to, unsigned int segments, const Color4F& color);
+    void drawTriangle(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3, const Color4F &color);
 
     /** Clear the geometry in the node's buffer. */
     void clear();
     /** Get the color mixed mode.
-     * @lua NA
-     */
+    * @lua NA
+    */
     const BlendFunc& getBlendFunc() const;
     /** Set the color mixed mode.
-     * @code
-     * When this function bound into js or lua,the parameter will be changed
-     * In js: var setBlendFunc(var src, var dst)
-     * @endcode
-     * @lua NA
-     */
-    void setBlendFunc(const BlendFunc& blendFunc);
-
-    /**
-     * @js NA
-     */
-    virtual void onDraw(const Mat4& transform, uint32_t flags);
-    /**
-     * @js NA
-     */
-    virtual void onDrawGLLine(const Mat4& transform, uint32_t flags);
-    /**
-     * @js NA
-     */
-    virtual void onDrawGLPoint(const Mat4& transform, uint32_t flags);
-
+    * @code
+    * When this function bound into js or lua,the parameter will be changed
+    * In js: var setBlendFunc(var src, var dst)
+    * @endcode
+    * @lua NA
+    */
+    void setBlendFunc(const BlendFunc &blendFunc);
+    
     // Overrides
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
-    void setLineWidth(int lineWidth);
+    virtual void visit(Renderer* renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
+    
+    void setLineWidth(float lineWidth);
 
     // Get CocosStudio guide lines width.
     float getLineWidth();
 
-    CC_CONSTRUCTOR_ACCESS : DrawNode(int lineWidth = DEFAULT_LINE_WIDTH);
-    ~DrawNode() override;
-    bool init() override;
+    /**
+    * When isolated is set, the position of the node is no longer affected by parent nodes.
+    * Which means it will be drawn just like a root node.
+    */
+    void setIsolated(bool isolated) { _isolated = isolated; }
+
+    bool isIsolated() const { return _isolated; }
+
+CC_CONSTRUCTOR_ACCESS:
+    DrawNode(float lineWidth = DEFAULT_LINE_WIDTH);
+    virtual ~DrawNode();
+    virtual bool init() override;
 
 protected:
     void ensureCapacity(int count);
     void ensureCapacityGLPoint(int count);
     void ensureCapacityGLLine(int count);
 
-    GLuint _vao;
-    GLuint _vbo;
-    GLuint _vaoGLPoint;
-    GLuint _vboGLPoint;
-    GLuint _vaoGLLine;
-    GLuint _vboGLLine;
-
-    int _bufferCapacity;
-    GLsizei _bufferCount;
-    V2F_C4B_T2F* _buffer;
-
-    int _bufferCapacityGLPoint;
-    GLsizei _bufferCountGLPoint;
-    V2F_C4B_T2F* _bufferGLPoint;
-    Color4F _pointColor;
-    int _pointSize;
-
-    int _bufferCapacityGLLine;
-    GLsizei _bufferCountGLLine;
-    V2F_C4B_T2F* _bufferGLLine;
-
-    BlendFunc _blendFunc;
+    void updateShader();
+    void setVertexLayout(CustomCommand& cmd);
+    void updateBlendState(CustomCommand& cmd);
+    void updateUniforms(const Mat4 &transform, CustomCommand& cmd);
+
+    int         _bufferCapacity = 0;
+    int         _bufferCount = 0;
+    V2F_C4B_T2F *_buffer = nullptr;
+    
+    int         _bufferCapacityGLPoint = 0;
+    int         _bufferCountGLPoint = 0;
+    V2F_C4B_T2F *_bufferGLPoint = nullptr;
+    Color4F     _pointColor;
+    int         _pointSize = 0;
+    
+    int         _bufferCapacityGLLine = 0;
+    int         _bufferCountGLLine = 0;
+    V2F_C4B_T2F *_bufferGLLine = nullptr;
+
+    BlendFunc   _blendFunc;
+    
+    backend::ProgramState* _programState = nullptr;
+    backend::ProgramState* _programStatePoint = nullptr;
+    backend::ProgramState* _programStateLine = nullptr;
+    
     CustomCommand _customCommand;
     CustomCommand _customCommandGLPoint;
     CustomCommand _customCommandGLLine;
 
-    bool _dirty;
-    bool _dirtyGLPoint;
-    bool _dirtyGLLine;
-
-    int _lineWidth;
-
-    int _defaultLineWidth;
-
+    bool        _dirty = false;
+    bool        _dirtyGLPoint = false;
+    bool        _dirtyGLLine = false;
+    bool        _isolated = false;
+    float       _lineWidth = 0.0f;
+    
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(DrawNode)
+    CC_DISALLOW_COPY_AND_ASSIGN(DrawNode);
 };
 /** @} */
 NS_CC_END
 
-#endif // CC_2D_DRAWNODE_H
+#endif // __CCDRAWNODES_CCDRAW_NODE_H__
diff --git a/cocos2d/cocos/2d/CCFastTMXLayer.cpp b/cocos2d/cocos/2d/CCFastTMXLayer.cpp
index 60ae6b475b..bb4676c615 100644
--- a/cocos2d/cocos/2d/CCFastTMXLayer.cpp
+++ b/cocos2d/cocos/2d/CCFastTMXLayer.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 Copyright (c) 2011 HKASoftware
 
@@ -35,844 +36,886 @@ THE SOFTWARE.
 
  */
 #include <cocos/2d/CCFastTMXLayer.h>
-
-#include <cocos/2d/CCCamera.h>
 #include <cocos/2d/CCFastTMXTiledMap.h>
 #include <cocos/2d/CCSprite.h>
+#include <cocos/2d/CCCamera.h>
+#include <cocos/renderer/CCTextureCache.h>
+#include <cocos/renderer/CCRenderer.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/Device.h>
+#include <cocos/renderer/backend/Buffer.h>
 #include <cocos/base/CCDirector.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramCache.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCPrimitive.h>
-#include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTextureCache.h>
-#include <cocos/renderer/CCVertexIndexBuffer.h>
-#include <cocos/renderer/CCVertexIndexData.h>
-#include <cocos/renderer/ccGLStateCache.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
-namespace experimental
-{
-    const int TMXLayer::FAST_TMX_ORIENTATION_ORTHO = 0;
-    const int TMXLayer::FAST_TMX_ORIENTATION_HEX = 1;
-    const int TMXLayer::FAST_TMX_ORIENTATION_ISO = 2;
+namespace experimental {
 
-    // FastTMXLayer - init & alloc & dealloc
-    TMXLayer* TMXLayer::create(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
-    {
-        TMXLayer* ret = new (std::nothrow) TMXLayer();
-        if (ret->initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo))
-        {
-            ret->autorelease();
-            return ret;
-        }
-        CC_SAFE_DELETE(ret);
-        return nullptr;
-    }
-
-    bool TMXLayer::initWithTilesetInfo(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
-    {
-        if (tilesetInfo)
-        {
-            _texture = Director::getInstance()->getTextureCache()->addImage(tilesetInfo->_sourceImage);
-            _texture->retain();
-        }
+const int TMXLayer::FAST_TMX_ORIENTATION_ORTHO = 0;
+const int TMXLayer::FAST_TMX_ORIENTATION_HEX = 1;
+const int TMXLayer::FAST_TMX_ORIENTATION_ISO = 2;
 
-        // layerInfo
-        _layerName = layerInfo->_name;
-        _layerSize = layerInfo->_layerSize;
-        _tiles = layerInfo->_tiles;
-        _quadsDirty = true;
-        setOpacity(layerInfo->_opacity);
-        setProperties(layerInfo->getProperties());
-
-        // tilesetInfo
-        _tileSet = tilesetInfo;
-        CC_SAFE_RETAIN(_tileSet);
-
-        // mapInfo
-        _mapTileSize = mapInfo->getTileSize();
-        _layerOrientation = mapInfo->getOrientation();
-
-        // offset (after layer orientation is set);
-        Vec2 offset = this->calculateLayerOffset(layerInfo->_offset);
-        this->setPosition(CC_POINT_PIXELS_TO_POINTS(offset));
-
-        this->setContentSize(CC_SIZE_PIXELS_TO_POINTS(Size(_layerSize.width * _mapTileSize.width, _layerSize.height * _mapTileSize.height)));
-
-        this->tileToNodeTransform();
-
-        // shader, and other stuff
-        setGLProgram(GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR));
-
-        _useAutomaticVertexZ = false;
-        _vertexZvalue = 0;
-
-        return true;
-    }
-
-    TMXLayer::TMXLayer()
-    : _layerName("")
-    , _layerSize(Size::ZERO)
-    , _mapTileSize(Size::ZERO)
-    , _tiles(nullptr)
-    , _tileSet(nullptr)
-    , _layerOrientation(FAST_TMX_ORIENTATION_ORTHO)
-    , _texture(nullptr)
-    , _vertexZvalue(0)
-    , _useAutomaticVertexZ(false)
-    , _quadsDirty(true)
-    , _dirty(true)
-    , _vertexBuffer(nullptr)
-    , _vData(nullptr)
-    , _indexBuffer(nullptr)
+// FastTMXLayer - init & alloc & dealloc
+TMXLayer * TMXLayer::create(TMXTilesetInfo *tilesetInfo, TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo)
+{
+    TMXLayer *ret = new (std::nothrow) TMXLayer();
+    if (ret->initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo))
     {
+        ret->autorelease();
+        return ret;
     }
+    CC_SAFE_DELETE(ret);
+    return nullptr;
+}
 
-    TMXLayer::~TMXLayer()
-    {
-        CC_SAFE_RELEASE(_tileSet);
-        CC_SAFE_RELEASE(_texture);
-        CC_SAFE_FREE(_tiles);
-        CC_SAFE_RELEASE(_vData);
-        CC_SAFE_RELEASE(_vertexBuffer);
-        CC_SAFE_RELEASE(_indexBuffer);
-    }
+bool TMXLayer::initWithTilesetInfo(TMXTilesetInfo *tilesetInfo, TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo)
+{    
 
-    void TMXLayer::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+    if( tilesetInfo )
     {
-        updateTotalQuads();
+        _texture = Director::getInstance()->getTextureCache()->addImage(tilesetInfo->_sourceImage);
+        _texture->retain();
+    }
 
-        bool isViewProjectionUpdated = true;
-        auto visitingCamera = Camera::getVisitingCamera();
-        auto defaultCamera = Camera::getDefaultCamera();
-        if (visitingCamera == defaultCamera)
-        {
-            isViewProjectionUpdated = visitingCamera->isViewProjectionUpdated();
-        }
+    // layerInfo
+    _layerName = layerInfo->_name;
+    _layerSize = layerInfo->_layerSize;
+    _tiles = layerInfo->_tiles;
+    _quadsDirty = true;
+    setOpacity( layerInfo->_opacity );
+    setProperties(layerInfo->getProperties());
 
-        if (flags != 0 || _dirty || _quadsDirty || isViewProjectionUpdated)
-        {
-            Size s = Director::getInstance()->getVisibleSize();
-            auto rect = Rect(Camera::getVisitingCamera()->getPositionX() - s.width * 0.5f, Camera::getVisitingCamera()->getPositionY() - s.height * 0.5f,
-                             s.width, s.height);
-
-            Mat4 inv = transform;
-            inv.inverse();
-            rect = RectApplyTransform(rect, inv);
-
-            updateTiles(rect);
-            updateIndexBuffer();
-            updatePrimitives();
-            _dirty = false;
-        }
+    // tilesetInfo
+    _tileSet = tilesetInfo;
+    CC_SAFE_RETAIN(_tileSet);
 
-        if (_renderCommands.size() < static_cast<size_t>(_primitives.size()))
-        {
-            _renderCommands.resize(_primitives.size());
-        }
+    // mapInfo
+    _mapTileSize = mapInfo->getTileSize();
+    _layerOrientation = mapInfo->getOrientation();
 
-        int index = 0;
-        for (const auto& iter : _primitives)
-        {
-            if (iter.second->getCount() > 0)
-            {
-                auto& cmd = _renderCommands[index++];
-                auto blendfunc = _texture->hasPremultipliedAlpha() ? BlendFunc::ALPHA_PREMULTIPLIED : BlendFunc::ALPHA_NON_PREMULTIPLIED;
-                cmd.init(iter.first, _texture->getName(), getGLProgramState(), blendfunc, iter.second, _modelViewTransform, flags);
-                renderer->addCommand(&cmd);
-            }
-        }
-    }
+    // offset (after layer orientation is set);
+    Vec2 offset = this->calculateLayerOffset(layerInfo->_offset);
+    this->setPosition(CC_POINT_PIXELS_TO_POINTS(offset));
 
-    void TMXLayer::onDraw(Primitive* primitive)
-    {
-        GL::bindTexture2D(_texture->getName());
-        getGLProgramState()->apply(_modelViewTransform);
+    this->setContentSize(CC_SIZE_PIXELS_TO_POINTS(Size(_layerSize.width * _mapTileSize.width, _layerSize.height * _mapTileSize.height)));
+    
+    this->tileToNodeTransform();
 
-        GL::bindVAO(0);
-        primitive->draw();
-        glBindBuffer(GL_ARRAY_BUFFER, 0);
-        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-        CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, primitive->getCount() * 4);
-    }
+    _useAutomaticVertexZ = false;
+    _vertexZvalue = 0;
 
-    void TMXLayer::updateTiles(const Rect& culledRect)
-    {
-        Rect visibleTiles = culledRect;
-        Size mapTileSize = CC_SIZE_PIXELS_TO_POINTS(_mapTileSize);
-        Size tileSize = CC_SIZE_PIXELS_TO_POINTS(_tileSet->_tileSize);
-        Mat4 nodeToTileTransform = _tileToNodeTransform.getInversed();
-        // transform to tile
-        visibleTiles = RectApplyTransform(visibleTiles, nodeToTileTransform);
-        // tile coordinate is upside-down, so we need to make the tile coordinate use top-left for the start point.
-        visibleTiles.origin.y += 1;
-
-        // if x=0.7, width=9.5, we need to draw number 0~10 of tiles, and so is height.
-        visibleTiles.size.width = ceil(visibleTiles.origin.x + visibleTiles.size.width) - floor(visibleTiles.origin.x);
-        visibleTiles.size.height = ceil(visibleTiles.origin.y + visibleTiles.size.height) - floor(visibleTiles.origin.y);
-        visibleTiles.origin.x = floor(visibleTiles.origin.x);
-        visibleTiles.origin.y = floor(visibleTiles.origin.y);
-
-        // for the bigger tiles.
-        int tilesOverX = 0;
-        int tilesOverY = 0;
-        // for diagonal orientation tiles
-        float tileSizeMax = std::max(tileSize.width, tileSize.height);
-        if (_layerOrientation == FAST_TMX_ORIENTATION_ORTHO)
-        {
-            tilesOverX = ceil(tileSizeMax / mapTileSize.width) - 1;
-            tilesOverY = ceil(tileSizeMax / mapTileSize.height) - 1;
+    return true;
+}
 
-            if (tilesOverX < 0)
-                tilesOverX = 0;
-            if (tilesOverY < 0)
-                tilesOverY = 0;
-        }
-        else if (_layerOrientation == FAST_TMX_ORIENTATION_ISO)
-        {
-            Rect overTileRect(0, 0, tileSizeMax - mapTileSize.width, tileSizeMax - mapTileSize.height);
-            if (overTileRect.size.width < 0)
-                overTileRect.size.width = 0;
-            if (overTileRect.size.height < 0)
-                overTileRect.size.height = 0;
-            overTileRect = RectApplyTransform(overTileRect, nodeToTileTransform);
-
-            tilesOverX = ceil(overTileRect.origin.x + overTileRect.size.width) - floor(overTileRect.origin.x);
-            tilesOverY = ceil(overTileRect.origin.y + overTileRect.size.height) - floor(overTileRect.origin.y);
-        }
-        else
-        {
-            // do nothing, do not support
-            // CCASSERT(0, "TMX invalid value");
-        }
+TMXLayer::TMXLayer()
+{
+}
 
-        _indicesVertexZNumber.clear();
+TMXLayer::~TMXLayer()
+{
+    CC_SAFE_RELEASE(_tileSet);
+    CC_SAFE_RELEASE(_texture);
+    CC_SAFE_DELETE_ARRAY(_tiles);;
+    CC_SAFE_RELEASE(_vertexBuffer);
+    CC_SAFE_RELEASE(_indexBuffer);
 
-        for (const auto& iter : _indicesVertexZOffsets)
-        {
-            _indicesVertexZNumber[iter.first] = iter.second;
-        }
+    for (auto& e : _customCommands)
+    {
+        CC_SAFE_RELEASE(e.second->getPipelineDescriptor().programState);
+        delete e.second;
+    }
+}
 
-        int yBegin = std::max(0.f, visibleTiles.origin.y - tilesOverY);
-        int yEnd = std::min(_layerSize.height, visibleTiles.origin.y + visibleTiles.size.height + tilesOverY);
-        int xBegin = std::max(0.f, visibleTiles.origin.x - tilesOverX);
-        int xEnd = std::min(_layerSize.width, visibleTiles.origin.x + visibleTiles.size.width + tilesOverX);
+void TMXLayer::draw(Renderer *renderer, const Mat4& transform, uint32_t flags)
+{
+    updateTotalQuads();
 
-        for (int y = yBegin; y < yEnd; ++y)
-        {
-            for (int x = xBegin; x < xEnd; ++x)
-            {
-                int tileIndex = getTileIndexByPos(x, y);
-                if (_tiles[tileIndex] == 0)
-                    continue;
-
-                int vertexZ = getVertexZForPos(Vec2(x, y));
-                auto iter = _indicesVertexZNumber.find(vertexZ);
-                int offset = iter->second;
-                iter->second++;
-
-                int quadIndex = _tileToQuadIndex[tileIndex];
-                CC_ASSERT(-1 != quadIndex);
-                _indices[6 * offset + 0] = quadIndex * 4 + 0;
-                _indices[6 * offset + 1] = quadIndex * 4 + 1;
-                _indices[6 * offset + 2] = quadIndex * 4 + 2;
-                _indices[6 * offset + 3] = quadIndex * 4 + 3;
-                _indices[6 * offset + 4] = quadIndex * 4 + 2;
-                _indices[6 * offset + 5] = quadIndex * 4 + 1;
-
-            } // for x
-        } // for y
-
-        for (const auto& iter : _indicesVertexZOffsets)
-        {
-            _indicesVertexZNumber[iter.first] -= iter.second;
-            if (_indicesVertexZNumber[iter.first] == 0)
-            {
-                _indicesVertexZNumber.erase(iter.first);
-            }
-        }
+    bool isViewProjectionUpdated = true;
+    auto visitingCamera = Camera::getVisitingCamera();
+    auto defaultCamera = Camera::getDefaultCamera();
+    if (visitingCamera == defaultCamera) {
+        isViewProjectionUpdated = visitingCamera->isViewProjectionUpdated();
+    }
+    
+    if( flags != 0 || _dirty || _quadsDirty || isViewProjectionUpdated)
+    {
+        Size s = Director::getInstance()->getVisibleSize();
+        const Vec2 &anchor = getAnchorPoint();
+        auto rect = Rect(Camera::getVisitingCamera()->getPositionX() - s.width * (anchor.x == 0.0f ? 0.5f : anchor.x),
+                         Camera::getVisitingCamera()->getPositionY() - s.height * (anchor.y == 0.0f ? 0.5f : anchor.y),
+                     s.width,
+                     s.height);
+
+        
+        Mat4 inv = transform;
+        inv.inverse();
+        rect = RectApplyTransform(rect, inv);
+        
+        updateTiles(rect);
+        updateIndexBuffer();
+        updatePrimitives();
+        _dirty = false;
     }
 
-    void TMXLayer::updateVertexBuffer()
+    const auto& projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    Mat4 finalMat = projectionMat * _modelViewTransform;
+    for (const auto& e : _customCommands)
     {
-        GL::bindVAO(0);
-        if (nullptr == _vData)
-        {
-            _vertexBuffer = VertexBuffer::create(sizeof(V3F_C4B_T2F), (int)_totalQuads.size() * 4);
-            _vData = VertexData::create();
-            _vData->setStream(_vertexBuffer, VertexStreamAttribute(0, GLProgram::VERTEX_ATTRIB_POSITION, GL_FLOAT, 3));
-            _vData->setStream(_vertexBuffer, VertexStreamAttribute(offsetof(V3F_C4B_T2F, colors), GLProgram::VERTEX_ATTRIB_COLOR, GL_UNSIGNED_BYTE, 4, true));
-            _vData->setStream(_vertexBuffer, VertexStreamAttribute(offsetof(V3F_C4B_T2F, texCoords), GLProgram::VERTEX_ATTRIB_TEX_COORD, GL_FLOAT, 2));
-            CC_SAFE_RETAIN(_vData);
-            CC_SAFE_RETAIN(_vertexBuffer);
-        }
-        if (_vertexBuffer)
+        if (e.second->getIndexDrawCount() > 0)
         {
-            _vertexBuffer->updateVertices((void*)&_totalQuads[0], (int)_totalQuads.size() * 4, 0);
+            auto mvpmatrixLocation = e.second->getPipelineDescriptor().programState->getUniformLocation("u_MVPMatrix");
+            e.second->getPipelineDescriptor().programState->setUniform(mvpmatrixLocation, finalMat.m, sizeof(finalMat.m));
+            renderer->addCommand(e.second);
         }
     }
+}
 
-    void TMXLayer::updateIndexBuffer()
+void TMXLayer::updateTiles(const Rect& culledRect)
+{
+    Rect visibleTiles = Rect(culledRect.origin, culledRect.size * Director::getInstance()->getContentScaleFactor());
+    Size mapTileSize = CC_SIZE_PIXELS_TO_POINTS(_mapTileSize);
+    Size tileSize = CC_SIZE_PIXELS_TO_POINTS(_tileSet->_tileSize);
+    Mat4 nodeToTileTransform = _tileToNodeTransform.getInversed();
+    //transform to tile
+    visibleTiles = RectApplyTransform(visibleTiles, nodeToTileTransform);
+    // tile coordinate is upside-down, so we need to make the tile coordinate use top-left for the start point.
+    visibleTiles.origin.y += 1;
+    
+    // if x=0.7, width=9.5, we need to draw number 0~10 of tiles, and so is height.
+    visibleTiles.size.width = ceil(visibleTiles.origin.x + visibleTiles.size.width)  - floor(visibleTiles.origin.x);
+    visibleTiles.size.height = ceil(visibleTiles.origin.y + visibleTiles.size.height) - floor(visibleTiles.origin.y);
+    visibleTiles.origin.x = floor(visibleTiles.origin.x);
+    visibleTiles.origin.y = floor(visibleTiles.origin.y);
+
+    // for the bigger tiles.
+    int tilesOverX = 0;
+    int tilesOverY = 0;
+    // for diagonal orientation tiles
+    float tileSizeMax = std::max(tileSize.width, tileSize.height);
+    if (_layerOrientation == FAST_TMX_ORIENTATION_ORTHO)
+    {
+        tilesOverX = (int)ceil(tileSizeMax / mapTileSize.width) - 1;
+        tilesOverY = (int)ceil(tileSizeMax / mapTileSize.height) - 1;
+        
+        if (tilesOverX < 0) tilesOverX = 0;
+        if (tilesOverY < 0) tilesOverY = 0;
+    }
+    else if(_layerOrientation == FAST_TMX_ORIENTATION_ISO)
+    {
+        Rect overTileRect(0, 0, tileSizeMax - mapTileSize.width, tileSizeMax - mapTileSize.height);
+        if (overTileRect.size.width < 0) overTileRect.size.width = 0;
+        if (overTileRect.size.height < 0) overTileRect.size.height = 0;
+        overTileRect = RectApplyTransform(overTileRect, nodeToTileTransform);
+        
+        tilesOverX = (int)(ceil(overTileRect.origin.x + overTileRect.size.width) - floor(overTileRect.origin.x));
+        tilesOverY = (int)(ceil(overTileRect.origin.y + overTileRect.size.height) - floor(overTileRect.origin.y));
+    }
+    else
     {
-        if (nullptr == _indexBuffer)
+        //do nothing, do not support
+        //CCASSERT(0, "TMX invalid value");
+    }
+    
+    _indicesVertexZNumber.clear();
+    
+    for(const auto& iter : _indicesVertexZOffsets)
+    {
+        _indicesVertexZNumber[iter.first] = iter.second;
+    }
+    
+    int yBegin = static_cast<int>(std::max(0.f,visibleTiles.origin.y - tilesOverY));
+    int yEnd = static_cast<int>(std::min(_layerSize.height,visibleTiles.origin.y + visibleTiles.size.height + tilesOverY));
+    int xBegin = static_cast<int>(std::max(0.f,visibleTiles.origin.x - tilesOverX));
+    int xEnd = static_cast<int>(std::min(_layerSize.width,visibleTiles.origin.x + visibleTiles.size.width + tilesOverX));
+    
+    for (int y =  yBegin; y < yEnd; ++y)
+    {
+        for (int x = xBegin; x < xEnd; ++x)
+        {
+            int tileIndex = getTileIndexByPos(x, y);
+            if(_tiles[tileIndex] == 0) continue;
+            
+            int vertexZ = getVertexZForPos(Vec2((float)x,(float)y));
+            auto iter = _indicesVertexZNumber.find(vertexZ);
+            int offset = iter->second;
+            iter->second++;
+            
+            unsigned short quadIndex = static_cast<unsigned short>(_tileToQuadIndex[tileIndex]);
+            CC_ASSERT(-1 != quadIndex);
+            _indices[6 * offset + 0] = quadIndex * 4 + 0;
+            _indices[6 * offset + 1] = quadIndex * 4 + 1;
+            _indices[6 * offset + 2] = quadIndex * 4 + 2;
+            _indices[6 * offset + 3] = quadIndex * 4 + 3;
+            _indices[6 * offset + 4] = quadIndex * 4 + 2;
+            _indices[6 * offset + 5] = quadIndex * 4 + 1;
+            
+        } // for x
+    } // for y
+    
+    for(const auto& iter : _indicesVertexZOffsets)
+    {
+        _indicesVertexZNumber[iter.first] -= iter.second;
+        if(_indicesVertexZNumber[iter.first] == 0)
         {
-            _indexBuffer = IndexBuffer::create(IndexBuffer::IndexType::INDEX_TYPE_SHORT_16, (int)_indices.size());
-            CC_SAFE_RETAIN(_indexBuffer);
+            _indicesVertexZNumber.erase(iter.first);
         }
-        _indexBuffer->updateIndices(&_indices[0], (int)_indices.size(), 0);
     }
+    
+}
 
-    // FastTMXLayer - setup Tiles
-    void TMXLayer::setupTiles()
+void TMXLayer::updateVertexBuffer()
+{
+    unsigned int vertexBufferSize = (unsigned int)(sizeof(V3F_C4B_T2F) * _totalQuads.size() * 4);
+    if (!_vertexBuffer)
     {
-        // Optimization: quick hack that sets the image size on the tileset
-        _tileSet->_imageSize = _texture->getContentSizeInPixels();
+        auto device = backend::Device::getInstance();
+        _vertexBuffer = device->newBuffer(vertexBufferSize, backend::BufferType::VERTEX, backend::BufferUsage::STATIC);
+    }
+    _vertexBuffer->updateData(&_totalQuads[0], vertexBufferSize);
+}
 
-        // By default all the tiles are aliased
-        // pros: easier to render
-        // cons: difficult to scale / rotate / etc.
-        _texture->setAliasTexParameters();
+void TMXLayer::updateIndexBuffer()
+{
+#ifdef CC_FAST_TILEMAP_32_BIT_INDICES
+    unsigned int indexBufferSize = (unsigned int)(sizeof(unsigned int) * _indices.size());
+#else
+    unsigned int indexBufferSize = (unsigned int)(sizeof(unsigned short) * _indices.size());
+#endif
+    if (!_indexBuffer)
+    {
+        auto device = backend::Device::getInstance();
+        _indexBuffer = device->newBuffer(indexBufferSize, backend::BufferType::INDEX, backend::BufferUsage::STATIC);
+    }
+    _indexBuffer->updateData(&_indices[0], indexBufferSize);
+}
 
-        // CFByteOrder o = CFByteOrderGetCurrent();
+// FastTMXLayer - setup Tiles
+void TMXLayer::setupTiles()
+{    
+    // Optimization: quick hack that sets the image size on the tileset
+    _tileSet->_imageSize = _texture->getContentSizeInPixels();
 
-        // Parse cocos2d properties
-        this->parseInternalProperties();
+    // By default all the tiles are aliased
+    // pros: easier to render
+    // cons: difficult to scale / rotate / etc.
+    _texture->setAliasTexParameters();
 
-        Size screenSize = Director::getInstance()->getWinSize();
+    //CFByteOrder o = CFByteOrderGetCurrent();
 
-        switch (_layerOrientation)
-        {
-            case FAST_TMX_ORIENTATION_ORTHO:
-                _screenGridSize.width = ceil(screenSize.width / _mapTileSize.width) + 1;
-                _screenGridSize.height = ceil(screenSize.height / _mapTileSize.height) + 1;
+    // Parse cocos2d properties
+    this->parseInternalProperties();
 
-                // tiles could be bigger than the grid, add additional rows if needed
-                _screenGridSize.height += _tileSet->_tileSize.height / _mapTileSize.height;
-                break;
-            case FAST_TMX_ORIENTATION_ISO:
-                _screenGridSize.width = ceil(screenSize.width / _mapTileSize.width) + 2;
-                _screenGridSize.height = ceil(screenSize.height / (_mapTileSize.height / 2)) + 4;
-                break;
-            case FAST_TMX_ORIENTATION_HEX:
-            default:
-                CCLOGERROR("FastTMX does not support type %d", _layerOrientation);
-                break;
-        }
+    Size screenSize = Director::getInstance()->getWinSize();
 
-        _screenTileCount = _screenGridSize.width * _screenGridSize.height;
+    switch (_layerOrientation)
+    {
+        case FAST_TMX_ORIENTATION_ORTHO:
+            _screenGridSize.width = ceil(screenSize.width / _mapTileSize.width) + 1;
+            _screenGridSize.height = ceil(screenSize.height / _mapTileSize.height) + 1;
+
+            // tiles could be bigger than the grid, add additional rows if needed
+            _screenGridSize.height += _tileSet->_tileSize.height / _mapTileSize.height;
+            break;
+        case FAST_TMX_ORIENTATION_ISO:
+            _screenGridSize.width = ceil(screenSize.width / _mapTileSize.width) + 2;
+            _screenGridSize.height = ceil(screenSize.height / (_mapTileSize.height/2)) + 4;
+            break;
+        case FAST_TMX_ORIENTATION_HEX:
+        default:
+            CCLOGERROR("FastTMX does not support type %d", _layerOrientation);
+            break;
     }
 
-    Mat4 TMXLayer::tileToNodeTransform()
-    {
-        float w = _mapTileSize.width / CC_CONTENT_SCALE_FACTOR();
-        float h = _mapTileSize.height / CC_CONTENT_SCALE_FACTOR();
-        float offY = (_layerSize.height - 1) * h;
+    _screenTileCount = (int)(_screenGridSize.width * _screenGridSize.height);
 
-        switch (_layerOrientation)
-        {
-            case FAST_TMX_ORIENTATION_ORTHO:
-            {
-                _tileToNodeTransform = Mat4(w, 0.0f, 0.0f, 0.0f, 0.0f, -h, 0.0f, offY, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0, 0.0f, 1.0f);
+}
 
-                return _tileToNodeTransform;
-            }
-            case FAST_TMX_ORIENTATION_ISO:
-            {
-                float offX = (_layerSize.width - 1) * w / 2;
-                _tileToNodeTransform = Mat4(w / 2, -w / 2, 0.0f, offX, -h / 2, -h / 2, 0.0f, offY, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
-                return _tileToNodeTransform;
-            }
-            case FAST_TMX_ORIENTATION_HEX:
-            {
-                _tileToNodeTransform = Mat4(h * sqrtf(0.75), 0, 0, 0, -h / 2, -h, 0, offY, 0, 0, 1, 0, 0, 0, 0, 1);
-                return _tileToNodeTransform;
-            }
-            default:
-            {
-                _tileToNodeTransform = Mat4::IDENTITY;
-                return _tileToNodeTransform;
-            }
+Mat4 TMXLayer::tileToNodeTransform()
+{
+    float w = _mapTileSize.width / CC_CONTENT_SCALE_FACTOR();
+    float h = _mapTileSize.height / CC_CONTENT_SCALE_FACTOR();
+    float offY = (_layerSize.height - 1) * h;
+    
+    switch(_layerOrientation)
+    {
+        case FAST_TMX_ORIENTATION_ORTHO:
+        {
+            _tileToNodeTransform = Mat4
+            (
+                w, 0.0f, 0.0f, 0.0f,
+                0.0f, -h, 0.0f, offY,
+                0.0f, 0.0f, 1.0f, 0.0f,
+                0.0f, 0.0, 0.0f, 1.0f
+            );
+            
+            return _tileToNodeTransform;
+        }
+        case FAST_TMX_ORIENTATION_ISO:
+        {
+            float offX = (_layerSize.width - 1) * w / 2;
+            _tileToNodeTransform = Mat4
+            (
+                w/2, -w/2, 0.0f, offX,
+                -h/2, -h/2, 0.0f, offY,
+                0.0f, 0.0f, 1.0f, 0.0f,
+                0.0f, 0.0f, 0.0f, 1.0f
+            );
+            return _tileToNodeTransform;
+        }
+        case FAST_TMX_ORIENTATION_HEX:
+        {
+            _tileToNodeTransform = Mat4
+            (
+                h * sqrtf(0.75),    0,   0, 0,
+                -h/2,      -h,      0,   offY,
+                0,               0,     1,  0,
+                0,               0,     0,  1
+            );
+            return _tileToNodeTransform;
+        }
+        default:
+        {
+            _tileToNodeTransform = Mat4::IDENTITY;
+            return _tileToNodeTransform;
         }
     }
+    
+}
 
-    void TMXLayer::updatePrimitives()
+void TMXLayer::updatePrimitives()
+{
+    auto blendfunc = _texture->hasPremultipliedAlpha() ? BlendFunc::ALPHA_PREMULTIPLIED : BlendFunc::ALPHA_NON_PREMULTIPLIED;
+    for(const auto& iter : _indicesVertexZNumber)
     {
-        for (const auto& iter : _indicesVertexZNumber)
+        int start = _indicesVertexZOffsets.at(iter.first);
+
+        auto commandIter = _customCommands.find(iter.first);
+        if (_customCommands.end() == commandIter)
         {
-            int start = _indicesVertexZOffsets.at(iter.first);
+            auto command = new CustomCommand();
+            command->setVertexBuffer(_vertexBuffer);
 
-            auto primitiveIter = _primitives.find(iter.first);
-            if (primitiveIter == _primitives.end())
-            {
-                auto primitive = Primitive::create(_vData, _indexBuffer, GL_TRIANGLES);
-                primitive->setCount(iter.second * 6);
-                primitive->setStart(start * 6);
+            CustomCommand::IndexFormat indexFormat = CustomCommand::IndexFormat::U_SHORT;
+#if CC_FAST_TILEMAP_32_BIT_INDICES
+            indexFormat = CustomCommand::IndexFormat::U_INT;
+#endif
+            command->setIndexBuffer(_indexBuffer, indexFormat);
 
-                _primitives.insert(iter.first, primitive);
+            command->setIndexDrawInfo(start * 6, iter.second * 6);
+
+            auto& pipelineDescriptor = command->getPipelineDescriptor();
+
+            if (_useAutomaticVertexZ)
+            {
+                CC_SAFE_RELEASE(pipelineDescriptor.programState);
+                auto programState = new (std::nothrow) backend::ProgramState(positionTextureColor_vert, positionTextureColorAlphaTest_frag);
+                pipelineDescriptor.programState = programState;
+                _alphaValueLocation = pipelineDescriptor.programState->getUniformLocation("u_alpha_value");
+                pipelineDescriptor.programState->setUniform(_alphaValueLocation, &_alphaFuncValue, sizeof(_alphaFuncValue));
+               
             }
             else
             {
-                primitiveIter->second->setCount(iter.second * 6);
-                primitiveIter->second->setStart(start * 6);
+                CC_SAFE_RELEASE(pipelineDescriptor.programState);
+                auto programState = new (std::nothrow) backend::ProgramState(positionTextureColor_vert, positionTextureColor_frag);
+                pipelineDescriptor.programState = programState;
             }
-        }
-    }
-
-    void TMXLayer::updateTotalQuads()
-    {
-        if (_quadsDirty)
-        {
-            Size tileSize = CC_SIZE_PIXELS_TO_POINTS(_tileSet->_tileSize);
-            Size texSize = _tileSet->_imageSize;
-            _tileToQuadIndex.clear();
-            _totalQuads.resize(int(_layerSize.width * _layerSize.height));
-            _indices.resize(6 * int(_layerSize.width * _layerSize.height));
-            _tileToQuadIndex.resize(int(_layerSize.width * _layerSize.height), -1);
-            _indicesVertexZOffsets.clear();
-
-            int quadIndex = 0;
-            for (int y = 0; y < _layerSize.height; ++y)
+            auto vertexLayout = pipelineDescriptor.programState->getVertexLayout();
+            const auto& attributeInfo = pipelineDescriptor.programState->getProgram()->getActiveAttributes();
+            auto iterAttribute = attributeInfo.find("a_position");
+            if(iterAttribute != attributeInfo.end())
             {
-                for (int x = 0; x < _layerSize.width; ++x)
-                {
-                    int tileIndex = getTileIndexByPos(x, y);
-                    int tileGID = _tiles[tileIndex];
-
-                    if (tileGID == 0)
-                        continue;
-
-                    _tileToQuadIndex[tileIndex] = quadIndex;
-
-                    auto& quad = _totalQuads[quadIndex];
-
-                    Vec3 nodePos(float(x), float(y), 0);
-                    _tileToNodeTransform.transformPoint(nodePos);
-
-                    float left, right, top, bottom, z;
-
-                    z = getVertexZForPos(Vec2(x, y));
-                    auto iter = _indicesVertexZOffsets.find(z);
-                    if (iter == _indicesVertexZOffsets.end())
-                    {
-                        _indicesVertexZOffsets[z] = 1;
-                    }
-                    else
-                    {
-                        iter->second++;
-                    }
-                    // vertices
-                    if (tileGID & kTMXTileDiagonalFlag)
-                    {
-                        left = nodePos.x;
-                        right = nodePos.x + tileSize.height;
-                        bottom = nodePos.y + tileSize.width;
-                        top = nodePos.y;
-                    }
-                    else
-                    {
-                        left = nodePos.x;
-                        right = nodePos.x + tileSize.width;
-                        bottom = nodePos.y + tileSize.height;
-                        top = nodePos.y;
-                    }
-
-                    if (tileGID & kTMXTileVerticalFlag)
-                        std::swap(top, bottom);
-                    if (tileGID & kTMXTileHorizontalFlag)
-                        std::swap(left, right);
-
-                    if (tileGID & kTMXTileDiagonalFlag)
-                    {
-                        // FIXME: not working correctly
-                        quad.bl.vertices.x = left;
-                        quad.bl.vertices.y = bottom;
-                        quad.bl.vertices.z = z;
-                        quad.br.vertices.x = left;
-                        quad.br.vertices.y = top;
-                        quad.br.vertices.z = z;
-                        quad.tl.vertices.x = right;
-                        quad.tl.vertices.y = bottom;
-                        quad.tl.vertices.z = z;
-                        quad.tr.vertices.x = right;
-                        quad.tr.vertices.y = top;
-                        quad.tr.vertices.z = z;
-                    }
-                    else
-                    {
-                        quad.bl.vertices.x = left;
-                        quad.bl.vertices.y = bottom;
-                        quad.bl.vertices.z = z;
-                        quad.br.vertices.x = right;
-                        quad.br.vertices.y = bottom;
-                        quad.br.vertices.z = z;
-                        quad.tl.vertices.x = left;
-                        quad.tl.vertices.y = top;
-                        quad.tl.vertices.z = z;
-                        quad.tr.vertices.x = right;
-                        quad.tr.vertices.y = top;
-                        quad.tr.vertices.z = z;
-                    }
-
-                    // texcoords
-                    Rect tileTexture = _tileSet->getRectForGID(tileGID);
-                    left = (tileTexture.origin.x / texSize.width);
-                    right = left + (tileTexture.size.width / texSize.width);
-                    bottom = (tileTexture.origin.y / texSize.height);
-                    top = bottom + (tileTexture.size.height / texSize.height);
-
-                    quad.bl.texCoords.u = left;
-                    quad.bl.texCoords.v = bottom;
-                    quad.br.texCoords.u = right;
-                    quad.br.texCoords.v = bottom;
-                    quad.tl.texCoords.u = left;
-                    quad.tl.texCoords.v = top;
-                    quad.tr.texCoords.u = right;
-                    quad.tr.texCoords.v = top;
-
-                    quad.bl.colors = Color4B::WHITE;
-                    quad.br.colors = Color4B::WHITE;
-                    quad.tl.colors = Color4B::WHITE;
-                    quad.tr.colors = Color4B::WHITE;
-
-                    ++quadIndex;
-                }
+                vertexLayout->setAttribute("a_position", iterAttribute->second.location, backend::VertexFormat::FLOAT3, 0, false);
             }
-
-            int offset = 0;
-            for (auto iter = _indicesVertexZOffsets.begin(); iter != _indicesVertexZOffsets.end(); ++iter)
+            iterAttribute = attributeInfo.find("a_texCoord");
+            if(iterAttribute != attributeInfo.end())
+            {
+                vertexLayout->setAttribute("a_texCoord", iterAttribute->second.location, backend::VertexFormat::FLOAT2, offsetof(V3F_C4B_T2F, texCoords), false);
+            }
+            iterAttribute = attributeInfo.find("a_color");
+            if(iterAttribute != attributeInfo.end())
             {
-                std::swap(offset, iter->second);
-                offset += iter->second;
+                vertexLayout->setAttribute("a_color", iterAttribute->second.location, backend::VertexFormat::UBYTE4, offsetof(V3F_C4B_T2F, colors), true);
             }
-            updateVertexBuffer();
+            vertexLayout->setLayout(sizeof(V3F_C4B_T2F));
+            _mvpMatrixLocaiton = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+            _textureLocation = pipelineDescriptor.programState->getUniformLocation("u_texture");
+            pipelineDescriptor.programState->setTexture(_textureLocation, 0, _texture->getBackendTexture());
+            command->init(_globalZOrder, blendfunc);
 
-            _quadsDirty = false;
+            _customCommands[iter.first] = command;
         }
-    }
-
-    // removing / getting tiles
-    Sprite* TMXLayer::getTileAt(const Vec2& tileCoordinate)
-    {
-        CCASSERT(tileCoordinate.x < _layerSize.width && tileCoordinate.y < _layerSize.height && tileCoordinate.x >= 0 && tileCoordinate.y >= 0,
-                 "TMXLayer: invalid position");
-        CCASSERT(_tiles, "TMXLayer: the tiles map has been released");
-
-        Sprite* tile = nullptr;
-        int gid = this->getTileGIDAt(tileCoordinate);
-
-        // if GID == 0, then no tile is present
-        if (gid)
+        else
         {
-            int index = (int)tileCoordinate.x + (int)tileCoordinate.y * _layerSize.width;
-
-            auto it = _spriteContainer.find(index);
-            if (it != _spriteContainer.end())
-            {
-                tile = it->second.first;
-            }
-            else
-            {
-                // tile not created yet. create it
-                Rect rect = _tileSet->getRectForGID(gid);
-                rect = CC_RECT_PIXELS_TO_POINTS(rect);
-                tile = Sprite::createWithTexture(_texture, rect);
-
-                Vec2 p = this->getPositionAt(tileCoordinate);
-                tile->setAnchorPoint(Vec2::ZERO);
-                tile->setPosition(p);
-                tile->setPositionZ((float)getVertexZForPos(tileCoordinate));
-                tile->setOpacity(this->getOpacity());
-                tile->setTag(index);
-                this->addChild(tile, index);
-                _spriteContainer.insert(std::pair<int, std::pair<Sprite*, int>>(index, std::pair<Sprite*, int>(tile, gid)));
-
-                // tile is converted to sprite.
-                setFlaggedTileGIDByIndex(index, 0);
-            }
+            commandIter->second->setIndexDrawInfo(start * 6, iter.second * 6);
         }
-        return tile;
     }
+}
 
-    int TMXLayer::getTileGIDAt(const Vec2& tileCoordinate, TMXTileFlags* flags /* = nullptr*/)
-    {
-        CCASSERT(tileCoordinate.x < _layerSize.width && tileCoordinate.y < _layerSize.height && tileCoordinate.x >= 0 && tileCoordinate.y >= 0,
-                 "TMXLayer: invalid position");
-        CCASSERT(_tiles, "TMXLayer: the tiles map has been released");
+void TMXLayer::setOpacity(uint8_t opacity) 
+{
+    Node::setOpacity(opacity);
+    _quadsDirty = true;
+}
 
-        int idx = static_cast<int>(((int)tileCoordinate.x + (int)tileCoordinate.y * _layerSize.width));
 
-        // Bits on the far end of the 32-bit global tile ID are used for tile flags
-        int tile = _tiles[idx];
-        auto it = _spriteContainer.find(idx);
+void TMXLayer::updateTotalQuads()
+{
+    if(_quadsDirty)
+    {
+        Size tileSize = CC_SIZE_PIXELS_TO_POINTS(_tileSet->_tileSize);
+        Size texSize = _tileSet->_imageSize;
+        _tileToQuadIndex.clear();
+        _totalQuads.resize(int(_layerSize.width * _layerSize.height));
+        _indices.resize(6 * int(_layerSize.width * _layerSize.height));
+        _tileToQuadIndex.resize(int(_layerSize.width * _layerSize.height),-1);
+        _indicesVertexZOffsets.clear();
 
-        // converted to sprite.
-        if (tile == 0 && it != _spriteContainer.end())
-        {
-            tile = it->second.second;
-        }
+        auto color = Color4B::WHITE;
+        color.a = getDisplayedOpacity();
 
-        // issue1264, flipped tiles can be changed dynamically
-        if (flags)
+        if (_texture->hasPremultipliedAlpha()) 
         {
-            *flags = (TMXTileFlags)(tile & kTMXFlipedAll);
+            auto alpha = color.a / 255.0f;
+            color.r = static_cast<uint8_t>(color.r * alpha);
+            color.g = static_cast<uint8_t>(color.g * alpha);
+            color.b = static_cast<uint8_t>(color.b * alpha);
         }
 
-        return (tile & kTMXFlippedMask);
-    }
-
-    Vec2 TMXLayer::getPositionAt(const Vec2& pos) { return PointApplyTransform(pos, _tileToNodeTransform); }
-
-    int TMXLayer::getVertexZForPos(const Vec2& pos)
-    {
-        int ret = 0;
-        int maxVal = 0;
-        if (_useAutomaticVertexZ)
+        int quadIndex = 0;
+        for(int y = 0; y < _layerSize.height; ++y)
         {
-            switch (_layerOrientation)
+            for(int x =0; x < _layerSize.width; ++x)
             {
-                case FAST_TMX_ORIENTATION_ISO:
-                    maxVal = static_cast<int>(_layerSize.width + _layerSize.height);
-                    ret = static_cast<int>(-(maxVal - (pos.x + pos.y)));
-                    break;
-                case FAST_TMX_ORIENTATION_ORTHO:
-                    ret = static_cast<int>(-(_layerSize.height - pos.y));
-                    break;
-                case FAST_TMX_ORIENTATION_HEX:
-                    CCASSERT(0, "TMX Hexa vertexZ not supported");
-                    break;
-                default:
-                    CCASSERT(0, "TMX invalid value");
-                    break;
+                int tileIndex = getTileIndexByPos(x, y);
+                int tileGID = _tiles[tileIndex];
+                
+                if(tileGID == 0) continue;
+                
+                _tileToQuadIndex[tileIndex] = quadIndex;
+                
+                auto& quad = _totalQuads[quadIndex];
+                
+                Vec3 nodePos(float(x), float(y), 0);
+                _tileToNodeTransform.transformPoint(&nodePos);
+                
+                float left, right, top, bottom, z;
+                
+                int zPos = getVertexZForPos(Vec2((float)x, (float)y));
+                z = (float)zPos;
+                auto iter = _indicesVertexZOffsets.find(zPos);
+                if(iter == _indicesVertexZOffsets.end())
+                {
+                    _indicesVertexZOffsets[zPos] = 1;
+                }
+                else
+                {
+                    iter->second++;
+                }
+                // vertices
+                if (tileGID & kTMXTileDiagonalFlag)
+                {
+                    left = nodePos.x;
+                    right = nodePos.x + tileSize.height;
+                    bottom = nodePos.y + tileSize.width;
+                    top = nodePos.y;
+                }
+                else
+                {
+                    left = nodePos.x;
+                    right = nodePos.x + tileSize.width;
+                    bottom = nodePos.y + tileSize.height;
+                    top = nodePos.y;
+                }
+                
+                if(tileGID & kTMXTileVerticalFlag)
+                    std::swap(top, bottom);
+                if(tileGID & kTMXTileHorizontalFlag)
+                    std::swap(left, right);
+                
+                if(tileGID & kTMXTileDiagonalFlag)
+                {
+                    // FIXME: not working correctly
+                    quad.bl.vertices.x = left;
+                    quad.bl.vertices.y = bottom;
+                    quad.bl.vertices.z = z;
+                    quad.br.vertices.x = left;
+                    quad.br.vertices.y = top;
+                    quad.br.vertices.z = z;
+                    quad.tl.vertices.x = right;
+                    quad.tl.vertices.y = bottom;
+                    quad.tl.vertices.z = z;
+                    quad.tr.vertices.x = right;
+                    quad.tr.vertices.y = top;
+                    quad.tr.vertices.z = z;
+                }
+                else
+                {
+                    quad.bl.vertices.x = left;
+                    quad.bl.vertices.y = bottom;
+                    quad.bl.vertices.z = z;
+                    quad.br.vertices.x = right;
+                    quad.br.vertices.y = bottom;
+                    quad.br.vertices.z = z;
+                    quad.tl.vertices.x = left;
+                    quad.tl.vertices.y = top;
+                    quad.tl.vertices.z = z;
+                    quad.tr.vertices.x = right;
+                    quad.tr.vertices.y = top;
+                    quad.tr.vertices.z = z;
+                }
+                
+                // texcoords
+                Rect tileTexture = _tileSet->getRectForGID(tileGID);
+                left   = (tileTexture.origin.x / texSize.width);
+                right  = left + (tileTexture.size.width / texSize.width);
+                bottom = (tileTexture.origin.y / texSize.height);
+                top    = bottom + (tileTexture.size.height / texSize.height);
+                
+                quad.bl.texCoords.u = left;
+                quad.bl.texCoords.v = bottom;
+                quad.br.texCoords.u = right;
+                quad.br.texCoords.v = bottom;
+                quad.tl.texCoords.u = left;
+                quad.tl.texCoords.v = top;
+                quad.tr.texCoords.u = right;
+                quad.tr.texCoords.v = top;
+                
+                quad.bl.colors = color;
+                quad.br.colors = color;
+                quad.tl.colors = color;
+                quad.tr.colors = color;
+
+                
+                ++quadIndex;
             }
         }
-        else
+        
+        int offset = 0;
+        for(auto& vertexZOffset : _indicesVertexZOffsets)
         {
-            ret = _vertexZvalue;
+            std::swap(offset, vertexZOffset.second);
+            offset += vertexZOffset.second;
         }
-
-        return ret;
+        updateVertexBuffer();
+        
+        _quadsDirty = false;
     }
+}
 
-    void TMXLayer::removeTileAt(const Vec2& tileCoordinate)
-    {
-        CCASSERT(tileCoordinate.x < _layerSize.width && tileCoordinate.y < _layerSize.height && tileCoordinate.x >= 0 && tileCoordinate.y >= 0,
-                 "TMXLayer: invalid position");
-
-        int gid = this->getTileGIDAt(tileCoordinate);
-
-        if (gid)
+// removing / getting tiles
+Sprite* TMXLayer::getTileAt(const Vec2& tileCoordinate)
+{
+    CCASSERT( tileCoordinate.x < _layerSize.width && tileCoordinate.y < _layerSize.height && tileCoordinate.x >=0 && tileCoordinate.y >=0, "TMXLayer: invalid position");
+    CCASSERT( _tiles, "TMXLayer: the tiles map has been released");
+    
+    Sprite *tile = nullptr;
+    int gid = this->getTileGIDAt(tileCoordinate);
+    
+    // if GID == 0, then no tile is present
+    if( gid ) {
+        int index = (int) tileCoordinate.x + (int)(tileCoordinate.y * _layerSize.width);
+        
+        auto it = _spriteContainer.find(index);
+        if (it != _spriteContainer.end())
+        {
+            tile = it->second.first;
+        }
+        else
         {
-            int z = (int)tileCoordinate.x + (int)tileCoordinate.y * _layerSize.width;
-
-            // remove tile from GID map
-            setFlaggedTileGIDByIndex(z, 0);
-
-            // remove it from sprites
-            auto it = _spriteContainer.find(z);
-            if (it != _spriteContainer.end())
-            {
-                this->removeChild(it->second.first);
-            }
+            // tile not created yet. create it
+            Rect rect = _tileSet->getRectForGID(gid);
+            rect = CC_RECT_PIXELS_TO_POINTS(rect);
+            tile = Sprite::createWithTexture(_texture, rect);
+            
+            Vec2 p = this->getPositionAt(tileCoordinate);
+            tile->setAnchorPoint(Vec2::ZERO);
+            tile->setPosition(p);
+            tile->setPositionZ((float)getVertexZForPos(tileCoordinate));
+            tile->setOpacity(this->getOpacity());
+            tile->setTag(index);
+            this->addChild(tile, index);
+            _spriteContainer.insert(std::pair<int, std::pair<Sprite*, int> >(index, std::pair<Sprite*, int>(tile, gid)));
+            
+            // tile is converted to sprite.
+            setFlaggedTileGIDByIndex(index, 0);
         }
     }
+    return tile;
+}
 
-    void TMXLayer::setFlaggedTileGIDByIndex(int index, int gid)
+int TMXLayer::getTileGIDAt(const Vec2& tileCoordinate, TMXTileFlags* flags/* = nullptr*/)
+{
+    CCASSERT(tileCoordinate.x < _layerSize.width && tileCoordinate.y < _layerSize.height && tileCoordinate.x >=0 && tileCoordinate.y >=0, "TMXLayer: invalid position");
+    CCASSERT(_tiles, "TMXLayer: the tiles map has been released");
+    
+    int idx = static_cast<int>(((int) tileCoordinate.x + (int) tileCoordinate.y * _layerSize.width));
+    
+    // Bits on the far end of the 32-bit global tile ID are used for tile flags
+    int tile = _tiles[idx];
+    auto it = _spriteContainer.find(idx);
+    
+    // converted to sprite.
+    if (tile == 0 && it != _spriteContainer.end())
+    {
+        tile = it->second.second;
+    }
+    
+    // issue1264, flipped tiles can be changed dynamically
+    if (flags)
     {
-        if (gid == _tiles[index])
-            return;
-        _tiles[index] = gid;
-        _quadsDirty = true;
-        _dirty = true;
+        *flags = (TMXTileFlags)(tile & kTMXFlipedAll);
     }
+    
+    return (tile & kTMXFlippedMask);
+}
 
-    void TMXLayer::removeChild(Node* node, bool cleanup)
+Vec2 TMXLayer::getPositionAt(const Vec2& pos)
+{
+    return PointApplyTransform(pos, _tileToNodeTransform);
+}
+
+int TMXLayer::getVertexZForPos(const Vec2& pos)
+{
+    int ret = 0;
+    int maxVal = 0;
+    if (_useAutomaticVertexZ)
     {
-        int tag = node->getTag();
-        auto it = _spriteContainer.find(tag);
-        if (it != _spriteContainer.end() && it->second.first == node)
+        switch (_layerOrientation)
         {
-            _spriteContainer.erase(it);
+            case FAST_TMX_ORIENTATION_ISO:
+                maxVal = static_cast<int>(_layerSize.width + _layerSize.height);
+                ret = static_cast<int>(-(maxVal - (pos.x + pos.y)));
+                break;
+            case FAST_TMX_ORIENTATION_ORTHO:
+                ret = static_cast<int>(-(_layerSize.height-pos.y));
+                break;
+            case FAST_TMX_ORIENTATION_HEX:
+                CCASSERT(0, "TMX Hexa vertexZ not supported");
+                break;
+            default:
+                CCASSERT(0, "TMX invalid value");
+                break;
         }
-        Node::removeChild(node, cleanup);
     }
-
-    // TMXLayer - Properties
-    Value TMXLayer::getProperty(const std::string& propertyName) const
+    else
     {
-        if (_properties.find(propertyName) != _properties.end())
-            return _properties.at(propertyName);
+        ret = _vertexZvalue;
+    }
+    
+    return ret;
+}
 
-        return Value();
+void TMXLayer::removeTileAt(const Vec2& tileCoordinate)
+{
+    
+    CCASSERT( tileCoordinate.x < _layerSize.width && tileCoordinate.y < _layerSize.height && tileCoordinate.x >=0 && tileCoordinate.y >=0, "TMXLayer: invalid position");
+    
+    int gid = this->getTileGIDAt(tileCoordinate);
+    
+    if( gid ) {
+        
+        int z = (int) tileCoordinate.x + (int)(tileCoordinate.y * _layerSize.width);
+        
+        // remove tile from GID map
+        setFlaggedTileGIDByIndex(z, 0);
+        
+        // remove it from sprites
+        auto it = _spriteContainer.find(z);
+        if (it != _spriteContainer.end())
+        {
+            this->removeChild(it->second.first);
+        }
     }
+}
 
-    void TMXLayer::parseInternalProperties()
+void TMXLayer::setFlaggedTileGIDByIndex(int index, uint32_t gid)
+{
+    if(gid == _tiles[index]) return;
+    _tiles[index] = gid;
+    _quadsDirty = true;
+    _dirty = true;
+}
+
+void TMXLayer::removeChild(Node* node, bool cleanup)
+{
+    int tag = node->getTag();
+    auto it = _spriteContainer.find(tag);
+    if (it != _spriteContainer.end() && it->second.first == node)
     {
-        auto vertexz = getProperty("cc_vertexz");
-        if (vertexz.isNull())
-            return;
+        _spriteContainer.erase(it);
+    }
+    Node::removeChild(node, cleanup);
+}
 
-        std::string vertexZStr = vertexz.asString();
-        // If "automatic" is on, then parse the "cc_alpha_func" too
-        if (vertexZStr == "automatic")
-        {
-            _useAutomaticVertexZ = true;
-            auto alphaFuncVal = getProperty("cc_alpha_func");
-            float alphaFuncValue = alphaFuncVal.asFloat();
-            setGLProgram(GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST));
+// TMXLayer - Properties
+Value TMXLayer::getProperty(const std::string& propertyName) const
+{
+    auto propItr = _properties.find(propertyName);
+    if (propItr != _properties.end())
+        return propItr->second;
+    
+    return Value();
+}
+
+void TMXLayer::parseInternalProperties()
+{
+    auto vertexz = getProperty("cc_vertexz");
+    if (vertexz.isNull()) return;
+    
+    std::string vertexZStr = vertexz.asString();
+    // If "automatic" is on, then parse the "cc_alpha_func" too
+    if (vertexZStr == "automatic")
+    {
+        _useAutomaticVertexZ = true;
+        auto alphaFuncVal = getProperty("cc_alpha_func");
+        _alphaFuncValue = alphaFuncVal.asFloat();
+    }
+    else
+    {
+        _vertexZvalue = vertexz.asInt();
+    }
+}
 
-            GLint alphaValueLocation = glGetUniformLocation(getGLProgram()->getProgram(), GLProgram::UNIFORM_NAME_ALPHA_TEST_VALUE);
+//CCTMXLayer2 - obtaining positions, offset
+Vec2 TMXLayer::calculateLayerOffset(const Vec2& pos)
+{
+    Vec2 ret;
+    switch (_layerOrientation) 
+    {
+    case FAST_TMX_ORIENTATION_ORTHO:
+        ret.set( pos.x * _mapTileSize.width, -pos.y *_mapTileSize.height);
+        break;
+    case FAST_TMX_ORIENTATION_ISO:
+        ret.set((_mapTileSize.width /2) * (pos.x - pos.y),
+                  (_mapTileSize.height /2 ) * (-pos.x - pos.y));
+        break;
+    case FAST_TMX_ORIENTATION_HEX:
+    default:
+        CCASSERT(pos.isZero(), "offset for this map not implemented yet");
+        break;
+    }
+    return ret;    
+}
 
-            // NOTE: alpha test shader is hard-coded to use the equivalent of a glAlphaFunc(GL_GREATER) comparison
+// TMXLayer - adding / remove tiles
+void TMXLayer::setTileGID(int gid, const Vec2& tileCoordinate)
+{
+    setTileGID(gid, tileCoordinate, (TMXTileFlags)0);
+}
 
-            // use shader program to set uniform
-            getGLProgram()->use();
-            getGLProgram()->setUniformLocationWith1f(alphaValueLocation, alphaFuncValue);
-            CHECK_GL_ERROR_DEBUG();
+void TMXLayer::setTileGID(int gid, const Vec2& tileCoordinate, TMXTileFlags flags)
+{
+    CCASSERT(tileCoordinate.x < _layerSize.width && tileCoordinate.y < _layerSize.height && tileCoordinate.x >=0 && tileCoordinate.y >=0, "TMXLayer: invalid position");
+    CCASSERT(_tiles, "TMXLayer: the tiles map has been released");
+    CCASSERT(gid == 0 || gid >= _tileSet->_firstGid, "TMXLayer: invalid gid" );
+    
+    TMXTileFlags currentFlags;
+    int currentGID = getTileGIDAt(tileCoordinate, &currentFlags);
+    
+    if (currentGID == gid && currentFlags == flags) return;
+    
+    uint32_t gidAndFlags = gid | flags;
+    
+    // setting gid=0 is equal to remove the tile
+    if (gid == 0)
+    {
+        removeTileAt(tileCoordinate);
+    }
+    // empty tile. create a new one
+    else if (currentGID == 0)
+    {
+        int z = (int) tileCoordinate.x + (int)(tileCoordinate.y * _layerSize.width);
+        setFlaggedTileGIDByIndex(z, gidAndFlags);
+    }
+    // modifying an existing tile with a non-empty tile
+    else
+    {
+        int z = (int) tileCoordinate.x + (int)(tileCoordinate.y * _layerSize.width);
+        auto it = _spriteContainer.find(z);
+        if (it != _spriteContainer.end())
+        {
+            Sprite *sprite = it->second.first;
+            Rect rect = _tileSet->getRectForGID(gid);
+            rect = CC_RECT_PIXELS_TO_POINTS(rect);
+            
+            sprite->setTextureRect(rect, false, rect.size);
+            this->reorderChild(sprite, z);
+            if (flags)
+            {
+                setupTileSprite(sprite, sprite->getPosition(), gidAndFlags);
+            }
+            
+            it->second.second = gidAndFlags;
         }
         else
         {
-            _vertexZvalue = vertexz.asInt();
+            setFlaggedTileGIDByIndex(z, gidAndFlags);
         }
     }
+}
 
-    // CCTMXLayer2 - obtaining positions, offset
-    Vec2 TMXLayer::calculateLayerOffset(const Vec2& pos)
+void TMXLayer::setupTileSprite(Sprite* sprite, const Vec2& pos, uint32_t gid)
+{
+    sprite->setPosition(getPositionAt(pos));
+    sprite->setPositionZ((float)getVertexZForPos(pos));
+    sprite->setAnchorPoint(Vec2::ZERO);
+    sprite->setOpacity(this->getOpacity());
+    
+    //issue 1264, flip can be undone as well
+    sprite->setFlippedX(false);
+    sprite->setFlippedY(false);
+    sprite->setRotation(0.0f);
+    
+    // Rotation in tiled is achieved using 3 flipped states, flipping across the horizontal, vertical, and diagonal axes of the tiles.
+    if (gid & kTMXTileDiagonalFlag)
     {
-        Vec2 ret;
-        switch (_layerOrientation)
+        // put the anchor in the middle for ease of rotation.
+        sprite->setAnchorPoint(Vec2(0.5f,0.5f));
+        sprite->setPosition(getPositionAt(pos).x + sprite->getContentSize().height/2,
+                                  getPositionAt(pos).y + sprite->getContentSize().width/2 );
+        
+        uint32_t flag = gid & (kTMXTileHorizontalFlag | kTMXTileVerticalFlag );
+        
+        // handle the 4 diagonally flipped states.
+        if (flag == kTMXTileHorizontalFlag)
         {
-            case FAST_TMX_ORIENTATION_ORTHO:
-                ret.set(pos.x * _mapTileSize.width, -pos.y * _mapTileSize.height);
-                break;
-            case FAST_TMX_ORIENTATION_ISO:
-                ret.set((_mapTileSize.width / 2) * (pos.x - pos.y), (_mapTileSize.height / 2) * (-pos.x - pos.y));
-                break;
-            case FAST_TMX_ORIENTATION_HEX:
-            default:
-                CCASSERT(pos.isZero(), "offset for this map not implemented yet");
-                break;
+            sprite->setRotation(90.0f);
         }
-        return ret;
-    }
-
-    // TMXLayer - adding / remove tiles
-    void TMXLayer::setTileGID(int gid, const Vec2& tileCoordinate) { setTileGID(gid, tileCoordinate, (TMXTileFlags)0); }
-
-    void TMXLayer::setTileGID(int gid, const Vec2& tileCoordinate, TMXTileFlags flags)
-    {
-        CCASSERT(tileCoordinate.x < _layerSize.width && tileCoordinate.y < _layerSize.height && tileCoordinate.x >= 0 && tileCoordinate.y >= 0,
-                 "TMXLayer: invalid position");
-        CCASSERT(_tiles, "TMXLayer: the tiles map has been released");
-        CCASSERT(gid == 0 || gid >= _tileSet->_firstGid, "TMXLayer: invalid gid");
-
-        TMXTileFlags currentFlags;
-        int currentGID = getTileGIDAt(tileCoordinate, &currentFlags);
-
-        if (currentGID == gid && currentFlags == flags)
-            return;
-
-        int gidAndFlags = gid | flags;
-
-        // setting gid=0 is equal to remove the tile
-        if (gid == 0)
+        else if (flag == kTMXTileVerticalFlag)
         {
-            removeTileAt(tileCoordinate);
+            sprite->setRotation(270.0f);
         }
-        // empty tile. create a new one
-        else if (currentGID == 0)
+        else if (flag == (kTMXTileVerticalFlag | kTMXTileHorizontalFlag) )
         {
-            int z = (int)tileCoordinate.x + (int)tileCoordinate.y * _layerSize.width;
-            setFlaggedTileGIDByIndex(z, gidAndFlags);
+            sprite->setRotation(90.0f);
+            sprite->setFlippedX(true);
         }
-        // modifying an existing tile with a non-empty tile
         else
         {
-            int z = (int)tileCoordinate.x + (int)tileCoordinate.y * _layerSize.width;
-            auto it = _spriteContainer.find(z);
-            if (it != _spriteContainer.end())
-            {
-                Sprite* sprite = it->second.first;
-                Rect rect = _tileSet->getRectForGID(gid);
-                rect = CC_RECT_PIXELS_TO_POINTS(rect);
-
-                sprite->setTextureRect(rect, false, rect.size);
-                this->reorderChild(sprite, z);
-                if (flags)
-                {
-                    setupTileSprite(sprite, sprite->getPosition(), gidAndFlags);
-                }
-
-                it->second.second = gidAndFlags;
-            }
-            else
-            {
-                setFlaggedTileGIDByIndex(z, gidAndFlags);
-            }
+            sprite->setRotation(270.0f);
+            sprite->setFlippedX(true);
         }
     }
-
-    void TMXLayer::setupTileSprite(Sprite* sprite, const Vec2& pos, int gid)
+    else
     {
-        sprite->setPosition(getPositionAt(pos));
-        sprite->setPositionZ((float)getVertexZForPos(pos));
-        sprite->setAnchorPoint(Vec2::ZERO);
-        sprite->setOpacity(this->getOpacity());
-
-        // issue 1264, flip can be undone as well
-        sprite->setFlippedX(false);
-        sprite->setFlippedY(false);
-        sprite->setRotation(0.0f);
-
-        // Rotation in tiled is achieved using 3 flipped states, flipping across the horizontal, vertical, and diagonal axes of the tiles.
-        if (gid & kTMXTileDiagonalFlag)
+        if (gid & kTMXTileHorizontalFlag)
         {
-            // put the anchor in the middle for ease of rotation.
-            sprite->setAnchorPoint(Vec2(0.5f, 0.5f));
-            sprite->setPosition(getPositionAt(pos).x + sprite->getContentSize().height / 2, getPositionAt(pos).y + sprite->getContentSize().width / 2);
-
-            int flag = gid & (kTMXTileHorizontalFlag | kTMXTileVerticalFlag);
-
-            // handle the 4 diagonally flipped states.
-            if (flag == kTMXTileHorizontalFlag)
-            {
-                sprite->setRotation(90.0f);
-            }
-            else if (flag == kTMXTileVerticalFlag)
-            {
-                sprite->setRotation(270.0f);
-            }
-            else if (flag == (kTMXTileVerticalFlag | kTMXTileHorizontalFlag))
-            {
-                sprite->setRotation(90.0f);
-                sprite->setFlippedX(true);
-            }
-            else
-            {
-                sprite->setRotation(270.0f);
-                sprite->setFlippedX(true);
-            }
+            sprite->setFlippedX(true);
         }
-        else
+        
+        if (gid & kTMXTileVerticalFlag)
         {
-            if (gid & kTMXTileHorizontalFlag)
-            {
-                sprite->setFlippedX(true);
-            }
-
-            if (gid & kTMXTileVerticalFlag)
-            {
-                sprite->setFlippedY(true);
-            }
+            sprite->setFlippedY(true);
         }
     }
+}
 
-    std::string TMXLayer::getDescription() const
-    {
-        return StringUtils::format("<FastTMXLayer | tag = %d, size = %d,%d>", _tag, (int)_mapTileSize.width, (int)_mapTileSize.height);
-    }
+std::string TMXLayer::getDescription() const
+{
+    return StringUtils::format("<FastTMXLayer | tag = %d, size = %d,%d>", _tag, (int)_mapTileSize.width, (int)_mapTileSize.height);
+}
 
-} // end of namespace experimental
+} //end of namespace experimental
 
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCFastTMXLayer.h b/cocos2d/cocos/2d/CCFastTMXLayer.h
index 581d25134b..a7b7c6fc28 100644
--- a/cocos2d/cocos/2d/CCFastTMXLayer.h
+++ b/cocos2d/cocos/2d/CCFastTMXLayer.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,353 +25,341 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_FASTTMXLAYER_H
-#define CC_2D_FASTTMXLAYER_H
+#pragma once
 
+#include <unordered_map>
 #include <cocos/2d/CCNode.h>
 #include <cocos/2d/CCTMXXMLParser.h>
-#include <cocos/base/CCMap.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCPrimitiveCommand.h>
-
-#include <cstdint>
-#include <map>
-#include <string>
-#include <unordered_map>
-#include <utility>
-#include <vector>
+#include <cocos/renderer/CCCustomCommand.h>
 
 NS_CC_BEGIN
 
-class IndexBuffer;
-class Sprite;
+class TMXMapInfo;
+class TMXLayerInfo;
+class TMXTilesetInfo;
 class Texture2D;
-class Vec2;
-class VertexBuffer;
-class VertexData;
+class Sprite;
 
-namespace experimental
+namespace backend
 {
-    /**
-     * @addtogroup _2d
-     * @{
-     */
+    class Buffer;
+}
 
-    /** @brief FastTMXLayer represents the TMX layer.
+namespace experimental{
 
-     * It is a subclass of SpriteBatchNode. By default the tiles are rendered using a TextureAtlas.
-     * If you modify a tile on runtime, then, that tile will become a Sprite, otherwise no Sprite objects are created.
-     * The benefits of using Sprite objects as tiles are:
-     * - tiles (Sprite) can be rotated/scaled/moved with a nice API.
+/**
+ * @addtogroup _2d
+ * @{
+ */
 
-     * If the layer contains a property named "cc_vertexz" with an integer (in can be positive or negative),
-     * then all the tiles belonging to the layer will use that value as their OpenGL vertex Z for depth.
+/** @brief FastTMXLayer represents the TMX layer.
 
-     * On the other hand, if the "cc_vertexz" property has the "automatic" value, then the tiles will use an automatic vertex Z value.
-     * Also before drawing the tiles, GL_ALPHA_TEST will be enabled, and disabled after drawing them. The used alpha func will be:
+ * It is a subclass of SpriteBatchNode. By default the tiles are rendered using a TextureAtlas.
+ * If you modify a tile on runtime, then, that tile will become a Sprite, otherwise no Sprite objects are created.
+ * The benefits of using Sprite objects as tiles are:
+ * - tiles (Sprite) can be rotated/scaled/moved with a nice API.
 
-     * glAlphaFunc( GL_GREATER, value ).
+ * If the layer contains a property named "cc_vertexz" with an integer (in can be positive or negative),
+ * then all the tiles belonging to the layer will use that value as their OpenGL vertex Z for depth.
 
-     * "value" by default is 0, but you can change it from Tiled by adding the "cc_alpha_func" property to the layer.
-     * The value 0 should work for most cases, but if you have tiles that are semi-transparent, then you might want to use a different
-     * value, like 0.5.
+ * On the other hand, if the "cc_vertexz" property has the "automatic" value, then the tiles will use an automatic vertex Z value.
+ * Also before drawing the tiles, GL_ALPHA_TEST will be enabled, and disabled after drawing them. The used alpha func will be:
 
-     * For further information, please see the programming guide:
-     * http://www.cocos2d-iphone.org/wiki/doku.php/prog_guide:tiled_maps
+ * glAlphaFunc( GL_GREATER, value ).
 
-     * @since v3.2
+ * "value" by default is 0, but you can change it from Tiled by adding the "cc_alpha_func" property to the layer.
+ * The value 0 should work for most cases, but if you have tiles that are semi-transparent, then you might want to use a different
+ * value, like 0.5.
+ 
+ * For further information, please see the programming guide:
+ * http://www.cocos2d-iphone.org/wiki/doku.php/prog_guide:tiled_maps
+ 
+ * @since v3.2
+ * @js NA
+ */
+
+class CC_DLL TMXLayer : public Node
+{
+public:
+    /** Possible orientations of the TMX map */
+    static const int FAST_TMX_ORIENTATION_ORTHO;
+    static const int FAST_TMX_ORIENTATION_HEX;
+    static const int FAST_TMX_ORIENTATION_ISO;
+
+    /** Creates a FastTMXLayer with an tileset info, a layer info and a map info.
+     *
+     * @param tilesetInfo An tileset info.
+     * @param layerInfo A layer info.
+     * @param mapInfo A map info.
+     * @return Return an autorelease object.
+     */
+    static TMXLayer * create(TMXTilesetInfo *tilesetInfo, TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo);
+    /**
+     * @js ctor
+     */
+    TMXLayer();
+    /**
      * @js NA
+     * @lua NA
+     */
+    virtual ~TMXLayer();
+
+    /** Returns the tile gid at a given tile coordinate. It also returns the tile flags.
+     * 
+     * @param tileCoordinate The tile coordinate.
+     * @param flags A TMXTileFlags.
+     * @return The tile gid at a given tile coordinate. It also returns the tile flags.
+     */
+    int getTileGIDAt(const Vec2& tileCoordinate, TMXTileFlags* flags = nullptr);
+
+    /** Sets the tile gid (gid = tile global id) at a given tile coordinate.
+     * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor -> Tileset Mgr +1.
+     * If a tile is already placed at that position, then it will be removed.
+     * @param gid The gid value.
+     * @param tileCoordinate The tile coordinate.
+     */
+    void setTileGID(int gid, const Vec2& tileCoordinate);
+
+    /** Sets the tile gid (gid = tile global id) at a given tile coordinate.
+     * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor -> Tileset Mgr +1.
+     * If a tile is already placed at that position, then it will be removed.
+     * Use withFlags if the tile flags need to be changed as well.
+     *
+     * @param gid A integer value,it will be sets the tile gid.
+     * @param tileCoordinate The tile coordinate.
+     * @param flags A TMXTileFlags.
+     */
+    void setTileGID(int gid, const Vec2& tileCoordinate, TMXTileFlags flags);
+
+    /** Removes a tile at given tile coordinate.
+     *
+     * @param tileCoordinate The tile Coordinate.
+     */
+    void removeTileAt(const Vec2& tileCoordinate);
+
+    /** Returns the position in points of a given tile coordinate.
+     *
+     * @param tileCoordinate The tile Coordinate.
+     * @return The position in points of a given tile coordinate.
      */
+    Vec2 getPositionAt(const Vec2& tileCoordinate);
 
-    class CC_DLL TMXLayer : public Node
+    /** Return the value for the specific property name.
+     *
+     * @param propertyName The value for the specific property name.
+     * @return The value for the specific property name.
+     */
+    Value getProperty(const std::string& propertyName) const;
+
+    /** Creates the tiles. */
+    void setupTiles();
+    
+    /** Get the tile layer name.
+     *
+     * @return The tile layer name.
+     */
+    const std::string& getLayerName() { return _layerName; }
+    
+    /** Set the tile layer name.
+     *
+     * @param layerName The new layer name.
+     */
+    void setLayerName(const std::string& layerName) { _layerName = layerName; }
+
+    /** Size of the layer in tiles.
+     *
+     * @return Size of the layer in tiles.
+     */
+    const Size& getLayerSize() const { return _layerSize; }
+    
+    /** Set the size of the layer in tiles. 
+     *
+     * @param size The new size of the layer in tiles.
+     */
+    void setLayerSize(const Size& size) { _layerSize = size; }
+    
+    /** Size of the map's tile (could be different from the tile's size).
+     *
+     * @return Size of the map's tile (could be different from the tile's size).
+     */
+    const Size& getMapTileSize() const { return _mapTileSize; }
+    
+    /** Set the size of the map's tile. 
+     *
+     * @param size The new size of the map's tile.
+     */
+    void setMapTileSize(const Size& size) { _mapTileSize = size; }
+    
+    /** Pointer to the map of tiles.
+     * @js NA
+     * @lua NA
+     * @return The pointer to the map of tiles.
+     */
+    const uint32_t* getTiles() const { return _tiles; };
+    
+    /** Set the pointer to the map of tiles.
+     *
+     * @param tiles The pointer to the map of tiles.
+     */
+    void setTiles(uint32_t* tiles) { _tiles = tiles; _quadsDirty = true;};
+    
+    /** Tileset information for the layer.
+     *
+     * @return Tileset information for the layer.
+     */
+    TMXTilesetInfo* getTileSet() const { return _tileSet; }
+    
+    /** Set the tileset information for the layer. 
+     *
+     * @param info The new tileset information for the layer.
+     */
+    void setTileSet(TMXTilesetInfo* info) {
+        CC_SAFE_RETAIN(info);
+        CC_SAFE_RELEASE(_tileSet);
+        _tileSet = info;
+    }
+    
+    /** Layer orientation, which is the same as the map orientation.
+     *
+     * @return Layer orientation, which is the same as the map orientation.
+     */
+    int getLayerOrientation() const { return _layerOrientation; }
+    
+    /** Set Layer orientation, which is the same as the map orientation. 
+     *
+     * @param orientation Layer orientation, which is the same as the map orientation.
+     */
+    void setLayerOrientation(int orientation) { _layerOrientation = orientation; }
+    
+    /** Properties from the layer. They can be added using Tiled. 
+     *
+     * @return Properties from the layer. They can be added using Tiled.
+     */
+    const ValueMap& getProperties() const { return _properties; }
+    
+    /** Properties from the layer. They can be added using Tiled.
+     *
+     * @return Properties from the layer. They can be added using Tiled.
+     */
+    ValueMap& getProperties() { return _properties; }
+    
+    /** Set the properties to the layer.
+     *
+     * @param properties The properties to the layer.
+     */
+    void setProperties(const ValueMap& properties)
     {
-    public:
-        /** Creates a FastTMXLayer with an tileset info, a layer info and a map info.
-         *
-         * @param tilesetInfo An tileset info.
-         * @param layerInfo A layer info.
-         * @param mapInfo A map info.
-         * @return Return an autorelease object.
-         */
-        static TMXLayer* create(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo);
-        /**
-         * @js ctor
-         */
-        TMXLayer();
-        /**
-         * @js NA
-         * @lua NA
-         */
-        ~TMXLayer() override;
-
-        /** Returns the tile gid at a given tile coordinate. It also returns the tile flags.
-         *
-         * @param tileCoordinate The tile coordinate.
-         * @param flags A TMXTileFlags.
-         * @return The tile gid at a given tile coordinate. It also returns the tile flags.
-         */
-        int getTileGIDAt(const Vec2& tileCoordinate, TMXTileFlags* flags = nullptr);
-
-        /** Sets the tile gid (gid = tile global id) at a given tile coordinate.
-         * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor -> Tileset Mgr +1.
-         * If a tile is already placed at that position, then it will be removed.
-         * @param gid The gid value.
-         * @param tileCoordinate The tile coordinate.
-         */
-        void setTileGID(int gid, const Vec2& tileCoordinate);
-
-        /** Sets the tile gid (gid = tile global id) at a given tile coordinate.
-         * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor -> Tileset Mgr +1.
-         * If a tile is already placed at that position, then it will be removed.
-         * Use withFlags if the tile flags need to be changed as well.
-         *
-         * @param gid A integer value,it will be sets the tile gid.
-         * @param tileCoordinate The tile coordinate.
-         * @param flags A TMXTileFlags.
-         */
-        void setTileGID(int gid, const Vec2& tileCoordinate, TMXTileFlags flags);
-
-        /** Removes a tile at given tile coordinate.
-         *
-         * @param tileCoordinate The tile Coordinate.
-         */
-        void removeTileAt(const Vec2& tileCoordinate);
-
-        /** Returns the position in points of a given tile coordinate.
-         *
-         * @param tileCoordinate The tile Coordinate.
-         * @return The position in points of a given tile coordinate.
-         */
-        Vec2 getPositionAt(const Vec2& tileCoordinate);
-
-        /** Return the value for the specific property name.
-         *
-         * @param propertyName The value for the specific property name.
-         * @return The value for the specific property name.
-         */
-        Value getProperty(const std::string& propertyName) const;
-
-        /** Creates the tiles. */
-        void setupTiles();
-
-        /** Get the tile layer name.
-         *
-         * @return The tile layer name.
-         */
-        const std::string& getLayerName() { return _layerName; }
-
-        /** Set the tile layer name.
-         *
-         * @param layerName The new layer name.
-         */
-        void setLayerName(const std::string& layerName) { _layerName = layerName; }
-
-        /** Size of the layer in tiles.
-         *
-         * @return Size of the layer in tiles.
-         */
-        const Size& getLayerSize() const { return _layerSize; }
-
-        /** Set the size of the layer in tiles.
-         *
-         * @param size The new size of the layer in tiles.
-         */
-        void setLayerSize(const Size& size) { _layerSize = size; }
-
-        /** Size of the map's tile (could be different from the tile's size).
-         *
-         * @return Size of the map's tile (could be different from the tile's size).
-         */
-        const Size& getMapTileSize() const { return _mapTileSize; }
-
-        /** Set the size of the map's tile.
-         *
-         * @param size The new size of the map's tile.
-         */
-        void setMapTileSize(const Size& size) { _mapTileSize = size; }
-
-        /** Pointer to the map of tiles.
-         * @js NA
-         * @lua NA
-         * @return The pointer to the map of tiles.
-         */
-        const uint32_t* getTiles() const { return _tiles; }
-
-        /** Set the pointer to the map of tiles.
-         *
-         * @param tiles The pointer to the map of tiles.
-         */
-        void setTiles(uint32_t* tiles)
-        {
-            _tiles = tiles;
-            _quadsDirty = true;
-        }
-
-        /** Tileset information for the layer.
-         *
-         * @return Tileset information for the layer.
-         */
-        TMXTilesetInfo* getTileSet() const { return _tileSet; }
-
-        /** Set the tileset information for the layer.
-         *
-         * @param info The new tileset information for the layer.
-         */
-        void setTileSet(TMXTilesetInfo* info)
-        {
-            CC_SAFE_RETAIN(info);
-            CC_SAFE_RELEASE(_tileSet);
-            _tileSet = info;
-        }
-
-        /** Layer orientation, which is the same as the map orientation.
-         *
-         * @return Layer orientation, which is the same as the map orientation.
-         */
-        int getLayerOrientation() const { return _layerOrientation; }
-
-        /** Set Layer orientation, which is the same as the map orientation.
-         *
-         * @param orientation Layer orientation, which is the same as the map orientation.
-         */
-        void setLayerOrientation(int orientation) { _layerOrientation = orientation; }
-
-        /** Properties from the layer. They can be added using Tiled.
-         *
-         * @return Properties from the layer. They can be added using Tiled.
-         */
-        const ValueMap& getProperties() const { return _properties; }
-
-        /** Properties from the layer. They can be added using Tiled.
-         *
-         * @return Properties from the layer. They can be added using Tiled.
-         */
-        ValueMap& getProperties() { return _properties; }
-
-        /** Set the properties to the layer.
-         *
-         * @param properties The properties to the layer.
-         */
-        void setProperties(const ValueMap& properties) { _properties = properties; }
-
-        /** Returns the tile (Sprite) at a given a tile coordinate.
-         * The returned Sprite will be already added to the TMXLayer. Don't add it again.
-         * The Sprite can be treated like any other Sprite: rotated, scaled, translated, opacity, color, etc.
-         * You can remove either by calling:
-         * - layer->removeChild(sprite, cleanup);
-         *
-         * @return Returns the tile (Sprite) at a given a tile coordinate.
-         */
-        Sprite* getTileAt(const Vec2& tileCoordinate);
-
-        /** Set an sprite to the tile,with the tile coordinate and gid.
-         *
-         * @param sprite A Sprite.
-         * @param pos The tile coordinate.
-         * @param gid The tile gid.
-         */
-        void setupTileSprite(Sprite* sprite, const Vec2& pos, int gid);
-
-        //
-        // Override
-        //
-        virtual std::string getDescription() const override;
-        virtual void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
-        void removeChild(Node* child, bool cleanup = true) override;
-
-    protected:
-        bool initWithTilesetInfo(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo);
-        void updateTiles(const Rect& culledRect);
-        Vec2 calculateLayerOffset(const Vec2& offset);
-
-        /* The layer recognizes some special properties, like cc_vertexz */
-        void parseInternalProperties();
-
-        Mat4 tileToNodeTransform();
-        Rect tileBoundsForClipTransform(const Mat4& tileToClip);
-
-        int getVertexZForPos(const Vec2& pos);
-
-        // Flip flags is packed into gid
-        void setFlaggedTileGIDByIndex(int index, int gid);
-
-        //
-        void updateTotalQuads();
-
-        void onDraw(Primitive* primitive);
-        int getTileIndexByPos(int x, int y) const { return x + y * static_cast<int>(_layerSize.width); }
-
-        void updateVertexBuffer();
-        void updateIndexBuffer();
-        void updatePrimitives();
-
-    protected:
-        //! name of the layer
-        std::string _layerName;
-
-        /** size of the layer in tiles */
-        Size _layerSize;
-        /** size of the map's tile (could be different from the tile's size) */
-        Size _mapTileSize;
-        /** pointer to the map of tiles */
-        std::uint32_t* _tiles;
-        /** Tileset information for the layer */
-        TMXTilesetInfo* _tileSet;
-        /** Layer orientation, which is the same as the map orientation */
-        int _layerOrientation;
-        /** properties from the layer. They can be added using Tiled */
-        ValueMap _properties;
-
-        Texture2D* _texture;
-
-        /** container for sprite children. map<index, pair<sprite, gid> > */
-        std::map<int, std::pair<Sprite*, int>> _spriteContainer;
-
-        // GLuint _buffersVBO; //0: vertex, 1: indices
-
-        Size _screenGridSize;
-        Rect _screenGridRect;
-        int _screenTileCount;
-
-        int _vertexZvalue;
-        bool _useAutomaticVertexZ;
-
-        /** tile coordinate to node coordinate transform */
-        Mat4 _tileToNodeTransform;
-        /** data for rendering */
-        bool _quadsDirty;
-        std::vector<int> _tileToQuadIndex;
-        std::vector<V3F_C4B_T2F_Quad> _totalQuads;
-        std::vector<GLushort> _indices;
-        std::map<int /*vertexZ*/, int /*offset to _indices by quads*/> _indicesVertexZOffsets;
-        std::unordered_map<int /*vertexZ*/, int /*number to quads*/> _indicesVertexZNumber;
-        std::vector<PrimitiveCommand> _renderCommands;
-        bool _dirty;
-
-        VertexBuffer* _vertexBuffer;
-
-        VertexData* _vData;
-
-        IndexBuffer* _indexBuffer;
-
-        Map<int, Primitive*> _primitives;
-
-    public:
-        /** Possible orientations of the TMX map */
-        static const int FAST_TMX_ORIENTATION_ORTHO;
-        static const int FAST_TMX_ORIENTATION_HEX;
-        static const int FAST_TMX_ORIENTATION_ISO;
-    };
-
-    // end of tilemap_parallax_nodes group
-    /// @}
-} // end of namespace experimental
+        _properties = properties;
+    }
+
+    /** Returns the tile (Sprite) at a given a tile coordinate.
+     * The returned Sprite will be already added to the TMXLayer. Don't add it again.
+     * The Sprite can be treated like any other Sprite: rotated, scaled, translated, opacity, color, etc.
+     * You can remove either by calling:
+     * - layer->removeChild(sprite, cleanup);
+     *
+     * @return Returns the tile (Sprite) at a given a tile coordinate.
+     */
+    Sprite* getTileAt(const Vec2& tileCoordinate);
+    
+    /** Set an sprite to the tile,with the tile coordinate and gid.
+     *
+     * @param sprite A Sprite.
+     * @param pos The tile coordinate.
+     * @param gid The tile gid.
+     */
+    void setupTileSprite(Sprite* sprite, const Vec2& pos, uint32_t gid);
+
+    //
+    // Override
+    //
+    virtual std::string getDescription() const override;
+    virtual void draw(Renderer *renderer, const Mat4& transform, uint32_t flags) override;
+    void removeChild(Node* child, bool cleanup = true) override;
+
+protected:
+    virtual void setOpacity(GLubyte opacity) override;
+
+    bool initWithTilesetInfo(TMXTilesetInfo *tilesetInfo, TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo);
+    void updateTiles(const Rect& culledRect);
+    Vec2 calculateLayerOffset(const Vec2& offset);
+
+    /* The layer recognizes some special properties, like cc_vertexz */
+    void parseInternalProperties();
+    
+    Mat4 tileToNodeTransform();
+    Rect tileBoundsForClipTransform(const Mat4 &tileToClip);
+    
+    int getVertexZForPos(const Vec2& pos);
+    
+    //Flip flags is packed into gid
+    void setFlaggedTileGIDByIndex(int index, uint32_t gid);
+    
+    //
+    void updateTotalQuads();
+    
+    int getTileIndexByPos(int x, int y) const { return x + y * (int) _layerSize.width; }
+    
+    void updateVertexBuffer();
+    void updateIndexBuffer();
+    void updatePrimitives();
+
+    //! name of the layer
+    std::string _layerName;
+
+    /** size of the layer in tiles */
+    Size _layerSize;
+    /** size of the map's tile (could be different from the tile's size) */
+    Size _mapTileSize;
+    /** pointer to the map of tiles */
+    uint32_t* _tiles = nullptr;
+    /** Tileset information for the layer */
+    TMXTilesetInfo* _tileSet = nullptr;
+    /** Layer orientation, which is the same as the map orientation */
+    int _layerOrientation = FAST_TMX_ORIENTATION_ORTHO;
+    /** properties from the layer. They can be added using Tiled */
+    ValueMap _properties;
+
+    Texture2D *_texture = nullptr;
+    
+    /** container for sprite children. map<index, pair<sprite, gid> > */
+    std::map<int, std::pair<Sprite*, int> > _spriteContainer;
+
+    Size _screenGridSize;
+    Rect _screenGridRect;
+    int _screenTileCount = 0;
+    
+    int _vertexZvalue = 0;
+    bool _useAutomaticVertexZ = false;
+    
+    /** tile coordinate to node coordinate transform */
+    Mat4 _tileToNodeTransform;
+    /** data for rendering */
+    bool _quadsDirty = true;
+    std::vector<int> _tileToQuadIndex;
+    std::vector<V3F_C4B_T2F_Quad> _totalQuads;
+#ifdef CC_FAST_TILEMAP_32_BIT_INDICES
+    std::vector<unsigned int> _indices;
+#else
+    std::vector<unsigned short> _indices;
+#endif
+    std::map<int/*vertexZ*/, int/*offset to _indices by quads*/> _indicesVertexZOffsets;
+    std::unordered_map<int/*vertexZ*/, int/*number to quads*/> _indicesVertexZNumber;
+    bool _dirty = true;
+    
+    backend::Buffer* _vertexBuffer = nullptr;
+    backend::Buffer* _indexBuffer = nullptr;
+
+    float _alphaFuncValue = 0.f;
+    std::unordered_map<int, CustomCommand*> _customCommands;
+    
+    backend::UniformLocation _mvpMatrixLocaiton;
+    backend::UniformLocation _textureLocation;
+    backend::UniformLocation _alphaValueLocation;
+    backend::ProgramState* _programState = nullptr;
+};
+
+// end of tilemap_parallax_nodes group
+/// @}
+} //end of namespace experimental
 NS_CC_END
-
-#endif // CC_2D_FASTTMXLAYER_H
diff --git a/cocos2d/cocos/2d/CCFastTMXTiledMap.cpp b/cocos2d/cocos/2d/CCFastTMXTiledMap.cpp
index 563eea6023..d6d7b89f9d 100644
--- a/cocos2d/cocos/2d/CCFastTMXTiledMap.cpp
+++ b/cocos2d/cocos/2d/CCFastTMXTiledMap.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2009-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,250 +26,239 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCFastTMXTiledMap.h>
-
 #include <cocos/2d/CCFastTMXLayer.h>
-#include <cocos/2d/CCNode.h>
-#include <cocos/2d/CCTMXObjectGroup.h>
-#include <cocos/2d/CCTMXXMLParser.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccMacros.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <algorithm>
-#include <cstdint>
-#include <new>
-#include <string>
-#include <unordered_map>
 
 NS_CC_BEGIN
-namespace experimental
-{
-    // implementation FastTMXTiledMap
+namespace experimental {
 
-    TMXTiledMap* TMXTiledMap::create(const std::string& tmxFile)
-    {
-        TMXTiledMap* ret = new (std::nothrow) TMXTiledMap();
-        if (ret->initWithTMXFile(tmxFile))
-        {
-            ret->autorelease();
-            return ret;
-        }
-        CC_SAFE_DELETE(ret);
-        return nullptr;
-    }
+// implementation FastTMXTiledMap
 
-    TMXTiledMap* TMXTiledMap::createWithXML(const std::string& tmxString, const std::string& resourcePath)
+TMXTiledMap * TMXTiledMap::create(const std::string& tmxFile)
+{
+    TMXTiledMap *ret = new (std::nothrow) TMXTiledMap();
+    if (ret->initWithTMXFile(tmxFile))
     {
-        TMXTiledMap* ret = new (std::nothrow) TMXTiledMap();
-        if (ret->initWithXML(tmxString, resourcePath))
-        {
-            ret->autorelease();
-            return ret;
-        }
-        CC_SAFE_DELETE(ret);
-        return nullptr;
+        ret->autorelease();
+        return ret;
     }
+    CC_SAFE_DELETE(ret);
+    return nullptr;
+}
 
-    bool TMXTiledMap::initWithTMXFile(const std::string& tmxFile)
+TMXTiledMap* TMXTiledMap::createWithXML(const std::string& tmxString, const std::string& resourcePath)
+{
+    TMXTiledMap *ret = new (std::nothrow) TMXTiledMap();
+    if (ret->initWithXML(tmxString, resourcePath))
     {
-        CCASSERT(tmxFile.size() > 0, "FastTMXTiledMap: tmx file should not be empty");
-
-        setContentSize(Size::ZERO);
+        ret->autorelease();
+        return ret;
+    }
+    CC_SAFE_DELETE(ret);
+    return nullptr;
+}
 
-        TMXMapInfo* mapInfo = TMXMapInfo::create(tmxFile);
+bool TMXTiledMap::initWithTMXFile(const std::string& tmxFile)
+{
+    CCASSERT(tmxFile.size()>0, "FastTMXTiledMap: tmx file should not be empty");
+    
+    setContentSize(Size::ZERO);
 
-        if (!mapInfo)
-        {
-            return false;
-        }
-        CCASSERT(!mapInfo->getTilesets().empty(), "FastTMXTiledMap: Map not found. Please check the filename.");
-        buildWithMapInfo(mapInfo);
+    TMXMapInfo *mapInfo = TMXMapInfo::create(tmxFile);
 
-        return true;
+    if (! mapInfo)
+    {
+        return false;
     }
+    CCASSERT( !mapInfo->getTilesets().empty(), "FastTMXTiledMap: Map not found. Please check the filename.");
+    buildWithMapInfo(mapInfo);
 
-    bool TMXTiledMap::initWithXML(const std::string& tmxString, const std::string& resourcePath)
-    {
-        setContentSize(Size::ZERO);
+    return true;
+}
 
-        TMXMapInfo* mapInfo = TMXMapInfo::createWithXML(tmxString, resourcePath);
+bool TMXTiledMap::initWithXML(const std::string& tmxString, const std::string& resourcePath)
+{
+    setContentSize(Size::ZERO);
 
-        CCASSERT(!mapInfo->getTilesets().empty(), "FastTMXTiledMap: Map not found. Please check the filename.");
-        buildWithMapInfo(mapInfo);
+    TMXMapInfo *mapInfo = TMXMapInfo::createWithXML(tmxString, resourcePath);
 
-        return true;
-    }
+    CCASSERT( !mapInfo->getTilesets().empty(), "FastTMXTiledMap: Map not found. Please check the filename.");
+    buildWithMapInfo(mapInfo);
 
-    TMXTiledMap::TMXTiledMap()
-    : _mapSize(Size::ZERO)
-    , _tileSize(Size::ZERO)
-    {
-    }
+    return true;
+}
 
-    TMXTiledMap::~TMXTiledMap() {}
+TMXTiledMap::TMXTiledMap()
+    :_mapSize(Size::ZERO)
+    ,_tileSize(Size::ZERO)        
+{
+}
 
-    // private
-    TMXLayer* TMXTiledMap::parseLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
-    {
-        TMXTilesetInfo* tileset = tilesetForLayer(layerInfo, mapInfo);
-        if (tileset == nullptr)
-            return nullptr;
+TMXTiledMap::~TMXTiledMap()
+{
+}
 
-        TMXLayer* layer = TMXLayer::create(tileset, layerInfo, mapInfo);
+// private
+TMXLayer * TMXTiledMap::parseLayer(TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo)
+{
+    TMXTilesetInfo *tileset = tilesetForLayer(layerInfo, mapInfo);
+    if (tileset == nullptr)
+        return nullptr;
+    
+    TMXLayer *layer = TMXLayer::create(tileset, layerInfo, mapInfo);
 
-        // tell the layerinfo to release the ownership of the tiles map.
-        layerInfo->_ownTiles = false;
-        layer->setupTiles();
+    // tell the layerinfo to release the ownership of the tiles map.
+    layerInfo->_ownTiles = false;
+    layer->setupTiles();
 
-        return layer;
-    }
+    return layer;
+}
 
-    TMXTilesetInfo* TMXTiledMap::tilesetForLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
-    {
-        Size size = layerInfo->_layerSize;
-        auto& tilesets = mapInfo->getTilesets();
+TMXTilesetInfo * TMXTiledMap::tilesetForLayer(TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo)
+{
+    Size size = layerInfo->_layerSize;
+    auto& tilesets = mapInfo->getTilesets();
 
-        for (auto iter = tilesets.crbegin(); iter != tilesets.crend(); ++iter)
+    for (auto iter = tilesets.crbegin(), iterCrend = tilesets.crend(); iter != iterCrend; ++iter)
+    {
+        TMXTilesetInfo* tilesetInfo = *iter;
+        if (tilesetInfo)
         {
-            TMXTilesetInfo* tilesetInfo = *iter;
-            if (tilesetInfo)
+            for( int y=0; y < size.height; y++ )
             {
-                for (int y = 0; y < size.height; y++)
+                for( int x=0; x < size.width; x++ )
                 {
-                    for (int x = 0; x < size.width; x++)
+                    uint32_t pos = static_cast<uint32_t>(x + size.width * y);
+                    uint32_t gid = layerInfo->_tiles[ pos ];
+                    
+                    // gid are stored in little endian.
+                    // if host is big endian, then swap
+                    //if( o == CFByteOrderBigEndian )
+                    //    gid = CFSwapInt32( gid );
+                    /* We support little endian.*/
+                    
+                    // FIXME: gid == 0 --> empty tile
+                    if( gid != 0 )
                     {
-                        int pos = static_cast<int>(x + size.width * y);
-                        int gid = layerInfo->_tiles[pos];
-
-                        // gid are stored in little endian.
-                        // if host is big endian, then swap
-                        // if( o == CFByteOrderBigEndian )
-                        //    gid = CFSwapInt32( gid );
-                        /* We support little endian.*/
-
-                        // FIXME: gid == 0 --> empty tile
-                        if (gid != 0)
+                        // Optimization: quick return
+                        // if the layer is invalid (more than 1 tileset per layer) an CCAssert will be thrown later
+                        if( (gid & kTMXFlippedMask)
+                            >= static_cast<uint32_t>(tilesetInfo->_firstGid))
                         {
-                            // Optimization: quick return
-                            // if the layer is invalid (more than 1 tileset per layer) an CCAssert will be thrown later
-                            if ((gid & kTMXFlippedMask) >= tilesetInfo->_firstGid)
-                                return tilesetInfo;
+                            return tilesetInfo;
                         }
                     }
                 }
             }
         }
-
-        // If all the tiles are 0, return empty tileset
-        CCLOG("cocos2d: Warning: TMX Layer '%s' has no tiles", layerInfo->_name.c_str());
-        return nullptr;
     }
 
-    void TMXTiledMap::buildWithMapInfo(TMXMapInfo* mapInfo)
-    {
-        _mapSize = mapInfo->getMapSize();
-        _tileSize = mapInfo->getTileSize();
-        _mapOrientation = mapInfo->getOrientation();
+    // If all the tiles are 0, return empty tileset
+    CCLOG("cocos2d: Warning: TMX Layer '%s' has no tiles", layerInfo->_name.c_str());
+    return nullptr;
+}
 
-        _objectGroups = mapInfo->getObjectGroups();
+void TMXTiledMap::buildWithMapInfo(TMXMapInfo* mapInfo)
+{
+    _mapSize = mapInfo->getMapSize();
+    _tileSize = mapInfo->getTileSize();
+    _mapOrientation = mapInfo->getOrientation();
 
-        _properties = mapInfo->getProperties();
+    _objectGroups = mapInfo->getObjectGroups();
 
-        _tileProperties = mapInfo->getTileProperties();
+    _properties = mapInfo->getProperties();
 
-        int idx = 0;
+    _tileProperties = mapInfo->getTileProperties();
 
-        auto& layers = mapInfo->getLayers();
-        for (const auto& layerInfo : layers)
-        {
-            if (layerInfo->_visible)
-            {
-                TMXLayer* child = parseLayer(layerInfo, mapInfo);
-                if (child == nullptr)
-                {
-                    idx++;
-                    continue;
-                }
-                addChild(child, idx, idx);
-
-                // update content size with the max size
-                const Size& childSize = child->getContentSize();
-                Size currentSize = this->getContentSize();
-                currentSize.width = std::max(currentSize.width, childSize.width);
-                currentSize.height = std::max(currentSize.height, childSize.height);
-                this->setContentSize(currentSize);
+    int idx=0;
 
+    auto& layers = mapInfo->getLayers();
+    for(const auto &layerInfo : layers) {
+        if (layerInfo->_visible)
+        {
+            TMXLayer *child = parseLayer(layerInfo, mapInfo);
+            if (child == nullptr) {
                 idx++;
+                continue;
             }
+            addChild(child, idx, idx);
+            
+            // update content size with the max size
+            const Size& childSize = child->getContentSize();
+            Size currentSize = this->getContentSize();
+            currentSize.width = std::max( currentSize.width, childSize.width );
+            currentSize.height = std::max( currentSize.height, childSize.height );
+            this->setContentSize(currentSize);
+            
+            idx++;
         }
     }
+}
 
-    // public
-    TMXLayer* TMXTiledMap::getLayer(const std::string& layerName) const
+// public
+TMXLayer * TMXTiledMap::getLayer(const std::string& layerName) const
+{
+    CCASSERT(layerName.size() > 0, "Invalid layer name!");
+    
+    for (auto& child : _children)
     {
-        CCASSERT(layerName.size() > 0, "Invalid layer name!");
-
-        for (auto& child : _children)
+        TMXLayer* layer = dynamic_cast<TMXLayer*>(child);
+        if(layer)
         {
-            TMXLayer* layer = dynamic_cast<TMXLayer*>(child);
-            if (layer)
+            if(layerName.compare( layer->getLayerName()) == 0)
             {
-                if (layerName.compare(layer->getLayerName()) == 0)
-                {
-                    return layer;
-                }
+                return layer;
             }
         }
-
-        // layer not found
-        return nullptr;
     }
 
-    TMXObjectGroup* TMXTiledMap::getObjectGroup(const std::string& groupName) const
-    {
-        CCASSERT(groupName.size() > 0, "Invalid group name!");
+    // layer not found
+    return nullptr;
+}
+
+TMXObjectGroup * TMXTiledMap::getObjectGroup(const std::string& groupName) const
+{
+    CCASSERT(groupName.size() > 0, "Invalid group name!");
 
-        if (_objectGroups.size() > 0)
+    if (_objectGroups.size()>0)
+    {
+        for (const auto& objectGroup : _objectGroups)
         {
-            TMXObjectGroup* objectGroup = nullptr;
-            for (auto iter = _objectGroups.cbegin(); iter != _objectGroups.cend(); ++iter)
+            if (objectGroup && objectGroup->getGroupName() == groupName)
             {
-                objectGroup = *iter;
-                if (objectGroup && objectGroup->getGroupName() == groupName)
-                {
-                    return objectGroup;
-                }
+                return objectGroup;
             }
         }
-
-        // objectGroup not found
-        return nullptr;
-    }
-
-    Value TMXTiledMap::getProperty(const std::string& propertyName) const
-    {
-        if (_properties.find(propertyName) != _properties.end())
-            return _properties.at(propertyName);
-
-        return Value();
     }
 
-    Value TMXTiledMap::getPropertiesForGID(int GID) const
-    {
-        if (_tileProperties.find(GID) != _tileProperties.end())
-            return _tileProperties.at(GID);
-
-        return Value();
-    }
+    // objectGroup not found
+    return nullptr;
+}
 
-    std::string TMXTiledMap::getDescription() const
-    {
-        return StringUtils::format("<FastTMXTiledMap | Tag = %d, Layers = %d", _tag, static_cast<int>(_children.size()));
-    }
+Value TMXTiledMap::getProperty(const std::string& propertyName) const
+{
+    auto propsItr = _properties.find(propertyName);
+    if (propsItr != _properties.end())
+        return propsItr->second;
+    
+    return Value();
+}
+
+Value TMXTiledMap::getPropertiesForGID(int GID) const
+{
+    auto propsItr = _tileProperties.find(GID);
+    if (propsItr != _tileProperties.end())
+        return propsItr->second;
+    
+    return Value();
+}
+
+std::string TMXTiledMap::getDescription() const
+{
+    return StringUtils::format("<FastTMXTiledMap | Tag = %d, Layers = %d", _tag, static_cast<int>(_children.size()));
+}
 
-} // end of namespace experimental
+} //end of namespace experimental
 
 NS_CC_END
+
diff --git a/cocos2d/cocos/2d/CCFastTMXTiledMap.h b/cocos2d/cocos/2d/CCFastTMXTiledMap.h
index 68f5548605..007ddbc041 100644
--- a/cocos2d/cocos/2d/CCFastTMXTiledMap.h
+++ b/cocos2d/cocos/2d/CCFastTMXTiledMap.h
@@ -3,6 +3,7 @@ Copyright (c) 2009-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,19 +25,11 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_FASTTMXTILEDMAP_H
-#define CC_2D_FASTTMXTILEDMAP_H
+#ifndef __CC_FAST_TMX_TILEMAP_H__
+#define __CC_FAST_TMX_TILEMAP_H__
 
 #include <cocos/2d/CCNode.h>
 #include <cocos/2d/CCTMXObjectGroup.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
-#include <vector>
 
 NS_CC_BEGIN
 
@@ -44,214 +37,221 @@ class TMXLayerInfo;
 class TMXTilesetInfo;
 class TMXMapInfo;
 
-namespace experimental
+namespace experimental {
+    
+class TMXLayer;
+/**
+ * @addtogroup _2d
+ * @{
+ */
+    
+/** @brief FastTMXTiledMap knows how to parse and render a TMX map.
+
+ * It adds support for the TMX tiled map format used by http://www.mapeditor.org.
+ * It supports isometric, hexagonal and orthogonal tiles.
+ * It also supports object groups, objects, and properties.
+
+ * Features:
+ * - Each tile will be treated as an Sprite.
+ * - The sprites are created on demand. They will be created only when you call "layer->tileAt(position)".
+ * - Each tile can be rotated / moved / scaled / tinted / "opaqued", since each tile is a Sprite.
+ * - Tiles can be added/removed in runtime.
+ * - The z-order of the tiles can be modified in runtime.
+ * - Each tile has an anchorPoint of (0,0).
+ * - The anchorPoint of the TMXTileMap is (0,0).
+ * - The TMX layers will be added as a child.
+ * - The TMX layers will be aliased by default.
+ * - The tileset image will be loaded using the TextureCache.
+ * - Each tile will have a unique tag.
+ * - Each tile will have a unique z value. top-left: z=1, bottom-right: z=max z.
+ * - Each object group will be treated as an MutableArray.
+ * - Object class which will contain all the properties in a dictionary.
+ * - Properties can be assigned to the Map, Layer, Object Group, and Object.
+
+ * Limitations:
+ * - It only supports one tileset per layer.
+ * - Embedded images are not supported.
+ * - It only supports the XML format (the JSON format is not supported).
+
+ * Technical description:
+ * Each layer is created using an FastTMXLayer (subclass of SpriteBatchNode). If you have 5 layers, then 5 FastTMXLayer will be created,
+ * unless the layer visibility is off. In that case, the layer won't be created at all.
+ * You can obtain the layers (FastTMXLayer objects) at runtime by:
+ * - map->getChildByTag(tag_number);  // 0=1st layer, 1=2nd layer, 2=3rd layer, etc...
+ * - map->getLayer(name_of_the_layer);
+
+ * Each object group is created using a TMXObjectGroup which is a subclass of MutableArray.
+ * You can obtain the object groups at runtime by:
+ * - map->getObjectGroup(name_of_the_object_group);
+
+ * Each object is a TMXObject.
+
+ * Each property is stored as a key-value pair in an MutableDictionary.
+ * You can obtain the properties at runtime by:
+
+ * map->getProperty(name_of_the_property);
+ * layer->getProperty(name_of_the_property);
+ * objectGroup->getProperty(name_of_the_property);
+ * object->getProperty(name_of_the_property);
+
+ * @since v3.2
+ * @js NA
+ */
+class CC_DLL TMXTiledMap : public Node
 {
-    class TMXLayer;
-    /**
-     * @addtogroup _2d
-     * @{
+public:
+    /** Creates a TMX Tiled Map with a TMX file.
+     *
+     * @return An autorelease object.
+     */
+    static TMXTiledMap* create(const std::string& tmxFile);
+
+    /** Initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources. 
+     *
+     * @param tmxString A TMX formatted XML string.
+     * @param resourcePath A path to TMX resources.
+     * @return An autorelease object.
+     */
+    static TMXTiledMap* createWithXML(const std::string& tmxString, const std::string& resourcePath);
+
+    /** Return the FastTMXLayer for the specific layer. 
+     * 
+     * @return Return the FastTMXLayer for the specific layer.
+     */
+    TMXLayer* getLayer(const std::string& layerName) const;
+
+    /** Return the TMXObjectGroup for the specific group. 
+     * 
+     * @return Return the TMXObjectGroup for the specific group.
+     */
+    TMXObjectGroup* getObjectGroup(const std::string& groupName) const;
+
+    /** Return the value for the specific property name.
+     *
+     * @return Return the value for the specific property name.
+     */
+    Value getProperty(const std::string& propertyName) const;
+
+    /** Return properties dictionary for tile GID.
+     *
+     * @return Return properties dictionary for tile GID.
+     */
+    Value getPropertiesForGID(int GID) const;
+
+    /** The map's size property measured in tiles. 
+     *
+     * @return The map's size property measured in tiles.
+     */
+    const Size& getMapSize() const { return _mapSize; }
+    
+    /** Set the map's size property measured in tiles.
+     *
+     * @param mapSize The map's size property measured in tiles.
+     */
+    void setMapSize(const Size& mapSize) { _mapSize = mapSize; }
+
+    /** The tiles's size property measured in pixels.
+     *
+     * @return The tiles's size property measured in pixels.
+     */
+    const Size& getTileSize() const { return _tileSize; }
+    
+    /** Set the tiles's size property measured in pixels. 
+     *
+     * @param tileSize The tiles's size property measured in pixels.
+     */
+    void setTileSize(const Size& tileSize) { _tileSize = tileSize; }
+
+    /** Get map orientation. 
+     *
+     * @return The map orientation.
+     */
+    int getMapOrientation() const { return _mapOrientation; }
+    
+    /** Set map orientation. 
+     *
+     * @param mapOrientation The map orientation.
+     */
+    void setMapOrientation(int mapOrientation) { _mapOrientation = mapOrientation; }
+
+    /** Get object groups. 
+     *
+     * @return Object groups.
+     */
+    const Vector<TMXObjectGroup*>& getObjectGroups() const { return _objectGroups; }
+    Vector<TMXObjectGroup*>& getObjectGroups() { return _objectGroups; }
+    
+    /** Set object groups. 
+     *
+     * @param groups An object groups.
      */
+    void setObjectGroups(const Vector<TMXObjectGroup*>& groups) {
+        _objectGroups = groups;
+    }
+    
+    /** Get properties.
+     *
+     * @return Properties.
+     */
+    const ValueMap& getProperties() const { return _properties; }
+    
+    /** Set properties. 
+     *
+     * @param properties An ValueMap Properties.
+     */
+    void setProperties(const ValueMap& properties) {
+        _properties = properties;
+    }
 
-    /** @brief FastTMXTiledMap knows how to parse and render a TMX map.
-
-     * It adds support for the TMX tiled map format used by http://www.mapeditor.org.
-     * It supports isometric, hexagonal and orthogonal tiles.
-     * It also supports object groups, objects, and properties.
-
-     * Features:
-     * - Each tile will be treated as an Sprite.
-     * - The sprites are created on demand. They will be created only when you call "layer->tileAt(position)".
-     * - Each tile can be rotated / moved / scaled / tinted / "opaqued", since each tile is a Sprite.
-     * - Tiles can be added/removed in runtime.
-     * - The z-order of the tiles can be modified in runtime.
-     * - Each tile has an anchorPoint of (0,0).
-     * - The anchorPoint of the TMXTileMap is (0,0).
-     * - The TMX layers will be added as a child.
-     * - The TMX layers will be aliased by default.
-     * - The tileset image will be loaded using the TextureCache.
-     * - Each tile will have a unique tag.
-     * - Each tile will have a unique z value. top-left: z=1, bottom-right: z=max z.
-     * - Each object group will be treated as an MutableArray.
-     * - Object class which will contain all the properties in a dictionary.
-     * - Properties can be assigned to the Map, Layer, Object Group, and Object.
-
-     * Limitations:
-     * - It only supports one tileset per layer.
-     * - Embedded images are not supported.
-     * - It only supports the XML format (the JSON format is not supported).
-
-     * Technical description:
-     * Each layer is created using an FastTMXLayer (subclass of SpriteBatchNode). If you have 5 layers, then 5 FastTMXLayer will be created,
-     * unless the layer visibility is off. In that case, the layer won't be created at all.
-     * You can obtain the layers (FastTMXLayer objects) at runtime by:
-     * - map->getChildByTag(tag_number);  // 0=1st layer, 1=2nd layer, 2=3rd layer, etc...
-     * - map->getLayer(name_of_the_layer);
-
-     * Each object group is created using a TMXObjectGroup which is a subclass of MutableArray.
-     * You can obtain the object groups at runtime by:
-     * - map->getObjectGroup(name_of_the_object_group);
-
-     * Each object is a TMXObject.
-
-     * Each property is stored as a key-value pair in an MutableDictionary.
-     * You can obtain the properties at runtime by:
-
-     * map->getProperty(name_of_the_property);
-     * layer->getProperty(name_of_the_property);
-     * objectGroup->getProperty(name_of_the_property);
-     * object->getProperty(name_of_the_property);
-
-     * @since v3.2
+    virtual std::string getDescription() const override;
+
+protected:
+    /**
+     * @js ctor
+     */
+    TMXTiledMap();
+    /**
      * @js NA
+     * @lua NA
      */
-    class CC_DLL TMXTiledMap : public Node
-    {
-    public:
-        /** Creates a TMX Tiled Map with a TMX file.
-         *
-         * @return An autorelease object.
-         */
-        static TMXTiledMap* create(const std::string& tmxFile);
-
-        /** Initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources.
-         *
-         * @param tmxString A TMX formatted XML string.
-         * @param resourcePath A path to TMX resources.
-         * @return An autorelease object.
-         */
-        static TMXTiledMap* createWithXML(const std::string& tmxString, const std::string& resourcePath);
-
-        /** Return the FastTMXLayer for the specific layer.
-         *
-         * @return Return the FastTMXLayer for the specific layer.
-         */
-        TMXLayer* getLayer(const std::string& layerName) const;
-
-        /** Return the TMXObjectGroup for the specific group.
-         *
-         * @return Return the TMXObjectGroup for the specific group.
-         */
-        TMXObjectGroup* getObjectGroup(const std::string& groupName) const;
-
-        /** Return the value for the specific property name.
-         *
-         * @return Return the value for the specific property name.
-         */
-        Value getProperty(const std::string& propertyName) const;
-
-        /** Return properties dictionary for tile GID.
-         *
-         * @return Return properties dictionary for tile GID.
-         */
-        Value getPropertiesForGID(int GID) const;
-
-        /** The map's size property measured in tiles.
-         *
-         * @return The map's size property measured in tiles.
-         */
-        const Size& getMapSize() const { return _mapSize; }
-
-        /** Set the map's size property measured in tiles.
-         *
-         * @param mapSize The map's size property measured in tiles.
-         */
-        void setMapSize(const Size& mapSize) { _mapSize = mapSize; }
-
-        /** The tiles's size property measured in pixels.
-         *
-         * @return The tiles's size property measured in pixels.
-         */
-        const Size& getTileSize() const { return _tileSize; }
-
-        /** Set the tiles's size property measured in pixels.
-         *
-         * @param tileSize The tiles's size property measured in pixels.
-         */
-        void setTileSize(const Size& tileSize) { _tileSize = tileSize; }
-
-        /** Get map orientation.
-         *
-         * @return The map orientation.
-         */
-        int getMapOrientation() const { return _mapOrientation; }
-
-        /** Set map orientation.
-         *
-         * @param mapOrientation The map orientation.
-         */
-        void setMapOrientation(int mapOrientation) { _mapOrientation = mapOrientation; }
-
-        /** Get object groups.
-         *
-         * @return Object groups.
-         */
-        const Vector<TMXObjectGroup*>& getObjectGroups() const { return _objectGroups; }
-        Vector<TMXObjectGroup*>& getObjectGroups() { return _objectGroups; }
-
-        /** Set object groups.
-         *
-         * @param groups An object groups.
-         */
-        void setObjectGroups(const Vector<TMXObjectGroup*>& groups) { _objectGroups = groups; }
-
-        /** Get properties.
-         *
-         * @return Properties.
-         */
-        const ValueMap& getProperties() const { return _properties; }
-
-        /** Set properties.
-         *
-         * @param properties An ValueMap Properties.
-         */
-        void setProperties(const ValueMap& properties) { _properties = properties; }
-
-        virtual std::string getDescription() const override;
-
-    protected:
-        /**
-         * @js ctor
-         */
-        TMXTiledMap();
-        /**
-         * @js NA
-         * @lua NA
-         */
-        ~TMXTiledMap() override;
-
-        /** initializes a TMX Tiled Map with a TMX file */
-        bool initWithTMXFile(const std::string& tmxFile);
-
-        /** initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources */
-        bool initWithXML(const std::string& tmxString, const std::string& resourcePath);
-
-        TMXLayer* parseLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo);
-        TMXTilesetInfo* tilesetForLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo);
-        void buildWithMapInfo(TMXMapInfo* mapInfo);
-
-        /** the map's size property measured in tiles */
-        Size _mapSize;
-        /** the tiles's size property measured in pixels */
-        Size _tileSize;
-        /** map orientation */
-        int _mapOrientation;
-        /** object groups */
-        Vector<TMXObjectGroup*> _objectGroups;
-        /** properties */
-        ValueMap _properties;
-
-        //! tile properties
-        ValueMapIntKey _tileProperties;
-
-    private:
-        CC_DISALLOW_COPY_AND_ASSIGN(TMXTiledMap)
-    };
-
-    // end of tilemap_parallax_nodes group
-    /** @} */
-
-} // end of namespace experimental
+    virtual ~TMXTiledMap();
+
+    /** initializes a TMX Tiled Map with a TMX file */
+    bool initWithTMXFile(const std::string& tmxFile);
+
+    /** initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources */
+    bool initWithXML(const std::string& tmxString, const std::string& resourcePath);
+    
+    TMXLayer * parseLayer(TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo);
+    TMXTilesetInfo * tilesetForLayer(TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo);
+    void buildWithMapInfo(TMXMapInfo* mapInfo);
+
+    /** the map's size property measured in tiles */
+    Size _mapSize;
+    /** the tiles's size property measured in pixels */
+    Size _tileSize;
+    /** map orientation */
+    int _mapOrientation;
+    /** object groups */
+    Vector<TMXObjectGroup*> _objectGroups;
+    /** properties */
+    ValueMap _properties;
+    
+    //! tile properties
+    ValueMapIntKey _tileProperties;
+
+private:
+    CC_DISALLOW_COPY_AND_ASSIGN(TMXTiledMap);
+
+};
+
+// end of tilemap_parallax_nodes group
+/** @} */
+    
+} //end of namespace experimental
 
 NS_CC_END
 
-#endif // CC_2D_FASTTMXTILEDMAP_H
+#endif //__CCTMX_TILE_MAP2_H__
+
+
diff --git a/cocos2d/cocos/2d/CCFont.cpp b/cocos2d/cocos/2d/CCFont.cpp
index 306d3fd5b5..f41166c23a 100644
--- a/cocos2d/cocos/2d/CCFont.cpp
+++ b/cocos2d/cocos/2d/CCFont.cpp
@@ -1,11 +1,24 @@
-#include "CCFont.h"
+/****************************************************************************
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
+ http://www.cocos2d-x.org
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ THE SOFTWARE.
+ ****************************************************************************/
 
-#include <cocos/platform/CCPlatformMacros.h>
-
-NS_CC_BEGIN
-
-Font::~Font()
-{
-}
-
-NS_CC_END
diff --git a/cocos2d/cocos/2d/CCFont.h b/cocos2d/cocos/2d/CCFont.h
index 2f529026fe..8efb248cb6 100644
--- a/cocos2d/cocos/2d/CCFont.h
+++ b/cocos2d/cocos/2d/CCFont.h
@@ -1,19 +1,20 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -23,16 +24,14 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_FONT_H
-#define CC_2D_FONT_H
+#ifndef _CCFont_h_
+#define _CCFont_h_
 
 /// @cond DO_NOT_SHOW
 
-#include <cocos/base/CCRef.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
 #include <string>
+#include <cocos/base/ccTypes.h>
+#include <cocos/base/ccUTF8.h>
 
 NS_CC_BEGIN
 
@@ -41,16 +40,12 @@ class FontAtlas;
 class CC_DLL Font : public Ref
 {
 public:
-    ~Font() override;
-
     virtual FontAtlas* createFontAtlas() = 0;
-
-    virtual int* getHorizontalKerningForTextUTF16(const std::u16string& text, int& outNumLetters) const = 0;
-
+    virtual int* getHorizontalKerningForTextUTF32(const std::u32string& text, int &outNumLetters) const = 0;
     virtual int getFontMaxHeight() const { return 0; }
 };
 
 NS_CC_END
 
 /// @endcond
-#endif // CC_2D_FONT_H
+#endif
diff --git a/cocos2d/cocos/2d/CCFontAtlas.cpp b/cocos2d/cocos/2d/CCFontAtlas.cpp
index 0f624f02b7..f31412a75b 100644
--- a/cocos2d/cocos/2d/CCFontAtlas.cpp
+++ b/cocos2d/cocos/2d/CCFontAtlas.cpp
@@ -1,7 +1,8 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
 
  Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -24,21 +25,17 @@
  ****************************************************************************/
 
 #include <cocos/2d/CCFontAtlas.h>
-
+#if CC_TARGET_PLATFORM != CC_PLATFORM_WIN32 && CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID
+#include <iconv.h>
+#elif CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID
+#include <cocos/platform/android/jni/Java_org_cocos2dx_lib_Cocos2dxHelper.h>
+#endif
 #include <cocos/2d/CCFontFreeType.h>
+#include <cocos/base/ccUTF8.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/CCEventListenerCustom.h>
+#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/CCEventType.h>
-#include <cocos/base/ccUTF8.h>
-#include <cocos/platform/CCPlatformConfig.h>
-#include <cocos/renderer/CCTexture2D.h>
-
-#if CC_TARGET_PLATFORM != CC_PLATFORM_WIN32 && CC_TARGET_PLATFORM != CC_PLATFORM_WINRT && CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID
-#    include <iconv.h>
-#elif CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID
-#    include "platform/android/jni/Java_org_cocos2dx_lib_Cocos2dxHelper.h"
-#endif
 
 NS_CC_BEGIN
 
@@ -47,61 +44,66 @@ const int FontAtlas::CacheTextureHeight = 512;
 const char* FontAtlas::CMD_PURGE_FONTATLAS = "__cc_PURGE_FONTATLAS";
 const char* FontAtlas::CMD_RESET_FONTATLAS = "__cc_RESET_FONTATLAS";
 
-FontAtlas::FontAtlas(Font& theFont)
+FontAtlas::FontAtlas(Font &theFont) 
 : _font(&theFont)
-, _fontFreeType(nullptr)
-, _iconv(nullptr)
-, _currentPageData(nullptr)
-, _fontAscender(0)
-, _rendererRecreatedListener(nullptr)
-, _antialiasEnabled(true)
-, _currLineHeight(0)
 {
     _font->retain();
 
     _fontFreeType = dynamic_cast<FontFreeType*>(_font);
     if (_fontFreeType)
     {
-        _lineHeight = _font->getFontMaxHeight();
+        _lineHeight = (float)_font->getFontMaxHeight();
         _fontAscender = _fontFreeType->getFontAscender();
-        auto texture = new (std::nothrow) Texture2D;
-        _currentPage = 0;
-        _currentPageOrigX = 0;
-        _currentPageOrigY = 0;
         _letterEdgeExtend = 2;
-        _letterPadding = 0;
 
         if (_fontFreeType->isDistanceFieldEnabled())
         {
-            _letterPadding += 2 * FontFreeType::DistanceMapSpread;
+            _letterPadding += 2 * FontFreeType::DistanceMapSpread;    
         }
-        _currentPageDataSize = CacheTextureWidth * CacheTextureHeight;
-        auto outlineSize = _fontFreeType->getOutlineSize();
-        if (outlineSize > 0)
-        {
-            _lineHeight += 2 * outlineSize;
-            _currentPageDataSize *= 2;
-        }
-
-        _currentPageData = new (std::nothrow) unsigned char[_currentPageDataSize];
-        memset(_currentPageData, 0, _currentPageDataSize);
-
-        auto pixelFormat = outlineSize > 0 ? Texture2D::PixelFormat::AI88 : Texture2D::PixelFormat::A8;
-        texture->initWithData(_currentPageData, _currentPageDataSize, pixelFormat, CacheTextureWidth, CacheTextureHeight,
-                              Size(CacheTextureWidth, CacheTextureHeight));
-
-        addTexture(texture, 0);
-        texture->release();
-
+        
 #if CC_ENABLE_CACHE_TEXTURE_DATA
         auto eventDispatcher = Director::getInstance()->getEventDispatcher();
 
-        _rendererRecreatedListener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, [this](EventCustom* evt) { listenRendererRecreated(evt); });
+        _rendererRecreatedListener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, CC_CALLBACK_1(FontAtlas::listenRendererRecreated, this));
         eventDispatcher->addEventListenerWithFixedPriority(_rendererRecreatedListener, 1);
 #endif
     }
 }
 
+void FontAtlas::reinit()
+{
+    if (_currentPageData)
+    {
+        delete []_currentPageData;
+        _currentPageData = nullptr;
+    }
+    
+    CC_SAFE_DELETE_ARRAY(_currentPageDataRGBA);
+    
+    auto texture = new (std::nothrow) Texture2D;
+    
+    _currentPageDataSize = CacheTextureWidth * CacheTextureHeight;
+    
+    auto outlineSize = _fontFreeType->getOutlineSize();
+    if(outlineSize > 0)
+    {
+        _lineHeight += 2 * outlineSize;
+        _currentPageDataSize *= 2;
+        
+        _currentPageDataSizeRGBA = _currentPageDataSize * 2;
+        _currentPageDataRGBA = new (std::nothrow) unsigned char[_currentPageDataSizeRGBA];
+        memset(_currentPageDataRGBA, 0, _currentPageDataSizeRGBA);
+    }
+    
+    _currentPageData = new (std::nothrow) unsigned char[_currentPageDataSize];
+    memset(_currentPageData, 0, _currentPageDataSize);
+    
+    initTextureWithZeros(texture);
+
+    addTexture(texture,0);
+    texture->release();
+}
+
 FontAtlas::~FontAtlas()
 {
 #if CC_ENABLE_CACHE_TEXTURE_DATA
@@ -116,9 +118,9 @@ FontAtlas::~FontAtlas()
     _font->release();
     releaseTextures();
 
-    delete[] _currentPageData;
+    delete []_currentPageData;
 
-#if CC_TARGET_PLATFORM != CC_PLATFORM_WIN32 && CC_TARGET_PLATFORM != CC_PLATFORM_WINRT && CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID
+#if CC_TARGET_PLATFORM != CC_PLATFORM_WIN32 && CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID
     if (_iconv)
     {
         iconv_close(_iconv);
@@ -127,20 +129,45 @@ FontAtlas::~FontAtlas()
 #endif
 }
 
+void FontAtlas::initTextureWithZeros(Texture2D *texture)
+{
+    char *zeros = nullptr;    
+    backend::PixelFormat pixelFormat;
+    float outlineSize = _fontFreeType->getOutlineSize();
+    size_t zeroBytes = 0;
+    if (outlineSize > 0)
+    {    
+        //metal do no support AI88 format
+        pixelFormat = backend::PixelFormat::RGBA8888;
+        zeroBytes = CacheTextureWidth * CacheTextureWidth * 4;
+    }
+    else
+    {
+        pixelFormat = backend::PixelFormat::A8;
+        zeroBytes = CacheTextureWidth * CacheTextureWidth;
+    }
+    zeros = new char[zeroBytes]();
+    //std::fill(zeros, zeros + cnt, 0);
+    texture->initWithData(zeros, zeroBytes, pixelFormat, CacheTextureWidth, CacheTextureHeight, Size(CacheTextureWidth, CacheTextureHeight));
+    delete[] zeros;
+}
+
 void FontAtlas::reset()
 {
     releaseTextures();
-
+    
     _currLineHeight = 0;
     _currentPage = 0;
     _currentPageOrigX = 0;
     _currentPageOrigY = 0;
     _letterDefinitions.clear();
+    
+    reinit();
 }
 
 void FontAtlas::releaseTextures()
 {
-    for (auto& item : _atlasTextures)
+    for( auto &item: _atlasTextures)
     {
         item.second->release();
     }
@@ -153,37 +180,36 @@ void FontAtlas::purgeTexturesAtlas()
     {
         reset();
         auto eventDispatcher = Director::getInstance()->getEventDispatcher();
-        eventDispatcher->dispatchCustomEvent(CMD_PURGE_FONTATLAS, this);
-        eventDispatcher->dispatchCustomEvent(CMD_RESET_FONTATLAS, this);
+        eventDispatcher->dispatchCustomEvent(CMD_PURGE_FONTATLAS,this);
+        eventDispatcher->dispatchCustomEvent(CMD_RESET_FONTATLAS,this);
     }
 }
 
-void FontAtlas::listenRendererRecreated(EventCustom* event)
+void FontAtlas::listenRendererRecreated(EventCustom * /*event*/)
 {
     purgeTexturesAtlas();
 }
 
-void FontAtlas::addLetterDefinition(char16_t utf16Char, const FontLetterDefinition& letterDefinition)
+void FontAtlas::addLetterDefinition(char32_t utf32Char, const FontLetterDefinition &letterDefinition)
 {
-    _letterDefinitions[utf16Char] = letterDefinition;
+    _letterDefinitions[utf32Char] = letterDefinition;
 }
 
 void FontAtlas::scaleFontLetterDefinition(float scaleFactor)
 {
-    for (auto&& fontDefinition : _letterDefinitions)
-    {
+    for (auto&& fontDefinition : _letterDefinitions) {
         auto& letterDefinition = fontDefinition.second;
         letterDefinition.width *= scaleFactor;
         letterDefinition.height *= scaleFactor;
         letterDefinition.offsetX *= scaleFactor;
         letterDefinition.offsetY *= scaleFactor;
-        letterDefinition.xAdvance *= scaleFactor;
+        letterDefinition.xAdvance = (int)(letterDefinition.xAdvance * scaleFactor);
     }
 }
 
-bool FontAtlas::getLetterDefinitionForChar(char16_t utf16Char, FontLetterDefinition& letterDefinition)
+bool FontAtlas::getLetterDefinitionForChar(char32_t utf32Char, FontLetterDefinition &letterDefinition)
 {
-    auto outIterator = _letterDefinitions.find(utf16Char);
+    auto outIterator = _letterDefinitions.find(utf32Char);
 
     if (outIterator != _letterDefinitions.end())
     {
@@ -196,64 +222,66 @@ bool FontAtlas::getLetterDefinitionForChar(char16_t utf16Char, FontLetterDefinit
     }
 }
 
-void FontAtlas::conversionU16TOGB2312(const std::u16string& u16Text, std::unordered_map<unsigned short, unsigned short>& charCodeMap)
+void FontAtlas::conversionU32TOGB2312(const std::u32string& u32Text, std::unordered_map<unsigned int, unsigned int>& charCodeMap)
 {
-    size_t strLen = u16Text.length();
+    size_t strLen = u32Text.length();
     auto gb2312StrSize = strLen * 2;
     auto gb2312Text = new (std::nothrow) char[gb2312StrSize];
     memset(gb2312Text, 0, gb2312StrSize);
 
     switch (_fontFreeType->getEncoding())
     {
-        case FT_ENCODING_GB2312:
-        {
-#if CC_TARGET_PLATFORM == CC_PLATFORM_WIN32 || CC_TARGET_PLATFORM == CC_PLATFORM_WINRT
-            WideCharToMultiByte(936, NULL, (LPCWCH)u16Text.c_str(), strLen, (LPSTR)gb2312Text, gb2312StrSize, NULL, NULL);
+    case FT_ENCODING_GB2312:
+    {
+#if CC_TARGET_PLATFORM == CC_PLATFORM_WIN32
+        std::u16string u16Text;
+        cocos2d::StringUtils::UTF32ToUTF16(u32Text, u16Text);
+        WideCharToMultiByte(936, NULL, (LPCWCH)u16Text.c_str(), strLen, (LPSTR)gb2312Text, gb2312StrSize, NULL, NULL);
 #elif CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID
-            conversionEncodingJNI((char*)u16Text.c_str(), gb2312StrSize, "UTF-16LE", gb2312Text, "GB2312");
+        conversionEncodingJNI((char*)u32Text.c_str(), gb2312StrSize, "UTF-32LE", gb2312Text, "GB2312");
 #else
-            if (_iconv == nullptr)
-            {
-                _iconv = iconv_open("gb2312", "utf-16le");
-            }
+        if (_iconv == nullptr)
+        {
+            _iconv = iconv_open("GBK//TRANSLIT", "UTF-32LE");
+        }
 
-            if (_iconv == (iconv_t)-1)
-            {
-                CCLOG("conversion from utf16 to gb2312 not available");
-            }
-            else
-            {
-                char* pin = (char*)u16Text.c_str();
-                char* pout = gb2312Text;
-                size_t inLen = strLen * 2;
-                size_t outLen = gb2312StrSize;
+        if (_iconv == (iconv_t)-1)
+        {
+            CCLOG("conversion from utf32 to gb2312 not available");
+        }
+        else
+        {
+            char* pin = (char*)u32Text.c_str();
+            char* pout = gb2312Text;
+            size_t inLen = strLen * 2;
+            size_t outLen = gb2312StrSize;
 
-                iconv(_iconv, (char**)&pin, &inLen, &pout, &outLen);
-            }
-#endif
+            iconv(_iconv, (char**)&pin, &inLen, &pout, &outLen);
         }
+#endif
+    }
+    break;
+    default:
+        CCLOG("Unsupported encoding:%d", _fontFreeType->getEncoding());
         break;
-        default:
-            CCLOG("Unsupported encoding:%d", _fontFreeType->getEncoding());
-            break;
     }
 
     unsigned short gb2312Code = 0;
     unsigned char* dst = (unsigned char*)&gb2312Code;
-    unsigned short u16Code;
+    char32_t u32Code;
     for (size_t index = 0, gbIndex = 0; index < strLen; ++index)
     {
-        u16Code = u16Text[index];
-        if (u16Code < 256)
+        u32Code = u32Text[index];
+        if (u32Code < 256)
         {
-            charCodeMap[u16Code] = u16Code;
+            charCodeMap[u32Code] = u32Code;
             gbIndex += 1;
         }
         else
         {
             dst[0] = gb2312Text[gbIndex + 1];
             dst[1] = gb2312Text[gbIndex];
-            charCodeMap[u16Code] = gb2312Code;
+            charCodeMap[u32Code] = gb2312Code;
 
             gbIndex += 2;
         }
@@ -262,39 +290,39 @@ void FontAtlas::conversionU16TOGB2312(const std::u16string& u16Text, std::unorde
     delete[] gb2312Text;
 }
 
-void FontAtlas::findNewCharacters(const std::u16string& u16Text, std::unordered_map<unsigned short, unsigned short>& charCodeMap)
+void FontAtlas::findNewCharacters(const std::u32string& u32Text, std::unordered_map<unsigned int, unsigned int>& charCodeMap)
 {
-    std::u16string newChars;
+    std::u32string newChars;
     FT_Encoding charEncoding = _fontFreeType->getEncoding();
 
-    // find new characters
+    //find new characters
     if (_letterDefinitions.empty())
     {
         // fixed #16169: new android project crash in android 5.0.2 device (Nexus 7) when use 3.12.
-        // While using clang compiler with gnustl_static on android, the copy assignment operator of `std::u16string`
-        // will affect the memory validity, it means after `newChars` is destroyed, the memory of `u16Text` holds
-        // will be a dead region. `u16text` represents the variable in `Label::_utf16Text`, when somewhere
+        // While using clang compiler with gnustl_static on android, the copy assignment operator of `std::u32string`
+        // will affect the memory validity, it means after `newChars` is destroyed, the memory of `u32Text` holds
+        // will be a dead region. `u32text` represents the variable in `Label::_utf32Text`, when somewhere
         // allocates memory by `malloc, realloc, new, new[]`, the generated memory address may be the same
-        // as `Label::_utf16Text` holds. If doing a `memset` or other memory operations, the orignal `Label::_utf16Text`
-        // will be in an unknown state. Meanwhile, a bunch lots of logic which depends on `Label::_utf16Text`
+        // as `Label::_utf32Text` holds. If doing a `memset` or other memory operations, the orignal `Label::_utf32Text`
+        // will be in an unknown state. Meanwhile, a bunch lots of logic which depends on `Label::_utf32Text`
         // will be broken.
-
-        // newChars = u16Text;
-
+        
+        // newChars = u32Text;
+        
         // Using `append` method is a workaround for this issue. So please be carefuly while using the assignment operator
-        // of `std::u16string`.
-        newChars.append(u16Text);
+        // of `std::u32string`.
+        newChars.append(u32Text);
     }
     else
     {
-        auto length = u16Text.length();
+        auto length = u32Text.length();
         newChars.reserve(length);
         for (size_t i = 0; i < length; ++i)
         {
-            auto outIterator = _letterDefinitions.find(u16Text[i]);
+            auto outIterator = _letterDefinitions.find(u32Text[i]);
             if (outIterator == _letterDefinitions.end())
             {
-                newChars.push_back(u16Text[i]);
+                newChars.push_back(u32Text[i]);
             }
         }
     }
@@ -303,35 +331,38 @@ void FontAtlas::findNewCharacters(const std::u16string& u16Text, std::unordered_
     {
         switch (charEncoding)
         {
-            case FT_ENCODING_UNICODE:
-            {
-                for (auto u16Code : newChars)
-                {
-                    charCodeMap[u16Code] = u16Code;
-                }
-                break;
-            }
-            case FT_ENCODING_GB2312:
+        case FT_ENCODING_UNICODE:
+        {
+            for (auto u32Code : newChars)
             {
-                conversionU16TOGB2312(newChars, charCodeMap);
-                break;
+                charCodeMap[u32Code] = u32Code;
             }
-            default:
-                CCLOG("FontAtlas::findNewCharacters: Unsupported encoding:%d", charEncoding);
-                break;
+            break;
+        }
+        case FT_ENCODING_GB2312:
+        {
+            conversionU32TOGB2312(newChars, charCodeMap);
+            break;
+        }
+        default:
+            CCLOG("FontAtlas::findNewCharacters: Unsupported encoding:%d", charEncoding);
+            break;
         }
     }
 }
 
-bool FontAtlas::prepareLetterDefinitions(const std::u16string& utf16Text)
+bool FontAtlas::prepareLetterDefinitions(const std::u32string& utf32Text)
 {
     if (_fontFreeType == nullptr)
     {
         return false;
     }
 
-    std::unordered_map<unsigned short, unsigned short> codeMapOfNewChar;
-    findNewCharacters(utf16Text, codeMapOfNewChar);
+    if (!_currentPageData)
+        reinit(); 
+    
+    std::unordered_map<unsigned int, unsigned int> codeMapOfNewChar;
+    findNewCharacters(utf32Text, codeMapOfNewChar);
     if (codeMapOfNewChar.empty())
     {
         return false;
@@ -346,9 +377,9 @@ bool FontAtlas::prepareLetterDefinitions(const std::u16string& utf16Text)
     FontLetterDefinition tempDef;
 
     auto scaleFactor = CC_CONTENT_SCALE_FACTOR();
-    auto pixelFormat = _fontFreeType->getOutlineSize() > 0 ? Texture2D::PixelFormat::AI88 : Texture2D::PixelFormat::A8;
+    auto  pixelFormat = _fontFreeType->getOutlineSize() > 0 ? backend::PixelFormat::AI88 : backend::PixelFormat::A8;
 
-    float startY = _currentPageOrigY;
+    int startY = (int)_currentPageOrigY;
 
     for (auto&& it : codeMapOfNewChar)
     {
@@ -358,7 +389,7 @@ bool FontAtlas::prepareLetterDefinitions(const std::u16string& utf16Text)
             tempDef.validDefinition = true;
             tempDef.width = tempRect.size.width + _letterPadding + _letterEdgeExtend;
             tempDef.height = tempRect.size.height + _letterPadding + _letterEdgeExtend;
-            tempDef.offsetX = tempRect.origin.x + adjustForDistanceMap + adjustForExtend;
+            tempDef.offsetX = tempRect.origin.x - adjustForDistanceMap - adjustForExtend;
             tempDef.offsetY = _fontAscender + tempRect.origin.y - adjustForDistanceMap - adjustForExtend;
 
             if (_currentPageOrigX + tempDef.width > CacheTextureWidth)
@@ -368,23 +399,17 @@ bool FontAtlas::prepareLetterDefinitions(const std::u16string& utf16Text)
                 _currentPageOrigX = 0;
                 if (_currentPageOrigY + _lineHeight + _letterPadding + _letterEdgeExtend >= CacheTextureHeight)
                 {
-                    unsigned char* data = nullptr;
-                    if (pixelFormat == Texture2D::PixelFormat::AI88)
-                    {
-                        data = _currentPageData + CacheTextureWidth * (int)startY * 2;
-                    }
-                    else
-                    {
-                        data = _currentPageData + CacheTextureWidth * (int)startY;
-                    }
-                    _atlasTextures[_currentPage]->updateWithData(data, 0, startY, CacheTextureWidth, CacheTextureHeight - startY);
+                    updateTextureContent(pixelFormat, startY);
 
-                    startY = 0.0f;
+                    startY = 0;
 
                     _currentPageOrigY = 0;
                     memset(_currentPageData, 0, _currentPageDataSize);
                     _currentPage++;
                     auto tex = new (std::nothrow) Texture2D;
+                    
+                    initTextureWithZeros(tex);
+
                     if (_antialiasEnabled)
                     {
                         tex->setAntiAliasTexParameters();
@@ -393,9 +418,8 @@ bool FontAtlas::prepareLetterDefinitions(const std::u16string& utf16Text)
                     {
                         tex->setAliasTexParameters();
                     }
-                    tex->initWithData(_currentPageData, _currentPageDataSize, pixelFormat, CacheTextureWidth, CacheTextureHeight,
-                                      Size(CacheTextureWidth, CacheTextureHeight));
                     addTexture(tex, _currentPage);
+                    
                     tex->release();
                 }
             }
@@ -404,8 +428,7 @@ bool FontAtlas::prepareLetterDefinitions(const std::u16string& utf16Text)
             {
                 _currLineHeight = glyphHeight;
             }
-            _fontFreeType->renderCharAt(_currentPageData, _currentPageOrigX + adjustForExtend, _currentPageOrigY + adjustForExtend, bitmap, bitmapWidth,
-                                        bitmapHeight);
+            _fontFreeType->renderCharAt(_currentPageData, (int)_currentPageOrigX + adjustForExtend, (int)_currentPageOrigY + adjustForExtend, bitmap, bitmapWidth, bitmapHeight);
 
             tempDef.U = _currentPageOrigX;
             tempDef.V = _currentPageOrigY;
@@ -417,8 +440,9 @@ bool FontAtlas::prepareLetterDefinitions(const std::u16string& utf16Text)
             tempDef.U = tempDef.U / scaleFactor;
             tempDef.V = tempDef.V / scaleFactor;
         }
-        else
-        {
+        else{
+            if(bitmap)
+                delete[] bitmap;
             if (tempDef.xAdvance)
                 tempDef.validDefinition = true;
             else
@@ -437,21 +461,34 @@ bool FontAtlas::prepareLetterDefinitions(const std::u16string& utf16Text)
         _letterDefinitions[it.first] = tempDef;
     }
 
-    unsigned char* data = nullptr;
-    if (pixelFormat == Texture2D::PixelFormat::AI88)
+    updateTextureContent(pixelFormat, startY);
+    return true;
+}
+
+void FontAtlas::updateTextureContent(backend::PixelFormat format, int startY)
+{
+    unsigned char *data = nullptr;
+    auto outlineSize = _fontFreeType->getOutlineSize();
+    if (outlineSize > 0 && format == backend::PixelFormat::AI88)
     {
+        int nLen = CacheTextureWidth * ((int)_currentPageOrigY - startY + _currLineHeight);
         data = _currentPageData + CacheTextureWidth * (int)startY * 2;
+        memset(_currentPageDataRGBA, 0, 4 * nLen);
+        for (auto i = 0; i < nLen; i++)
+        {
+            _currentPageDataRGBA[i*4] = data[i*2];
+            _currentPageDataRGBA[i*4+3] = data[i*2+1];
+        }
+        _atlasTextures[_currentPage]->updateWithData(_currentPageDataRGBA, 0, startY, CacheTextureWidth, (int)_currentPageOrigY - startY + _currLineHeight);
     }
     else
     {
         data = _currentPageData + CacheTextureWidth * (int)startY;
+       _atlasTextures[_currentPage]->updateWithData(data, 0, startY, CacheTextureWidth, (int)_currentPageOrigY - startY + _currLineHeight);
     }
-    _atlasTextures[_currentPage]->updateWithData(data, 0, startY, CacheTextureWidth, _currentPageOrigY - startY + _currLineHeight);
-
-    return true;
 }
 
-void FontAtlas::addTexture(Texture2D* texture, int slot)
+void FontAtlas::addTexture(Texture2D *texture, int slot)
 {
     texture->retain();
     _atlasTextures[slot] = texture;
@@ -467,12 +504,23 @@ void FontAtlas::setLineHeight(float newHeight)
     _lineHeight = newHeight;
 }
 
+std::string FontAtlas::getFontName() const
+{
+    std::string fontName = _fontFreeType ? _fontFreeType->getFontName() : "";
+    if(fontName.empty()) return fontName;
+    auto idx = fontName.rfind('/');
+    if (idx != std::string::npos) { return fontName.substr(idx + 1); }
+    idx = fontName.rfind('\\');
+    if (idx != std::string::npos) { return fontName.substr(idx + 1); }
+    return fontName;
+}
+
 void FontAtlas::setAliasTexParameters()
 {
     if (_antialiasEnabled)
     {
         _antialiasEnabled = false;
-        for (const auto& tex : _atlasTextures)
+        for (const auto & tex : _atlasTextures)
         {
             tex.second->setAliasTexParameters();
         }
@@ -481,10 +529,10 @@ void FontAtlas::setAliasTexParameters()
 
 void FontAtlas::setAntiAliasTexParameters()
 {
-    if (!_antialiasEnabled)
+    if (! _antialiasEnabled)
     {
         _antialiasEnabled = true;
-        for (const auto& tex : _atlasTextures)
+        for (const auto & tex : _atlasTextures)
         {
             tex.second->setAntiAliasTexParameters();
         }
diff --git a/cocos2d/cocos/2d/CCFontAtlas.h b/cocos2d/cocos/2d/CCFontAtlas.h
index 15db84ee41..08081c6a62 100644
--- a/cocos2d/cocos/2d/CCFontAtlas.h
+++ b/cocos2d/cocos/2d/CCFontAtlas.h
@@ -1,19 +1,20 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -23,22 +24,22 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_FONTATLAS_H
-#define CC_2D_FONTATLAS_H
+#ifndef _CCFontAtlas_h_
+#define _CCFontAtlas_h_
 
 /// @cond DO_NOT_SHOW
 
-#include <cocos/base/CCRef.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
 #include <string>
 #include <unordered_map>
 
+#include <cocos/platform/CCPlatformMacros.h>
+#include <cocos/base/CCRef.h>
+#include <cocos/platform/CCStdC.h> // ssize_t on windows
+#include <cocos/renderer/CCTexture2D.h>
+
 NS_CC_BEGIN
 
 class Font;
-class Texture2D;
 class EventCustom;
 class EventListenerCustom;
 class FontFreeType;
@@ -66,22 +67,24 @@ public:
     /**
      * @js ctor
      */
-    FontAtlas(Font& theFont);
+    FontAtlas(Font &theFont);
     /**
      * @js NA
      * @lua NA
      */
     virtual ~FontAtlas();
-
-    void addLetterDefinition(char16_t utf16Char, const FontLetterDefinition& letterDefinition);
-    bool getLetterDefinitionForChar(char16_t utf16Char, FontLetterDefinition& letterDefinition);
-
-    bool prepareLetterDefinitions(const std::u16string& utf16String);
-
-    const std::unordered_map<std::size_t, Texture2D*>& getTextures() const { return _atlasTextures; }
-    void addTexture(Texture2D* texture, int slot);
+    
+    void addLetterDefinition(char32_t utf32Char, const FontLetterDefinition &letterDefinition);
+    bool getLetterDefinitionForChar(char32_t utf32Char, FontLetterDefinition &letterDefinition);
+    
+    bool prepareLetterDefinitions(const std::u32string& utf16String);
+
+    const std::unordered_map<ssize_t, Texture2D*>& getTextures() const { return _atlasTextures; }
+    void  addTexture(Texture2D *texture, int slot);
     float getLineHeight() const { return _lineHeight; }
-    void setLineHeight(float newHeight);
+    void  setLineHeight(float newHeight);
+    
+    std::string getFontName() const;
 
     Texture2D* getTexture(int slot);
     const Font* getFont() const { return _font; }
@@ -89,8 +92,8 @@ public:
     /** listen the event that renderer was recreated on Android/WP8
      It only has effect on Android and WP8.
      */
-    void listenRendererRecreated(EventCustom* event);
-
+    void listenRendererRecreated(EventCustom *event);
+    
     /** Removes textures atlas.
      It will purge the textures atlas and if multiple texture exist in the FontAtlas.
      */
@@ -100,22 +103,26 @@ public:
      - GL_TEXTURE_MIN_FILTER = GL_LINEAR
      - GL_TEXTURE_MAG_FILTER = GL_LINEAR
      */
-    void setAntiAliasTexParameters();
+     void setAntiAliasTexParameters();
 
-    /** sets font texture parameters:
+     /** sets font texture parameters:
      - GL_TEXTURE_MIN_FILTER = GL_NEAREST
      - GL_TEXTURE_MAG_FILTER = GL_NEAREST
      */
-    void setAliasTexParameters();
+     void setAliasTexParameters();
 
 protected:
     void reset();
-
+    
+    void reinit();
+    
     void releaseTextures();
 
-    void findNewCharacters(const std::u16string& u16Text, std::unordered_map<unsigned short, unsigned short>& charCodeMap);
+    void findNewCharacters(const std::u32string& u32Text, std::unordered_map<unsigned int, unsigned int>& charCodeMap);
+
+    void conversionU32TOGB2312(const std::u32string& u32Text, std::unordered_map<unsigned int, unsigned int>& charCodeMap);
 
-    void conversionU16TOGB2312(const std::u16string& u16Text, std::unordered_map<unsigned short, unsigned short>& charCodeMap);
+    void initTextureWithZeros(Texture2D *texture);
 
     /**
      * Scale each font letter by scaleFactor.
@@ -123,27 +130,31 @@ protected:
      * @param scaleFactor A float scale factor for scaling font letter info.
      */
     void scaleFontLetterDefinition(float scaleFactor);
+    
+    void updateTextureContent(backend::PixelFormat format, int startY);
 
-    std::unordered_map<std::size_t, Texture2D*> _atlasTextures;
-    std::unordered_map<char16_t, FontLetterDefinition> _letterDefinitions;
-    float _lineHeight;
-    Font* _font;
-    FontFreeType* _fontFreeType;
-    void* _iconv;
+    std::unordered_map<ssize_t, Texture2D*> _atlasTextures;
+    std::unordered_map<char32_t, FontLetterDefinition> _letterDefinitions;
+    float _lineHeight = 0.f;
+    Font* _font = nullptr;
+    FontFreeType* _fontFreeType = nullptr;
+    void* _iconv = nullptr;
 
     // Dynamic GlyphCollection related stuff
-    int _currentPage;
-    unsigned char* _currentPageData;
-    int _currentPageDataSize;
-    float _currentPageOrigX;
-    float _currentPageOrigY;
-    int _letterPadding;
-    int _letterEdgeExtend;
-
-    int _fontAscender;
-    EventListenerCustom* _rendererRecreatedListener;
-    bool _antialiasEnabled;
-    int _currLineHeight;
+    int _currentPage = 0;
+    unsigned char *_currentPageData = nullptr;
+    unsigned char *_currentPageDataRGBA = nullptr;
+    int _currentPageDataSize = 0;
+    int _currentPageDataSizeRGBA = 0;
+    float _currentPageOrigX = 0;
+    float _currentPageOrigY = 0;
+    int _letterPadding = 0;
+    int _letterEdgeExtend = 0;
+
+    int _fontAscender = 0;
+    EventListenerCustom* _rendererRecreatedListener = nullptr;
+    bool _antialiasEnabled = true;
+    int _currLineHeight = 0;
 
     friend class Label;
 };
@@ -151,4 +162,4 @@ protected:
 NS_CC_END
 
 /// @endcond
-#endif // CC_2D_FONTATLAS_H
+#endif /* defined(__cocos2d_libs__CCFontAtlas__) */
diff --git a/cocos2d/cocos/2d/CCFontAtlasCache.cpp b/cocos2d/cocos/2d/CCFontAtlasCache.cpp
index df579d0bf5..f17c0fe815 100644
--- a/cocos2d/cocos/2d/CCFontAtlasCache.cpp
+++ b/cocos2d/cocos/2d/CCFontAtlasCache.cpp
@@ -1,19 +1,20 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -24,56 +25,53 @@
  ****************************************************************************/
 #include <cocos/2d/CCFontAtlasCache.h>
 
-#include <cocos/2d/CCFontAtlas.h>
-#include <cocos/2d/CCFontCharMap.h>
+#include <cocos/base/CCDirector.h>
 #include <cocos/2d/CCFontFNT.h>
 #include <cocos/2d/CCFontFreeType.h>
+#include <cocos/2d/CCFontAtlas.h>
+#include <cocos/2d/CCFontCharMap.h>
 #include <cocos/2d/CCLabel.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/renderer/CCTexture2D.h>
+#include <cocos/platform/CCFileUtils.h>
 
 NS_CC_BEGIN
 
-std::unordered_map<std::string, FontAtlas*> FontAtlasCache::_atlasMap;
-#define ATLAS_MAP_KEY_BUFFER 255
+std::unordered_map<std::string, FontAtlas *> FontAtlasCache::_atlasMap;
+#define ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE 255
 
 void FontAtlasCache::purgeCachedData()
 {
-    if (!_atlasMap.empty())
+    auto atlasMapCopy = _atlasMap;
+    for (auto&& atlas : atlasMapCopy)
     {
-        auto atlasMapCopy = _atlasMap;
-        _atlasMap.clear();
-        for (auto& atlas : atlasMapCopy)
-        {
+        auto refCount = atlas.second->getReferenceCount();
+        atlas.second->release();
+        if (refCount != 1)
             atlas.second->purgeTexturesAtlas();
-        }
     }
+    _atlasMap.clear();
 }
 
 FontAtlas* FontAtlasCache::getFontAtlasTTF(const _ttfConfig* config)
 {
+    auto realFontFilename = FileUtils::getInstance()->getNewFilename(config->fontFilePath);  // resolves real file path, to prevent storing multiple atlases for the same file.
     bool useDistanceField = config->distanceFieldEnabled;
-    if (config->outlineSize > 0)
+    if(config->outlineSize > 0)
     {
         useDistanceField = false;
     }
 
-    char tmp[ATLAS_MAP_KEY_BUFFER];
-    if (useDistanceField)
-    {
-        snprintf(tmp, ATLAS_MAP_KEY_BUFFER, "df %.2f %d %s", config->fontSize, config->outlineSize, config->fontFilePath.c_str());
-    }
-    else
-    {
-        snprintf(tmp, ATLAS_MAP_KEY_BUFFER, "%.2f %d %s", config->fontSize, config->outlineSize, config->fontFilePath.c_str());
-    }
-    std::string atlasName = tmp;
+    std::string key;
+    char keyPrefix[ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE];
+    snprintf(keyPrefix, ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE, useDistanceField ? "df %.2f %d " : "%.2f %d ", config->fontSize, config->outlineSize);
+    std::string atlasName(keyPrefix);
+    atlasName += realFontFilename;
 
     auto it = _atlasMap.find(atlasName);
 
-    if (it == _atlasMap.end())
+    if ( it == _atlasMap.end() )
     {
-        auto font = FontFreeType::create(config->fontFilePath, config->fontSize, config->glyphs, config->customGlyphs, useDistanceField, config->outlineSize);
+        auto font = FontFreeType::create(realFontFilename, config->fontSize, config->glyphs,
+            config->customGlyphs, useDistanceField, (float)config->outlineSize);
         if (font)
         {
             auto tempAtlas = font->createFontAtlas();
@@ -85,26 +83,25 @@ FontAtlas* FontAtlasCache::getFontAtlasTTF(const _ttfConfig* config)
         }
     }
     else
-    {
-        _atlasMap[atlasName]->retain();
-        return _atlasMap[atlasName];
-    }
+        return it->second;
 
     return nullptr;
 }
 
 FontAtlas* FontAtlasCache::getFontAtlasFNT(const std::string& fontFileName, const Vec2& imageOffset /* = Vec2::ZERO */)
 {
-    char tmp[ATLAS_MAP_KEY_BUFFER];
-    snprintf(tmp, ATLAS_MAP_KEY_BUFFER, "%.2f %.2f %s", imageOffset.x, imageOffset.y, fontFileName.c_str());
-    std::string atlasName = tmp;
-
+    auto realFontFilename = FileUtils::getInstance()->getNewFilename(fontFileName);  // resolves real file path, to prevent storing multiple atlases for the same file.
+    char keyPrefix[ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE];
+    snprintf(keyPrefix, ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE, "%.2f %.2f ", imageOffset.x, imageOffset.y);
+    std::string atlasName(keyPrefix);
+    atlasName += realFontFilename;
+    
     auto it = _atlasMap.find(atlasName);
-    if (it == _atlasMap.end())
+    if ( it == _atlasMap.end() )
     {
-        auto font = FontFNT::create(fontFileName, imageOffset);
+        auto font = FontFNT::create(realFontFilename, imageOffset);
 
-        if (font)
+        if(font)
         {
             auto tempAtlas = font->createFontAtlas();
             if (tempAtlas)
@@ -115,24 +112,21 @@ FontAtlas* FontAtlasCache::getFontAtlasFNT(const std::string& fontFileName, cons
         }
     }
     else
-    {
-        _atlasMap[atlasName]->retain();
-        return _atlasMap[atlasName];
-    }
-
+        return it->second;
+    
     return nullptr;
 }
 
 FontAtlas* FontAtlasCache::getFontAtlasCharMap(const std::string& plistFile)
 {
     std::string atlasName = plistFile;
-
+    
     auto it = _atlasMap.find(atlasName);
-    if (it == _atlasMap.end())
+    if ( it == _atlasMap.end() )
     {
         auto font = FontCharMap::create(plistFile);
 
-        if (font)
+        if(font)
         {
             auto tempAtlas = font->createFontAtlas();
             if (tempAtlas)
@@ -143,26 +137,23 @@ FontAtlas* FontAtlasCache::getFontAtlasCharMap(const std::string& plistFile)
         }
     }
     else
-    {
-        _atlasMap[atlasName]->retain();
-        return _atlasMap[atlasName];
-    }
+        return it->second;
 
     return nullptr;
 }
 
 FontAtlas* FontAtlasCache::getFontAtlasCharMap(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap)
 {
-    char tmp[30];
-    sprintf(tmp, "name:%u_%d_%d_%d", texture->getName(), itemWidth, itemHeight, startCharMap);
-    std::string atlasName = tmp;
+    char key[ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE];
+    sprintf(key,"name:%p_%d_%d_%d",texture->getBackendTexture(),itemWidth,itemHeight,startCharMap);
+    std::string atlasName = key;
 
     auto it = _atlasMap.find(atlasName);
-    if (it == _atlasMap.end())
+    if ( it == _atlasMap.end() )
     {
-        auto font = FontCharMap::create(texture, itemWidth, itemHeight, startCharMap);
+        auto font = FontCharMap::create(texture,itemWidth,itemHeight,startCharMap);
 
-        if (font)
+        if(font)
         {
             auto tempAtlas = font->createFontAtlas();
             if (tempAtlas)
@@ -173,26 +164,24 @@ FontAtlas* FontAtlasCache::getFontAtlasCharMap(Texture2D* texture, int itemWidth
         }
     }
     else
-    {
-        _atlasMap[atlasName]->retain();
-        return _atlasMap[atlasName];
-    }
+        return it->second;
 
     return nullptr;
 }
 
 FontAtlas* FontAtlasCache::getFontAtlasCharMap(const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap)
 {
-    char tmp[ATLAS_MAP_KEY_BUFFER];
-    snprintf(tmp, ATLAS_MAP_KEY_BUFFER, "%d %d %d %s", itemWidth, itemHeight, startCharMap, charMapFile.c_str());
-    std::string atlasName = tmp;
+    char keyPrefix[ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE];
+    snprintf(keyPrefix, ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE, "%d %d %d ", itemWidth, itemHeight, startCharMap);
+    std::string atlasName(keyPrefix);
+    atlasName += charMapFile;
 
     auto it = _atlasMap.find(atlasName);
-    if (it == _atlasMap.end())
+    if ( it == _atlasMap.end() )
     {
-        auto font = FontCharMap::create(charMapFile, itemWidth, itemHeight, startCharMap);
+        auto font = FontCharMap::create(charMapFile,itemWidth,itemHeight,startCharMap);
 
-        if (font)
+        if(font)
         {
             auto tempAtlas = font->createFontAtlas();
             if (tempAtlas)
@@ -203,43 +192,41 @@ FontAtlas* FontAtlasCache::getFontAtlasCharMap(const std::string& charMapFile, i
         }
     }
     else
-    {
-        _atlasMap[atlasName]->retain();
-        return _atlasMap[atlasName];
-    }
+        return it->second;
 
     return nullptr;
 }
 
-bool FontAtlasCache::releaseFontAtlas(FontAtlas* atlas)
+bool FontAtlasCache::releaseFontAtlas(FontAtlas *atlas)
 {
     if (nullptr != atlas)
     {
-        for (auto& item : _atlasMap)
+        for( auto &item: _atlasMap )
         {
-            if (item.second == atlas)
+            if ( item.second == atlas )
             {
                 if (atlas->getReferenceCount() == 1)
                 {
-                    _atlasMap.erase(item.first);
+                  _atlasMap.erase(item.first);
                 }
-
+                
                 atlas->release();
-
+                
                 return true;
             }
         }
     }
-
+    
     return false;
 }
 
-void FontAtlasCache::reloadFontAtlasFNT(const std::string& fontFileName, const Vec2& imageOffset /* = Vec2::ZERO*/)
+void FontAtlasCache::reloadFontAtlasFNT(const std::string& fontFileName, const Vec2& imageOffset/* = Vec2::ZERO*/)
 {
-    char tmp[ATLAS_MAP_KEY_BUFFER];
-    snprintf(tmp, ATLAS_MAP_KEY_BUFFER, "%.2f %.2f %s", imageOffset.x, imageOffset.y, fontFileName.c_str());
-    std::string atlasName = tmp;
-
+    char keyPrefix[ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE];
+    snprintf(keyPrefix, ATLAS_MAP_KEY_PREFIX_BUFFER_SIZE, "%.2f %.2f ", imageOffset.x, imageOffset.y);
+    std::string atlasName(keyPrefix);
+    atlasName += fontFileName;
+    
     auto it = _atlasMap.find(atlasName);
     if (it != _atlasMap.end())
     {
@@ -256,6 +243,7 @@ void FontAtlasCache::reloadFontAtlasFNT(const std::string& fontFileName, const V
             _atlasMap[atlasName] = tempAtlas;
         }
     }
+
 }
 
 void FontAtlasCache::unloadFontAtlasTTF(const std::string& fontFileName)
diff --git a/cocos2d/cocos/2d/CCFontAtlasCache.h b/cocos2d/cocos/2d/CCFontAtlasCache.h
index a70a411a51..279f6ba82e 100644
--- a/cocos2d/cocos/2d/CCFontAtlasCache.h
+++ b/cocos2d/cocos/2d/CCFontAtlasCache.h
@@ -1,19 +1,20 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -23,14 +24,13 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_FONTATLASCACHE_H
-#define CC_2D_FONTATLASCACHE_H
+#ifndef _CCFontAtlasCache_h_
+#define _CCFontAtlasCache_h_
 
 /// @cond DO_NOT_SHOW
 
-#include <cocos/base/ccTypes.h>
-
 #include <unordered_map>
+#include <cocos/base/ccTypes.h>
 
 NS_CC_BEGIN
 
@@ -39,7 +39,7 @@ class Texture2D;
 struct _ttfConfig;
 
 class CC_DLL FontAtlasCache
-{
+{  
 public:
     static FontAtlas* getFontAtlasTTF(const _ttfConfig* config);
     static FontAtlas* getFontAtlasFNT(const std::string& fontFileName, const Vec2& imageOffset = Vec2::ZERO);
@@ -47,8 +47,8 @@ public:
     static FontAtlas* getFontAtlasCharMap(const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap);
     static FontAtlas* getFontAtlasCharMap(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap);
     static FontAtlas* getFontAtlasCharMap(const std::string& plistFile);
-
-    static bool releaseFontAtlas(FontAtlas* atlas);
+    
+    static bool releaseFontAtlas(FontAtlas *atlas);
 
     /** Removes cached data.
      It will purge the textures atlas and if multiple texture exist in one FontAtlas.
@@ -68,10 +68,10 @@ public:
     static void unloadFontAtlasTTF(const std::string& fontFileName);
 
 private:
-    static std::unordered_map<std::string, FontAtlas*> _atlasMap;
+    static std::unordered_map<std::string, FontAtlas *> _atlasMap;
 };
 
 NS_CC_END
 
 /// @endcond
-#endif // CC_2D_FONTATLASCACHE_H
+#endif
diff --git a/cocos2d/cocos/2d/CCFontCharMap.cpp b/cocos2d/cocos/2d/CCFontCharMap.cpp
index f05131c11f..82275844f6 100644
--- a/cocos2d/cocos/2d/CCFontCharMap.cpp
+++ b/cocos2d/cocos/2d/CCFontCharMap.cpp
@@ -1,7 +1,8 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
 
  Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -24,25 +25,17 @@
  ****************************************************************************/
 
 #include <cocos/2d/CCFontCharMap.h>
-
 #include <cocos/2d/CCFontAtlas.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/math/CCGeometry.h>
 #include <cocos/platform/CCFileUtils.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCTexture2D.h>
+#include <cocos/base/CCDirector.h>
 #include <cocos/renderer/CCTextureCache.h>
 
-#include <new>
-
 NS_CC_BEGIN
 
-FontCharMap* FontCharMap::create(const std::string& plistFile)
+FontCharMap * FontCharMap::create(const std::string& plistFile)
 {
     std::string pathStr = FileUtils::getInstance()->fullPathForFilename(plistFile);
-    std::string relPathStr = pathStr.substr(0, pathStr.find_last_of("/")) + "/";
+    std::string relPathStr = pathStr.substr(0, pathStr.find_last_of('/'))+"/";
 
     ValueMap dict = FileUtils::getInstance()->getValueMapFromFile(pathStr);
 
@@ -54,14 +47,14 @@ FontCharMap* FontCharMap::create(const std::string& plistFile)
     unsigned int height = dict["itemHeight"].asInt();
     unsigned int startChar = dict["firstChar"].asInt();
 
-    Texture2D* tempTexture = Director::getInstance()->getTextureCache()->addImage(textureFilename);
+    Texture2D *tempTexture = Director::getInstance()->getTextureCache()->addImage(textureFilename);
     if (!tempTexture)
     {
         return nullptr;
     }
-
-    FontCharMap* tempFont = new FontCharMap(tempTexture, width, height, startChar);
-
+    
+    FontCharMap *tempFont =  new FontCharMap(tempTexture,width,height,startChar);
+    
     if (!tempFont)
     {
         return nullptr;
@@ -72,14 +65,14 @@ FontCharMap* FontCharMap::create(const std::string& plistFile)
 
 FontCharMap* FontCharMap::create(const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap)
 {
-    Texture2D* tempTexture = Director::getInstance()->getTextureCache()->addImage(charMapFile);
+    Texture2D *tempTexture = Director::getInstance()->getTextureCache()->addImage(charMapFile);
 
     if (!tempTexture)
     {
         return nullptr;
     }
 
-    FontCharMap* tempFont = new FontCharMap(tempTexture, itemWidth, itemHeight, startCharMap);
+    FontCharMap *tempFont =  new FontCharMap(tempTexture,itemWidth,itemHeight,startCharMap);
 
     if (!tempFont)
     {
@@ -91,7 +84,7 @@ FontCharMap* FontCharMap::create(const std::string& charMapFile, int itemWidth,
 
 FontCharMap* FontCharMap::create(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap)
 {
-    FontCharMap* tempFont = new FontCharMap(texture, itemWidth, itemHeight, startCharMap);
+    FontCharMap *tempFont =  new FontCharMap(texture,itemWidth,itemHeight,startCharMap);
 
     if (!tempFont)
     {
@@ -101,41 +94,34 @@ FontCharMap* FontCharMap::create(Texture2D* texture, int itemWidth, int itemHeig
     return tempFont;
 }
 
-FontCharMap::FontCharMap(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap)
-: _texture(texture)
-, _mapStartChar(startCharMap)
-, _itemWidth(itemWidth)
-, _itemHeight(itemHeight)
-{
-}
-
 FontCharMap::~FontCharMap()
 {
+
 }
 
-int* FontCharMap::getHorizontalKerningForTextUTF16(const std::u16string& text, int& outNumLetters) const
+int* FontCharMap::getHorizontalKerningForTextUTF32(const std::u32string& /*text*/, int & /*outNumLetters*/) const
 {
     return nullptr;
 }
 
-FontAtlas* FontCharMap::createFontAtlas()
+FontAtlas * FontCharMap::createFontAtlas()
 {
-    FontAtlas* tempAtlas = new (std::nothrow) FontAtlas(*this);
+    FontAtlas *tempAtlas = new (std::nothrow) FontAtlas(*this);
     if (!tempAtlas)
         return nullptr;
-
+    
     Size s = _texture->getContentSizeInPixels();
-    int itemsPerColumn = static_cast<int>(s.height / _itemHeight);
-    int itemsPerRow = static_cast<int>(s.width / _itemWidth);
+    int itemsPerColumn = (int)(s.height / _itemHeight);
+    int itemsPerRow = (int)(s.width / _itemWidth);
 
-    tempAtlas->setLineHeight(_itemHeight);
+    tempAtlas->setLineHeight((float)_itemHeight);
 
     auto contentScaleFactor = CC_CONTENT_SCALE_FACTOR();
 
     FontLetterDefinition tempDefinition;
     tempDefinition.textureID = 0;
-    tempDefinition.offsetX = 0.0f;
-    tempDefinition.offsetY = 0.0f;
+    tempDefinition.offsetX  = 0.0f;
+    tempDefinition.offsetY  = 0.0f;
     tempDefinition.validDefinition = true;
     tempDefinition.width = _itemWidth / contentScaleFactor;
     tempDefinition.height = _itemHeight / contentScaleFactor;
@@ -153,8 +139,8 @@ FontAtlas* FontCharMap::createFontAtlas()
             charId++;
         }
     }
-
-    tempAtlas->addTexture(_texture, 0);
+    
+    tempAtlas->addTexture(_texture,0);
 
     return tempAtlas;
 }
diff --git a/cocos2d/cocos/2d/CCFontCharMap.h b/cocos2d/cocos/2d/CCFontCharMap.h
index 35b87163e4..40156c469c 100644
--- a/cocos2d/cocos/2d/CCFontCharMap.h
+++ b/cocos2d/cocos/2d/CCFontCharMap.h
@@ -1,19 +1,20 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -23,49 +24,49 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_FONTCHARMAP_H
-#define CC_2D_FONTCHARMAP_H
+#ifndef _CCFontCharMap_h_
+#define _CCFontCharMap_h_
 
 /// @cond DO_NOT_SHOW
 
 #include <cocos/2d/CCFont.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
-#include <string>
 
 NS_CC_BEGIN
 
 class Texture2D;
-class FontAtlas;
-
 class FontCharMap : public Font
-{
+{  
 public:
-    static FontCharMap* create(const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap);
-    static FontCharMap* create(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap);
-    static FontCharMap* create(const std::string& plistFile);
-
-    int* getHorizontalKerningForTextUTF16(const std::u16string& text, int& outNumLetters) const override;
-    FontAtlas* createFontAtlas() override;
-
-protected:
-    FontCharMap(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap);
+    static FontCharMap * create(const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap);
+    static FontCharMap * create(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap);
+    static FontCharMap * create(const std::string& plistFile);
+    
+    virtual int* getHorizontalKerningForTextUTF32(const std::u32string& text, int &outNumLetters) const override;
+    virtual FontAtlas *createFontAtlas() override;
+    
+protected:    
+    FontCharMap(Texture2D* texture,int itemWidth, int itemHeight, int startCharMap)
+        :_texture(texture)
+        ,_mapStartChar(startCharMap)
+        ,_itemWidth(itemWidth)
+        ,_itemHeight(itemHeight)
+    {}
     /**
      * @js NA
      * @lua NA
      */
-    ~FontCharMap() override;
-
+    virtual ~FontCharMap();
+    
 private:
     Texture2D* _texture;
     int _mapStartChar;
     int _itemWidth;
     int _itemHeight;
+
 };
 
 /// @endcond
 
 NS_CC_END
 
-#endif // CC_2D_FONTCHARMAP_H
+#endif /* defined(_CCFontCharMap_h_) */
diff --git a/cocos2d/cocos/2d/CCFontFNT.cpp b/cocos2d/cocos/2d/CCFontFNT.cpp
index cbe2630bbe..c329b3c3fd 100644
--- a/cocos2d/cocos/2d/CCFontFNT.cpp
+++ b/cocos2d/cocos/2d/CCFontFNT.cpp
@@ -1,7 +1,8 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
 
  Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -24,167 +25,160 @@
  ****************************************************************************/
 
 #include <cocos/2d/CCFontFNT.h>
-
 #include <cocos/2d/CCFontAtlas.h>
+#include <cocos/platform/CCFileUtils.h>
 #include <cocos/base/CCConfiguration.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCRef.h>
-#include <cocos/base/ccMacros.h>
+#include <cocos/base/CCMap.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCFileUtils.h>
-#include <cocos/platform/CCPlatformMacros.h>
 #include <cocos/renderer/CCTextureCache.h>
 
-#include <array>
 #include <cmath>
-#include <cstdint>
-#include <cstdio>
-#include <cstring>
-#include <limits>
-#include <new>
-#include <sstream>
-#include <string_view>
-#include <type_traits>
+#include <set>
 #include <unordered_map>
-#include <unordered_set>
-#include <utility>
-
-namespace cocos2d
-{
-    class Texture2D;
-}
 
 NS_CC_BEGIN
 
+/**
+ * @addtogroup GUI
+ * @{
+ * @addtogroup label
+ * @{
+ */
+
+enum {
+    kLabelAutomaticWidth = -1,
+};
+
+struct _FontDefHashElement;
+
 /**
 @struct BMFontDef
 BMFont definition
 */
-struct BMFontDef
-{
+typedef struct _BMFontDef {
     //! ID of the character
-    unsigned int charID = 0;
+    unsigned int charID;
     //! origin and size of the font
-    Rect rect = Rect::ZERO;
+    Rect rect;
     //! The X amount the image should be offset when drawing the image (in pixels)
-    short xOffset = 0;
+    short xOffset;
     //! The Y amount the image should be offset when drawing the image (in pixels)
-    short yOffset = 0;
+    short yOffset;
     //! The amount to move the current position after drawing the character (in pixels)
-    short xAdvance = 0;
-};
+    short xAdvance;
+} BMFontDef;
 
 /** @struct BMFontPadding
 BMFont padding
 @since v0.8.2
 */
-struct BMFontPadding
-{
+typedef struct _BMFontPadding {
     /// padding left
-    int left = 0;
+    int left;
     /// padding top
-    int top = 0;
+    int top;
     /// padding right
-    int right = 0;
+    int right;
     /// padding bottom
-    int bottom = 0;
-};
+    int bottom;
+} BMFontPadding;
 
 /** @brief BMFontConfiguration has parsed configuration of the .fnt file
 @since v0.8
 */
-class CC_DLL BMFontConfiguration final : public Ref
+class CC_DLL BMFontConfiguration : public Ref
 {
+    // FIXME: Creating a public interface so that the bitmapFontArray[] is accessible
+public://@public
     // BMFont definitions
-    std::unordered_map<unsigned int, BMFontDef> _fontDefDictionary;
+    std::unordered_map<int /* key */, BMFontDef /* fontDef */> _fontDefDictionary;
 
     //! FNTConfig: Common Height Should be signed (issue #1343)
-    int _commonHeight = 0;
+    int _commonHeight;
     //! Padding
-    BMFontPadding _padding;
+    BMFontPadding    _padding;
     //! atlas name
     std::string _atlasName;
     //! values for kerning
-    std::unordered_map<unsigned int, int> _kerningDictionary;
-
+    std::unordered_map<uint64_t /* key */, int /* amount */> _kerningDictionary;
+    
     // Character Set defines the letters that actually exist in the font
-    std::unordered_set<unsigned int> _characterSet;
+    std::set<unsigned int> *_characterSet;
     //! Font Size
-    int _fontSize = 0;
-
+    int _fontSize;
 public:
-    BMFontConfiguration() = default;
-    BMFontConfiguration(BMFontConfiguration const&) = delete;
-    BMFontConfiguration& operator=(BMFontConfiguration const&) = delete;
-    BMFontConfiguration(BMFontConfiguration&&) noexcept = delete;
-    BMFontConfiguration& operator=(BMFontConfiguration&&) noexcept = delete;
-    ~BMFontConfiguration() final = default;
-
+    /**
+     * @js ctor
+     */
+    BMFontConfiguration();
+    /**
+     * @js NA
+     * @lua NA
+     */
+    virtual ~BMFontConfiguration();
+    /**
+     * @js NA
+     * @lua NA
+     */
     std::string description() const;
 
     /** allocates a BMFontConfiguration with a FNT file */
-    static BMFontConfiguration* create(std::string const& FNTfile);
+    static BMFontConfiguration * create(const std::string& FNTfile);
 
     /** initializes a BitmapFontConfiguration with a FNT file */
-    bool initWithFNTfile(std::string const& FNTfile);
-
-    inline const std::string& getAtlasName() const noexcept { return _atlasName; }
-    inline void setAtlasName(std::string const& atlasName) { _atlasName = atlasName; }
-
-    inline decltype(_characterSet) const& getCharacterSet() const noexcept { return _characterSet; }
-
-    inline int getFontSize() const noexcept { return _fontSize; }
-    inline int getCommonHeight() const noexcept { return _commonHeight; }
-
-    inline decltype(_kerningDictionary) const& getKerningDictionary() const noexcept { return _kerningDictionary; }
-    inline decltype(_fontDefDictionary) const& getKFontDefDictionary() const noexcept { return _fontDefDictionary; }
-
+    bool initWithFNTfile(const std::string& FNTfile);
+    
+    const std::string& getAtlasName() { return _atlasName; }
+    void setAtlasName(const std::string& atlasName) { _atlasName = atlasName; }
+    
+    std::set<unsigned int>* getCharacterSet() const;
 private:
-    std::unordered_set<unsigned int> parseConfigFile(const std::string& controlFile);
-    std::unordered_set<unsigned int> parseBinaryConfigFile(unsigned char* pData, unsigned long size, std::string const& controlFile);
-
-    void parseCharacterDefinition(std::string const& line, BMFontDef& characterDefinition);
-    void parseInfoArguments(std::string const& line);
-    void parseCommonArguments(std::string const& line);
-    void parseImageFileName(std::string const& line, std::string const& fntFile);
-    void parseKerningEntry(std::string const& line);
+    std::set<unsigned int>* parseConfigFile(const std::string& controlFile);
+    std::set<unsigned int>* parseBinaryConfigFile(unsigned char* pData, unsigned long size, const std::string& controlFile);
+    unsigned int parseCharacterDefinition(const char* line);
+    void parseInfoArguments(const char* line);
+    void parseCommonArguments(const char* line);
+    void parseImageFileName(const char* line, const std::string& fntFile);
+    void parseKerningEntry(const char* line);
+    void purgeKerningDictionary();
+    void purgeFontDefDictionary();
 };
 
 //
-// FNTConfig Cache - free functions
+//FNTConfig Cache - free functions
 //
-std::unordered_map<std::string, BMFontConfiguration*>& get_configurations()
-{
-    static std::unordered_map<std::string, BMFontConfiguration*> configurations;
-    return configurations;
-}
+static Map<std::string, BMFontConfiguration*>* s_configurations = nullptr;
 
-BMFontConfiguration* FNTConfigLoadFile(std::string const& fntFile)
+BMFontConfiguration* FNTConfigLoadFile(const std::string& fntFile)
 {
-    auto& configurations = get_configurations();
+    BMFontConfiguration* ret = nullptr;
 
-    if (auto search = configurations.find(fntFile); search != configurations.end())
+    if (s_configurations == nullptr)
     {
-        return search->second;
+        s_configurations = new (std::nothrow) Map<std::string, BMFontConfiguration*>();
     }
-    else
+
+    ret = s_configurations->at(fntFile);
+    if( ret == nullptr )
     {
-        BMFontConfiguration* ret = BMFontConfiguration::create(fntFile);
-        ret->retain();
-        configurations.emplace(fntFile, ret);
-        return ret;
+        ret = BMFontConfiguration::create(fntFile);
+        if (ret)
+        {
+            s_configurations->insert(fntFile, ret);
+        }        
     }
+
+    return ret;
 }
 
 //
-// BitmapFontConfiguration
+//BitmapFontConfiguration
 //
 
-BMFontConfiguration* BMFontConfiguration::create(std::string const& FNTfile)
+BMFontConfiguration * BMFontConfiguration::create(const std::string& FNTfile)
 {
-    BMFontConfiguration* ret = new (std::nothrow) BMFontConfiguration();
+    BMFontConfiguration * ret = new (std::nothrow) BMFontConfiguration();
     if (ret->initWithFNTfile(FNTfile))
     {
         ret->autorelease();
@@ -194,11 +188,11 @@ BMFontConfiguration* BMFontConfiguration::create(std::string const& FNTfile)
     return nullptr;
 }
 
-bool BMFontConfiguration::initWithFNTfile(std::string const& FNTfile)
+bool BMFontConfiguration::initWithFNTfile(const std::string& FNTfile)
 {
     _characterSet = this->parseConfigFile(FNTfile);
 
-    if (_characterSet.empty())
+    if (! _characterSet)
     {
         return false;
     }
@@ -206,99 +200,147 @@ bool BMFontConfiguration::initWithFNTfile(std::string const& FNTfile)
     return true;
 }
 
+std::set<unsigned int>* BMFontConfiguration::getCharacterSet() const
+{
+    return _characterSet;
+}
+
+BMFontConfiguration::BMFontConfiguration()
+: _commonHeight(0)
+, _characterSet(nullptr)
+, _fontSize(0)
+{
+
+}
+
+BMFontConfiguration::~BMFontConfiguration()
+{
+    CCLOGINFO( "deallocing BMFontConfiguration: %p", this );
+    this->purgeFontDefDictionary();
+    this->purgeKerningDictionary();
+    _atlasName.clear();
+    CC_SAFE_DELETE(_characterSet);
+}
+
 std::string BMFontConfiguration::description() const
 {
-    return StringUtils::format("<BMFontConfiguration = " CC_FORMAT_PRINTF_SIZE_T " | Glphys:%d Kernings:%d | Image = %s>", (size_t)this,
-                               _fontDefDictionary.size(), _kerningDictionary.size(), _atlasName.c_str());
+    return StringUtils::format(
+        "<BMFontConfiguration = " CC_FORMAT_PRINTF_SIZE_T " | Glphys:%d Kernings:%d | Image = %s>",
+        (size_t)this,
+        static_cast<int>(_fontDefDictionary.size()),
+        static_cast<int>(_kerningDictionary.size()),
+        _atlasName.c_str()
+    );
 }
 
-std::unordered_set<unsigned int> BMFontConfiguration::parseConfigFile(std::string const& controlFile)
+void BMFontConfiguration::purgeKerningDictionary()
 {
-    std::unordered_set<unsigned int> validCharsString;
-    std::string const data = FileUtils::getInstance()->getStringFromFile(controlFile);
+    _kerningDictionary.clear();
+}
+
+void BMFontConfiguration::purgeFontDefDictionary()
+{
+    _fontDefDictionary.clear();
+}
+
+std::set<unsigned int>* BMFontConfiguration::parseConfigFile(const std::string& controlFile)
+{
+    std::string data = FileUtils::getInstance()->getStringFromFile(controlFile);
     if (data.empty())
     {
-        return validCharsString;
+        return nullptr;
     }
-    if (data.size() >= (sizeof("BMP") - 1) && memcmp("BMF", data.c_str(), sizeof("BMP") - 1) == 0)
-    {
+    if (data.size() >= (sizeof("BMP") - 1) && memcmp("BMF", data.c_str(), sizeof("BMP") - 1) == 0) {
         // Handle fnt file of binary format
-        return parseBinaryConfigFile(reinterpret_cast<unsigned char*>(const_cast<char*>(data.data())), data.size(), controlFile);
+        std::set<unsigned int>* ret = parseBinaryConfigFile((unsigned char*)&data.front(), data.size(), controlFile);
+        return ret;
     }
-    if (data.front() == '\0')
+    if (data[0] == 0)
     {
         CCLOG("cocos2d: Error parsing FNTfile %s", controlFile.c_str());
-        return validCharsString;
+        return nullptr;
     }
+    auto contents = data.c_str();
+    
+    std::set<unsigned int> *validCharsString = new (std::nothrow) std::set<unsigned int>();
+    
+    auto contentsLen = strlen(contents);
+    char line[512] = {0};
+    
+    auto next = strchr(contents, '\n');
+    auto base = contents;
+    size_t lineLength = 0;
+    size_t parseCount = 0;
+    while (next)
+    {
+        lineLength = ((int)(next - base));
+        memcpy(line, contents + parseCount, lineLength);
+        line[lineLength] = 0;
 
-    using namespace std::literals;
-    static constexpr std::string_view const prefix_info_face = "info face"sv;
-    static constexpr std::string_view const prefix_common_line_height = "common lineHeight"sv;
-    static constexpr std::string_view const prefix_page_id = "page id"sv;
-    static constexpr std::string_view const prefix_chars_c = "chars c"sv;
-    static constexpr std::string_view const prefix_char = "char"sv;
-    static constexpr std::string_view const prefix_kerning_first = "kerning first"sv;
+        parseCount += lineLength + 1;
+        if (parseCount < contentsLen)
+        {
+            base = next + 1;
+            next = strchr(base, '\n');
+        } 
+        else
+        {
+            next = nullptr;
+        }
 
-    std::istringstream input(data);
-    for (std::string line; std::getline(input, line);)
-    {
-        if (line.compare(0, prefix_info_face.size(), prefix_info_face) == 0)
+        if (memcmp(line, "info face", 9) == 0)
         {
-            parseInfoArguments(line);
+            // FIXME: info parsing is incomplete
+            // Not needed for the Hiero editors, but needed for the AngelCode editor
+            //            [self parseInfoArguments:line];
+            this->parseInfoArguments(line);
         }
-        else if (line.compare(0, prefix_common_line_height.size(), prefix_common_line_height) == 0)
+        // Check to see if the start of the line is something we are interested in
+        else if (memcmp(line, "common lineHeight", 17) == 0)
         {
-            parseCommonArguments(line);
+            this->parseCommonArguments(line);
         }
-        else if (line.compare(0, prefix_page_id.size(), prefix_page_id) == 0)
+        else if (memcmp(line, "page id", 7) == 0)
         {
-            parseImageFileName(line, controlFile);
+            this->parseImageFileName(line, controlFile);
         }
-        else if (line.compare(0, prefix_chars_c.size(), prefix_chars_c) == 0)
+        else if (memcmp(line, "chars c", 7) == 0)
         {
             // Ignore this line
         }
-        else if (line.compare(0, prefix_char.size(), prefix_char) == 0)
+        else if (memcmp(line, "char", 4) == 0)
         {
             // Parse the current line and create a new CharDef
-            BMFontDef fontDef;
-            parseCharacterDefinition(line, fontDef);
-
-            _fontDefDictionary.emplace(fontDef.charID, fontDef);
-            validCharsString.emplace(fontDef.charID);
+            unsigned int charID = this->parseCharacterDefinition(line);
+            validCharsString->insert(charID);
         }
-        else if (line.compare(0, prefix_kerning_first.size(), prefix_kerning_first) == 0)
+        else if (memcmp(line, "kerning first", 13) == 0)
         {
-            parseKerningEntry(line);
+            this->parseKerningEntry(line);
         }
     }
-
+    
     return validCharsString;
 }
 
-std::unordered_set<unsigned int> BMFontConfiguration::parseBinaryConfigFile(unsigned char* pData, unsigned long size, std::string const& controlFile)
+std::set<unsigned int>* BMFontConfiguration::parseBinaryConfigFile(unsigned char* pData, unsigned long size, const std::string& controlFile)
 {
     /* based on http://www.angelcode.com/products/bmfont/doc/file_format.html file format */
 
-    std::unordered_set<unsigned int> validCharsString;
+    std::set<unsigned int> *validCharsString = new (std::nothrow) std::set<unsigned int>();
 
     unsigned long remains = size;
 
     CCASSERT(pData[3] == 3, "Only version 3 is supported");
 
-    pData += 4;
-    remains -= 4;
+    pData += 4; remains -= 4;
 
     while (remains > 0)
     {
-        unsigned char blockId = pData[0];
-        pData += 1;
-        remains -= 1;
-        uint32_t blockSize = 0;
-        memcpy(&blockSize, pData, 4);
+        unsigned char blockId = pData[0]; pData += 1; remains -= 1;
+        uint32_t blockSize = 0; memcpy(&blockSize, pData, 4);
 
-        pData += 4;
-        remains -= 4;
+        pData += 4; remains -= 4;
 
         if (blockId == 1)
         {
@@ -324,8 +366,8 @@ std::unordered_set<unsigned int> BMFontConfiguration::parseBinaryConfigFile(unsi
             _padding.bottom = (unsigned char)pData[9];
             _padding.left = (unsigned char)pData[10];
         }
-        else if (blockId == 2)
-        {
+		else if (blockId == 2)
+		{
             /*
              lineHeight 2   uint    0
              base       2   uint    2
@@ -339,20 +381,15 @@ std::unordered_set<unsigned int> BMFontConfiguration::parseBinaryConfigFile(unsi
              blueChnl   1   uint    14
              */
 
-            uint16_t lineHeight = 0;
-            memcpy(&lineHeight, pData, 2);
+            uint16_t lineHeight = 0; memcpy(&lineHeight, pData, 2);
             _commonHeight = lineHeight;
 
-            uint16_t scaleW = 0;
-            memcpy(&scaleW, pData + 4, 2);
-            uint16_t scaleH = 0;
-            memcpy(&scaleH, pData + 6, 2);
+            uint16_t scaleW = 0; memcpy(&scaleW, pData + 4, 2);
+            uint16_t scaleH = 0; memcpy(&scaleH, pData + 6, 2);
 
-            CCASSERT(scaleW <= Configuration::getInstance()->getMaxTextureSize() && scaleH <= Configuration::getInstance()->getMaxTextureSize(),
-                     "CCLabelBMFont: page can't be larger than supported");
+            CCASSERT(scaleW <= Configuration::getInstance()->getMaxTextureSize() && scaleH <= Configuration::getInstance()->getMaxTextureSize(), "CCLabelBMFont: page can't be larger than supported");
 
-            uint16_t pages = 0;
-            memcpy(&pages, pData + 8, 2);
+            uint16_t pages = 0; memcpy(&pages, pData + 8, 2);
             CCASSERT(pages == 1, "CCBitfontAtlas: only supports 1 page");
         }
         else if (blockId == 3)
@@ -361,13 +398,13 @@ std::unordered_set<unsigned int> BMFontConfiguration::parseBinaryConfigFile(unsi
              pageNames 	p*(n+1) 	strings 	0 	p null terminated strings, each with length n
              */
 
-            const char* value = reinterpret_cast<char const*>(pData);
+            const char *value = (const char *)pData;
             CCASSERT(strlen(value) < blockSize, "Block size should be less then string");
 
             _atlasName = FileUtils::getInstance()->fullPathFromRelativeFile(value, controlFile);
         }
-        else if (blockId == 4)
-        {
+		else if (blockId == 4)
+		{
             /*
              id         4   uint    0+c*20  These fields are repeated until all characters have been described
              x          2   uint    4+c*20
@@ -385,46 +422,36 @@ std::unordered_set<unsigned int> BMFontConfiguration::parseBinaryConfigFile(unsi
 
             for (unsigned long i = 0; i < count; i++)
             {
-                BMFontDef fontDef;
-
-                uint32_t charId = 0;
-                memcpy(&charId, pData + (i * 20), 4);
+                uint32_t charId = 0; memcpy(&charId, pData + (i * 20), 4);
+                
+                BMFontDef& fontDef = _fontDefDictionary[charId];
                 fontDef.charID = charId;
 
-                uint16_t charX = 0;
-                memcpy(&charX, pData + (i * 20) + 4, 2);
+                uint16_t charX = 0; memcpy(&charX, pData + (i * 20) + 4, 2);
                 fontDef.rect.origin.x = charX;
 
-                uint16_t charY = 0;
-                memcpy(&charY, pData + (i * 20) + 6, 2);
+                uint16_t charY = 0; memcpy(&charY, pData + (i * 20) + 6, 2);
                 fontDef.rect.origin.y = charY;
 
-                uint16_t charWidth = 0;
-                memcpy(&charWidth, pData + (i * 20) + 8, 2);
+                uint16_t charWidth = 0; memcpy(&charWidth, pData + (i * 20) + 8, 2);
                 fontDef.rect.size.width = charWidth;
 
-                uint16_t charHeight = 0;
-                memcpy(&charHeight, pData + (i * 20) + 10, 2);
+                uint16_t charHeight = 0; memcpy(&charHeight, pData + (i * 20) + 10, 2);
                 fontDef.rect.size.height = charHeight;
 
-                int16_t xoffset = 0;
-                memcpy(&xoffset, pData + (i * 20) + 12, 2);
+                int16_t xoffset = 0; memcpy(&xoffset, pData + (i * 20) + 12, 2);
                 fontDef.xOffset = xoffset;
 
-                int16_t yoffset = 0;
-                memcpy(&yoffset, pData + (i * 20) + 14, 2);
+                int16_t yoffset = 0; memcpy(&yoffset, pData + (i * 20) + 14, 2);
                 fontDef.yOffset = yoffset;
 
-                int16_t xadvance = 0;
-                memcpy(&xadvance, pData + (i * 20) + 16, 2);
+                int16_t xadvance = 0; memcpy(&xadvance, pData + (i * 20) + 16, 2);
                 fontDef.xAdvance = xadvance;
 
-                _fontDefDictionary.emplace(fontDef.charID, fontDef);
-                validCharsString.emplace(fontDef.charID);
+                validCharsString->insert(fontDef.charID);
             }
         }
-        else if (blockId == 5)
-        {
+        else if (blockId == 5) {
             /*
              first  4   uint    0+c*10 	These fields are repeated until all kerning pairs have been described
              second 4   uint    4+c*10
@@ -435,72 +462,62 @@ std::unordered_set<unsigned int> BMFontConfiguration::parseBinaryConfigFile(unsi
 
             for (unsigned long i = 0; i < count; i++)
             {
-                uint32_t first = 0;
-                memcpy(&first, pData + (i * 10), 4);
-                uint32_t second = 0;
-                memcpy(&second, pData + (i * 10) + 4, 4);
-                int16_t amount = 0;
-                memcpy(&amount, pData + (i * 10) + 8, 2);
-
-                unsigned int key = (first << 16) | (second & 0xffff);
-                _kerningDictionary.emplace(key, amount);
+                uint32_t first = 0; memcpy(&first, pData + (i * 10), 4);
+                uint32_t second = 0; memcpy(&second, pData + (i * 10) + 4, 4);
+                int16_t amount = 0; memcpy(&amount, pData + (i * 10) + 8, 2);
+
+                uint64_t key = ((uint64_t)first<<32) | ((uint64_t)second&0xffffffffll);
+                _kerningDictionary[key] = amount;
             }
         }
 
-        pData += blockSize;
-        remains -= blockSize;
+        pData += blockSize; remains -= blockSize;
     }
 
     return validCharsString;
 }
 
-void BMFontConfiguration::parseImageFileName(std::string const& line, std::string const& fntFile)
+void BMFontConfiguration::parseImageFileName(const char* line, const std::string& fntFile)
 {
     //////////////////////////////////////////////////////////////////////////
     // line to parse:
     // page id=0 file="bitmapFontTest.png"
     //////////////////////////////////////////////////////////////////////////
-    auto line_c = line.c_str();
 
     // page ID. Sanity check
-    int pageId = 0;
-    sscanf(line_c, "page id=%d", &pageId);
+    int pageId;
+    sscanf(line, "page id=%d", &pageId);
     CCASSERT(pageId == 0, "LabelBMFont file could not be found");
-    // file
-    std::array<char, 255> fileName;
-    fileName.fill('\0');
-    sscanf(strchr(line_c, '"') + 1, "%[^\"]", fileName.data());
-    _atlasName = FileUtils::getInstance()->fullPathFromRelativeFile(fileName.data(), fntFile);
+    // file 
+    char fileName[255];
+    sscanf(strchr(line,'"') + 1, "%[^\"]", fileName);
+    _atlasName = FileUtils::getInstance()->fullPathFromRelativeFile(fileName, fntFile);
 }
 
-void BMFontConfiguration::parseInfoArguments(std::string const& line)
+void BMFontConfiguration::parseInfoArguments(const char* line)
 {
     //////////////////////////////////////////////////////////////////////////
     // possible lines to parse:
     // info face="Script" size=32 bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=1 aa=1 padding=1,4,3,2 spacing=0,0 outline=0
     // info face="Cracked" size=36 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1
     //////////////////////////////////////////////////////////////////////////
-    auto line_c = line.c_str();
-
-    sscanf(strstr(line_c, "size=") + 5, "%d", &_fontSize);
+    sscanf(strstr(line, "size=") + 5, "%d", &_fontSize);
     // padding
-    sscanf(strstr(line_c, "padding=") + 8, "%d,%d,%d,%d", &_padding.top, &_padding.right, &_padding.bottom, &_padding.left);
-    // CCLOG("cocos2d: padding: %d,%d,%d,%d", _padding.left, _padding.top, _padding.right, _padding.bottom);
+    sscanf(strstr(line,"padding=") + 8, "%d,%d,%d,%d", &_padding.top, &_padding.right, &_padding.bottom, &_padding.left);
+    //CCLOG("cocos2d: padding: %d,%d,%d,%d", _padding.left, _padding.top, _padding.right, _padding.bottom);
 }
 
-void BMFontConfiguration::parseCommonArguments(std::string const& line)
+void BMFontConfiguration::parseCommonArguments(const char* line)
 {
     //////////////////////////////////////////////////////////////////////////
     // line to parse:
     // common lineHeight=104 base=26 scaleW=1024 scaleH=512 pages=1 packed=0
     //////////////////////////////////////////////////////////////////////////
-
-    auto line_c = line.c_str();
-
+  
     // Height
-    auto tmp = strstr(line_c, "lineHeight=") + 11;
+    auto tmp = strstr(line, "lineHeight=") + 11;
     sscanf(tmp, "%d", &_commonHeight);
-
+    
 #if COCOS2D_DEBUG > 0
     // scaleW. sanity check
     int value;
@@ -523,18 +540,21 @@ void BMFontConfiguration::parseCommonArguments(std::string const& line)
     // packed (ignore) What does this mean ??
 }
 
-void BMFontConfiguration::parseCharacterDefinition(std::string const& line, BMFontDef& characterDefinition)
+unsigned int BMFontConfiguration::parseCharacterDefinition(const char* line)
 {
+    unsigned int charID = 0;
+    
     //////////////////////////////////////////////////////////////////////////
     // line to parse:
-    // char id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=44    xadvance=14     page=0  chnl=0
+    // char id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=44    xadvance=14     page=0  chnl=0 
     //////////////////////////////////////////////////////////////////////////
 
-    auto line_c = line.c_str();
-
     // Character ID
-    auto tmp = strstr(line_c, "id=") + 3;
-    sscanf(tmp, "%u", &characterDefinition.charID);
+    auto tmp = strstr(line, "id=") + 3;
+    sscanf(tmp, "%u", &charID);
+    
+    BMFontDef& characterDefinition = _fontDefDictionary[charID];
+    characterDefinition.charID = charID;
 
     // Character x
     tmp = strstr(tmp, "x=") + 2;
@@ -557,19 +577,19 @@ void BMFontConfiguration::parseCharacterDefinition(std::string const& line, BMFo
     // Character xadvance
     tmp = strstr(tmp, "xadvance=") + 9;
     sscanf(tmp, "%hd", &characterDefinition.xAdvance);
+    
+    return charID;
 }
 
-void BMFontConfiguration::parseKerningEntry(std::string const& line)
-{
+void BMFontConfiguration::parseKerningEntry(const char* line)
+{        
     //////////////////////////////////////////////////////////////////////////
     // line to parse:
     // kerning first=121  second=44  amount=-7
     //////////////////////////////////////////////////////////////////////////
 
-    auto line_c = line.c_str();
-
     int first, second, amount;
-    auto tmp = strstr(line_c, "first=") + 6;
+    auto tmp = strstr(line, "first=") + 6;
     sscanf(tmp, "%d", &first);
 
     tmp = strstr(tmp, "second=") + 7;
@@ -578,25 +598,26 @@ void BMFontConfiguration::parseKerningEntry(std::string const& line)
     tmp = strstr(tmp, "amount=") + 7;
     sscanf(tmp, "%d", &amount);
 
-    unsigned int key = (first << 16) | (second & 0xffff);
-    _kerningDictionary.emplace(key, amount);
+    uint64_t key = ((uint64_t)first<<32) | ((uint64_t)second&0xffffffffll);
+    
+    _kerningDictionary[key] = amount;
 }
 
-FontFNT* FontFNT::create(std::string const& fntFilePath, Vec2 const& imageOffset /* = Vec2::ZERO */)
+FontFNT * FontFNT::create(const std::string& fntFilePath, const Vec2& imageOffset /* = Vec2::ZERO */)
 {
-    BMFontConfiguration* newConf = FNTConfigLoadFile(fntFilePath);
+    BMFontConfiguration *newConf = FNTConfigLoadFile(fntFilePath);
     if (!newConf)
         return nullptr;
-
+    
     // add the texture
-    Texture2D* tempTexture = Director::getInstance()->getTextureCache()->addImage(newConf->getAtlasName());
+    Texture2D *tempTexture = Director::getInstance()->getTextureCache()->addImage(newConf->getAtlasName());
     if (!tempTexture)
     {
         return nullptr;
     }
-
-    FontFNT* tempFont = new FontFNT(newConf, imageOffset);
-    tempFont->setFontSize(newConf->getFontSize());
+    
+    FontFNT *tempFont =  new FontFNT(newConf,imageOffset);
+    tempFont->setFontSize((float)newConf->_fontSize);
     if (!tempFont)
     {
         return nullptr;
@@ -605,9 +626,9 @@ FontFNT* FontFNT::create(std::string const& fntFilePath, Vec2 const& imageOffset
     return tempFont;
 }
 
-FontFNT::FontFNT(BMFontConfiguration* theContfig, const Vec2& imageOffset /* = Vec2::ZERO */)
-: _configuration(theContfig)
-, _imageOffset(CC_POINT_PIXELS_TO_POINTS(imageOffset))
+FontFNT::FontFNT(BMFontConfiguration *theContfig, const Vec2& imageOffset /* = Vec2::ZERO */)
+:_configuration(theContfig)
+,_imageOffset(CC_POINT_PIXELS_TO_POINTS(imageOffset))
 {
     _configuration->retain();
 }
@@ -619,147 +640,155 @@ FontFNT::~FontFNT()
 
 void FontFNT::purgeCachedData()
 {
-    auto& configurations = get_configurations();
-    for (auto& conf : configurations)
+    if (s_configurations)
     {
-        conf.second->release();
+        s_configurations->clear();
+        CC_SAFE_DELETE(s_configurations);
     }
-    configurations.clear();
 }
 
-int* FontFNT::getHorizontalKerningForTextUTF16(std::u16string const& text, int& outNumLetters) const
+int * FontFNT::getHorizontalKerningForTextUTF32(const std::u32string& text, int &outNumLetters) const
 {
-    outNumLetters = static_cast<int>(text.size());
-
+    outNumLetters = static_cast<int>(text.length());
+    
     if (!outNumLetters)
         return nullptr;
-
-    int* sizes = new (std::nothrow) int[outNumLetters];
+    
+    int *sizes = new (std::nothrow) int[outNumLetters];
     if (!sizes)
         return nullptr;
-
+    
     for (int c = 0; c < outNumLetters; ++c)
     {
-        if (c < (outNumLetters - 1))
-            sizes[c] = getHorizontalKerningForChars(text[c], text[c + 1]);
+        if (c < (outNumLetters-1))
+            sizes[c] = getHorizontalKerningForChars(text[c], text[c+1]);
         else
             sizes[c] = 0;
     }
-
+    
     return sizes;
 }
 
-int FontFNT::getHorizontalKerningForChars(unsigned short firstChar, unsigned short secondChar) const noexcept
+int  FontFNT::getHorizontalKerningForChars(char32_t firstChar, char32_t secondChar) const
 {
-    unsigned int const key = (firstChar << 16) | (secondChar & 0xffff);
-
-    auto const& kerningDic = _configuration->getKerningDictionary();
-    auto search = kerningDic.find(key);
-    if (search != kerningDic.end())
+    int ret = 0;
+    uint64_t key = ((uint64_t)firstChar << 32) | ((uint64_t)secondChar & 0xffffffffll);
+    
+    auto iter = _configuration->_kerningDictionary.find(key);
+    
+    if (iter != _configuration->_kerningDictionary.end())
     {
-        return search->second;
+        ret = iter->second;
     }
+    
+    return ret;
+}
 
-    return 0;
+void FontFNT::setFontSize(float fontSize)
+{
+    _fontSize = fontSize;
 }
 
-int FontFNT::getOriginalFontSize() const noexcept
+int FontFNT::getOriginalFontSize()const
 {
-    return _configuration->getFontSize();
+    return _configuration->_fontSize;
 }
 
-FontAtlas* FontFNT::createFontAtlas()
+FontAtlas * FontFNT::createFontAtlas()
 {
     // check that everything is fine with the BMFontCofniguration
-    if (_configuration->getKFontDefDictionary().size() == 0)
+    if (_configuration->_fontDefDictionary.empty())
         return nullptr;
-
-    if (_configuration->getCharacterSet().size() == 0)
+    
+    size_t numGlyphs = _configuration->_characterSet->size();
+    if (numGlyphs == 0)
         return nullptr;
-
-    if (_configuration->getCommonHeight() == 0)
+    
+    if (_configuration->_commonHeight == 0)
         return nullptr;
-
-    FontAtlas* tempAtlas = new (std::nothrow) FontAtlas(*this);
+    
+    FontAtlas *tempAtlas = new (std::nothrow) FontAtlas(*this);
     if (tempAtlas == nullptr)
         return nullptr;
-
+    
     // common height
-    int originalFontSize = _configuration->getFontSize();
-    float originalLineHeight = _configuration->getCommonHeight();
+    int originalFontSize = _configuration->_fontSize;
+    float originalLineHeight = (float)_configuration->_commonHeight;
     float factor = 0.0f;
-    if (std::abs(_fontSize - originalFontSize) < std::numeric_limits<float>::epsilon())
-    {
+    if (std::abs(_fontSize - originalFontSize) < FLT_EPSILON) {
         factor = 1.0f;
-    }
-    else
-    {
+    }else {
         factor = _fontSize / originalFontSize;
     }
-
+    
     tempAtlas->setLineHeight(originalLineHeight * factor);
-
-    // Purge uniform hash
-    for (auto const& [key, fontDef] : _configuration->getKFontDefDictionary())
+    
+    for (auto&& e : _configuration->_fontDefDictionary)
     {
+        BMFontDef& fontDef = e.second;
+        
         FontLetterDefinition tempDefinition;
-        Rect tempRect;
 
+        Rect tempRect;
+        
         tempRect = fontDef.rect;
         tempRect = CC_RECT_PIXELS_TO_POINTS(tempRect);
-
-        tempDefinition.offsetX = fontDef.xOffset;
-        tempDefinition.offsetY = fontDef.yOffset;
-
-        tempDefinition.U = tempRect.origin.x + _imageOffset.x;
-        tempDefinition.V = tempRect.origin.y + _imageOffset.y;
-
-        tempDefinition.width = tempRect.size.width;
-        tempDefinition.height = tempRect.size.height;
-
-        // carloX: only one texture supported FOR NOW
+        
+        tempDefinition.offsetX  = fontDef.xOffset;
+        tempDefinition.offsetY  = fontDef.yOffset;
+        
+        tempDefinition.U        = tempRect.origin.x + _imageOffset.x;
+        tempDefinition.V        = tempRect.origin.y + _imageOffset.y;
+        
+        tempDefinition.width    = tempRect.size.width;
+        tempDefinition.height   = tempRect.size.height;
+        
+        //carloX: only one texture supported FOR NOW
         tempDefinition.textureID = 0;
-
+        
         tempDefinition.validDefinition = true;
         tempDefinition.xAdvance = fontDef.xAdvance;
         // add the new definition
-        if (65535 < fontDef.charID)
-        {
+        if (65535 < fontDef.charID) {
             CCLOGWARN("Warning: 65535 < fontDef.charID (%u), ignored", fontDef.charID);
-        }
-        else
-        {
-            tempAtlas->addLetterDefinition(fontDef.charID, tempDefinition);
+        } else {
+            tempAtlas->addLetterDefinition(fontDef.charID,tempDefinition);
         }
     }
-
+    
     // add the texture (only one texture for now)
-    Texture2D* tempTexture = Director::getInstance()->getTextureCache()->addImage(_configuration->getAtlasName());
-    if (tempTexture == nullptr)
-    {
+    
+    Texture2D *tempTexture = Director::getInstance()->getTextureCache()->addImage(_configuration->getAtlasName());
+    if (!tempTexture) {
         CC_SAFE_RELEASE(tempAtlas);
         return nullptr;
     }
+    
     // add the texture
     tempAtlas->addTexture(tempTexture, 0);
+    
     // done
     return tempAtlas;
 }
 
 void FontFNT::reloadBMFontResource(const std::string& fntFilePath)
 {
-    auto& configurations = get_configurations();
-
-    if (auto search = configurations.find(fntFilePath); search != configurations.end())
+    if (s_configurations == nullptr)
     {
-        search->second->release();
-        configurations.erase(search);
+        s_configurations = new (std::nothrow) Map<std::string, BMFontConfiguration*>();
     }
 
-    if (BMFontConfiguration* ret = BMFontConfiguration::create(fntFilePath); ret != nullptr)
+    BMFontConfiguration *ret = s_configurations->at(fntFilePath);
+    if (ret != nullptr)
     {
-        configurations.emplace(fntFilePath, ret);
+        s_configurations->erase(fntFilePath);
+    }
+    ret = BMFontConfiguration::create(fntFilePath);
+    if (ret)
+    {
+        s_configurations->insert(fntFilePath, ret);
         Director::getInstance()->getTextureCache()->reloadTexture(ret->getAtlasName());
+
     }
 }
 
diff --git a/cocos2d/cocos/2d/CCFontFNT.h b/cocos2d/cocos/2d/CCFontFNT.h
index f3356bad7d..8038fa76b4 100644
--- a/cocos2d/cocos/2d/CCFontFNT.h
+++ b/cocos2d/cocos/2d/CCFontFNT.h
@@ -1,19 +1,20 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -23,55 +24,55 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_FONTFNT_H
-#define CC_2D_FONTFNT_H
+#ifndef _CCFontFNT_h_
+#define _CCFontFNT_h_
 
-#include <cocos/2d/CCFont.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
+/// @cond DO_NOT_SHOW
 
-#include <iosfwd>
-#include <string>
+#include <cocos/2d/CCFont.h>
 
 NS_CC_BEGIN
 
 class BMFontConfiguration;
-class FontAtlas;
 
-class CC_DLL FontFNT final : public Font
+class CC_DLL FontFNT : public Font
 {
-    BMFontConfiguration* _configuration = nullptr;
-    Vec2 _imageOffset = Vec2::ZERO;
-    // User defined font size
-    float _fontSize;
-
+    
 public:
-    static FontFNT* create(std::string const& fntFilePath, Vec2 const& imageOffset = Vec2::ZERO);
+    
+    static FontFNT * create(const std::string& fntFilePath, const Vec2& imageOffset = Vec2::ZERO);
     /** Purges the cached data.
     Removes from memory the cached configurations and the atlas name dictionary.
     */
     static void purgeCachedData();
-    int* getHorizontalKerningForTextUTF16(std::u16string const& text, int& outNumLetters) const final;
-    FontAtlas* createFontAtlas() final;
-    inline void setFontSize(float fontSize) noexcept { _fontSize = fontSize; }
-    int getOriginalFontSize() const noexcept;
-
-    static void reloadBMFontResource(std::string const& fntFilePath);
-
+    virtual int* getHorizontalKerningForTextUTF32(const std::u32string& text, int &outNumLetters) const override;
+    virtual FontAtlas *createFontAtlas() override;
+    void setFontSize(float fontSize);
+    int getOriginalFontSize()const;
+
+    static void reloadBMFontResource(const std::string& fntFilePath);
+
+protected:
+    
+    FontFNT(BMFontConfiguration *theContfig, const Vec2& imageOffset = Vec2::ZERO);
+    /**
+     * @js NA
+     * @lua NA
+     */
+    virtual ~FontFNT();
+    
 private:
-    FontFNT() = default;
-    FontFNT(BMFontConfiguration* theContfig, Vec2 const& imageOffset = Vec2::ZERO);
-    FontFNT(FontFNT const&) = delete;
-    FontFNT& operator=(FontFNT const&) = delete;
-    FontFNT(FontFNT&&) noexcept = delete;
-    FontFNT& operator=(FontFNT&&) noexcept = delete;
-    ~FontFNT() final;
-
-private:
-    int getHorizontalKerningForChars(unsigned short firstChar, unsigned short secondChar) const noexcept;
+    
+    int  getHorizontalKerningForChars(char32_t firstChar, char32_t secondChar) const;
+    
+    BMFontConfiguration * _configuration;
+    Vec2                   _imageOffset;
+    //User defined font size
+    float  _fontSize;
 };
 
+/// @endcond
+
 NS_CC_END
 
-#endif // CC_2D_FONTFNT_H
+#endif /* defined(__cocos2d_libs__CCFontFNT__) */
diff --git a/cocos2d/cocos/2d/CCFontFreeType.cpp b/cocos2d/cocos/2d/CCFontFreeType.cpp
index efac8ffb13..8170783e5b 100644
--- a/cocos2d/cocos/2d/CCFontFreeType.cpp
+++ b/cocos2d/cocos/2d/CCFontFreeType.cpp
@@ -1,7 +1,8 @@
 /****************************************************************************
 Copyright (c) 2013      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -24,13 +25,8 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCFontFreeType.h>
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Weverything"
 #include FT_BBOX_H
 #include "edtaa3func.h"
-#pragma clang diagnostic pop
-
 #include <cocos/2d/CCFontAtlas.h>
 #include <cocos/base/CCDirector.h>
 #include <cocos/base/ccUTF8.h>
@@ -38,37 +34,37 @@ THE SOFTWARE.
 
 NS_CC_BEGIN
 
+
 FT_Library FontFreeType::_FTlibrary;
-bool FontFreeType::_FTInitialized = false;
-const int FontFreeType::DistanceMapSpread = 3;
+bool       FontFreeType::_FTInitialized = false;
+const int  FontFreeType::DistanceMapSpread = 3;
 
-const char* FontFreeType::_glyphASCII =
-    "\"!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþ ";
+const char* FontFreeType::_glyphASCII = "\"!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþ ";
 const char* FontFreeType::_glyphNEHE = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ";
 
 typedef struct _DataRef
 {
     Data data;
     unsigned int referenceCount;
-} DataRef;
+}DataRef;
 
 static std::unordered_map<std::string, DataRef> s_cacheFontData;
 
-FontFreeType* FontFreeType::create(const std::string& fontName, float fontSize, GlyphCollection glyphs, const char* customGlyphs,
-                                   bool distanceFieldEnabled /* = false */, int outline /* = 0 */)
+FontFreeType * FontFreeType::create(const std::string &fontName, float fontSize, GlyphCollection glyphs, const char *customGlyphs,bool distanceFieldEnabled /* = false */,float outline /* = 0 */)
 {
-    FontFreeType* tempFont = new FontFreeType(distanceFieldEnabled, outline);
+    FontFreeType *tempFont =  new (std::nothrow) FontFreeType(distanceFieldEnabled,outline);
 
     if (!tempFont)
         return nullptr;
-
+    
     tempFont->setGlyphCollection(glyphs, customGlyphs);
-
+    
     if (!tempFont->createFontObject(fontName, fontSize))
     {
         delete tempFont;
         return nullptr;
     }
+    tempFont->autorelease();
     return tempFont;
 }
 
@@ -77,13 +73,13 @@ bool FontFreeType::initFreeType()
     if (_FTInitialized == false)
     {
         // begin freetype
-        if (FT_Init_FreeType(&_FTlibrary))
+        if (FT_Init_FreeType( &_FTlibrary ))
             return false;
-
+        
         _FTInitialized = true;
     }
-
-    return _FTInitialized;
+    
+    return  _FTInitialized;
 }
 
 void FontFreeType::shutdownFreeType()
@@ -102,25 +98,29 @@ FT_Library FontFreeType::getFTLibrary()
     return _FTlibrary;
 }
 
-FontFreeType::FontFreeType(bool distanceFieldEnabled /* = false */, int outline /* = 0 */)
+FontFreeType::FontFreeType(bool distanceFieldEnabled /* = false */, float outline /* = 0 */)
 : _fontRef(nullptr)
 , _stroker(nullptr)
+, _encoding(FT_ENCODING_UNICODE)
 , _distanceFieldEnabled(distanceFieldEnabled)
 , _outlineSize(0.0f)
 , _lineHeight(0)
-, _encoding(FT_ENCODING_UNICODE)
 , _fontAtlas(nullptr)
 , _usedGlyphs(GlyphCollection::ASCII)
 {
-    if (outline > 0)
+    if (outline > 0.0f)
     {
         _outlineSize = outline * CC_CONTENT_SCALE_FACTOR();
         FT_Stroker_New(FontFreeType::getFTLibrary(), &_stroker);
-        FT_Stroker_Set(_stroker, static_cast<int>(_outlineSize * 64), FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);
+        FT_Stroker_Set(_stroker,
+            (int)(_outlineSize * 64),
+            FT_STROKER_LINECAP_ROUND,
+            FT_STROKER_LINEJOIN_ROUND,
+            0);
     }
 }
 
-bool FontFreeType::createFontObject(const std::string& fontName, float fontSize)
+bool FontFreeType::createFontObject(const std::string &fontName, float fontSize)
 {
     FT_Face face;
     // save font name locally
@@ -134,7 +134,7 @@ bool FontFreeType::createFontObject(const std::string& fontName, float fontSize)
     else
     {
         s_cacheFontData[fontName].referenceCount = 1;
-        s_cacheFontData[fontName].data = FileUtils::getInstance()->getDataFromFile(fontName);
+        s_cacheFontData[fontName].data = FileUtils::getInstance()->getDataFromFile(fontName);    
 
         if (s_cacheFontData[fontName].data.isNull())
         {
@@ -142,7 +142,7 @@ bool FontFreeType::createFontObject(const std::string& fontName, float fontSize)
         }
     }
 
-    if (FT_New_Memory_Face(getFTLibrary(), s_cacheFontData[fontName].data.getBytes(), s_cacheFontData[fontName].data.getSize(), 0, &face))
+    if (FT_New_Memory_Face(getFTLibrary(), s_cacheFontData[fontName].data.getBytes(), s_cacheFontData[fontName].data.getSize(), 0, &face ))
         return false;
 
     if (FT_Select_Charmap(face, FT_ENCODING_UNICODE))
@@ -171,14 +171,14 @@ bool FontFreeType::createFontObject(const std::string& fontName, float fontSize)
 
     // set the requested font size
     int dpi = 72;
-    int fontSizePoints = static_cast<int>(64.f * fontSize * CC_CONTENT_SCALE_FACTOR());
+    int fontSizePoints = (int)(64.f * fontSize * CC_CONTENT_SCALE_FACTOR());
     if (FT_Set_Char_Size(face, fontSizePoints, fontSizePoints, dpi, dpi))
         return false;
-
+    
     // store the face globally
     _fontRef = face;
-    _lineHeight = static_cast<int>(_fontRef->size->metrics.height >> 6);
-
+    _lineHeight = static_cast<int>((_fontRef->size->metrics.ascender - _fontRef->size->metrics.descender) >> 6);
+    
     // done and good
     return true;
 }
@@ -197,78 +197,82 @@ FontFreeType::~FontFreeType()
         }
     }
 
-    s_cacheFontData[_fontName].referenceCount -= 1;
-    if (s_cacheFontData[_fontName].referenceCount == 0)
+    auto iter = s_cacheFontData.find(_fontName);
+    if (iter != s_cacheFontData.end())
     {
-        s_cacheFontData.erase(_fontName);
+        iter->second.referenceCount -= 1;
+        if (iter->second.referenceCount == 0)
+        {
+            s_cacheFontData.erase(iter);
+        }
     }
 }
 
-FontAtlas* FontFreeType::createFontAtlas()
+FontAtlas * FontFreeType::createFontAtlas()
 {
     if (_fontAtlas == nullptr)
     {
         _fontAtlas = new (std::nothrow) FontAtlas(*this);
         if (_fontAtlas && _usedGlyphs != GlyphCollection::DYNAMIC)
         {
-            std::u16string utf16;
-            if (StringUtils::UTF8ToUTF16(getGlyphCollection(), utf16))
+            std::u32string utf32;
+            if (StringUtils::UTF8ToUTF32(getGlyphCollection(), utf32))
             {
-                _fontAtlas->prepareLetterDefinitions(utf16);
+                _fontAtlas->prepareLetterDefinitions(utf32);
             }
         }
-        this->autorelease();
+//        this->autorelease();
     }
-
+    
     return _fontAtlas;
 }
 
-int* FontFreeType::getHorizontalKerningForTextUTF16(const std::u16string& text, int& outNumLetters) const
+int * FontFreeType::getHorizontalKerningForTextUTF32(const std::u32string& text, int &outNumLetters) const
 {
     if (!_fontRef)
         return nullptr;
-
+    
     outNumLetters = static_cast<int>(text.length());
 
     if (!outNumLetters)
         return nullptr;
-
-    int* sizes = new (std::nothrow) int[outNumLetters];
+    
+    int *sizes = new (std::nothrow) int[outNumLetters];
     if (!sizes)
         return nullptr;
-    memset(sizes, 0, outNumLetters * sizeof(int));
+    memset(sizes,0,outNumLetters * sizeof(int));
 
-    bool hasKerning = FT_HAS_KERNING(_fontRef) != 0;
+    bool hasKerning = FT_HAS_KERNING( _fontRef ) != 0;
     if (hasKerning)
     {
         for (int c = 1; c < outNumLetters; ++c)
         {
-            sizes[c] = getHorizontalKerningForChars(text[c - 1], text[c]);
+            sizes[c] = getHorizontalKerningForChars(text[c-1], text[c]);
         }
     }
-
+    
     return sizes;
 }
 
-int FontFreeType::getHorizontalKerningForChars(unsigned short firstChar, unsigned short secondChar) const
+int  FontFreeType::getHorizontalKerningForChars(uint64_t firstChar, uint64_t secondChar) const
 {
     // get the ID to the char we need
-    int glyphIndex1 = FT_Get_Char_Index(_fontRef, firstChar);
-
+    int glyphIndex1 = FT_Get_Char_Index(_fontRef, static_cast<FT_ULong>(firstChar));
+    
     if (!glyphIndex1)
         return 0;
-
+    
     // get the ID to the char we need
-    int glyphIndex2 = FT_Get_Char_Index(_fontRef, secondChar);
-
+    int glyphIndex2 = FT_Get_Char_Index(_fontRef, static_cast<FT_ULong>(secondChar));
+    
     if (!glyphIndex2)
         return 0;
-
+    
     FT_Vector kerning;
-
-    if (FT_Get_Kerning(_fontRef, glyphIndex1, glyphIndex2, FT_KERNING_DEFAULT, &kerning))
+    
+    if (FT_Get_Kerning( _fontRef, glyphIndex1, glyphIndex2,  FT_KERNING_DEFAULT,  &kerning))
         return 0;
-
+    
     return (static_cast<int>(kerning.x >> 6));
 }
 
@@ -285,7 +289,7 @@ const char* FontFreeType::getFontFamily() const
     return _fontRef->family_name;
 }
 
-unsigned char* FontFreeType::getGlyphBitmap(unsigned short theChar, long& outWidth, long& outHeight, Rect& outRect, int& xAdvance)
+unsigned char* FontFreeType::getGlyphBitmap(uint64_t theChar, long &outWidth, long &outHeight, Rect &outRect,int &xAdvance)
 {
     bool invalidChar = true;
     unsigned char* ret = nullptr;
@@ -297,50 +301,50 @@ unsigned char* FontFreeType::getGlyphBitmap(unsigned short theChar, long& outWid
 
         if (_distanceFieldEnabled)
         {
-            if (FT_Load_Char(_fontRef, theChar, FT_LOAD_RENDER | FT_LOAD_NO_HINTING | FT_LOAD_NO_AUTOHINT))
+            if (FT_Load_Char(_fontRef, static_cast<FT_ULong>(theChar), FT_LOAD_RENDER | FT_LOAD_NO_HINTING | FT_LOAD_NO_AUTOHINT))
                 break;
         }
         else
         {
-            if (FT_Load_Char(_fontRef, theChar, FT_LOAD_RENDER | FT_LOAD_NO_AUTOHINT))
+            if (FT_Load_Char(_fontRef, static_cast<FT_ULong>(theChar), FT_LOAD_RENDER | FT_LOAD_NO_AUTOHINT))
                 break;
         }
 
         auto& metrics = _fontRef->glyph->metrics;
-        outRect.origin.x = metrics.horiBearingX >> 6;
-        outRect.origin.y = -(metrics.horiBearingY >> 6);
-        outRect.size.width = (metrics.width >> 6);
-        outRect.size.height = (metrics.height >> 6);
+        outRect.origin.x = static_cast<float>(metrics.horiBearingX >> 6);
+        outRect.origin.y = static_cast<float>(-(metrics.horiBearingY >> 6));
+        outRect.size.width = static_cast<float>((metrics.width >> 6));
+        outRect.size.height = static_cast<float>((metrics.height >> 6));
 
         xAdvance = (static_cast<int>(_fontRef->glyph->metrics.horiAdvance >> 6));
 
-        outWidth = _fontRef->glyph->bitmap.width;
+        outWidth  = _fontRef->glyph->bitmap.width;
         outHeight = _fontRef->glyph->bitmap.rows;
         ret = _fontRef->glyph->bitmap.buffer;
 
         if (_outlineSize > 0 && outWidth > 0 && outHeight > 0)
         {
             auto copyBitmap = new (std::nothrow) unsigned char[outWidth * outHeight];
-            memcpy(copyBitmap, ret, outWidth * outHeight * sizeof(unsigned char));
+            memcpy(copyBitmap,ret,outWidth * outHeight * sizeof(unsigned char));
 
             FT_BBox bbox;
-            auto outlineBitmap = getGlyphBitmapWithOutline(theChar, bbox);
-            if (outlineBitmap == nullptr)
+            auto outlineBitmap = getGlyphBitmapWithOutline(theChar,bbox);
+            if(outlineBitmap == nullptr)
             {
                 ret = nullptr;
-                delete[] copyBitmap;
+                delete [] copyBitmap;
                 break;
             }
 
-            long glyphMinX = outRect.origin.x;
-            long glyphMaxX = outRect.origin.x + outWidth;
-            long glyphMinY = -outHeight - outRect.origin.y;
-            long glyphMaxY = -outRect.origin.y;
+            int glyphMinX = (int)outRect.origin.x;
+            int glyphMaxX = (int)(outRect.origin.x + outWidth);
+            int glyphMinY = (int)(-outHeight - outRect.origin.y);
+            int glyphMaxY = (int)-outRect.origin.y;
 
-            auto outlineMinX = bbox.xMin >> 6;
-            auto outlineMaxX = bbox.xMax >> 6;
-            auto outlineMinY = bbox.yMin >> 6;
-            auto outlineMaxY = bbox.yMax >> 6;
+            int outlineMinX = bbox.xMin >> 6;
+            int outlineMaxX = bbox.xMax >> 6;
+            int outlineMinY = bbox.yMin >> 6;
+            int outlineMaxY = bbox.yMax >> 6;
             auto outlineWidth = outlineMaxX - outlineMinX;
             auto outlineHeight = outlineMaxY - outlineMinY;
 
@@ -349,44 +353,49 @@ unsigned char* FontFreeType::getGlyphBitmap(unsigned short theChar, long& outWid
             auto blendWidth = MAX(outlineMaxX, glyphMaxX) - blendImageMinX;
             auto blendHeight = blendImageMaxY - MIN(outlineMinY, glyphMinY);
 
-            outRect.origin.x = blendImageMinX;
+            outRect.origin.x = (float)blendImageMinX;
             outRect.origin.y = -blendImageMaxY + _outlineSize;
 
-            long index, index2;
-            auto blendImage = new (std::nothrow) unsigned char[blendWidth * blendHeight * 2];
-            memset(blendImage, 0, blendWidth * blendHeight * 2);
-
-            auto px = outlineMinX - blendImageMinX;
-            auto py = blendImageMaxY - outlineMaxY;
-            for (int x = 0; x < outlineWidth; ++x)
+            unsigned char *blendImage = nullptr;
+            if (blendWidth > 0 && blendHeight > 0)
             {
-                for (int y = 0; y < outlineHeight; ++y)
+                int index, index2;
+                int imageSize = blendWidth * blendHeight * 2;
+                blendImage = new (std::nothrow) unsigned char[imageSize];
+                memset(blendImage, 0, imageSize);
+
+                auto px = outlineMinX - blendImageMinX;
+                auto py = blendImageMaxY - outlineMaxY;
+                for (int x = 0; x < outlineWidth; ++x)
                 {
-                    index = px + x + ((py + y) * blendWidth);
-                    index2 = x + (y * outlineWidth);
-                    blendImage[2 * index] = outlineBitmap[index2];
+                    for (int y = 0; y < outlineHeight; ++y)
+                    {
+                        index = px + x + ((py + y) * blendWidth);
+                        index2 = x + (y * outlineWidth);
+                        blendImage[2 * index] = outlineBitmap[index2];
+                    }
                 }
-            }
 
-            px = glyphMinX - blendImageMinX;
-            py = blendImageMaxY - glyphMaxY;
-            for (int x = 0; x < outWidth; ++x)
-            {
-                for (int y = 0; y < outHeight; ++y)
+                px = glyphMinX - blendImageMinX;
+                py = blendImageMaxY - glyphMaxY;
+                for (int x = 0; x < outWidth; ++x)
                 {
-                    index = px + x + ((y + py) * blendWidth);
-                    index2 = x + (y * outWidth);
-                    blendImage[2 * index + 1] = copyBitmap[index2];
+                    for (int y = 0; y < outHeight; ++y)
+                    {
+                        index = px + x + ((y + py) * blendWidth);
+                        index2 = x + (y * outWidth);
+                        blendImage[2 * index + 1] = copyBitmap[index2];
+                    }
                 }
             }
 
-            outRect.size.width = blendWidth;
-            outRect.size.height = blendHeight;
-            outWidth = blendWidth;
+            outRect.size.width  = (float)blendWidth;
+            outRect.size.height = (float)blendHeight;
+            outWidth  = blendWidth;
             outHeight = blendHeight;
 
-            delete[] outlineBitmap;
-            delete[] copyBitmap;
+            delete [] outlineBitmap;
+            delete [] copyBitmap;
             ret = blendImage;
         }
 
@@ -395,7 +404,7 @@ unsigned char* FontFreeType::getGlyphBitmap(unsigned short theChar, long& outWid
 
     if (invalidChar)
     {
-        outRect.size.width = 0;
+        outRect.size.width  = 0;
         outRect.size.height = 0;
         xAdvance = 0;
 
@@ -403,14 +412,14 @@ unsigned char* FontFreeType::getGlyphBitmap(unsigned short theChar, long& outWid
     }
     else
     {
-        return ret;
+       return ret;
     }
 }
 
-unsigned char* FontFreeType::getGlyphBitmapWithOutline(unsigned short theChar, FT_BBox& bbox)
-{
+unsigned char * FontFreeType::getGlyphBitmapWithOutline(uint64_t theChar, FT_BBox &bbox)
+{   
     unsigned char* ret = nullptr;
-    if (FT_Load_Char(_fontRef, theChar, FT_LOAD_NO_BITMAP) == 0)
+    if (FT_Load_Char(_fontRef, static_cast<FT_ULong>(theChar), FT_LOAD_NO_BITMAP) == 0)
     {
         if (_fontRef->glyph->format == FT_GLYPH_FORMAT_OUTLINE)
         {
@@ -420,26 +429,26 @@ unsigned char* FontFreeType::getGlyphBitmapWithOutline(unsigned short theChar, F
                 FT_Glyph_StrokeBorder(&glyph, _stroker, 0, 1);
                 if (glyph->format == FT_GLYPH_FORMAT_OUTLINE)
                 {
-                    FT_Outline* outline = &reinterpret_cast<FT_OutlineGlyph>(glyph)->outline;
-                    FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_GRIDFIT, &bbox);
-                    long width = (bbox.xMax - bbox.xMin) >> 6;
-                    long rows = (bbox.yMax - bbox.yMin) >> 6;
+                    FT_Outline *outline = &reinterpret_cast<FT_OutlineGlyph>(glyph)->outline;
+                    FT_Glyph_Get_CBox(glyph,FT_GLYPH_BBOX_GRIDFIT,&bbox);
+                    long width = (bbox.xMax - bbox.xMin)>>6;
+                    long rows = (bbox.yMax - bbox.yMin)>>6;
 
                     FT_Bitmap bmp;
                     bmp.buffer = new (std::nothrow) unsigned char[width * rows];
                     memset(bmp.buffer, 0, width * rows);
-                    bmp.width = static_cast<int>(width);
-                    bmp.rows = static_cast<int>(rows);
-                    bmp.pitch = static_cast<int>(width);
+                    bmp.width = (int)width;
+                    bmp.rows = (int)rows;
+                    bmp.pitch = (int)width;
                     bmp.pixel_mode = FT_PIXEL_MODE_GRAY;
                     bmp.num_grays = 256;
 
                     FT_Raster_Params params;
-                    memset(&params, 0, sizeof(params));
+                    memset(&params, 0, sizeof (params));
                     params.source = outline;
                     params.target = &bmp;
                     params.flags = FT_RASTER_FLAG_AA;
-                    FT_Outline_Translate(outline, -bbox.xMin, -bbox.yMin);
+                    FT_Outline_Translate(outline,-bbox.xMin,-bbox.yMin);
                     FT_Outline_Render(_FTlibrary, outline, &params);
 
                     ret = bmp.buffer;
@@ -452,18 +461,18 @@ unsigned char* FontFreeType::getGlyphBitmapWithOutline(unsigned short theChar, F
     return ret;
 }
 
-unsigned char* makeDistanceMap(unsigned char* img, long width, long height)
+unsigned char * makeDistanceMap( unsigned char *img, long width, long height)
 {
     long pixelAmount = (width + 2 * FontFreeType::DistanceMapSpread) * (height + 2 * FontFreeType::DistanceMapSpread);
 
-    short* xdist = reinterpret_cast<short*>(malloc(pixelAmount * sizeof(short)));
-    short* ydist = reinterpret_cast<short*>(malloc(pixelAmount * sizeof(short)));
-    double* gx = reinterpret_cast<double*>(calloc(pixelAmount, sizeof(double)));
-    double* gy = reinterpret_cast<double*>(calloc(pixelAmount, sizeof(double)));
-    double* data = reinterpret_cast<double*>(calloc(pixelAmount, sizeof(double)));
-    double* outside = reinterpret_cast<double*>(calloc(pixelAmount, sizeof(double)));
-    double* inside = reinterpret_cast<double*>(calloc(pixelAmount, sizeof(double)));
-    long i, j;
+    short * xdist = (short *)  malloc( pixelAmount * sizeof(short) );
+    short * ydist = (short *)  malloc( pixelAmount * sizeof(short) );
+    double * gx   = (double *) calloc( pixelAmount, sizeof(double) );
+    double * gy      = (double *) calloc( pixelAmount, sizeof(double) );
+    double * data    = (double *) calloc( pixelAmount, sizeof(double) );
+    double * outside = (double *) calloc( pixelAmount, sizeof(double) );
+    double * inside  = (double *) calloc( pixelAmount, sizeof(double) );
+    long i,j;
 
     // Convert img into double (data) rescale image levels between 0 and 1
     long outWidth = width + 2 * FontFreeType::DistanceMapSpread;
@@ -478,38 +487,36 @@ unsigned char* makeDistanceMap(unsigned char* img, long width, long height)
     width += 2 * FontFreeType::DistanceMapSpread;
     height += 2 * FontFreeType::DistanceMapSpread;
 
-    // Transform background (outside contour, in areas of 0's)
-    computegradient(data, static_cast<int>(width), static_cast<int>(height), gx, gy);
-    edtaa3(data, gx, gy, static_cast<int>(width), static_cast<int>(height), xdist, ydist, outside);
-    for (i = 0; i < pixelAmount; i++)
-        if (outside[i] < 0.0)
+    // Transform background (outside contour, in areas of 0's)   
+    computegradient( data, (int)width, (int)height, gx, gy);
+    edtaa3(data, gx, gy, (int)width, (int)height, xdist, ydist, outside);
+    for( i=0; i< pixelAmount; i++)
+        if( outside[i] < 0.0 )
             outside[i] = 0.0;
 
-    // Transform foreground (inside contour, in areas of 1's)
-    for (i = 0; i < pixelAmount; i++)
+    // Transform foreground (inside contour, in areas of 1's)   
+    for( i=0; i< pixelAmount; i++)
         data[i] = 1 - data[i];
-    computegradient(data, static_cast<int>(width), static_cast<int>(height), gx, gy);
-    edtaa3(data, gx, gy, static_cast<int>(width), static_cast<int>(height), xdist, ydist, inside);
-    for (i = 0; i < pixelAmount; i++)
-        if (inside[i] < 0.0)
+    computegradient( data, (int)width, (int)height, gx, gy);
+    edtaa3(data, gx, gy, (int)width, (int)height, xdist, ydist, inside);
+    for( i=0; i< pixelAmount; i++)
+        if( inside[i] < 0.0 )
             inside[i] = 0.0;
 
     // The bipolar distance field is now outside-inside
     double dist;
-    /* Single channel 8-bit output (bad precision and range, but simple) */
-    unsigned char* out = reinterpret_cast<unsigned char*>(malloc(pixelAmount * sizeof(unsigned char)));
-    for (i = 0; i < pixelAmount; i++)
+    /* Single channel 8-bit output (bad precision and range, but simple) */    
+    unsigned char *out = (unsigned char *) malloc( pixelAmount * sizeof(unsigned char) );
+    for( i=0; i < pixelAmount; i++)
     {
         dist = outside[i] - inside[i];
-        dist = 128.0 - dist * 16;
-        if (dist < 0)
-            dist = 0;
-        if (dist > 255)
-            dist = 255;
-        out[i] = static_cast<unsigned char>(dist);
+        dist = 128.0 - dist*16;
+        if( dist < 0 ) dist = 0;
+        if( dist > 255 ) dist = 255;
+        out[i] = (unsigned char) dist;
     }
     /* Dual channel 16-bit output (more complicated, but good precision and range) */
-    /*unsigned char *out = (unsigned char *) malloc( pixelAmount * 3 * sizeof(unsigned char) );
+    /*unsigned char *out = (unsigned char *) malloc( pixelAmount * 3 * sizeof(unsigned char) ); 
     for( i=0; i< pixelAmount; i++)
     {
         dist = outside[i] - inside[i];
@@ -521,28 +528,28 @@ unsigned char* makeDistanceMap(unsigned char* img, long width, long height)
         // G channel is fraction
         out[3*i + 1] = (unsigned char) ( 256 - (dist - floor(dist)* 256.0 ));
         // B channel is truncated integer part
-        out[3*i + 2] = (unsigned char)dist;
+        out[3*i + 2] = (unsigned char)dist; 
     }*/
-
-    free(xdist);
-    free(ydist);
-    free(gx);
-    free(gy);
-    free(data);
-    free(outside);
-    free(inside);
+    
+    free( xdist );
+    free( ydist );
+    free( gx );
+    free( gy );
+    free( data );
+    free( outside );
+    free( inside );
 
     return out;
 }
 
-void FontFreeType::renderCharAt(unsigned char* dest, int posX, int posY, unsigned char* bitmap, long bitmapWidth, long bitmapHeight)
+void FontFreeType::renderCharAt(unsigned char *dest,int posX, int posY, unsigned char* bitmap,long bitmapWidth,long bitmapHeight)
 {
     int iX = posX;
     int iY = posY;
 
     if (_distanceFieldEnabled)
     {
-        auto distanceMap = makeDistanceMap(bitmap, bitmapWidth, bitmapHeight);
+        auto distanceMap = makeDistanceMap(bitmap,bitmapWidth,bitmapHeight);
 
         bitmapWidth += 2 * DistanceMapSpread;
         bitmapHeight += 2 * DistanceMapSpread;
@@ -552,26 +559,26 @@ void FontFreeType::renderCharAt(unsigned char* dest, int posX, int posY, unsigne
             long bitmap_y = y * bitmapWidth;
 
             for (long x = 0; x < bitmapWidth; ++x)
-            {
+            {    
                 /* Dual channel 16-bit output (more complicated, but good precision and range) */
-                /*int index = (iX + ( iY * destSize )) * 3;
+                /*int index = (iX + ( iY * destSize )) * 3;                
                 int index2 = (bitmap_y + x)*3;
                 dest[index] = out[index2];
                 dest[index + 1] = out[index2 + 1];
                 dest[index + 2] = out[index2 + 2];*/
 
-                // Single channel 8-bit output
-                dest[iX + (iY * FontAtlas::CacheTextureWidth)] = distanceMap[bitmap_y + x];
+                //Single channel 8-bit output 
+                dest[iX + ( iY * FontAtlas::CacheTextureWidth )] = distanceMap[bitmap_y + x];
 
                 iX += 1;
             }
 
-            iX = posX;
+            iX  = posX;
             iY += 1;
         }
         free(distanceMap);
     }
-    else if (_outlineSize > 0)
+    else if(_outlineSize > 0)
     {
         unsigned char tempChar;
         for (long y = 0; y < bitmapHeight; ++y)
@@ -581,17 +588,17 @@ void FontFreeType::renderCharAt(unsigned char* dest, int posX, int posY, unsigne
             for (int x = 0; x < bitmapWidth; ++x)
             {
                 tempChar = bitmap[(bitmap_y + x) * 2];
-                dest[(iX + (iY * FontAtlas::CacheTextureWidth)) * 2] = tempChar;
+                dest[(iX + ( iY * FontAtlas::CacheTextureWidth ) ) * 2] = tempChar;
                 tempChar = bitmap[(bitmap_y + x) * 2 + 1];
-                dest[(iX + (iY * FontAtlas::CacheTextureWidth)) * 2 + 1] = tempChar;
+                dest[(iX + ( iY * FontAtlas::CacheTextureWidth ) ) * 2 + 1] = tempChar;
 
                 iX += 1;
             }
 
-            iX = posX;
+            iX  = posX;
             iY += 1;
         }
-        delete[] bitmap;
+        delete [] bitmap;
     }
     else
     {
@@ -604,15 +611,15 @@ void FontFreeType::renderCharAt(unsigned char* dest, int posX, int posY, unsigne
                 unsigned char cTemp = bitmap[bitmap_y + x];
 
                 // the final pixel
-                dest[(iX + (iY * FontAtlas::CacheTextureWidth))] = cTemp;
+                dest[(iX + ( iY * FontAtlas::CacheTextureWidth ) )] = cTemp;
 
                 iX += 1;
             }
 
-            iX = posX;
+            iX  = posX;
             iY += 1;
         }
-    }
+    } 
 }
 
 void FontFreeType::setGlyphCollection(GlyphCollection glyphs, const char* customGlyphs /* = nullptr */)
@@ -629,23 +636,25 @@ const char* FontFreeType::getGlyphCollection() const
     const char* glyphCollection = nullptr;
     switch (_usedGlyphs)
     {
-        case cocos2d::GlyphCollection::DYNAMIC:
-            break;
-        case cocos2d::GlyphCollection::NEHE:
-            glyphCollection = _glyphNEHE;
-            break;
-        case cocos2d::GlyphCollection::ASCII:
-            glyphCollection = _glyphASCII;
-            break;
-        case cocos2d::GlyphCollection::CUSTOM:
-            glyphCollection = _customGlyphs.c_str();
-            break;
+    case cocos2d::GlyphCollection::DYNAMIC:
+        break;
+    case cocos2d::GlyphCollection::NEHE:
+        glyphCollection = _glyphNEHE;
+        break;
+    case cocos2d::GlyphCollection::ASCII:
+        glyphCollection = _glyphASCII;
+        break;
+    case cocos2d::GlyphCollection::CUSTOM:
+        glyphCollection = _customGlyphs.c_str();
+        break;
+    default:
+        break;
     }
 
     return glyphCollection;
 }
 
-void FontFreeType::releaseFont(const std::string& fontName)
+void FontFreeType::releaseFont(const std::string &fontName)
 {
     auto item = s_cacheFontData.begin();
     while (s_cacheFontData.end() != item)
diff --git a/cocos2d/cocos/2d/CCFontFreeType.h b/cocos2d/cocos/2d/CCFontFreeType.h
index 50606ab48b..f21fc4b843 100644
--- a/cocos2d/cocos/2d/CCFontFreeType.h
+++ b/cocos2d/cocos/2d/CCFontFreeType.h
@@ -1,19 +1,20 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -23,70 +24,51 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_FONTFREETYPE_H
-#define CC_2D_FONTFREETYPE_H
+#ifndef _FontFreetype_h_
+#define _FontFreetype_h_
 
 /// @cond DO_NOT_SHOW
 
 #include <cocos/2d/CCFont.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/platform/CCPlatformConfig.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 
 #include <string>
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Weverything"
 #include <ft2build.h>
 
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-#    define generic GenericFromFreeTypeLibrary
-#    define internal InternalFromFreeTypeLibrary
-#endif
-
 #include FT_FREETYPE_H
 #include FT_STROKER_H
 
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-#    undef generic
-#    undef internal
-#endif
-#pragma clang diagnostic pop
-
 NS_CC_BEGIN
 
-class FontAtlas;
-
 class CC_DLL FontFreeType : public Font
 {
 public:
     static const int DistanceMapSpread;
 
-    static FontFreeType*
-    create(const std::string& fontName, float fontSize, GlyphCollection glyphs, const char* customGlyphs, bool distanceFieldEnabled = false, int outline = 0);
+    static FontFreeType* create(const std::string &fontName, float fontSize, GlyphCollection glyphs,
+        const char *customGlyphs,bool distanceFieldEnabled = false, float outline = 0);
 
     static void shutdownFreeType();
 
-    inline bool isDistanceFieldEnabled() const noexcept { return _distanceFieldEnabled; }
-
-    inline float getOutlineSize() const noexcept { return _outlineSize; }
-
-    void renderCharAt(unsigned char* dest, int posX, int posY, unsigned char* bitmap, long bitmapWidth, long bitmapHeight);
+    bool isDistanceFieldEnabled() const { return _distanceFieldEnabled;}
 
-    inline FT_Encoding getEncoding() const noexcept { return _encoding; }
+    float getOutlineSize() const { return _outlineSize; }
 
-    int* getHorizontalKerningForTextUTF16(const std::u16string& text, int& outNumLetters) const override;
+    void renderCharAt(unsigned char *dest,int posX, int posY, unsigned char* bitmap,long bitmapWidth,long bitmapHeight); 
 
-    unsigned char* getGlyphBitmap(unsigned short theChar, long& outWidth, long& outHeight, Rect& outRect, int& xAdvance);
+    FT_Encoding getEncoding() const { return _encoding; }
 
+    int* getHorizontalKerningForTextUTF32(const std::u32string& text, int &outNumLetters) const override;
+    
+    unsigned char* getGlyphBitmap(uint64_t theChar, long &outWidth, long &outHeight, Rect &outRect,int &xAdvance);
+    
     int getFontAscender() const;
     const char* getFontFamily() const;
+    std::string getFontName() const { return _fontName; }
 
-    FontAtlas* createFontAtlas() override;
-    inline int getFontMaxHeight() const override { return _lineHeight; }
+    virtual FontAtlas* createFontAtlas() override;
+    virtual int getFontMaxHeight() const override { return _lineHeight; }
 
-    static void releaseFont(const std::string& fontName);
+    static void releaseFont(const std::string &fontName);
 
 private:
     static const char* _glyphASCII;
@@ -94,20 +76,20 @@ private:
     static FT_Library _FTlibrary;
     static bool _FTInitialized;
 
-    FontFreeType(bool distanceFieldEnabled = false, int outline = 0);
-    ~FontFreeType() override;
+    FontFreeType(bool distanceFieldEnabled = false, float outline = 0);
+    virtual ~FontFreeType();
 
-    bool createFontObject(const std::string& fontName, float fontSize);
+    bool createFontObject(const std::string &fontName, float fontSize);
 
     bool initFreeType();
     FT_Library getFTLibrary();
-
-    int getHorizontalKerningForChars(unsigned short firstChar, unsigned short secondChar) const;
-    unsigned char* getGlyphBitmapWithOutline(unsigned short code, FT_BBox& bbox);
+    
+    int getHorizontalKerningForChars(uint64_t firstChar, uint64_t secondChar) const;
+    unsigned char* getGlyphBitmapWithOutline(uint64_t code, FT_BBox &bbox);
 
     void setGlyphCollection(GlyphCollection glyphs, const char* customGlyphs = nullptr);
     const char* getGlyphCollection() const;
-
+    
     FT_Face _fontRef;
     FT_Stroker _stroker;
     FT_Encoding _encoding;
@@ -126,4 +108,4 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_FONTFREETYPE_H
+#endif
diff --git a/cocos2d/cocos/2d/CCGrid.cpp b/cocos2d/cocos/2d/CCGrid.cpp
index 044bd333b6..4af5556f16 100644
--- a/cocos2d/cocos/2d/CCGrid.cpp
+++ b/cocos2d/cocos/2d/CCGrid.cpp
@@ -2,7 +2,8 @@
 Copyright (c) 2009      On-Core
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -25,175 +26,145 @@ THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCGrid.h>
 
-#include <cocos/2d/CCCamera.h>
-#include <cocos/2d/CCGrabber.h>
-#include <cocos/base/CCDirector.h>
 #include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
 #include <cocos/base/ccUtils.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCFrameBuffer.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramCache.h>
-#include <cocos/renderer/CCRenderState.h>
+#include <cocos/2d/CCNode.h>
 #include <cocos/renderer/CCRenderer.h>
 #include <cocos/renderer/CCTexture2D.h>
-#include <cocos/renderer/ccGLStateCache.h>
-
-#include <cstdlib>
-#include <cstring>
-#include <new>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/Device.h>
+#include <cocos/2d/CCCamera.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 // implementation of GridBase
 
-GridBase* GridBase::create(const Size& gridSize)
-{
-    GridBase* pGridBase = new (std::nothrow) GridBase();
-
-    if (pGridBase)
-    {
-        if (pGridBase->initWithSize(gridSize))
-        {
-            pGridBase->autorelease();
-        }
-        else
-        {
-            CC_SAFE_RELEASE_NULL(pGridBase);
-        }
-    }
-
-    return pGridBase;
-}
-
-GridBase* GridBase::create(const Size& gridSize, Texture2D* texture, bool flipped)
-{
-    GridBase* pGridBase = new (std::nothrow) GridBase();
-
-    if (pGridBase)
-    {
-        if (pGridBase->initWithSize(gridSize, texture, flipped))
-        {
-            pGridBase->autorelease();
-        }
-        else
-        {
-            CC_SAFE_RELEASE_NULL(pGridBase);
-        }
-    }
-
-    return pGridBase;
-}
-
 bool GridBase::initWithSize(const Size& gridSize)
 {
     return initWithSize(gridSize, Rect::ZERO);
 }
 
-bool GridBase::initWithSize(const cocos2d::Size& gridSize, const cocos2d::Rect& rect)
+bool GridBase::initWithSize(const cocos2d::Size &gridSize, const cocos2d::Rect &rect)
 {
-    Director* director = Director::getInstance();
+    Director *director = Director::getInstance();
     Size s = director->getWinSizeInPixels();
-
+    
     auto POTWide = ccNextPOT((unsigned int)s.width);
     auto POTHigh = ccNextPOT((unsigned int)s.height);
-
-    // we only use rgba8888
-    Texture2D::PixelFormat format = Texture2D::PixelFormat::RGBA8888;
-
-    auto dataLen = POTWide * POTHigh * 4;
-    void* data = calloc(dataLen, 1);
-    if (!data)
-    {
-        CCLOG("cocos2d: Grid: not enough memory.");
-        this->release();
-        return false;
-    }
-
-    Texture2D* texture = new (std::nothrow) Texture2D();
-    texture->initWithData(data, dataLen, format, POTWide, POTHigh, s);
-
-    free(data);
-
-    if (!texture)
+    
+    Texture2D *texture = new (std::nothrow) Texture2D();
+    if (! texture)
     {
         CCLOG("cocos2d: Grid: error creating texture");
         return false;
     }
 
+    backend::TextureDescriptor descriptor;
+    descriptor.width = POTWide;
+    descriptor.height = POTHigh;
+    descriptor.textureUsage = backend::TextureUsage::RENDER_TARGET;
+    descriptor.textureFormat = backend::PixelFormat::RGBA8888;
+    auto backendTexture = backend::Device::getInstance()->newTexture(descriptor);
+    texture->initWithBackendTexture(backendTexture);
+    backendTexture->release();
+    
     initWithSize(gridSize, texture, false, rect);
-
+    
     texture->release();
-
+    
     return true;
 }
 
-bool GridBase::initWithSize(const Size& gridSize, Texture2D* texture, bool flipped)
+bool GridBase::initWithSize(const Size& gridSize, Texture2D *texture, bool flipped)
 {
     return initWithSize(gridSize, texture, flipped, Rect::ZERO);
 }
 
-bool GridBase::initWithSize(const Size& gridSize, Texture2D* texture, bool flipped, const Rect& rect)
+bool GridBase::initWithSize(const Size& gridSize, Texture2D *texture, bool flipped, const Rect& rect)
 {
     bool ret = true;
-
+    
     _active = false;
     _reuseGrid = 0;
     _gridSize = gridSize;
-
+    
     _texture = texture;
     CC_SAFE_RETAIN(_texture);
     _isTextureFlipped = flipped;
 
-    if (rect.equals(Rect::ZERO))
-    {
+#ifdef CC_USE_METAL
+    _isTextureFlipped = !flipped;
+#endif
+    
+    if (rect.equals(Rect::ZERO)) {
         auto size = _texture->getContentSize();
         _gridRect.setRect(0, 0, size.width, size.height);
     }
-    else
-    {
+    else{
         _gridRect = rect;
     }
-    _step.x = _gridRect.size.width / _gridSize.width;
-    _step.y = _gridRect.size.height / _gridSize.height;
-
-    _grabber = new (std::nothrow) Grabber();
-    if (_grabber)
+    _step.x = _gridRect.size.width/_gridSize.width;
+    _step.y = _gridRect.size.height/_gridSize.height;
+
+    auto& pipelineDescriptor = _drawCommand.getPipelineDescriptor();
+    CC_SAFE_RELEASE(_programState);
+    _programState = new (std::nothrow) backend::ProgramState(positionTexture_vert, positionTexture_frag);
+    pipelineDescriptor.programState = _programState;
+    _mvpMatrixLocation = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    _textureLocation = pipelineDescriptor.programState->getUniformLocation("u_texture");
+    
+#define VERTEX_POSITION_SIZE 3
+#define VERTEX_TEXCOORD_SIZE 2
+    uint32_t texcoordOffset = (VERTEX_POSITION_SIZE)*sizeof(float);
+    uint32_t totalSize = (VERTEX_POSITION_SIZE+VERTEX_TEXCOORD_SIZE)*sizeof(float);
+    auto vertexLayout = _programState->getVertexLayout();
+    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
     {
-        _grabber->grab(_texture);
+        vertexLayout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT3, 0, false);
     }
-    else
+    iter = attributeInfo.find("a_texCoord");
+    if(iter != attributeInfo.end())
     {
-        ret = false;
+        vertexLayout->setAttribute("a_texCoord", iter->second.location, backend::VertexFormat::FLOAT2, texcoordOffset, false);
     }
+    vertexLayout->setLayout(totalSize);
 
-    _shaderProgram = GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_NAME_POSITION_TEXTURE);
     calculateVertexPoints();
-
+    updateBlendState();
     return ret;
 }
 
-GridBase::~GridBase(void)
+void GridBase::updateBlendState()
+{
+    if (! _texture || ! _texture->hasPremultipliedAlpha())
+    {
+        _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
+    }
+    else
+    {
+        _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
+    }
+}
+
+GridBase::~GridBase()
 {
     CCLOGINFO("deallocing GridBase: %p", this);
 
-    // TODO: ? why 2.0 comments this line:        setActive(false);
+    //TODO: ? why 2.0 comments this line:        setActive(false);
     CC_SAFE_RELEASE(_texture);
-    CC_SAFE_RELEASE(_grabber);
+    
+    CC_SAFE_RELEASE(_programState);
 }
 
 // properties
 void GridBase::setActive(bool active)
 {
     _active = active;
-    if (!active)
+    if (! active)
     {
-        Director* pDirector = Director::getInstance();
+        Director *pDirector = Director::getInstance();
         Director::Projection proj = pDirector->getProjection();
         pDirector->setProjection(proj);
     }
@@ -210,93 +181,100 @@ void GridBase::setTextureFlipped(bool flipped)
 
 void GridBase::set2DProjection()
 {
-    Director* director = Director::getInstance();
-    Size size = director->getWinSizeInPixels();
+    Director *director = Director::getInstance();
+    Size    size = director->getWinSizeInPixels();
 
     director->loadIdentityMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
 
     Mat4 orthoMatrix;
-    Mat4::createOrthographicOffCenter(0, size.width, 0, size.height, -1, 1, orthoMatrix);
+    Mat4::createOrthographicOffCenter(0, size.width, 0, size.height, -1, 1, &orthoMatrix);
     director->multiplyMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, orthoMatrix);
 
     director->loadIdentityMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
-
-    GL::setProjectionMatrixDirty();
 }
 
-void GridBase::setGridRect(const cocos2d::Rect& rect)
+void GridBase::setGridRect(const cocos2d::Rect &rect)
 {
     _gridRect = rect;
 }
 
-void GridBase::beforeDraw(void)
+void GridBase::beforeDraw()
 {
     // save projection
-    Director* director = Director::getInstance();
-    _directorProjection = director->getProjection();
+    Director *director = Director::getInstance();
 
-    // 2d projection
-    //    [director setProjection:Director::Projection::_2D];
-    set2DProjection();
+    auto renderer = director->getRenderer();
 
-    Size size = director->getWinSizeInPixels();
-    glViewport(0, 0, (GLsizei)(size.width), (GLsizei)(size.height));
-    _grabber->beforeRender(_texture);
-}
+    renderer->addCommand(&_groupCommand);
+    renderer->pushGroup(_groupCommand.getRenderQueueID());
 
-void GridBase::afterDraw(cocos2d::Node* target)
-{
-    _grabber->afterRender(_texture);
+    _beforeDrawCommand.func = [=]() -> void {
+        _directorProjection = director->getProjection();
+        set2DProjection();
+        Size    size = director->getWinSizeInPixels();
+        renderer->setViewPort(0, 0, (unsigned int)size.width, (unsigned int)size.height);
 
-    // restore projection
-    Director* director = Director::getInstance();
-    director->setProjection(_directorProjection);
-
-    director->setViewport();
-    const auto& vp = Camera::getDefaultViewport();
-    glViewport(vp._left, vp._bottom, vp._width, vp._height);
-    //    if (target->getCamera()->isDirty())
-    //    {
-    //        Vec2 offset = target->getAnchorPointInPoints();
-    //
-    //        //
-    //        // FIXME: Camera should be applied in the AnchorPoint
-    //        //
-    //        kmGLTranslatef(offset.x, offset.y, 0);
-    //        target->getCamera()->locate();
-    //        kmGLTranslatef(-offset.x, -offset.y, 0);
-    //    }
-
-    GL::bindTexture2D(_texture->getName());
+        RenderTargetFlag flags = RenderTargetFlag::COLOR;
+        _oldColorAttachment = renderer->getColorAttachment();
+        _oldDepthAttachment = renderer->getDepthAttachment();
+        _oldStencilAttachment = renderer->getStencilAttachment();
+        _oldRenderTargetFlag = renderer->getRenderTargetFlag();
 
-    // restore projection for default FBO .fixed bug #543 #544
-    // TODO:         Director::getInstance()->setProjection(Director::getInstance()->getProjection());
-    // TODO:         Director::getInstance()->applyOrientation();
-    beforeBlit();
-    blit();
-    afterBlit();
+        renderer->setRenderTarget(flags, _texture, nullptr, nullptr);
+    };
+    renderer->addCommand(&_beforeDrawCommand);
+    renderer->clear(ClearFlag::COLOR, _clearColor, 1, 0, 0.0);
 }
 
-void GridBase::blit(void)
+void GridBase::afterDraw(cocos2d::Node * /*target*/)
 {
-    CCASSERT(0, "Subclass should implement it.");
-}
+    // restore projection
+    Director *director = Director::getInstance();
+    auto renderer = director->getRenderer();
+
+    _afterDrawCommand.func = [=]() -> void {
+        director->setProjection(_directorProjection);
+        const auto& vp = Camera::getDefaultViewport();
+        renderer->setViewPort(vp.x, vp.y, vp.w, vp.h);
+        renderer->setRenderTarget(_oldRenderTargetFlag, _oldColorAttachment, _oldDepthAttachment, _oldStencilAttachment);
+    };
+    renderer->addCommand(&_afterDrawCommand);
+
+    renderer->popGroup();
+
+//    if (target->getCamera()->isDirty())
+//    {
+//        Vec2 offset = target->getAnchorPointInPoints();
+//
+//        //
+//        // FIXME: Camera should be applied in the AnchorPoint
+//        //
+//        kmGLTranslatef(offset.x, offset.y, 0);
+//        target->getCamera()->locate();
+//        kmGLTranslatef(-offset.x, -offset.y, 0);
+//    }
 
-void GridBase::reuse(void)
-{
-    CCASSERT(0, "Subclass should implement it!");
-}
+    // restore projection for default FBO .fixed bug #543 #544
+    //TODO:         Director::getInstance()->setProjection(Director::getInstance()->getProjection());
+    //TODO:         Director::getInstance()->applyOrientation();
+    _beforeBlitCommand.func = [=]() -> void {
+        beforeBlit();
+    };
+    renderer->addCommand(&_beforeBlitCommand);
 
-void GridBase::calculateVertexPoints(void)
-{
-    CCASSERT(0, "Subclass should implement it.");
+    blit();
+
+    _afterBlitCommand.func = [=]() -> void {
+        afterBlit();
+    };
+    renderer->addCommand(&_afterBlitCommand);
 }
 
 // implementation of Grid3D
 
 Grid3D* Grid3D::create(const Size& gridSize)
 {
-    Grid3D* ret = new (std::nothrow) Grid3D();
+    Grid3D *ret= new (std::nothrow) Grid3D();
 
     if (ret)
     {
@@ -316,8 +294,8 @@ Grid3D* Grid3D::create(const Size& gridSize)
 
 Grid3D* Grid3D::create(const Size& gridSize, const Rect& rect)
 {
-    Grid3D* ret = new (std::nothrow) Grid3D();
-
+    Grid3D *ret= new (std::nothrow) Grid3D();
+    
     if (ret)
     {
         if (ret->initWithSize(gridSize, rect))
@@ -330,14 +308,14 @@ Grid3D* Grid3D::create(const Size& gridSize, const Rect& rect)
             ret = nullptr;
         }
     }
-
+    
     return ret;
 }
 
-Grid3D* Grid3D::create(const Size& gridSize, Texture2D* texture, bool flipped)
+Grid3D* Grid3D::create(const Size& gridSize, Texture2D *texture, bool flipped)
 {
-    Grid3D* ret = new (std::nothrow) Grid3D();
-
+    Grid3D *ret= new (std::nothrow) Grid3D();
+    
     if (ret)
     {
         if (ret->initWithSize(gridSize, texture, flipped))
@@ -350,14 +328,14 @@ Grid3D* Grid3D::create(const Size& gridSize, Texture2D* texture, bool flipped)
             ret = nullptr;
         }
     }
-
+    
     return ret;
 }
 
-Grid3D* Grid3D::create(const Size& gridSize, Texture2D* texture, bool flipped, const Rect& rect)
+Grid3D* Grid3D::create(const Size& gridSize, Texture2D *texture, bool flipped, const Rect& rect)
 {
-    Grid3D* ret = new (std::nothrow) Grid3D();
-
+    Grid3D *ret= new (std::nothrow) Grid3D();
+    
     if (ret)
     {
         if (ret->initWithSize(gridSize, texture, flipped, rect))
@@ -370,125 +348,106 @@ Grid3D* Grid3D::create(const Size& gridSize, Texture2D* texture, bool flipped, c
             ret = nullptr;
         }
     }
-
+    
     return ret;
 }
 
+
 Grid3D::Grid3D()
-: _texCoordinates(nullptr)
-, _vertices(nullptr)
-, _originalVertices(nullptr)
-, _indices(nullptr)
-, _needDepthTestForBlit(false)
 {
 }
 
-Grid3D::~Grid3D(void)
+Grid3D::~Grid3D()
 {
-    CC_SAFE_FREE(_texCoordinates);
-    CC_SAFE_FREE(_vertices);
-    CC_SAFE_FREE(_indices);
-    CC_SAFE_FREE(_originalVertices);
+    CC_SAFE_DELETE_ARRAY(_texCoordinates);;
+    CC_SAFE_DELETE_ARRAY(_vertices);;
+    CC_SAFE_DELETE_ARRAY(_indices);;
+    CC_SAFE_DELETE_ARRAY(_originalVertices);;
+    CC_SAFE_DELETE_ARRAY(_vertexBuffer);;
 }
 
 void Grid3D::beforeBlit()
 {
-    if (_needDepthTestForBlit)
-    {
-        _oldDepthTestValue = glIsEnabled(GL_DEPTH_TEST) != GL_FALSE;
-        GLboolean depthWriteMask;
-        glGetBooleanv(GL_DEPTH_WRITEMASK, &depthWriteMask);
-        _oldDepthWriteValue = depthWriteMask != GL_FALSE;
-        CHECK_GL_ERROR_DEBUG();
+    auto renderer = Director::getInstance()->getRenderer();
 
-        glEnable(GL_DEPTH_TEST);
-        RenderState::StateBlock::_defaultState->setDepthTest(true);
+    if(_needDepthTestForBlit)
+    {
+        _oldDepthTest = renderer->getDepthTest();
+        renderer->setDepthTest(true);
 
-        glDepthMask(true);
-        RenderState::StateBlock::_defaultState->setDepthWrite(true);
+        _oldDepthWrite = renderer->getDepthWrite();
+        renderer->setDepthWrite(true);
     }
 }
 
 void Grid3D::afterBlit()
 {
-    if (_needDepthTestForBlit)
+    auto renderer = Director::getInstance()->getRenderer();
+    if(_needDepthTestForBlit)
     {
-        if (_oldDepthTestValue)
-            glEnable(GL_DEPTH_TEST);
-        else
-            glDisable(GL_DEPTH_TEST);
-        RenderState::StateBlock::_defaultState->setDepthTest(_oldDepthTestValue);
-
-        glDepthMask(_oldDepthWriteValue);
-        RenderState::StateBlock::_defaultState->setDepthWrite(_oldDepthWriteValue);
+       renderer->setDepthTest(_oldDepthTest);
+       renderer->setDepthWrite(_oldDepthWrite);
     }
 }
 
-void Grid3D::blit(void)
+void Grid3D::blit()
 {
-    int n = _gridSize.width * _gridSize.height;
-
-    GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POSITION | GL::VERTEX_ATTRIB_FLAG_TEX_COORD);
-    _shaderProgram->use();
-    _shaderProgram->setUniformsForBuiltins();
-
-    //
-    // Attributes
-    //
-
-    // position
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, 0, _vertices);
-
-    // texCoords
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, 0, _texCoordinates);
-
-    glDrawElements(GL_TRIANGLES, (GLsizei)n * 6, GL_UNSIGNED_SHORT, _indices);
+    updateVertexBuffer();
+    _drawCommand.init(0, _blendFunc);
+    Director::getInstance()->getRenderer()->addCommand(&_drawCommand);
+    cocos2d::Mat4 projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    auto programState = _drawCommand.getPipelineDescriptor().programState;
+    programState->setUniform(_mvpMatrixLocation, projectionMat.m, sizeof(projectionMat.m));
+    programState->setTexture(_textureLocation, 0, _texture->getBackendTexture());
 }
 
-void Grid3D::calculateVertexPoints(void)
+void Grid3D::calculateVertexPoints()
 {
     float width = (float)_texture->getPixelsWide();
     float height = (float)_texture->getPixelsHigh();
     float imageH = _texture->getContentSizeInPixels().height;
 
-    int x, y, i;
-    CC_SAFE_FREE(_vertices);
-    CC_SAFE_FREE(_originalVertices);
-    CC_SAFE_FREE(_texCoordinates);
-    CC_SAFE_FREE(_indices);
+    size_t x = 0, y = 0, i = 0;
+    CC_SAFE_DELETE_ARRAY(_vertices);;
+    CC_SAFE_DELETE_ARRAY(_originalVertices);;
+    CC_SAFE_DELETE_ARRAY(_texCoordinates);;
+    CC_SAFE_DELETE_ARRAY(_vertexBuffer);;
+    CC_SAFE_DELETE_ARRAY(_indices);;
 
-    unsigned int numOfPoints = (_gridSize.width + 1) * (_gridSize.height + 1);
+    size_t numOfPoints = static_cast<size_t>((_gridSize.width+1) * (_gridSize.height+1));
 
     _vertices = malloc(numOfPoints * sizeof(Vec3));
     _originalVertices = malloc(numOfPoints * sizeof(Vec3));
     _texCoordinates = malloc(numOfPoints * sizeof(Vec2));
-    _indices = (GLushort*)malloc(_gridSize.width * _gridSize.height * sizeof(GLushort) * 6);
+    _vertexBuffer = malloc(numOfPoints * (sizeof(Vec3) + sizeof(Vec2)));
+    _indices = (unsigned short*)malloc(static_cast<size_t>(_gridSize.width * _gridSize.height * sizeof(unsigned short) * 6));
 
-    GLfloat* vertArray = (GLfloat*)_vertices;
-    GLfloat* texArray = (GLfloat*)_texCoordinates;
-    GLushort* idxArray = _indices;
+    float *vertArray = (float*)_vertices;
+    float *texArray = (float*)_texCoordinates;
+    unsigned short *idxArray = _indices;
 
     for (x = 0; x < _gridSize.width; ++x)
     {
         for (y = 0; y < _gridSize.height; ++y)
         {
-            int idx = (y * _gridSize.width) + x;
+            int idx = (int)(y * _gridSize.width) + x;
+
+            float x1 = x * _step.x + _gridRect.origin.x;
+            float x2 = x1 + _step.x;
+            float y1 = y * _step.y + _gridRect.origin.y;
+            float y2= y1 + _step.y;
 
-            GLfloat x1 = x * _step.x + _gridRect.origin.x;
-            GLfloat x2 = x1 + _step.x;
-            GLfloat y1 = y * _step.y + _gridRect.origin.y;
-            GLfloat y2 = y1 + _step.y;
+            unsigned short a = (unsigned short)(x * (_gridSize.height + 1) + y);
+            unsigned short b = (unsigned short)((x + 1) * (_gridSize.height + 1) + y);
+            unsigned short c = (unsigned short)((x + 1) * (_gridSize.height + 1) + (y + 1));
+            unsigned short d = (unsigned short)(x * (_gridSize.height + 1) + (y + 1));
 
-            GLushort a = (GLushort)(x * (_gridSize.height + 1) + y);
-            GLushort b = (GLushort)((x + 1) * (_gridSize.height + 1) + y);
-            GLushort c = (GLushort)((x + 1) * (_gridSize.height + 1) + (y + 1));
-            GLushort d = (GLushort)(x * (_gridSize.height + 1) + (y + 1));
+            unsigned short tempidx[6] = {a, b, d, b, c, d};
 
-            GLushort tempidx[6] = {a, b, d, b, c, d};
+            memcpy(&idxArray[6*idx], tempidx, 6*sizeof(unsigned short));
 
-            memcpy(&idxArray[6 * idx], tempidx, 6 * sizeof(GLushort));
+            int l1[4] = {a*3, b*3, c*3, d*3};
 
-            int l1[4] = {a * 3, b * 3, c * 3, d * 3};
             Vec3 e(x1, y1, 0);
             Vec3 f(x2, y1, 0);
             Vec3 g(x2, y2, 0);
@@ -496,7 +455,7 @@ void Grid3D::calculateVertexPoints(void)
 
             Vec3 l2[4] = {e, f, g, h};
 
-            int tex1[4] = {a * 2, b * 2, c * 2, d * 2};
+            int tex1[4] = {a*2, b*2, c*2, d*2};
             Vec2 Tex2F[4] = {Vec2(x1, y1), Vec2(x2, y1), Vec2(x2, y2), Vec2(x1, y2)};
 
             for (i = 0; i < 4; ++i)
@@ -518,73 +477,100 @@ void Grid3D::calculateVertexPoints(void)
         }
     }
 
-    memcpy(_originalVertices, _vertices, (_gridSize.width + 1) * (_gridSize.height + 1) * sizeof(Vec3));
+    updateVertexAndTexCoordinate();
+
+    memcpy(_originalVertices, _vertices, static_cast<size_t>((_gridSize.width+1) * (_gridSize.height+1) * sizeof(Vec3)));
 }
 
 Vec3 Grid3D::getVertex(const Vec2& pos) const
 {
-    CCASSERT(pos.x == (unsigned int)pos.x && pos.y == (unsigned int)pos.y, "Numbers must be integers");
-
-    int index = (pos.x * (_gridSize.height + 1) + pos.y) * 3;
-    float* vertArray = (float*)_vertices;
+    CCASSERT( pos.x == (unsigned int)pos.x && pos.y == (unsigned int) pos.y , "Numbers must be integers");
+    
+    int index = (int)(pos.x * (_gridSize.height+1) + pos.y) * 3;
+    float *vertArray = (float*)_vertices;
 
-    Vec3 vert(vertArray[index], vertArray[index + 1], vertArray[index + 2]);
+    Vec3 vert(vertArray[index], vertArray[index+1], vertArray[index+2]);
 
     return vert;
 }
 
 Vec3 Grid3D::getOriginalVertex(const Vec2& pos) const
 {
-    CCASSERT(pos.x == (unsigned int)pos.x && pos.y == (unsigned int)pos.y, "Numbers must be integers");
+    CCASSERT( pos.x == (unsigned int)pos.x && pos.y == (unsigned int) pos.y , "Numbers must be integers");
+    
+    int index = (int)(pos.x * (_gridSize.height+1) + pos.y) * 3;
+    float *vertArray = (float*)_originalVertices;
 
-    int index = (pos.x * (_gridSize.height + 1) + pos.y) * 3;
-    float* vertArray = (float*)_originalVertices;
-
-    Vec3 vert(vertArray[index], vertArray[index + 1], vertArray[index + 2]);
+    Vec3 vert(vertArray[index], vertArray[index+1], vertArray[index+2]);
 
     return vert;
 }
 
 void Grid3D::setVertex(const Vec2& pos, const Vec3& vertex)
 {
-    CCASSERT(pos.x == (unsigned int)pos.x && pos.y == (unsigned int)pos.y, "Numbers must be integers");
-    int index = (pos.x * (_gridSize.height + 1) + pos.y) * 3;
-    float* vertArray = (float*)_vertices;
+    CCASSERT( pos.x == (unsigned int)pos.x && pos.y == (unsigned int) pos.y , "Numbers must be integers");
+    int index = (int)(pos.x * (_gridSize.height + 1) + pos.y) * 3;
+    float *vertArray = (float*)_vertices;
     vertArray[index] = vertex.x;
-    vertArray[index + 1] = vertex.y;
-    vertArray[index + 2] = vertex.z;
+    vertArray[index+1] = vertex.y;
+    vertArray[index+2] = vertex.z;
 }
 
-void Grid3D::reuse(void)
+void Grid3D::reuse()
 {
     if (_reuseGrid > 0)
     {
-        memcpy(_originalVertices, _vertices, (_gridSize.width + 1) * (_gridSize.height + 1) * sizeof(Vec3));
+        memcpy(_originalVertices, _vertices, static_cast<size_t>((_gridSize.width+1) * (_gridSize.height+1) * sizeof(Vec3)));
         --_reuseGrid;
     }
 }
 
-// implementation of TiledGrid3D
+void Grid3D::updateVertexBuffer()
+{
+    size_t numOfPoints = static_cast<size_t>((_gridSize.width+1) * (_gridSize.height+1));
+    auto tempVecPointer = (Vec3*)_vertices;
+    for (size_t i = 0; i < numOfPoints; ++i)
+    {
+        auto offset = i * (sizeof(Vec3) + sizeof(Vec2));
+        memcpy((char*)_vertexBuffer + offset, &tempVecPointer[i], sizeof(Vec3));
+    }
+    _drawCommand.updateVertexBuffer(_vertexBuffer, (unsigned int)(numOfPoints * sizeof(Vec3) + numOfPoints * sizeof(Vec2)) );
+
+    _drawCommand.updateIndexBuffer(_indices, static_cast<unsigned int>(_gridSize.width * _gridSize.height * 6 * sizeof(unsigned short)));
+}
 
-TiledGrid3D::TiledGrid3D()
-: _texCoordinates(nullptr)
-, _vertices(nullptr)
-, _originalVertices(nullptr)
-, _indices(nullptr)
+void Grid3D::updateVertexAndTexCoordinate()
 {
+    unsigned int numOfPoints = static_cast<unsigned int>((_gridSize.width+1) * (_gridSize.height+1));
+    auto tempVecPointer = (Vec3*)_vertices;
+    auto tempTexPointer = (Vec2*)_texCoordinates;
+    for (unsigned int i = 0; i < numOfPoints; ++i)
+    {
+        auto offset = i * (sizeof(Vec3) + sizeof(Vec2));
+        memcpy((char*)_vertexBuffer + offset, &tempVecPointer[i], sizeof(Vec3));
+        memcpy((char*)_vertexBuffer + offset + sizeof(Vec3), &tempTexPointer[i], sizeof(Vec2));
+    }
+    _drawCommand.createVertexBuffer((unsigned int)(sizeof(Vec3) + sizeof(Vec2)), numOfPoints, CustomCommand::BufferUsage::DYNAMIC);
+    _drawCommand.updateVertexBuffer(_vertexBuffer, numOfPoints * sizeof(Vec3) + numOfPoints * sizeof(Vec2));
+
+    unsigned int capacity = (unsigned int)(_gridSize.width * _gridSize.height) * 6;
+    _drawCommand.createIndexBuffer(CustomCommand::IndexFormat::U_SHORT, capacity, CustomCommand::BufferUsage::DYNAMIC);
+    _drawCommand.updateIndexBuffer(_indices, capacity * sizeof(unsigned short));
 }
 
-TiledGrid3D::~TiledGrid3D(void)
+// implementation of TiledGrid3D
+
+TiledGrid3D::~TiledGrid3D()
 {
-    CC_SAFE_FREE(_texCoordinates);
-    CC_SAFE_FREE(_vertices);
-    CC_SAFE_FREE(_originalVertices);
-    CC_SAFE_FREE(_indices);
+    CC_SAFE_DELETE_ARRAY(_texCoordinates);;
+    CC_SAFE_DELETE_ARRAY(_vertices);;
+    CC_SAFE_DELETE_ARRAY(_originalVertices);;
+    CC_SAFE_DELETE_ARRAY(_indices);;
 }
 
 TiledGrid3D* TiledGrid3D::create(const Size& gridSize)
 {
-    TiledGrid3D* ret = new (std::nothrow) TiledGrid3D();
+    TiledGrid3D *ret= new (std::nothrow) TiledGrid3D();
 
     if (ret)
     {
@@ -604,8 +590,8 @@ TiledGrid3D* TiledGrid3D::create(const Size& gridSize)
 
 TiledGrid3D* TiledGrid3D::create(const Size& gridSize, const Rect& rect)
 {
-    TiledGrid3D* ret = new (std::nothrow) TiledGrid3D();
-
+    TiledGrid3D *ret= new (std::nothrow) TiledGrid3D();
+    
     if (ret)
     {
         if (ret->initWithSize(gridSize, rect))
@@ -618,14 +604,14 @@ TiledGrid3D* TiledGrid3D::create(const Size& gridSize, const Rect& rect)
             ret = nullptr;
         }
     }
-
+    
     return ret;
 }
 
-TiledGrid3D* TiledGrid3D::create(const Size& gridSize, Texture2D* texture, bool flipped, const Rect& rect)
+TiledGrid3D* TiledGrid3D::create(const Size& gridSize, Texture2D *texture, bool flipped, const Rect& rect)
 {
-    TiledGrid3D* ret = new (std::nothrow) TiledGrid3D();
-
+    TiledGrid3D *ret= new (std::nothrow) TiledGrid3D();
+    
     if (ret)
     {
         if (ret->initWithSize(gridSize, texture, flipped, rect))
@@ -638,14 +624,14 @@ TiledGrid3D* TiledGrid3D::create(const Size& gridSize, Texture2D* texture, bool
             ret = nullptr;
         }
     }
-
+    
     return ret;
 }
 
-TiledGrid3D* TiledGrid3D::create(const Size& gridSize, Texture2D* texture, bool flipped)
+TiledGrid3D* TiledGrid3D::create(const Size& gridSize, Texture2D *texture, bool flipped)
 {
-    TiledGrid3D* ret = new (std::nothrow) TiledGrid3D();
-
+    TiledGrid3D *ret= new (std::nothrow) TiledGrid3D();
+    
     if (ret)
     {
         if (ret->initWithSize(gridSize, texture, flipped))
@@ -658,65 +644,53 @@ TiledGrid3D* TiledGrid3D::create(const Size& gridSize, Texture2D* texture, bool
             ret = nullptr;
         }
     }
-
+    
     return ret;
 }
 
-void TiledGrid3D::blit(void)
+void TiledGrid3D::blit()
 {
-    int n = _gridSize.width * _gridSize.height;
-
-    _shaderProgram->use();
-    _shaderProgram->setUniformsForBuiltins();
-
-    //
-    // Attributes
-    //
-    GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POSITION | GL::VERTEX_ATTRIB_FLAG_TEX_COORD);
-
-    // position
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, 0, _vertices);
-
-    // texCoords
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, 0, _texCoordinates);
-
-    glDrawElements(GL_TRIANGLES, (GLsizei)n * 6, GL_UNSIGNED_SHORT, _indices);
-
-    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, n * 6);
+    updateVertexBuffer();
+    Director::getInstance()->getRenderer()->addCommand(&_drawCommand);
+    cocos2d::Mat4 projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    auto programState = _drawCommand.getPipelineDescriptor().programState;
+    programState->setUniform(_mvpMatrixLocation, projectionMat.m, sizeof(projectionMat.m));
+    programState->setTexture(_textureLocation, 0, _texture->getBackendTexture());
 }
 
-void TiledGrid3D::calculateVertexPoints(void)
+void TiledGrid3D::calculateVertexPoints()
 {
     float width = (float)_texture->getPixelsWide();
     float height = (float)_texture->getPixelsHigh();
     float imageH = _texture->getContentSizeInPixels().height;
-
-    int numQuads = _gridSize.width * _gridSize.height;
-    CC_SAFE_FREE(_vertices);
-    CC_SAFE_FREE(_originalVertices);
-    CC_SAFE_FREE(_texCoordinates);
-    CC_SAFE_FREE(_indices);
-
-    _vertices = malloc(numQuads * 4 * sizeof(Vec3));
-    _originalVertices = malloc(numQuads * 4 * sizeof(Vec3));
-    _texCoordinates = malloc(numQuads * 4 * sizeof(Vec2));
-    _indices = (GLushort*)malloc(numQuads * 6 * sizeof(GLushort));
-
-    GLfloat* vertArray = (GLfloat*)_vertices;
-    GLfloat* texArray = (GLfloat*)_texCoordinates;
-    GLushort* idxArray = _indices;
-
-    int x, y;
-
-    for (x = 0; x < _gridSize.width; x++)
+    
+    int numQuads = (int)(_gridSize.width * _gridSize.height);
+    CC_SAFE_DELETE_ARRAY(_vertices);;
+    CC_SAFE_DELETE_ARRAY(_originalVertices);;
+    CC_SAFE_DELETE_ARRAY(_texCoordinates);;
+    CC_SAFE_DELETE_ARRAY(_indices);;
+    CC_SAFE_DELETE_ARRAY(_vertexBuffer);;
+
+    _vertices = malloc(numQuads*4*sizeof(Vec3));
+    _originalVertices = malloc(numQuads*4*sizeof(Vec3));
+    _texCoordinates = malloc(numQuads*4*sizeof(Vec2));
+    _indices = (unsigned short*)malloc(numQuads*6*sizeof(unsigned short));
+    _vertexBuffer = malloc(numQuads * 4 * (sizeof(Vec3) + sizeof(Vec2) ) );
+
+    float *vertArray = (float*)_vertices;
+    float *texArray = (float*)_texCoordinates;
+    unsigned short *idxArray = _indices;
+    
+
+    for (int x = 0; x < _gridSize.width; ++x)
     {
-        for (y = 0; y < _gridSize.height; y++)
+        for (int y = 0; y < _gridSize.height; ++y)
         {
             float x1 = x * _step.x + _gridRect.origin.x;
             float x2 = x1 + _step.x;
             float y1 = y * _step.y + _gridRect.origin.y;
             float y2 = y1 + _step.y;
-
+            
             *vertArray++ = x1;
             *vertArray++ = y1;
             *vertArray++ = 0;
@@ -729,11 +703,11 @@ void TiledGrid3D::calculateVertexPoints(void)
             *vertArray++ = x2;
             *vertArray++ = y2;
             *vertArray++ = 0;
-
+            
             float newY1 = y1;
             float newY2 = y2;
-
-            if (_isTextureFlipped)
+            
+            if (_isTextureFlipped) 
             {
                 newY1 = imageH - y1;
                 newY2 = imageH - y2;
@@ -749,34 +723,35 @@ void TiledGrid3D::calculateVertexPoints(void)
             *texArray++ = newY2 / height;
         }
     }
-
-    for (x = 0; x < numQuads; x++)
+    
+    for (int x = 0; x < numQuads; x++)
     {
-        idxArray[x * 6 + 0] = (GLushort)(x * 4 + 0);
-        idxArray[x * 6 + 1] = (GLushort)(x * 4 + 1);
-        idxArray[x * 6 + 2] = (GLushort)(x * 4 + 2);
-
-        idxArray[x * 6 + 3] = (GLushort)(x * 4 + 1);
-        idxArray[x * 6 + 4] = (GLushort)(x * 4 + 2);
-        idxArray[x * 6 + 5] = (GLushort)(x * 4 + 3);
+        idxArray[x*6+0] = (unsigned short)(x * 4 + 0);
+        idxArray[x*6+1] = (unsigned short)(x * 4 + 1);
+        idxArray[x*6+2] = (unsigned short)(x * 4 + 2);
+        
+        idxArray[x*6+3] = (unsigned short)(x * 4 + 1);
+        idxArray[x*6+4] = (unsigned short)(x * 4 + 2);
+        idxArray[x*6+5] = (unsigned short)(x * 4 + 3);
     }
 
-    memcpy(_originalVertices, _vertices, numQuads * 12 * sizeof(GLfloat));
+    updateVertexAndTexCoordinate();
+    memcpy(_originalVertices, _vertices, numQuads * 12 * sizeof(float));
 }
 
 void TiledGrid3D::setTile(const Vec2& pos, const Quad3& coords)
 {
-    CCASSERT(pos.x == (unsigned int)pos.x && pos.y == (unsigned int)pos.y, "Numbers must be integers");
-    int idx = (_gridSize.height * pos.x + pos.y) * 4 * 3;
-    float* vertArray = (float*)_vertices;
+    CCASSERT( pos.x == (unsigned int)pos.x && pos.y == (unsigned int) pos.y , "Numbers must be integers");
+    int idx = (int)(_gridSize.height * pos.x + pos.y) * 4 * 3;
+    float *vertArray = (float*)_vertices;
     memcpy(&vertArray[idx], &coords, sizeof(Quad3));
 }
 
 Quad3 TiledGrid3D::getOriginalTile(const Vec2& pos) const
 {
-    CCASSERT(pos.x == (unsigned int)pos.x && pos.y == (unsigned int)pos.y, "Numbers must be integers");
-    int idx = (_gridSize.height * pos.x + pos.y) * 4 * 3;
-    float* vertArray = (float*)_originalVertices;
+    CCASSERT( pos.x == (unsigned int)pos.x && pos.y == (unsigned int) pos.y , "Numbers must be integers");
+    int idx = (int)(_gridSize.height * pos.x + pos.y) * 4 * 3;
+    float *vertArray = (float*)_originalVertices;
 
     Quad3 ret;
     memcpy(&ret, &vertArray[idx], sizeof(Quad3));
@@ -786,9 +761,9 @@ Quad3 TiledGrid3D::getOriginalTile(const Vec2& pos) const
 
 Quad3 TiledGrid3D::getTile(const Vec2& pos) const
 {
-    CCASSERT(pos.x == (unsigned int)pos.x && pos.y == (unsigned int)pos.y, "Numbers must be integers");
-    int idx = (_gridSize.height * pos.x + pos.y) * 4 * 3;
-    float* vertArray = (float*)_vertices;
+    CCASSERT( pos.x == (unsigned int)pos.x && pos.y == (unsigned int) pos.y , "Numbers must be integers");
+    int idx = (int)(_gridSize.height * pos.x + pos.y) * 4 * 3;
+    float *vertArray = (float*)_vertices;
 
     Quad3 ret;
     memcpy(&ret, &vertArray[idx], sizeof(Quad3));
@@ -796,15 +771,49 @@ Quad3 TiledGrid3D::getTile(const Vec2& pos) const
     return ret;
 }
 
-void TiledGrid3D::reuse(void)
+void TiledGrid3D::reuse()
 {
     if (_reuseGrid > 0)
     {
-        int numQuads = _gridSize.width * _gridSize.height;
+        int numQuads = (int)(_gridSize.width * _gridSize.height);
 
-        memcpy(_originalVertices, _vertices, numQuads * 12 * sizeof(GLfloat));
+        memcpy(_originalVertices, _vertices, numQuads * 12 * sizeof(float));
         --_reuseGrid;
     }
 }
 
+void TiledGrid3D::updateVertexBuffer()
+{
+    size_t gradSize = static_cast<size_t>(_gridSize.width * _gridSize.height);
+    size_t numOfPoints = gradSize * 4;
+    auto tempVecPointer = (Vec3*)_vertices;
+    for (size_t i = 0; i < numOfPoints; ++i)
+    {
+        auto offset = i * (sizeof(Vec3) + sizeof(Vec2));
+        memcpy((char*)_vertexBuffer + offset, &tempVecPointer[i], sizeof(Vec3));
+    }
+    _drawCommand.updateVertexBuffer(_vertexBuffer, (unsigned int)(numOfPoints * sizeof(Vec3) + numOfPoints * sizeof(Vec2)) );
+
+    _drawCommand.updateIndexBuffer(_indices, gradSize * 6 * sizeof(unsigned short));
+}
+
+void TiledGrid3D::updateVertexAndTexCoordinate()
+{
+    size_t gradSize = static_cast<size_t>(_gridSize.width * _gridSize.height);
+    auto numOfPoints = gradSize * 4;
+    auto tempVecPointer = (Vec3*)_vertices;
+    auto tempTexPointer = (Vec2*)_texCoordinates;
+    for (size_t i = 0; i < numOfPoints; ++i)
+    {
+        auto offset = i * (sizeof(Vec3) + sizeof(Vec2));
+        memcpy((char*)_vertexBuffer + offset, &tempVecPointer[i], sizeof(Vec3));
+        memcpy((char*)_vertexBuffer + offset + sizeof(Vec3), &tempTexPointer[i], sizeof(Vec2));
+    }
+    _drawCommand.createVertexBuffer((unsigned int)(sizeof(Vec3) + sizeof(Vec2) ), numOfPoints, CustomCommand::BufferUsage::DYNAMIC);
+    _drawCommand.updateVertexBuffer(_vertexBuffer, numOfPoints * sizeof(Vec3) + numOfPoints * sizeof(Vec2));
+
+    _drawCommand.createIndexBuffer(CustomCommand::IndexFormat::U_SHORT, gradSize * 6, CustomCommand::BufferUsage::DYNAMIC);
+    _drawCommand.updateIndexBuffer(_indices, gradSize * 6 * sizeof(unsigned short));
+}
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCGrid.h b/cocos2d/cocos/2d/CCGrid.h
index 40065b8fc3..5a70ffa672 100644
--- a/cocos2d/cocos/2d/CCGrid.h
+++ b/cocos2d/cocos/2d/CCGrid.h
@@ -2,7 +2,8 @@
 Copyright (c) 2009      On-Core
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -23,25 +24,21 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_GRID_H
-#define CC_2D_GRID_H
+#pragma once
 
-#include <cocos/base/CCDirector.h>
 #include <cocos/base/CCRef.h>
 #include <cocos/base/ccTypes.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/renderer/CCGroupCommand.h>
+#include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/renderer/CCCallbackCommand.h>
 
 NS_CC_BEGIN
 
-class GLProgram;
-class Grabber;
-class Node;
 class Texture2D;
+// class Grabber;
+// class GLProgram;
+class Node;
 
 /**
  * @addtogroup _2d
@@ -49,20 +46,31 @@ class Texture2D;
  */
 
 /** Base class for Other grid.
- */
+*/
 class CC_DLL GridBase : public Ref
 {
 public:
-    /** create one Grid */
-    static GridBase* create(const Size& gridSize, Texture2D* texture, bool flipped);
-    /** create one Grid */
-    static GridBase* create(const Size& gridSize);
     /**
     Destructor.
      * @js NA
      * @lua NA
      */
-    virtual ~GridBase(void);
+    virtual ~GridBase();
+
+    /**@{
+     Interface for custom action when before or after draw.
+     @js NA
+     */
+    virtual void beforeBlit() {}
+    virtual void afterBlit() {}
+    /**@}*/
+
+    /**Interface used to blit the texture with grid to screen.*/
+    virtual void blit() = 0;
+    /**Interface, Reuse the grid vertices.*/
+    virtual void reuse() = 0;
+    /**Interface, Calculate the vertices used for the blit.*/
+    virtual void calculateVertexPoints() = 0;
 
     /**@{
      Init the Grid base.
@@ -73,8 +81,8 @@ public:
     */
     bool initWithSize(const Size& gridSize);
     bool initWithSize(const Size& gridSize, const Rect& rect);
-    bool initWithSize(const Size& gridSize, Texture2D* texture, bool flipped);
-    bool initWithSize(const Size& gridSize, Texture2D* texture, bool flipped, const Rect& rect);
+    bool initWithSize(const Size& gridSize, Texture2D *texture, bool flipped);
+    bool initWithSize(const Size& gridSize, Texture2D *texture, bool flipped, const Rect& rect);
 
     /**@}*/
     /** @{
@@ -103,32 +111,17 @@ public:
     bool isTextureFlipped() const { return _isTextureFlipped; }
     /**Set the texture flipped or not.*/
     void setTextureFlipped(bool flipped);
-
+    
     /**@{
      Init and reset the status when render effects by using the grid.
      */
-    void beforeDraw(void);
-    void afterDraw(Node* target);
-    /**@}*/
-
-    /**@{
-     Interface for custom action when before or after draw.
-     @js NA
-     */
-    virtual void beforeBlit() {}
-    virtual void afterBlit() {}
+    void beforeDraw();
+    void afterDraw(Node *target);
     /**@}*/
-
-    /**Interface used to blit the texture with grid to screen.*/
-    virtual void blit(void);
-    /**Interface, Reuse the grid vertices.*/
-    virtual void reuse(void);
-    /**Interface, Calculate the vertices used for the blit.*/
-    virtual void calculateVertexPoints(void);
-
+    
     /**Change projection to 2D for grabbing.*/
-    void set2DProjection(void);
-
+    void set2DProjection();
+    
     /**
      * @brief Set the effect grid rect.
      * @param rect The effect grid rect.
@@ -141,16 +134,35 @@ public:
     const Rect& getGridRect() const { return _gridRect; }
 
 protected:
-    bool _active;
-    int _reuseGrid;
+    void updateBlendState();
+    
+    bool _active = false;
+    int  _reuseGrid = 0;
     Size _gridSize;
-    Texture2D* _texture;
+    Texture2D *_texture = nullptr;
     Vec2 _step;
-    Grabber* _grabber;
-    bool _isTextureFlipped;
-    GLProgram* _shaderProgram;
-    Director::Projection _directorProjection;
+    bool _isTextureFlipped = false;
+    Director::Projection _directorProjection = Director::Projection::_2D;
     Rect _gridRect;
+
+    Color4F _clearColor = {0, 0, 0, 0};
+
+    GroupCommand _groupCommand;
+    CustomCommand _drawCommand;
+    CallbackCommand _beforeDrawCommand;
+    CallbackCommand _afterDrawCommand;
+    CallbackCommand _beforeBlitCommand;
+    CallbackCommand _afterBlitCommand;
+    RenderTargetFlag _oldRenderTargetFlag;
+    Texture2D* _oldColorAttachment = nullptr;
+    Texture2D* _oldDepthAttachment = nullptr;
+    Texture2D* _oldStencilAttachment = nullptr;
+    
+    backend::UniformLocation _mvpMatrixLocation;
+    backend::UniformLocation _textureLocation;
+    backend::ProgramState* _programState = nullptr;
+    
+    BlendFunc  _blendFunc;
 };
 
 /**
@@ -164,9 +176,9 @@ public:
     /** create one Grid. */
     static Grid3D* create(const Size& gridSize, const Rect& rect);
     /** create one Grid. */
-    static Grid3D* create(const Size& gridSize, Texture2D* texture, bool flipped);
+    static Grid3D* create(const Size& gridSize, Texture2D *texture, bool flipped);
     /** create one Grid. */
-    static Grid3D* create(const Size& gridSize, Texture2D* texture, bool flipped, const Rect& rect);
+    static Grid3D* create(const Size& gridSize, Texture2D *texture, bool flipped, const Rect& rect);
     /**
      Constructor.
      * @js ctor
@@ -177,26 +189,19 @@ public:
      * @js NA
      * @lua NA
      */
-    ~Grid3D() override;
+    ~Grid3D();
 
     /** Returns the vertex at a given position.
      * @js NA
      * @lua NA
      */
     Vec3 getVertex(const Vec2& pos) const;
-    /** @deprecated Use getVertex() instead
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE Vec3 vertex(const Vec2& pos) const { return getVertex(pos); }
+
     /** Returns the original (non-transformed) vertex at a given position.
      * @js NA
      * @lua NA
      */
     Vec3 getOriginalVertex(const Vec2& pos) const;
-    /** @deprecated Use getOriginalVertex() instead
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE Vec3 originalVertex(const Vec2& pos) const { return getOriginalVertex(pos); }
 
     /** Sets a new vertex at a given position.
      * @lua NA
@@ -205,13 +210,13 @@ public:
     /**@{
      Implementations for interfaces in base class.
      */
-    void beforeBlit() override;
-    void afterBlit() override;
-    void blit() override;
-    void reuse() override;
-    void calculateVertexPoints() override;
+    virtual void beforeBlit() override;
+    virtual void afterBlit() override;
+    virtual void blit() override;
+    virtual void reuse() override;
+    virtual void calculateVertexPoints() override;
     /**@}*/
-
+    
     /**@{
      Getter and Setter for depth test state when blit.
      @js NA
@@ -220,13 +225,17 @@ public:
     bool getNeedDepthTestForBlit() const { return _needDepthTestForBlit; }
     /**@}*/
 protected:
-    GLvoid* _texCoordinates;
-    GLvoid* _vertices;
-    GLvoid* _originalVertices;
-    GLushort* _indices;
-    bool _needDepthTestForBlit;
-    bool _oldDepthTestValue;
-    bool _oldDepthWriteValue;
+    void updateVertexBuffer();
+    void updateVertexAndTexCoordinate();
+
+    void* _vertexBuffer = nullptr;
+    void* _texCoordinates = nullptr;
+    void* _vertices = nullptr;
+    void* _originalVertices = nullptr;
+    unsigned short *_indices = nullptr;
+    bool _needDepthTestForBlit = false;
+    bool _oldDepthTest = false;
+    bool _oldDepthWrite = false;
 };
 
 /**
@@ -241,62 +250,58 @@ public:
     /** Create one Grid. */
     static TiledGrid3D* create(const Size& gridSize, const Rect& rect);
     /** Create one Grid. */
-    static TiledGrid3D* create(const Size& gridSize, Texture2D* texture, bool flipped);
+    static TiledGrid3D* create(const Size& gridSize, Texture2D *texture, bool flipped);
     /** Create one Grid. */
-    static TiledGrid3D* create(const Size& gridSize, Texture2D* texture, bool flipped, const Rect& rect);
-    /**
-     Constructor.
-     * @js ctor
-     */
-    TiledGrid3D();
-    /**
-     Destructor.
-     * @js NA
-     * @lua NA
+    static TiledGrid3D* create(const Size& gridSize, Texture2D *texture, bool flipped, const Rect& rect);
+
+    /**@{
+     Implementations for interfaces in base class.
      */
-    ~TiledGrid3D() override;
+    virtual void blit() override;
+    virtual void reuse() override;
+    virtual void calculateVertexPoints() override;
+    /**@}*/
 
     /** Returns the tile at the given position.
      * @js NA
      * @lua NA
      */
     Quad3 getTile(const Vec2& pos) const;
-    /** returns the tile at the given position
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE Quad3 tile(const Vec2& pos) const { return getTile(pos); }
     /** Returns the original tile (untransformed) at the given position.
      * @js NA
      * @lua NA
      */
     Quad3 getOriginalTile(const Vec2& pos) const;
-    /** returns the original tile (untransformed) at the given position
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE Quad3 originalTile(const Vec2& pos) const { return getOriginalTile(pos); }
 
     /** Sets a new tile.
      * @lua NA
      */
     void setTile(const Vec2& pos, const Quad3& coords);
 
-    /**@{
-     Implementations for interfaces in base class.
-     */
-    void blit() override;
-    void reuse() override;
-    void calculateVertexPoints() override;
-    /**@}*/
 protected:
-    GLvoid* _texCoordinates;
-    GLvoid* _vertices;
-    GLvoid* _originalVertices;
-    GLushort* _indices;
+    /**
+     Constructor.
+     * @js ctor
+     */
+    TiledGrid3D() = default;
+    /**
+     Destructor.
+     * @js NA
+     * @lua NA
+     */
+    ~TiledGrid3D();
+
+    void updateVertexBuffer();
+    void updateVertexAndTexCoordinate();
+
+    void* _texCoordinates = nullptr;
+    void* _vertices = nullptr;
+    void* _originalVertices = nullptr;
+    unsigned short* _indices = nullptr;
+    void* _vertexBuffer = nullptr;
 };
 
 // end of effects group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_GRID_H
diff --git a/cocos2d/cocos/2d/CCLabel.cpp b/cocos2d/cocos/2d/CCLabel.cpp
index 8374c75c59..e012897d60 100644
--- a/cocos2d/cocos/2d/CCLabel.cpp
+++ b/cocos2d/cocos/2d/CCLabel.cpp
@@ -1,6 +1,7 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
  http://www.cocos2d-x.org
 
@@ -25,30 +26,53 @@
 
 #include <cocos/2d/CCLabel.h>
 
-#include <cocos/2d/CCCamera.h>
-#include <cocos/2d/CCDrawNode.h>
+#include <algorithm>
+
 #include <cocos/2d/CCFont.h>
-#include <cocos/2d/CCFontAtlas.h>
 #include <cocos/2d/CCFontAtlasCache.h>
-#include <cocos/2d/CCFontFNT.h>
+#include <cocos/2d/CCFontAtlas.h>
 #include <cocos/2d/CCSprite.h>
 #include <cocos/2d/CCSpriteBatchNode.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/CCEventCustom.h>
-#include <cocos/base/CCEventDispatcher.h>
-#include <cocos/base/CCEventListenerCustom.h>
+#include <cocos/2d/CCDrawNode.h>
+#include <cocos/2d/CCCamera.h>
 #include <cocos/base/ccUTF8.h>
+#include <cocos/base/ccMacros.h>
 #include <cocos/platform/CCFileUtils.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
 #include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTextureAtlas.h>
-#include <cocos/renderer/ccGLStateCache.h>
-
-#include <algorithm>
+#include <cocos/renderer/CCRenderCommand.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/base/CCEventListenerCustom.h>
+#include <cocos/base/CCEventDispatcher.h>
+#include <cocos/base/CCEventCustom.h>
+#include <cocos/base/ccUtils.h>
+#include <cocos/2d/CCFontFNT.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 
+
+namespace {
+    void updateBlend(backend::BlendDescriptor &blendDescriptor, BlendFunc blendFunc)
+    {
+        blendDescriptor.blendEnabled = true;
+        if (blendFunc == BlendFunc::ALPHA_NON_PREMULTIPLIED)
+        {
+            blendDescriptor.sourceRGBBlendFactor = backend::BlendFactor::SRC_ALPHA;
+            blendDescriptor.destinationRGBBlendFactor = backend::BlendFactor::ONE_MINUS_SRC_ALPHA;
+            blendDescriptor.sourceAlphaBlendFactor = backend::BlendFactor::SRC_ALPHA;
+            blendDescriptor.destinationAlphaBlendFactor = backend::BlendFactor::ONE_MINUS_SRC_ALPHA;
+        }
+        else
+        {
+            blendDescriptor.sourceRGBBlendFactor = backend::BlendFactor::ONE;
+            blendDescriptor.destinationRGBBlendFactor = backend::BlendFactor::ONE_MINUS_SRC_ALPHA;
+            blendDescriptor.sourceAlphaBlendFactor = backend::BlendFactor::ONE;
+            blendDescriptor.destinationAlphaBlendFactor = backend::BlendFactor::ONE_MINUS_SRC_ALPHA;
+        }
+    }
+}
+
 /**
  * LabelLetter used to update the quad in texture atlas without SpriteBatchNode.
  */
@@ -61,7 +85,7 @@ public:
         _letterVisible = true;
     }
 
-    static LabelLetter* createWithTexture(Texture2D* texture, const Rect& rect, bool rotated = false)
+    static LabelLetter* createWithTexture(Texture2D *texture, const Rect& rect, bool rotated = false)
     {
         auto letter = new (std::nothrow) LabelLetter();
         if (letter && letter->initWithTexture(texture, rect, rotated))
@@ -73,28 +97,24 @@ public:
         CC_SAFE_DELETE(letter);
         return nullptr;
     }
-
-    CREATE_FUNC(LabelLetter)
+    
+    CREATE_FUNC(LabelLetter);
 
     virtual void updateTransform() override
     {
         if (isDirty())
         {
             _transformToBatch = getNodeToParentTransform();
-            Size& size = _rect.size;
+            Size &size = _rect.size;
 
             float x1 = _offsetPosition.x;
             float y1 = _offsetPosition.y;
             float x2 = x1 + size.width;
             float y2 = y1 + size.height;
-            if (_flippedX)
-            {
-                std::swap(x1, x2);
-            }
-            if (_flippedY)
-            {
-                std::swap(y1, y2);
-            }
+
+            // issue #17022: don't flip, again, the letter since they are flipped in sprite's code
+            //if (_flippedX) std::swap(x1, x2);
+            //if (_flippedY) std::swap(y1, y2);
 
             float x = _transformToBatch.m[12];
             float y = _transformToBatch.m[13];
@@ -138,7 +158,7 @@ public:
         }
 
         auto displayedOpacity = _displayedOpacity;
-        if (!_letterVisible)
+        if(!_letterVisible)
         {
             displayedOpacity = 0.0f;
         }
@@ -164,13 +184,42 @@ public:
         updateColor();
     }
 
-    // LabelLetter doesn't need to draw directly.
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override {}
-
+    bool isVisible() const override
+    {
+        return _letterVisible;
+    }
+    
+    //LabelLetter doesn't need to draw directly.
+    void draw(Renderer* /*renderer*/, const Mat4 & /*transform*/, uint32_t /*flags*/) override
+    {
+    }
+    
 private:
     bool _letterVisible;
 };
 
+Label::BatchCommand::BatchCommand()
+{
+    textCommand.setDrawType(CustomCommand::DrawType::ELEMENT);
+    textCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE);
+    shadowCommand.setDrawType(CustomCommand::DrawType::ELEMENT);
+    shadowCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE);
+    outLineCommand.setDrawType(CustomCommand::DrawType::ELEMENT);
+    outLineCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE);
+}
+
+Label::BatchCommand::~BatchCommand()
+{
+    CC_SAFE_RELEASE_NULL(textCommand.getPipelineDescriptor().programState);
+    CC_SAFE_RELEASE_NULL(shadowCommand.getPipelineDescriptor().programState);
+    CC_SAFE_RELEASE_NULL(outLineCommand.getPipelineDescriptor().programState);
+}
+
+std::array<CustomCommand*, 3> Label::BatchCommand::getCommandArray()
+{
+    return std::array<CustomCommand*, 3>{&textCommand, &shadowCommand, &outLineCommand};
+}
+
 Label* Label::create()
 {
     auto ret = new (std::nothrow) Label;
@@ -183,23 +232,9 @@ Label* Label::create()
     return ret;
 }
 
-Label* Label::create(const std::string& text, const std::string& font, float fontSize, const Size& dimensions /* = Size::ZERO */,
-                     TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignment vAlignment /* = TextVAlignment::TOP */)
-{
-    if (FileUtils::getInstance()->isFileExist(font))
-    {
-        return createWithTTF(text, font, fontSize, dimensions, hAlignment, vAlignment);
-    }
-    else
-    {
-        return createWithSystemFont(text, font, fontSize, dimensions, hAlignment, vAlignment);
-    }
-}
-
-Label* Label::createWithSystemFont(const std::string& text, const std::string& font, float fontSize, const Size& dimensions /* = Size::ZERO */,
-                                   TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignment vAlignment /* = TextVAlignment::TOP */)
+Label* Label::createWithSystemFont(const std::string& text, const std::string& font, float fontSize, const Size& dimensions /* = Size::ZERO */, TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignment vAlignment /* = TextVAlignment::TOP */)
 {
-    auto ret = new (std::nothrow) Label(hAlignment, vAlignment);
+    auto ret = new (std::nothrow) Label(hAlignment,vAlignment);
 
     if (ret)
     {
@@ -216,10 +251,9 @@ Label* Label::createWithSystemFont(const std::string& text, const std::string& f
     return nullptr;
 }
 
-Label* Label::createWithTTF(const std::string& text, const std::string& fontFile, float fontSize, const Size& dimensions /* = Size::ZERO */,
-                            TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignment vAlignment /* = TextVAlignment::TOP */)
+Label* Label::createWithTTF(const std::string& text, const std::string& fontFile, float fontSize, const Size& dimensions /* = Size::ZERO */, TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignment vAlignment /* = TextVAlignment::TOP */)
 {
-    auto ret = new (std::nothrow) Label(hAlignment, vAlignment);
+    auto ret = new (std::nothrow) Label(hAlignment,vAlignment);
 
     if (ret && ret->initWithTTF(text, fontFile, fontSize, dimensions, hAlignment, vAlignment))
     {
@@ -231,8 +265,7 @@ Label* Label::createWithTTF(const std::string& text, const std::string& fontFile
     return nullptr;
 }
 
-Label*
-Label::createWithTTF(const TTFConfig& ttfConfig, const std::string& text, TextHAlignment hAlignment /* = TextHAlignment::CENTER */, int maxLineWidth /* = 0 */)
+Label* Label::createWithTTF(const TTFConfig& ttfConfig, const std::string& text, TextHAlignment hAlignment /* = TextHAlignment::CENTER */, int maxLineWidth /* = 0 */)
 {
     auto ret = new (std::nothrow) Label(hAlignment);
 
@@ -246,12 +279,11 @@ Label::createWithTTF(const TTFConfig& ttfConfig, const std::string& text, TextHA
     return nullptr;
 }
 
-Label* Label::createWithBMFont(const std::string& bmfontFilePath, const std::string& text, const TextHAlignment& hAlignment /* = TextHAlignment::LEFT */,
-                               int maxLineWidth /* = 0 */, const Vec2& imageOffset /* = Vec2::ZERO */)
+Label* Label::createWithBMFont(const std::string& bmfontFilePath, const std::string& text,const TextHAlignment& hAlignment /* = TextHAlignment::LEFT */, int maxLineWidth /* = 0 */, const Vec2& imageOffset /* = Vec2::ZERO */)
 {
     auto ret = new (std::nothrow) Label(hAlignment);
 
-    if (ret && ret->setBMFontFilePath(bmfontFilePath, imageOffset))
+    if (ret && ret->setBMFontFilePath(bmfontFilePath,imageOffset))
     {
         ret->setMaxLineWidth(maxLineWidth);
         ret->setString(text);
@@ -259,7 +291,7 @@ Label* Label::createWithBMFont(const std::string& bmfontFilePath, const std::str
 
         return ret;
     }
-
+    
     delete ret;
     return nullptr;
 }
@@ -282,7 +314,7 @@ Label* Label::createWithCharMap(Texture2D* texture, int itemWidth, int itemHeigh
 {
     auto ret = new (std::nothrow) Label();
 
-    if (ret && ret->setCharMap(texture, itemWidth, itemHeight, startCharMap))
+    if (ret && ret->setCharMap(texture,itemWidth,itemHeight,startCharMap))
     {
         ret->autorelease();
         return ret;
@@ -296,7 +328,7 @@ Label* Label::createWithCharMap(const std::string& charMapFile, int itemWidth, i
 {
     auto ret = new (std::nothrow) Label();
 
-    if (ret && ret->setCharMap(charMapFile, itemWidth, itemHeight, startCharMap))
+    if (ret && ret->setCharMap(charMapFile,itemWidth,itemHeight,startCharMap))
     {
         ret->autorelease();
         return ret;
@@ -322,8 +354,11 @@ bool Label::setCharMap(const std::string& plistFile)
     return true;
 }
 
-bool Label::initWithTTF(const std::string& text, const std::string& fontFilePath, float fontSize, const Size& dimensions, TextHAlignment hAlignment,
-                        TextVAlignment vAlignment)
+
+bool Label::initWithTTF(const std::string& text,
+                        const std::string& fontFilePath, float fontSize,
+                        const Size& dimensions,
+                        TextHAlignment /*hAlignment*/, TextVAlignment /*vAlignment*/)
 {
     if (FileUtils::getInstance()->isFileExist(fontFilePath))
     {
@@ -338,7 +373,7 @@ bool Label::initWithTTF(const std::string& text, const std::string& fontFilePath
     return false;
 }
 
-bool Label::initWithTTF(const TTFConfig& ttfConfig, const std::string& text, TextHAlignment hAlignment, int maxLineWidth)
+bool Label::initWithTTF(const TTFConfig& ttfConfig, const std::string& text, TextHAlignment /*hAlignment*/, int maxLineWidth)
 {
     if (FileUtils::getInstance()->isFileExist(ttfConfig.fontFilePath) && setTTFConfig(ttfConfig))
     {
@@ -351,7 +386,7 @@ bool Label::initWithTTF(const TTFConfig& ttfConfig, const std::string& text, Tex
 
 bool Label::setCharMap(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap)
 {
-    auto newAtlas = FontAtlasCache::getFontAtlasCharMap(texture, itemWidth, itemHeight, startCharMap);
+    auto newAtlas = FontAtlasCache::getFontAtlasCharMap(texture,itemWidth,itemHeight,startCharMap);
 
     if (!newAtlas)
     {
@@ -367,7 +402,7 @@ bool Label::setCharMap(Texture2D* texture, int itemWidth, int itemHeight, int st
 
 bool Label::setCharMap(const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap)
 {
-    auto newAtlas = FontAtlasCache::getFontAtlasCharMap(charMapFile, itemWidth, itemHeight, startCharMap);
+    auto newAtlas = FontAtlasCache::getFontAtlasCharMap(charMapFile,itemWidth,itemHeight,startCharMap);
 
     if (!newAtlas)
     {
@@ -381,7 +416,8 @@ bool Label::setCharMap(const std::string& charMapFile, int itemWidth, int itemHe
     return true;
 }
 
-Label::Label(TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignment vAlignment /* = TextVAlignment::TOP */)
+Label::Label(TextHAlignment hAlignment /* = TextHAlignment::LEFT */, 
+             TextVAlignment vAlignment /* = TextVAlignment::TOP */)
 : _textSprite(nullptr)
 , _shadowNode(nullptr)
 , _fontAtlas(nullptr)
@@ -401,7 +437,7 @@ Label::Label(TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignm
     addChild(_debugDrawNode);
 #endif
 
-    _purgeTextureListener = EventListenerCustom::create(FontAtlas::CMD_PURGE_FONTATLAS, [this](EventCustom* event) {
+    _purgeTextureListener = EventListenerCustom::create(FontAtlas::CMD_PURGE_FONTATLAS, [this](EventCustom* event){
         if (_fontAtlas && _currentLabelType == LabelType::TTF && event->getUserData() == _fontAtlas)
         {
             for (auto&& it : _letters)
@@ -409,6 +445,7 @@ Label::Label(TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignm
                 it.second->setTexture(nullptr);
             }
             _batchNodes.clear();
+            _batchCommands.clear();
 
             if (_fontAtlas)
             {
@@ -417,12 +454,17 @@ Label::Label(TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignm
         }
     });
     _eventDispatcher->addEventListenerWithFixedPriority(_purgeTextureListener, 1);
-
-    _resetTextureListener = EventListenerCustom::create(FontAtlas::CMD_RESET_FONTATLAS, [this](EventCustom* event) {
+    
+    _resetTextureListener = EventListenerCustom::create(FontAtlas::CMD_RESET_FONTATLAS, [this](EventCustom* event){
         if (_fontAtlas && _currentLabelType == LabelType::TTF && event->getUserData() == _fontAtlas)
         {
             _fontAtlas = nullptr;
+            auto lineHeight = _lineHeight;
             this->setTTFConfig(_fontConfig);
+            if (_currentLabelType != LabelType::STRING_TEXTURE)
+            {
+                setLineHeight(lineHeight);
+            }
             for (auto&& it : _letters)
             {
                 getLetter(it.first);
@@ -434,7 +476,7 @@ Label::Label(TextHAlignment hAlignment /* = TextHAlignment::LEFT */, TextVAlignm
 
 Label::~Label()
 {
-    delete[] _horizontalKernings;
+    delete [] _horizontalKernings;
 
     if (_fontAtlas)
     {
@@ -443,11 +485,14 @@ Label::~Label()
         _batchNodes.clear();
         FontAtlasCache::releaseFontAtlas(_fontAtlas);
     }
+    _batchCommands.clear();
     _eventDispatcher->removeEventListener(_purgeTextureListener);
     _eventDispatcher->removeEventListener(_resetTextureListener);
 
     CC_SAFE_RELEASE_NULL(_textSprite);
     CC_SAFE_RELEASE_NULL(_shadowNode);
+    
+    CC_SAFE_RELEASE(_programState);
 }
 
 void Label::reset()
@@ -458,6 +503,7 @@ void Label::reset()
     CC_SAFE_RELEASE_NULL(_reusedLetter);
     _letters.clear();
     _batchNodes.clear();
+    _batchCommands.clear();
     _lettersInfo.clear();
     if (_fontAtlas)
     {
@@ -470,7 +516,7 @@ void Label::reset()
     _contentDirty = false;
     _numberOfLines = 0;
     _lengthOfString = 0;
-    _utf16Text.clear();
+    _utf32Text.clear();
     _utf8Text.clear();
 
     TTFConfig temp;
@@ -479,7 +525,7 @@ void Label::reset()
     _bmFontPath = "";
     _systemFontDirty = false;
     _systemFont = "Helvetica";
-    _systemFontSize = 12;
+    _systemFontSize = CC_DEFAULT_FONT_LABEL_SIZE;
 
     if (_horizontalKernings)
     {
@@ -507,6 +553,10 @@ void Label::reset()
     _shadowEnabled = false;
     _shadowBlurRadius = 0.f;
 
+    _uniformEffectColor = -1;
+    _uniformEffectType = -1;
+    _uniformTextColor = -1;
+
     _useDistanceField = false;
     _useA8Shader = false;
     _clipEnabled = false;
@@ -526,7 +576,7 @@ void Label::reset()
         _underlineNode = nullptr;
     }
     _strikethroughEnabled = false;
-    setRotationSkewX(0); // reverse italics
+    setRotationSkewX(0);        // reverse italics
 }
 
 //  ETC1 ALPHA supports, for LabelType::BMFONT & LabelType::CHARMAP
@@ -534,74 +584,177 @@ static Texture2D* _getTexture(Label* label)
 {
     auto fontAtlas = label->getFontAtlas();
     Texture2D* texture = nullptr;
-    if (fontAtlas != nullptr)
-    {
-        const auto& textures = fontAtlas->getTextures();
-        if (!textures.empty())
-        {
+    if (fontAtlas != nullptr) {
+        auto textures = fontAtlas->getTextures();
+        if(!textures.empty()) {
             texture = textures.begin()->second;
         }
     }
     return texture;
 }
 
+void Label::setVertexLayout(PipelineDescriptor& pipelineDescriptor)
+{
+    auto vertexLayout = _programState->getVertexLayout();
+    ///a_position
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_POSITION,
+                        _programState->getAttributeLocation(backend::Attribute::POSITION),
+                        backend::VertexFormat::FLOAT3,
+                        0,
+                        false);
+    
+    ///a_texCoord
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_TEXCOORD,
+                        _programState->getAttributeLocation(backend::Attribute::TEXCOORD),
+                        backend::VertexFormat::FLOAT2,
+                        offsetof(V3F_C4B_T2F, texCoords),
+                        false);
+    
+    ///a_color
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_COLOR,
+                        _programState->getAttributeLocation(backend::Attribute::COLOR),
+                        backend::VertexFormat::UBYTE4, 
+                        offsetof(V3F_C4B_T2F, colors), 
+                        true);
+    vertexLayout->setLayout(sizeof(V3F_C4B_T2F));
+}
+
+void Label::setProgramState(backend::ProgramState *programState)
+{
+    if (_programState != programState)
+    {
+        CC_SAFE_RELEASE_NULL(_programState);
+        _programState = programState;
+        CC_SAFE_RETAIN(programState);
+    }
+    updateUniformLocations();
+    for (auto &batch : _batchCommands)
+    {
+        updateBatchCommand(batch);
+    }
+
+    auto &quadPipeline = _quadCommand.getPipelineDescriptor();
+    setVertexLayout(quadPipeline);
+    quadPipeline.programState = _programState;
+}
+
 void Label::updateShaderProgram()
 {
-    switch (_currLabelEffect)
+    auto programType = backend::ProgramType::POSITION_TEXTURE_COLOR;
+    if (_currentLabelType == LabelType::BMFONT || _currentLabelType == LabelType::CHARMAP)
     {
-        case cocos2d::LabelEffect::NORMAL:
-            if (_useDistanceField)
-                setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_LABEL_DISTANCEFIELD_NORMAL));
-            else if (_useA8Shader)
-                setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_LABEL_NORMAL));
-            else if (_shadowEnabled)
-                setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR, _getTexture(this)));
-            else
-                setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP, _getTexture(this)));
+        auto texture = _getTexture(this);
+        if(texture && texture->getAlphaTextureName())
+        {
+            programType = backend::ProgramType::ETC1;
+        }
+    }
+    else
+    {
+        switch (_currLabelEffect)
+        {
+            case cocos2d::LabelEffect::NORMAL:
+                if (_useDistanceField)
+                {
+                    programType = backend::ProgramType::LABEL_DISTANCE_NORMAL;
+                }
+                else if (_useA8Shader)
+                {
+                    programType = backend::ProgramType::LABEL_NORMAL;
+                }
+                else
+                {
+                    auto texture = _getTexture(this);
+                    if(texture && texture->getAlphaTextureName())
+                    {
+                        programType = backend::ProgramType::ETC1;
+                    }
+                }
+                break;
+            case cocos2d::LabelEffect::OUTLINE:
+                {
+                    programType = backend::ProgramType::LABLE_OUTLINE;
+                }
+                break;
+            case cocos2d::LabelEffect::GLOW:
+                if (_useDistanceField)
+                {
+                    programType = backend::ProgramType::LABLE_DISTANCEFIELD_GLOW;
+                }
+                break;
+            default:
+                return;
+        }
+    }
 
-            break;
-        case cocos2d::LabelEffect::OUTLINE:
-            setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_LABEL_OUTLINE));
-            _uniformEffectColor = glGetUniformLocation(getGLProgram()->getProgram(), "u_effectColor");
-            break;
-        case cocos2d::LabelEffect::GLOW:
-            if (_useDistanceField)
-            {
-                setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_LABEL_DISTANCEFIELD_GLOW));
-                _uniformEffectColor = glGetUniformLocation(getGLProgram()->getProgram(), "u_effectColor");
-            }
-            break;
-        default:
-            return;
+    CC_SAFE_RELEASE(_programState);
+    _programState = new backend::ProgramState(programType);
+
+    updateUniformLocations();
+
+    for (auto &batch : _batchCommands)
+    {
+        updateBatchCommand(batch);
     }
 
-    _uniformTextColor = glGetUniformLocation(getGLProgram()->getProgram(), "u_textColor");
+    auto &quadPipeline = _quadCommand.getPipelineDescriptor();
+    setVertexLayout(quadPipeline);
+    quadPipeline.programState = _programState;
+}
+
+void Label::updateBatchCommand(Label::BatchCommand &batch)
+{
+    CCASSERT(_programState, "programState should be set!");
+
+    auto& pipelineDescriptor = batch.textCommand.getPipelineDescriptor();
+    CC_SAFE_RELEASE_NULL(pipelineDescriptor.programState);
+    pipelineDescriptor.programState = _programState->clone();
+    setVertexLayout(pipelineDescriptor);
+
+    auto &pipelineShadow = batch.shadowCommand.getPipelineDescriptor();
+    CC_SAFE_RELEASE_NULL(pipelineShadow.programState);
+    pipelineShadow.programState = _programState->clone();;
+    setVertexLayout(pipelineShadow);
+
+    auto &pipelineOutline = batch.outLineCommand.getPipelineDescriptor();
+    CC_SAFE_RELEASE_NULL(pipelineOutline.programState);
+    pipelineOutline.programState = _programState->clone();
+    setVertexLayout(pipelineOutline);
+
+}
+
+void Label::updateUniformLocations()
+{
+    _mvpMatrixLocation      = _programState->getUniformLocation(backend::Uniform::MVP_MATRIX);
+    _textureLocation        = _programState->getUniformLocation(backend::Uniform::TEXTURE);
+    _alphaTextureLocation   = _programState->getUniformLocation(backend::Uniform::TEXTURE1);
+    _textColorLocation      = _programState->getUniformLocation(backend::Uniform::TEXT_COLOR);
+    _effectColorLocation    = _programState->getUniformLocation(backend::Uniform::EFFECT_COLOR);
+    _effectTypeLocation     = _programState->getUniformLocation(backend::Uniform::EFFECT_TYPE);
 }
 
-void Label::setFontAtlas(FontAtlas* atlas, bool distanceFieldEnabled /* = false */, bool useA8Shader /* = false */)
+void Label::setFontAtlas(FontAtlas* atlas,bool distanceFieldEnabled /* = false */, bool useA8Shader /* = false */)
 {
-    if (atlas)
+    if(atlas)
     {
         _systemFontDirty = false;
     }
 
     if (atlas == _fontAtlas)
-    {
         return;
-    }
 
+    CC_SAFE_RETAIN(atlas);
     if (_fontAtlas)
     {
         _batchNodes.clear();
         FontAtlasCache::releaseFontAtlas(_fontAtlas);
-        _fontAtlas = nullptr;
     }
-
     _fontAtlas = atlas;
+    
     if (_reusedLetter == nullptr)
     {
         _reusedLetter = Sprite::create();
-        _reusedLetter->setOpacityModifyRGB(_isOpacityModifyRGB);
+        _reusedLetter->setOpacityModifyRGB(_isOpacityModifyRGB);            
         _reusedLetter->retain();
         _reusedLetter->setAnchorPoint(Vec2::ANCHOR_TOP_LEFT);
     }
@@ -630,27 +783,24 @@ bool Label::setTTFConfig(const TTFConfig& ttfConfig)
 
 bool Label::setBMFontFilePath(const std::string& bmfontFilePath, const Vec2& imageOffset, float fontSize)
 {
-    FontAtlas* newAtlas = FontAtlasCache::getFontAtlasFNT(bmfontFilePath, imageOffset);
-
+    FontAtlas *newAtlas = FontAtlasCache::getFontAtlasFNT(bmfontFilePath,imageOffset);
+    
     if (!newAtlas)
     {
         reset();
         return false;
     }
 
-    // assign the default fontSize
-    if (std::abs(fontSize) < FLT_EPSILON)
-    {
-        FontFNT* bmFont = static_cast<FontFNT*>(const_cast<Font*>(newAtlas->getFont()));
-        if (bmFont)
-        {
+    //assign the default fontSize
+    if (std::abs(fontSize) < FLT_EPSILON) {
+        FontFNT *bmFont = (FontFNT*)newAtlas->getFont();
+        if (bmFont) {
             float originalFontSize = bmFont->getOriginalFontSize();
             _bmFontSize = originalFontSize / CC_CONTENT_SCALE_FACTOR();
         }
     }
 
-    if (fontSize > 0.0f)
-    {
+    if(fontSize > 0.0f){
         _bmFontSize = fontSize;
     }
 
@@ -669,15 +819,15 @@ void Label::setString(const std::string& text)
         _utf8Text = text;
         _contentDirty = true;
 
-        std::u16string utf16String;
-        if (StringUtils::UTF8ToUTF16(_utf8Text, utf16String))
+        std::u32string utf32String;
+        if (StringUtils::UTF8ToUTF32(_utf8Text, utf32String))
         {
-            _utf16Text = utf16String;
+            _utf32Text  = utf32String;
         }
     }
 }
 
-void Label::setAlignment(TextHAlignment hAlignment, TextVAlignment vAlignment)
+void Label::setAlignment(TextHAlignment hAlignment,TextVAlignment vAlignment)
 {
     if (hAlignment != _hAlignment || vAlignment != _vAlignment)
     {
@@ -690,8 +840,7 @@ void Label::setAlignment(TextHAlignment hAlignment, TextVAlignment vAlignment)
 
 void Label::setMaxLineWidth(float maxLineWidth)
 {
-    static constexpr auto const epsi = std::numeric_limits<float>::epsilon();
-    if (std::abs(_labelWidth) < epsi && std::abs(_maxLineWidth - maxLineWidth) > epsi)
+    if (_labelWidth == 0 && _maxLineWidth != maxLineWidth)
     {
         _maxLineWidth = maxLineWidth;
         _contentDirty = true;
@@ -700,12 +849,10 @@ void Label::setMaxLineWidth(float maxLineWidth)
 
 void Label::setDimensions(float width, float height)
 {
-    if (_overflow == Overflow::RESIZE_HEIGHT)
-    {
+    if(_overflow == Overflow::RESIZE_HEIGHT){
         height = 0;
     }
-    static constexpr auto const epsi = std::numeric_limits<float>::epsilon();
-    if (std::abs(height - _labelHeight) > epsi || (width - _labelWidth) > epsi)
+    if (height != _labelHeight || width != _labelWidth)
     {
         _labelWidth = width;
         _labelHeight = height;
@@ -715,10 +862,8 @@ void Label::setDimensions(float width, float height)
         _maxLineWidth = width;
         _contentDirty = true;
 
-        if (_overflow == Overflow::SHRINK)
-        {
-            if (_originalFontSize > 0)
-            {
+        if(_overflow == Overflow::SHRINK){
+            if (_originalFontSize > 0) {
                 this->restoreFontSize();
             }
         }
@@ -727,18 +872,13 @@ void Label::setDimensions(float width, float height)
 
 void Label::restoreFontSize()
 {
-    if (_currentLabelType == LabelType::TTF)
-    {
+    if(_currentLabelType == LabelType::TTF){
         auto ttfConfig = this->getTTFConfig();
         ttfConfig.fontSize = _originalFontSize;
         this->setTTFConfigInternal(ttfConfig);
-    }
-    else if (_currentLabelType == LabelType::BMFONT)
-    {
+    }else if(_currentLabelType == LabelType::BMFONT){
         this->setBMFontSizeInternal(_originalFontSize);
-    }
-    else if (_currentLabelType == LabelType::STRING_TEXTURE)
-    {
+    }else if(_currentLabelType == LabelType::STRING_TEXTURE){
         this->setSystemFontSize(_originalFontSize);
     }
 }
@@ -748,7 +888,7 @@ void Label::setLineBreakWithoutSpace(bool breakWithoutSpace)
     if (breakWithoutSpace != _lineBreakWithoutSpaces)
     {
         _lineBreakWithoutSpaces = breakWithoutSpace;
-        _contentDirty = true;
+        _contentDirty = true;     
     }
 }
 
@@ -763,7 +903,7 @@ void Label::updateLabelLetters()
         for (auto it = _letters.begin(); it != _letters.end();)
         {
             letterIndex = it->first;
-            letterSprite = static_cast<LabelLetter*>(it->second);
+            letterSprite = (LabelLetter*)it->second;
 
             if (letterIndex >= _lengthOfString)
             {
@@ -773,30 +913,36 @@ void Label::updateLabelLetters()
             else
             {
                 auto& letterInfo = _lettersInfo[letterIndex];
-                auto& letterDef = _fontAtlas->_letterDefinitions[letterInfo.utf16Char];
-                uvRect.size.height = letterDef.height;
-                uvRect.size.width = letterDef.width;
-                uvRect.origin.x = letterDef.U;
-                uvRect.origin.y = letterDef.V;
-
-                auto batchNode = _batchNodes.at(letterDef.textureID);
-                letterSprite->setTextureAtlas(batchNode->getTextureAtlas());
-                letterSprite->setTexture(_fontAtlas->getTexture(letterDef.textureID));
-                if (letterDef.width <= 0.f || letterDef.height <= 0.f)
+                if (letterInfo.valid)
                 {
-                    letterSprite->setTextureAtlas(nullptr);
+                    auto& letterDef = _fontAtlas->_letterDefinitions[letterInfo.utf32Char];
+                    uvRect.size.height = letterDef.height;
+                    uvRect.size.width = letterDef.width;
+                    uvRect.origin.x = letterDef.U;
+                    uvRect.origin.y = letterDef.V;
+
+                    auto batchNode = _batchNodes.at(letterDef.textureID);
+                    letterSprite->setTextureAtlas(batchNode->getTextureAtlas());
+                    letterSprite->setTexture(_fontAtlas->getTexture(letterDef.textureID));
+                    if (letterDef.width <= 0.f || letterDef.height <= 0.f)
+                    {
+                        letterSprite->setTextureAtlas(nullptr);
+                    }
+                    else
+                    {
+                        letterSprite->setTextureRect(uvRect, false, uvRect.size);
+                        letterSprite->setTextureAtlas(_batchNodes.at(letterDef.textureID)->getTextureAtlas());
+                        letterSprite->setAtlasIndex(_lettersInfo[letterIndex].atlasIndex);
+                    }
+
+                    auto px = letterInfo.positionX + letterDef.width / 2 + _linesOffsetX[letterInfo.lineIndex];
+                    auto py = letterInfo.positionY - letterDef.height / 2 + _letterOffsetY;
+                    letterSprite->setPosition(px, py);
                 }
                 else
                 {
-                    letterSprite->setTextureRect(uvRect, false, uvRect.size);
-                    letterSprite->setTextureAtlas(_batchNodes.at(letterDef.textureID)->getTextureAtlas());
-                    letterSprite->setAtlasIndex(_lettersInfo[letterIndex].atlasIndex);
+                    letterSprite->setTextureAtlas(nullptr);
                 }
-
-                auto px = letterInfo.positionX + letterDef.width / 2 + _linesOffsetX[letterInfo.lineIndex];
-                auto py = letterInfo.positionY - letterDef.height / 2 + _letterOffsetY;
-                letterSprite->setPosition(px, py);
-
                 this->updateLetterSpriteScale(letterSprite);
                 ++it;
             }
@@ -806,20 +952,20 @@ void Label::updateLabelLetters()
 
 bool Label::alignText()
 {
-    if (_fontAtlas == nullptr || _utf16Text.empty())
+    if (_fontAtlas == nullptr || _utf32Text.empty())
     {
         setContentSize(Size::ZERO);
         return true;
     }
 
     bool ret = true;
-    do
-    {
-        _fontAtlas->prepareLetterDefinitions(_utf16Text);
+    do {
+        _fontAtlas->prepareLetterDefinitions(_utf32Text);
         auto& textures = _fontAtlas->getTextures();
-        if (textures.size() > static_cast<size_t>(_batchNodes.size()))
+        auto size = textures.size();
+        if (size > static_cast<size_t>(_batchNodes.size()))
         {
-            for (auto index = static_cast<size_t>(_batchNodes.size()); index < textures.size(); ++index)
+            for (auto index = static_cast<size_t>(_batchNodes.size()); index < size; ++index)
             {
                 auto batchNode = SpriteBatchNode::createWithTexture(textures.at(index));
                 if (batchNode)
@@ -836,14 +982,14 @@ bool Label::alignText()
         {
             return true;
         }
-        // optimize for one-texture-only sceneario
+        // optimize for one-texture-only scenario
         // if multiple textures, then we should count how many chars
         // are per texture
-        if (_batchNodes.size() == 1)
-            _batchNodes.at(0)->reserveCapacity(_utf16Text.size());
+        if (_batchNodes.size()==1)
+            _batchNodes.at(0)->reserveCapacity(_utf32Text.size());
 
         _reusedLetter->setBatchNode(_batchNodes.at(0));
-
+        
         _lengthOfString = 0;
         _textDesiredHeight = 0.f;
         _linesWidth.clear();
@@ -857,46 +1003,42 @@ bool Label::alignText()
         }
         computeAlignmentOffset();
 
-        if (_overflow == Overflow::SHRINK)
-        {
+        if(_overflow == Overflow::SHRINK){
             float fontSize = this->getRenderingFontSize();
 
-            if (fontSize > 0 && isVerticalClamp())
-            {
-                this->shrinkLabelToContentSize([this]() { return isVerticalClamp(); });
+            if(fontSize > 0 &&  isVerticalClamp()){
+                this->shrinkLabelToContentSize(CC_CALLBACK_0(Label::isVerticalClamp, this));
             }
         }
 
-        if (!updateQuads())
-        {
+        if(!updateQuads()){
             ret = false;
-            if (_overflow == Overflow::SHRINK)
-            {
-                this->shrinkLabelToContentSize([this]() { return isHorizontalClamp(); });
+            if(_overflow == Overflow::SHRINK){
+                this->shrinkLabelToContentSize(CC_CALLBACK_0(Label::isHorizontalClamp, this));
             }
             break;
         }
-
+    
         updateLabelLetters();
-
+        
         updateColor();
-    } while (0);
+    }while (0);
 
     return ret;
 }
 
-bool Label::computeHorizontalKernings(const std::u16string& stringToRender)
+bool Label::computeHorizontalKernings(const std::u32string& stringToRender)
 {
     if (_horizontalKernings)
     {
-        delete[] _horizontalKernings;
+        delete [] _horizontalKernings;
         _horizontalKernings = nullptr;
     }
 
     int letterCount = 0;
-    _horizontalKernings = _fontAtlas->getFont()->getHorizontalKerningForTextUTF16(stringToRender, letterCount);
+    _horizontalKernings = _fontAtlas->getFont()->getHorizontalKerningForTextUTF32(stringToRender, letterCount);
 
-    if (!_horizontalKernings)
+    if(!_horizontalKernings)
         return false;
     else
         return true;
@@ -906,12 +1048,9 @@ bool Label::isHorizontalClamped(float letterPositionX, int lineIndex)
 {
     auto wordWidth = this->_linesWidth[lineIndex];
     bool letterOverClamp = (letterPositionX > _contentSize.width || letterPositionX < 0);
-    if (!_enableWrap)
-    {
+    if (!_enableWrap) {
         return letterOverClamp;
-    }
-    else
-    {
+    }else{
         return (wordWidth > this->_contentSize.width && letterOverClamp);
     }
 }
@@ -923,22 +1062,20 @@ bool Label::updateQuads()
     {
         batchNode->getTextureAtlas()->removeAllQuads();
     }
-
-    bool letterClamp = false;
+    
     for (int ctr = 0; ctr < _lengthOfString; ++ctr)
     {
         if (_lettersInfo[ctr].valid)
         {
-            auto& letterDef = _fontAtlas->_letterDefinitions[_lettersInfo[ctr].utf16Char];
-
+            auto& letterDef = _fontAtlas->_letterDefinitions[_lettersInfo[ctr].utf32Char];
+            
             _reusedRect.size.height = letterDef.height;
-            _reusedRect.size.width = letterDef.width;
-            _reusedRect.origin.x = letterDef.U;
-            _reusedRect.origin.y = letterDef.V;
+            _reusedRect.size.width  = letterDef.width;
+            _reusedRect.origin.x    = letterDef.U;
+            _reusedRect.origin.y    = letterDef.V;
 
             auto py = _lettersInfo[ctr].positionY + _letterOffsetY;
-            if (_labelHeight > 0.f)
-            {
+            if (_labelHeight > 0.f) {
                 if (py > _tailoredTopY)
                 {
                     auto clipTop = py - _tailoredTopY;
@@ -953,32 +1090,25 @@ bool Label::updateQuads()
             }
 
             auto lineIndex = _lettersInfo[ctr].lineIndex;
-            auto px = _lettersInfo[ctr].positionX + letterDef.width / 2 * _bmfontScale + _linesOffsetX[lineIndex];
+            auto px = _lettersInfo[ctr].positionX + letterDef.width/2 * _bmfontScale + _linesOffsetX[lineIndex];
 
-            if (_labelWidth > 0.f)
-            {
-                if (this->isHorizontalClamped(px, lineIndex))
-                {
-                    if (_overflow == Overflow::CLAMP)
-                    {
+            if(_labelWidth > 0.f){
+                if (this->isHorizontalClamped(px, lineIndex)) {
+                    if(_overflow == Overflow::CLAMP){
                         _reusedRect.size.width = 0;
-                    }
-                    else if (_overflow == Overflow::SHRINK)
-                    {
-                        if (_contentSize.width > letterDef.width)
-                        {
-                            letterClamp = true;
+                    }else if(_overflow == Overflow::SHRINK){
+                        if (_contentSize.width > letterDef.width) {
                             ret = false;
                             break;
-                        }
-                        else
-                        {
+                        }else{
                             _reusedRect.size.width = 0;
                         }
+
                     }
                 }
             }
 
+
             if (_reusedRect.size.height > 0.f && _reusedRect.size.width > 0.f)
             {
                 _reusedLetter->setTextureRect(_reusedRect, false, _reusedRect.size);
@@ -991,15 +1121,16 @@ bool Label::updateQuads()
 
                 _batchNodes.at(letterDef.textureID)->insertQuadFromSprite(_reusedLetter, index);
             }
-        }
+        }     
     }
 
+
     return ret;
 }
 
 bool Label::setTTFConfigInternal(const TTFConfig& ttfConfig)
 {
-    FontAtlas* newAtlas = FontAtlasCache::getFontAtlasTTF(&ttfConfig);
+    FontAtlas *newAtlas = FontAtlasCache::getFontAtlasTTF(&ttfConfig);
 
     if (!newAtlas)
     {
@@ -1008,7 +1139,7 @@ bool Label::setTTFConfigInternal(const TTFConfig& ttfConfig)
     }
 
     _currentLabelType = LabelType::TTF;
-    setFontAtlas(newAtlas, ttfConfig.distanceFieldEnabled, true);
+    setFontAtlas(newAtlas,ttfConfig.distanceFieldEnabled,true);
 
     _fontConfig = ttfConfig;
 
@@ -1040,8 +1171,7 @@ bool Label::setTTFConfigInternal(const TTFConfig& ttfConfig)
 
 void Label::setBMFontSizeInternal(float fontSize)
 {
-    if (_currentLabelType == LabelType::BMFONT)
-    {
+    if(_currentLabelType == LabelType::BMFONT){
         this->setBMFontFilePath(_bmFontPath, Vec2::ZERO, fontSize);
         _contentDirty = true;
     }
@@ -1050,28 +1180,21 @@ void Label::setBMFontSizeInternal(float fontSize)
 void Label::scaleFontSizeDown(float fontSize)
 {
     bool shouldUpdateContent = true;
-    if (_currentLabelType == LabelType::TTF)
-    {
+    if(_currentLabelType == LabelType::TTF){
         auto ttfConfig = this->getTTFConfig();
         ttfConfig.fontSize = fontSize;
         this->setTTFConfigInternal(ttfConfig);
-    }
-    else if (_currentLabelType == LabelType::BMFONT)
-    {
-        if (std::abs(fontSize) < FLT_EPSILON)
-        {
+    }else if(_currentLabelType == LabelType::BMFONT){
+        if (std::abs(fontSize) < FLT_EPSILON) {
             fontSize = 0.1f;
             shouldUpdateContent = false;
         }
         this->setBMFontSizeInternal(fontSize);
-    }
-    else if (_currentLabelType == LabelType::STRING_TEXTURE)
-    {
+    }else if (_currentLabelType == LabelType::STRING_TEXTURE){
         this->setSystemFontSize(fontSize);
     }
-
-    if (shouldUpdateContent)
-    {
+    
+    if (shouldUpdateContent) {
         this->updateContent();
     }
 }
@@ -1097,7 +1220,7 @@ void Label::enableGlow(const Color4B& glowColor)
     }
 }
 
-void Label::enableOutline(const Color4B& outlineColor, int outlineSize /* = -1 */)
+void Label::enableOutline(const Color4B& outlineColor,int outlineSize /* = -1 */)
 {
     CCASSERT(_currentLabelType == LabelType::STRING_TEXTURE || _currentLabelType == LabelType::TTF, "Only supported system font and TTF!");
 
@@ -1116,7 +1239,7 @@ void Label::enableOutline(const Color4B& outlineColor, int outlineSize /* = -1 *
                 setTTFConfig(_fontConfig);
             }
         }
-        else if (_effectColorF != outlineColor || std::abs(_outlineSize - outlineSize) >= std::numeric_limits<float>::epsilon())
+        else if (_effectColorF != outlineColor || _outlineSize != outlineSize)
         {
             _effectColorF.r = outlineColor.r / 255.f;
             _effectColorF.g = outlineColor.g / 255.f;
@@ -1129,14 +1252,16 @@ void Label::enableOutline(const Color4B& outlineColor, int outlineSize /* = -1 *
     }
 }
 
-void Label::enableShadow(const Color4B& shadowColor /* = Color4B::BLACK */, const Size& offset /* = Size(2 ,-2)*/, int blurRadius /* = 0 */)
+void Label::enableShadow(const Color4B& shadowColor /* = Color4B::BLACK */,
+                         const Size &offset /* = Size(2 ,-2)*/,
+                         int /* blurRadius = 0 */)
 {
     _shadowEnabled = true;
     _shadowDirty = true;
 
     _shadowOffset.width = offset.width;
     _shadowOffset.height = offset.height;
-    // TODO: support blur for shadow
+    //TODO: support blur for shadow
 
     _shadowColor3B.r = shadowColor.r;
     _shadowColor3B.g = shadowColor.g;
@@ -1172,8 +1297,7 @@ void Label::enableShadow(const Color4B& shadowColor /* = Color4B::BLACK */, cons
 
     if (_currentLabelType == LabelType::BMFONT || _currentLabelType == LabelType::CHARMAP)
     {
-        setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(
-            _shadowEnabled ? GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR : GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP, _getTexture(this)));
+        updateShaderProgram();
     }
 }
 
@@ -1189,7 +1313,7 @@ void Label::enableBold()
         // bold is implemented with outline
         enableShadow(Color4B::WHITE, Size(0.9f, 0), 0);
         // add one to kerning
-        setAdditionalKerning(_additionalKerning + 1);
+        setAdditionalKerning(_additionalKerning+1);
         _boldEnabled = true;
     }
 }
@@ -1256,13 +1380,14 @@ void Label::disableEffect(LabelEffect effect)
             setRotationSkewX(0);
             break;
         case cocos2d::LabelEffect::BOLD:
-            _boldEnabled = false;
-            _additionalKerning -= 1;
-            disableEffect(LabelEffect::SHADOW);
+            if (_boldEnabled) {
+                _boldEnabled = false;
+                _additionalKerning -= 1;
+                disableEffect(LabelEffect::SHADOW);
+            }
             break;
         case cocos2d::LabelEffect::UNDERLINE:
-            if (_underlineNode)
-            {
+            if (_underlineNode) {
                 removeChild(_underlineNode);
                 _underlineNode = nullptr;
             }
@@ -1282,7 +1407,9 @@ void Label::disableEffect(LabelEffect effect)
             disableEffect(LabelEffect::UNDERLINE);
             disableEffect(LabelEffect::STRIKETHROUGH);
         }
-        break;
+            break;
+        default:
+            break;
     }
 }
 
@@ -1294,7 +1421,7 @@ void Label::createSpriteForSystemFont(const FontDefinition& fontDef)
     texture->initWithString(_utf8Text.c_str(), fontDef);
 
     _textSprite = Sprite::createWithTexture(texture);
-    // set camera mask using label's camera mask, because _textSprite may be null when setting camera mask to label
+    //set camera mask using label's camera mask, because _textSprite may be null when setting camera mask to label
     _textSprite->setCameraMask(getCameraMask());
     _textSprite->setGlobalZOrder(getGlobalZOrder());
     _textSprite->setAnchorPoint(Vec2::ANCHOR_BOTTOM_LEFT);
@@ -1312,7 +1439,8 @@ void Label::createSpriteForSystemFont(const FontDefinition& fontDef)
 
 void Label::createShadowSpriteForSystemFont(const FontDefinition& fontDef)
 {
-    if (!fontDef._stroke._strokeEnabled && fontDef._fontFillColor == _shadowColor3B && (fontDef._fontAlpha == _shadowOpacity))
+    if (!fontDef._stroke._strokeEnabled && fontDef._fontFillColor == _shadowColor3B
+        && (fontDef._fontAlpha == _shadowOpacity))
     {
         _shadowNode = Sprite::createWithTexture(_textSprite->getTexture());
     }
@@ -1353,7 +1481,7 @@ void Label::createShadowSpriteForSystemFont(const FontDefinition& fontDef)
 void Label::setCameraMask(unsigned short mask, bool applyChildren)
 {
     Node::setCameraMask(mask, applyChildren);
-
+    
     if (_textSprite)
     {
         _textSprite->setCameraMask(mask, applyChildren);
@@ -1364,38 +1492,6 @@ void Label::setCameraMask(unsigned short mask, bool applyChildren)
     }
 }
 
-void Label::setFontDefinition(const FontDefinition& textDefinition)
-{
-    _systemFont = textDefinition._fontName;
-    _systemFontSize = textDefinition._fontSize;
-    _hAlignment = textDefinition._alignment;
-    _vAlignment = textDefinition._vertAlignment;
-    setDimensions(textDefinition._dimensions.width, textDefinition._dimensions.height);
-    Color4B textColor = Color4B(textDefinition._fontFillColor);
-    textColor.a = textDefinition._fontAlpha;
-    setTextColor(textColor);
-
-#if (CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID) && (CC_TARGET_PLATFORM != CC_PLATFORM_IOS)
-    if (textDefinition._stroke._strokeEnabled)
-    {
-        CCLOGERROR("Stroke Currently only supported on iOS and Android!");
-    }
-    _outlineSize = 0.f;
-#else
-    if (textDefinition._stroke._strokeEnabled && textDefinition._stroke._strokeSize > 0.f)
-    {
-        Color4B outlineColor = Color4B(textDefinition._stroke._strokeColor);
-        outlineColor.a = textDefinition._stroke._strokeAlpha;
-        enableOutline(outlineColor, textDefinition._stroke._strokeSize);
-    }
-#endif
-
-    if (textDefinition._shadow._shadowEnabled)
-    {
-        enableShadow(Color4B(0, 0, 0, 255 * textDefinition._shadow._shadowOpacity), textDefinition._shadow._shadowOffset, textDefinition._shadow._shadowBlur);
-    }
-}
-
 void Label::updateContent()
 {
     if (_systemFontDirty)
@@ -1403,7 +1499,8 @@ void Label::updateContent()
         if (_fontAtlas)
         {
             _batchNodes.clear();
-
+            _batchCommands.clear();
+            CC_SAFE_RELEASE_NULL(_reusedLetter);
             FontAtlasCache::releaseFontAtlas(_fontAtlas);
             _fontAtlas = nullptr;
         }
@@ -1417,13 +1514,13 @@ void Label::updateContent()
 
     if (_fontAtlas)
     {
-        std::u16string utf16String;
-        if (StringUtils::UTF8ToUTF16(_utf8Text, utf16String))
+        std::u32string utf32String;
+        if (StringUtils::UTF8ToUTF32(_utf8Text, utf32String))
         {
-            _utf16Text = utf16String;
+            _utf32Text = utf32String;
         }
 
-        computeHorizontalKernings(_utf16Text);
+        computeHorizontalKernings(_utf32Text);
         updateFinished = alignText();
     }
     else
@@ -1444,10 +1541,10 @@ void Label::updateContent()
         {
             // This is the logic for TTF fonts
             const float charheight = (_textDesiredHeight / _numberOfLines);
-            _underlineNode->setLineWidth(charheight / 6);
+            _underlineNode->setLineWidth(charheight/6);
 
             // atlas font
-            for (int i = 0; i < _numberOfLines; ++i)
+            for (int i=0; i<_numberOfLines; ++i)
             {
                 float offsety = 0;
                 if (_strikethroughEnabled)
@@ -1457,7 +1554,7 @@ void Label::updateContent()
 
                 // Github issue #15214. Uses _displayedColor instead of _textColor for the underline.
                 // This is to have the same behavior of SystemFonts.
-                _underlineNode->drawLine(Vec2(_linesOffsetX[i], y), Vec2(_linesWidth[i] + _linesOffsetX[i], y), Color4F(_displayedColor));
+                _underlineNode->drawLine(Vec2(_linesOffsetX[i],y), Vec2(_linesWidth[i] + _linesOffsetX[i],y), Color4F(_displayedColor));
             }
         }
         else if (_textSprite)
@@ -1465,24 +1562,29 @@ void Label::updateContent()
             // ...and is the logic for System fonts
             float y = 0;
             const auto spriteSize = _textSprite->getContentSize();
-            _underlineNode->setLineWidth(spriteSize.height / 6);
+            _underlineNode->setLineWidth(spriteSize.height/6);
 
             if (_strikethroughEnabled)
                 // FIXME: system fonts don't report the height of the font correctly. only the size of the texture, which is POT
                 y += spriteSize.height / 2;
             // FIXME: Might not work with different vertical alignments
-            _underlineNode->drawLine(Vec2(0, y), Vec2(spriteSize.width, y), Color4F(_textSprite->getDisplayedColor()));
+            _underlineNode->drawLine(Vec2(0.0f,y), Vec2(spriteSize.width,y), Color4F(_textSprite->getDisplayedColor()));
         }
     }
 
-    if (updateFinished)
-    {
+    if(updateFinished){
         _contentDirty = false;
     }
 
 #if CC_LABEL_DEBUG_DRAW
     _debugDrawNode->clear();
-    Vec2 vertices[4] = {Vec2::ZERO, Vec2(_contentSize.width, 0), Vec2(_contentSize.width, _contentSize.height), Vec2(0, _contentSize.height)};
+    Vec2 vertices[4] =
+    {
+        Vec2::ZERO,
+        Vec2(_contentSize.width, 0.0f),
+        Vec2(_contentSize.width, _contentSize.height),
+        Vec2(0.0f, _contentSize.height)
+    };
     _debugDrawNode->drawPoly(vertices, 4, true, Color4F::WHITE);
 #endif
 }
@@ -1493,112 +1595,129 @@ void Label::setBMFontSize(float fontSize)
     _originalFontSize = fontSize;
 }
 
-float Label::getBMFontSize() const
+float Label::getBMFontSize()const
 {
     return _bmFontSize;
 }
 
-void Label::onDrawShadow(GLProgram* glProgram, const Color4F& shadowColor)
+void Label::updateBuffer(TextureAtlas* textureAtlas, CustomCommand& customCommand)
 {
-    if (_currentLabelType == LabelType::TTF)
-    {
-        glProgram->setUniformLocationWith4f(_uniformTextColor, shadowColor.r, shadowColor.g, shadowColor.b, shadowColor.a);
-        if (_currLabelEffect == LabelEffect::OUTLINE || _currLabelEffect == LabelEffect::GLOW)
-        {
-            glProgram->setUniformLocationWith4f(_uniformEffectColor, shadowColor.r, shadowColor.g, shadowColor.b, shadowColor.a);
-        }
-
-        glProgram->setUniformsForBuiltins(_shadowTransform);
-        for (auto&& it : _letters)
-        {
-            it.second->updateTransform();
-        }
-        for (auto&& batchNode : _batchNodes)
-        {
-            batchNode->getTextureAtlas()->drawQuads();
-        }
-    }
-    else
+    if (textureAtlas->getTotalQuads() > customCommand.getVertexCapacity())
     {
-        Color3B oldColor = _realColor;
-        GLubyte oldOPacity = _displayedOpacity;
-        _displayedOpacity = shadowColor.a * 255;
-        setColor(Color3B(shadowColor));
-
-        glProgram->setUniformsForBuiltins(_shadowTransform);
-        for (auto&& it : _letters)
-        {
-            it.second->updateTransform();
-        }
-        for (auto&& batchNode : _batchNodes)
-        {
-            batchNode->getTextureAtlas()->drawQuads();
-        }
-
-        _displayedOpacity = oldOPacity;
-        setColor(oldColor);
+        customCommand.createVertexBuffer((unsigned int)sizeof(V3F_C4B_T2F_Quad), (unsigned int)textureAtlas->getTotalQuads(), CustomCommand::BufferUsage::DYNAMIC);
+        customCommand.createIndexBuffer(CustomCommand::IndexFormat::U_SHORT, (unsigned int)textureAtlas->getTotalQuads() * 6, CustomCommand::BufferUsage::DYNAMIC);
     }
+    customCommand.updateVertexBuffer(textureAtlas->getQuads(), (unsigned int)(textureAtlas->getTotalQuads() * sizeof(V3F_C4B_T2F_Quad)));
+    customCommand.updateIndexBuffer(textureAtlas->getIndices(), (unsigned int)(textureAtlas->getTotalQuads() * 6 * sizeof(unsigned short)));
+    customCommand.setIndexDrawInfo(0, (unsigned int)(textureAtlas->getTotalQuads() * 6));
 }
 
-void Label::onDraw(const Mat4& transform, bool transformUpdated)
+void Label::updateEffectUniforms(BatchCommand &batch, TextureAtlas* textureAtlas, Renderer *renderer, const Mat4 &transform)
 {
-    auto glprogram = getGLProgram();
-    glprogram->use();
-    GL::blendFunc(_blendFunc.src, _blendFunc.dst);
+    updateBuffer(textureAtlas, batch.textCommand);
 
-    if (_shadowEnabled)
-    {
-        if (_boldEnabled)
-            onDrawShadow(glprogram, _textColorF);
-        else
-            onDrawShadow(glprogram, _shadowColor4F);
-    }
+    auto & matrixProjection = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
 
-    glprogram->setUniformsForBuiltins(transform);
-    for (auto&& it : _letters)
-    {
-        it.second->updateTransform();
+    if (_shadowEnabled) {
+        updateBuffer(textureAtlas, batch.shadowCommand);
+        auto shadowMatrix = matrixProjection * _shadowTransform;
+        batch.shadowCommand.getPipelineDescriptor().programState->setUniform(_mvpMatrixLocation, shadowMatrix.m, sizeof(shadowMatrix.m));
     }
 
-    if (_currentLabelType == LabelType::TTF)
+    if(_currentLabelType == LabelType::TTF)
     {
-        switch (_currLabelEffect)
-        {
+        switch (_currLabelEffect) {
             case LabelEffect::OUTLINE:
-                // draw text with outline
-                glprogram->setUniformLocationWith4f(_uniformTextColor, _textColorF.r, _textColorF.g, _textColorF.b, _textColorF.a);
-                glprogram->setUniformLocationWith4f(_uniformEffectColor, _effectColorF.r, _effectColorF.g, _effectColorF.b, _effectColorF.a);
-                for (auto&& batchNode : _batchNodes)
+            {
+                int effectType = 0;
+                Vec4 effectColor(_effectColorF.r, _effectColorF.g, _effectColorF.b, _effectColorF.a);
+                
+                //draw shadow
+                if(_shadowEnabled)
+                {
+                    effectType = 2;
+                    Vec4 shadowColor = Vec4(_shadowColor4F.r, _shadowColor4F.g, _shadowColor4F.b, _shadowColor4F.a);
+                    auto *programStateShadow = batch.shadowCommand.getPipelineDescriptor().programState;
+                    programStateShadow->setUniform(_effectColorLocation, &shadowColor, sizeof(Vec4));
+                    programStateShadow->setUniform(_effectTypeLocation, &effectType, sizeof(effectType));
+                    batch.shadowCommand.init(_globalZOrder);
+                    renderer->addCommand(&batch.shadowCommand);
+                }
+                
+                //draw outline
                 {
-                    batchNode->getTextureAtlas()->drawQuads();
+                    effectType = 1;
+                    updateBuffer(textureAtlas, batch.outLineCommand);
+                    auto *programStateOutline = batch.outLineCommand.getPipelineDescriptor().programState;
+                    programStateOutline->setUniform(_effectColorLocation, &effectColor, sizeof(Vec4));
+                    programStateOutline->setUniform(_effectTypeLocation, &effectType, sizeof(effectType));
+                    batch.outLineCommand.init(_globalZOrder);
+                    renderer->addCommand(&batch.outLineCommand);
                 }
+              
+                //draw text
+                {
+                    effectType = 0;
+                    auto *programStateText= batch.textCommand.getPipelineDescriptor().programState;
 
-                // draw text without outline
-                glprogram->setUniformLocationWith4f(_uniformEffectColor, _effectColorF.r, _effectColorF.g, _effectColorF.b, 0.f);
+                    programStateText->setUniform(_effectColorLocation, &effectColor, sizeof(effectColor));
+                    programStateText->setUniform(_effectTypeLocation, &effectType, sizeof(effectType));
+                }
+            }
                 break;
-            case LabelEffect::GLOW:
-                glprogram->setUniformLocationWith4f(_uniformEffectColor, _effectColorF.r, _effectColorF.g, _effectColorF.b, _effectColorF.a);
-                [[clang::fallthrough]];
             case LabelEffect::NORMAL:
-                glprogram->setUniformLocationWith4f(_uniformTextColor, _textColorF.r, _textColorF.g, _textColorF.b, _textColorF.a);
+            {
+                if (_shadowEnabled) {
+                    Vec4 shadowColor = Vec4(_shadowColor4F.r, _shadowColor4F.g, _shadowColor4F.b, _shadowColor4F.a);
+                    auto *programStateShadow = batch.shadowCommand.getPipelineDescriptor().programState;
+                    programStateShadow->setUniform(_textColorLocation, &shadowColor, sizeof(Vec4));
+                    batch.shadowCommand.init(_globalZOrder);
+                    renderer->addCommand(&batch.shadowCommand);
+                }
+            }
+                break;
+            case LabelEffect::GLOW:
+            {
+                //draw shadow
+                if(_shadowEnabled)
+                {
+                    Vec4 shadowColor = Vec4(_shadowColor4F.r, _shadowColor4F.g, _shadowColor4F.b, _shadowColor4F.a);
+                    auto *programStateShadow = batch.shadowCommand.getPipelineDescriptor().programState;
+                    programStateShadow->setUniform(_textColorLocation, &shadowColor, sizeof(Vec4));
+                    programStateShadow->setUniform(_effectColorLocation, &shadowColor, sizeof(Vec4));
+                    batch.shadowCommand.init(_globalZOrder);
+                    renderer->addCommand(&batch.shadowCommand);
+                }
+                
+                Vec4 effectColor(_effectColorF.r, _effectColorF.g, _effectColorF.b, _effectColorF.a);
+                batch.textCommand.getPipelineDescriptor().programState->setUniform(_effectColorLocation, &effectColor, sizeof(Vec4));
+            }
                 break;
-            case LabelEffect::SHADOW:
-            case LabelEffect::ITALICS:
-            case LabelEffect::BOLD:
-            case LabelEffect::UNDERLINE:
-            case LabelEffect::STRIKETHROUGH:
-            case LabelEffect::ALL:
+            default:
                 break;
         }
     }
-
-    for (auto&& batchNode : _batchNodes)
+    else
     {
-        batchNode->getTextureAtlas()->drawQuads();
+        if (_shadowEnabled) {
+            Color3B oldColor = _realColor;
+            uint8_t oldOPacity = _displayedOpacity;
+            _displayedOpacity = _shadowColor4F.a * (oldOPacity / 255.0f) * 255;
+            setColor(Color3B(_shadowColor4F));
+            batch.shadowCommand.updateVertexBuffer(textureAtlas->getQuads(), (unsigned int)(textureAtlas->getTotalQuads() * sizeof(V3F_C4B_T2F_Quad)) );
+            batch.shadowCommand.init(_globalZOrder);
+            renderer->addCommand(&batch.shadowCommand);
+            
+            _displayedOpacity = oldOPacity;
+            setColor(oldColor);
+        }
     }
+
+    batch.textCommand.init(_globalZOrder);
+    renderer->addCommand(&batch.textCommand);
 }
 
-void Label::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void Label::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
     if (_batchNodes.empty() || _lengthOfString <= 0)
     {
@@ -1609,8 +1728,7 @@ void Label::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
 #if CC_USE_CULLING
     auto visitingCamera = Camera::getVisitingCamera();
     auto defaultCamera = Camera::getDefaultCamera();
-    if (visitingCamera == defaultCamera)
-    {
+    if (visitingCamera == defaultCamera) {
         _insideBounds = (transformUpdated || visitingCamera->isViewProjectionUpdated()) ? renderer->checkVisibility(transform, _contentSize) : _insideBounds;
     }
     else
@@ -1621,40 +1739,102 @@ void Label::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
     if (_insideBounds)
 #endif
     {
+        cocos2d::Mat4 matrixProjection = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
         if (!_shadowEnabled && (_currentLabelType == LabelType::BMFONT || _currentLabelType == LabelType::CHARMAP))
         {
+            updateBlendState();
             for (auto&& it : _letters)
             {
                 it.second->updateTransform();
             }
             // ETC1 ALPHA supports for BMFONT & CHARMAP
             auto textureAtlas = _batchNodes.at(0)->getTextureAtlas();
+            if(!textureAtlas->getTotalQuads())
+                return;
+            
             auto texture = textureAtlas->getTexture();
-            _quadCommand.init(_globalZOrder, texture, getGLProgramState(), _blendFunc, textureAtlas->getQuads(), textureAtlas->getTotalQuads(), transform, flags);
+            auto& pipelineQuad = _quadCommand.getPipelineDescriptor();
+            pipelineQuad.programState->setUniform(_mvpMatrixLocation, matrixProjection.m, sizeof(matrixProjection.m));
+            pipelineQuad.programState->setTexture(_textureLocation, 0, texture->getBackendTexture());
+            auto alphaTexture = textureAtlas->getTexture()->getAlphaTexture();
+            if(alphaTexture && alphaTexture->getBackendTexture())
+            {
+                pipelineQuad.programState->setTexture(_alphaTextureLocation, 1, alphaTexture->getBackendTexture());
+            }
+            _quadCommand.init(_globalZOrder, texture, _blendFunc, textureAtlas->getQuads(), textureAtlas->getTotalQuads(), transform, flags);
             renderer->addCommand(&_quadCommand);
         }
         else
         {
-            _customCommand.init(_globalZOrder, transform, flags);
-            _customCommand.setFunc([this, transform, transformUpdated]() { onDraw(transform, transformUpdated); });
+            cocos2d::Mat4 matrixMVP = matrixProjection * transform;
+
+            for (auto &&it : _letters)
+            {
+                it.second->updateTransform();
+            }
+            int i = 0;
+
+            if (_batchCommands.size() != _batchNodes.size())
+            {
+                _batchCommands.resize(_batchNodes.size());
+                updateShaderProgram();
+            }
+
+            updateBlendState();
 
-            renderer->addCommand(&_customCommand);
+            for (auto&& batchNode : _batchNodes)
+            {
+                auto textureAtlas = batchNode->getTextureAtlas();
+                if (!textureAtlas->getTotalQuads())
+                    return;
+
+                auto &batch = _batchCommands[i++];
+                auto &&commands = batch.getCommandArray();
+                for (auto command : commands)
+                {
+                    auto *programState = command->getPipelineDescriptor().programState;
+                    Vec4 textColor(_textColorF.r, _textColorF.g, _textColorF.b, _textColorF.a);
+                    programState->setUniform(_textColorLocation, &textColor, sizeof(Vec4));
+                    programState->setTexture(_textureLocation, 0, textureAtlas->getTexture()->getBackendTexture());
+                    auto alphaTexture = textureAtlas->getTexture()->getAlphaTexture();
+                    if (alphaTexture && alphaTexture->getBackendTexture())
+                    {
+                        programState->setTexture(_alphaTextureLocation, 1, alphaTexture->getBackendTexture());
+                    }
+                }
+                batch.textCommand.getPipelineDescriptor().programState->setUniform(_mvpMatrixLocation, matrixMVP.m, sizeof(matrixMVP.m));
+                batch.outLineCommand.getPipelineDescriptor().programState->setUniform(_mvpMatrixLocation, matrixMVP.m, sizeof(matrixMVP.m));
+                updateEffectUniforms(batch, textureAtlas, renderer, transform);
+            }
         }
     }
 }
 
-void Label::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void Label::updateBlendState()
 {
-    if (!_visible || (_utf8Text.empty() && _children.empty()))
+    setOpacityModifyRGB(_blendFunc != BlendFunc::ALPHA_NON_PREMULTIPLIED);
+    for(auto &batch: _batchCommands)
     {
-        return;
+        for(auto *command : batch.getCommandArray()) {
+            auto & blendDescriptor = command->getPipelineDescriptor().blendDescriptor;
+            updateBlend(blendDescriptor, _blendFunc);
+        }
     }
+    updateBlend(_quadCommand.getPipelineDescriptor().blendDescriptor, _blendFunc);
+}
 
+void Label::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
+{
+    if (! _visible || (_utf8Text.empty() && _children.empty()) )
+    {
+        return;
+    }
+    
     if (_systemFontDirty || _contentDirty)
     {
         updateContent();
     }
-
+    
     uint32_t flags = processParentFlags(parentTransform, parentFlags);
 
     if (!_utf8Text.empty() && _shadowEnabled && (_shadowDirty || (flags & FLAGS_DIRTY_MASK)))
@@ -1683,14 +1863,14 @@ void Label::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t pare
     // but it is deprecated and your code should not rely on it
     _director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
     _director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform);
-
+    
     if (!_children.empty())
     {
         sortAllChildren();
 
         int i = 0;
         // draw children zOrder < 0
-        for (; i < _children.size(); i++)
+        for (auto size = _children.size(); i < size; ++i)
         {
             auto node = _children.at(i);
 
@@ -1699,13 +1879,14 @@ void Label::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t pare
             else
                 break;
         }
-
+        
         this->drawSelf(visibleByCamera, renderer, flags);
 
-        for (auto it = _children.cbegin() + i; it != _children.cend(); ++it)
+        for (auto it = _children.cbegin() + i, itCend = _children.cend(); it != itCend; ++it)
         {
             (*it)->visit(renderer, _modelViewTransform, flags);
         }
+            
     }
     else
     {
@@ -1743,7 +1924,7 @@ void Label::setSystemFontName(const std::string& systemFont)
 
 void Label::setSystemFontSize(float fontSize)
 {
-    if (std::abs(_systemFontSize - fontSize) >= std::numeric_limits<float>::epsilon())
+    if (_systemFontSize != fontSize)
     {
         _systemFontSize = fontSize;
         _originalFontSize = fontSize;
@@ -1771,8 +1952,8 @@ Sprite* Label::getLetter(int letterIndex)
 
         if (_textSprite == nullptr && letterIndex < _lengthOfString)
         {
-            const auto& letterInfo = _lettersInfo[letterIndex];
-            if (!letterInfo.valid)
+            const auto &letterInfo = _lettersInfo[letterIndex];
+            if (!letterInfo.valid || letterInfo.atlasIndex<0)
             {
                 break;
             }
@@ -1784,7 +1965,7 @@ Sprite* Label::getLetter(int letterIndex)
 
             if (letter == nullptr)
             {
-                auto& letterDef = _fontAtlas->_letterDefinitions[letterInfo.utf16Char];
+                auto& letterDef = _fontAtlas->_letterDefinitions[letterInfo.utf32Char];
                 auto textureID = letterDef.textureID;
                 Rect uvRect;
                 uvRect.size.height = letterDef.height;
@@ -1798,15 +1979,17 @@ Sprite* Label::getLetter(int letterIndex)
                 }
                 else
                 {
+                    this->updateBMFontScale();
                     letter = LabelLetter::createWithTexture(_fontAtlas->getTexture(textureID), uvRect);
                     letter->setTextureAtlas(_batchNodes.at(textureID)->getTextureAtlas());
                     letter->setAtlasIndex(letterInfo.atlasIndex);
-                    auto px = letterInfo.positionX + uvRect.size.width / 2 + _linesOffsetX[letterInfo.lineIndex];
-                    auto py = letterInfo.positionY - uvRect.size.height / 2 + _letterOffsetY;
-                    letter->setPosition(px, py);
+                    auto px = letterInfo.positionX + _bmfontScale * uvRect.size.width / 2 + _linesOffsetX[letterInfo.lineIndex];
+                    auto py = letterInfo.positionY - _bmfontScale * uvRect.size.height / 2 + _letterOffsetY;
+                    letter->setPosition(px,py);
                     letter->setOpacity(_realOpacity);
+                    this->updateLetterSpriteScale(letter);
                 }
-
+                
                 addChild(letter);
                 _letters[letterIndex] = letter;
             }
@@ -1820,7 +2003,7 @@ void Label::setLineHeight(float height)
 {
     CCASSERT(_currentLabelType != LabelType::STRING_TEXTURE, "Not supported system font!");
 
-    if (std::abs(_lineHeight - height) >= std::numeric_limits<float>::epsilon())
+    if (_lineHeight != height)
     {
         _lineHeight = height;
         _contentDirty = true;
@@ -1835,7 +2018,7 @@ float Label::getLineHeight() const
 
 void Label::setLineSpacing(float height)
 {
-    if (std::abs(_lineSpacing - height) >= std::numeric_limits<float>::epsilon())
+    if (_lineSpacing != height)
     {
         _lineSpacing = height;
         _contentDirty = true;
@@ -1849,9 +2032,10 @@ float Label::getLineSpacing() const
 
 void Label::setAdditionalKerning(float space)
 {
+
     if (_currentLabelType != LabelType::STRING_TEXTURE)
     {
-        if (std::abs(_additionalKerning - space) >= std::numeric_limits<float>::epsilon())
+        if (_additionalKerning != space)
         {
             _additionalKerning = space;
             _contentDirty = true;
@@ -1872,17 +2056,17 @@ void Label::computeStringNumLines()
 {
     int quantityOfLines = 1;
 
-    if (_utf16Text.empty())
+    if (_utf32Text.empty())
     {
         _numberOfLines = 0;
         return;
     }
 
     // count number of lines
-    size_t stringLen = _utf16Text.length();
+    size_t stringLen = _utf32Text.length();
     for (size_t i = 0; i < stringLen - 1; ++i)
     {
-        if (_utf16Text[i] == static_cast<char16_t>(TextFormatter::NewLine))
+        if (_utf32Text[i] == StringUtils::UnicodeCharacters::NewLine)
         {
             quantityOfLines++;
         }
@@ -1908,7 +2092,7 @@ int Label::getStringNumLines()
 
 int Label::getStringLength()
 {
-    _lengthOfString = static_cast<int>(_utf16Text.length());
+    _lengthOfString = static_cast<int>(_utf32Text.length());
     return _lengthOfString;
 }
 
@@ -1952,7 +2136,7 @@ void Label::updateDisplayedColor(const Color3B& parentColor)
     }
 }
 
-void Label::updateDisplayedOpacity(GLubyte parentOpacity)
+void Label::updateDisplayedOpacity(uint8_t parentOpacity)
 {
     Node::updateDisplayedOpacity(parentOpacity);
 
@@ -1974,7 +2158,7 @@ void Label::updateDisplayedOpacity(GLubyte parentOpacity)
 // FIXME: it is not clear what is the difference between setTextColor() and setColor()
 // if setTextColor() only changes the text and nothing but the text (no glow, no outline, not underline)
 // that's fine but it should be documented
-void Label::setTextColor(const Color4B& color)
+void Label::setTextColor(const Color4B &color)
 {
     CCASSERT(_currentLabelType == LabelType::TTF || _currentLabelType == LabelType::STRING_TEXTURE, "Only supported system font and ttf!");
 
@@ -1997,19 +2181,19 @@ void Label::updateColor()
         return;
     }
 
-    Color4B color4(_displayedColor.r, _displayedColor.g, _displayedColor.b, _displayedOpacity);
+    Color4B color4( _displayedColor.r, _displayedColor.g, _displayedColor.b, _displayedOpacity );
 
     // special opacity for premultiplied textures
     if (_isOpacityModifyRGB)
     {
-        color4.r *= _displayedOpacity / 255.0f;
-        color4.g *= _displayedOpacity / 255.0f;
-        color4.b *= _displayedOpacity / 255.0f;
+        color4.r *= _displayedOpacity/255.0f;
+        color4.g *= _displayedOpacity/255.0f;
+        color4.b *= _displayedOpacity/255.0f;
     }
 
     cocos2d::TextureAtlas* textureAtlas;
-    V3F_C4B_T2F_Quad* quads;
-    for (auto&& batchNode : _batchNodes)
+    V3F_C4B_T2F_Quad *quads;
+    for (auto&& batchNode:_batchNodes)
     {
         textureAtlas = batchNode->getTextureAtlas();
         quads = textureAtlas->getQuads();
@@ -2052,7 +2236,7 @@ Rect Label::getBoundingBox() const
     return Node::getBoundingBox();
 }
 
-void Label::setBlendFunc(const BlendFunc& blendFunc)
+void Label::setBlendFunc(const BlendFunc &blendFunc)
 {
     _blendFunc = blendFunc;
     _blendFuncDirty = true;
@@ -2088,7 +2272,11 @@ void Label::removeChild(Node* child, bool cleanup /* = true */)
 FontDefinition Label::_getFontDefinition() const
 {
     FontDefinition systemFontDef;
-    systemFontDef._fontName = _systemFont;
+
+    std::string fontName = _systemFont;
+    if (_fontAtlas && !_fontAtlas->getFontName().empty()) fontName = _fontAtlas->getFontName();
+
+    systemFontDef._fontName = fontName;
     systemFontDef._fontSize = _systemFontSize;
     systemFontDef._alignment = _hAlignment;
     systemFontDef._vertAlignment = _vAlignment;
@@ -2100,7 +2288,7 @@ FontDefinition Label::_getFontDefinition() const
     systemFontDef._fontAlpha = _textColor.a;
     systemFontDef._shadow._shadowEnabled = false;
     systemFontDef._enableWrap = _enableWrap;
-    systemFontDef._overflow = static_cast<int>(_overflow);
+    systemFontDef._overflow = (int)_overflow;
 
     if (_currLabelEffect == LabelEffect::OUTLINE && _outlineSize > 0.f)
     {
@@ -2140,23 +2328,16 @@ void Label::setGlobalZOrder(float globalZOrder)
     }
 }
 
-float Label::getRenderingFontSize() const
+float Label::getRenderingFontSize()const
 {
     float fontSize;
-    if (_currentLabelType == LabelType::BMFONT)
-    {
+    if (_currentLabelType == LabelType::BMFONT) {
         fontSize = _bmFontSize;
-    }
-    else if (_currentLabelType == LabelType::TTF)
-    {
+    }else if(_currentLabelType == LabelType::TTF){
         fontSize = this->getTTFConfig().fontSize;
-    }
-    else if (_currentLabelType == LabelType::STRING_TEXTURE)
-    {
+    }else if(_currentLabelType == LabelType::STRING_TEXTURE){
         fontSize = _systemFontSize;
-    }
-    else
-    { // FIXME: find a way to calculate char map font size
+    }else{ //FIXME: find a way to calculate char map font size
         fontSize = this->getLineHeight();
     }
     return fontSize;
@@ -2164,60 +2345,54 @@ float Label::getRenderingFontSize() const
 
 void Label::enableWrap(bool enable)
 {
-    if (enable == _enableWrap || _overflow == Overflow::RESIZE_HEIGHT)
-    {
+    if(enable == _enableWrap || _overflow == Overflow::RESIZE_HEIGHT){
         return;
     }
 
     this->_enableWrap = enable;
-
+   
     this->rescaleWithOriginalFontSize();
-
+    
     _contentDirty = true;
 }
 
-bool Label::isWrapEnabled() const
+bool Label::isWrapEnabled()const
 {
     return this->_enableWrap;
 }
 
 void Label::setOverflow(Overflow overflow)
 {
-    if (_overflow == overflow)
-    {
+    if(_overflow == overflow){
         return;
     }
-
-    if (_currentLabelType == LabelType::CHARMAP)
-    {
-        if (overflow == Overflow::SHRINK)
-        {
+    
+    if (_currentLabelType == LabelType::CHARMAP) {
+        if (overflow == Overflow::SHRINK) {
             return;
         }
     }
 
-    if (overflow == Overflow::RESIZE_HEIGHT)
-    {
-        this->setDimensions(_labelDimensions.width, 0);
+    if(overflow == Overflow::RESIZE_HEIGHT){
+        this->setDimensions(_labelDimensions.width,0);
         this->enableWrap(true);
     }
     _overflow = overflow;
-
+    
     this->rescaleWithOriginalFontSize();
-
+    
     _contentDirty = true;
 }
 
 void Label::rescaleWithOriginalFontSize()
 {
     auto renderingFontSize = this->getRenderingFontSize();
-    if (_originalFontSize - renderingFontSize >= 1)
-    {
+    if (_originalFontSize - renderingFontSize >= 1) {
         this->scaleFontSizeDown(_originalFontSize);
     }
 }
 
-Label::Overflow Label::getOverflow() const
+Label::Overflow Label::getOverflow()const
 {
     return _overflow;
 }
diff --git a/cocos2d/cocos/2d/CCLabel.h b/cocos2d/cocos/2d/CCLabel.h
index b3191d06c9..463bb49dca 100644
--- a/cocos2d/cocos/2d/CCLabel.h
+++ b/cocos2d/cocos/2d/CCLabel.h
@@ -1,6 +1,7 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
  http://www.cocos2d-x.org
 
@@ -23,14 +24,14 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_LABEL_H
-#define CC_2D_LABEL_H
+#ifndef _COCOS2D_CCLABEL_H_
+#define _COCOS2D_CCLABEL_H_
 
-#include <cocos/2d/CCFontAtlas.h>
 #include <cocos/2d/CCNode.h>
-#include <cocos/base/ccTypes.h>
 #include <cocos/renderer/CCCustomCommand.h>
 #include <cocos/renderer/CCQuadCommand.h>
+#include <cocos/2d/CCFontAtlas.h>
+#include <cocos/base/ccTypes.h>
 
 NS_CC_BEGIN
 
@@ -39,6 +40,8 @@ NS_CC_BEGIN
  * @{
  */
 
+#define CC_DEFAULT_FONT_LABEL_SIZE  12
+
 /**
  * @struct TTFConfig
  * @see `GlyphCollection`
@@ -49,7 +52,7 @@ typedef struct _ttfConfig
     float fontSize;
 
     GlyphCollection glyphs;
-    const char* customGlyphs;
+    const char *customGlyphs;
 
     bool distanceFieldEnabled;
     int outlineSize;
@@ -59,38 +62,32 @@ typedef struct _ttfConfig
     bool underline;
     bool strikethrough;
 
-    _ttfConfig(const std::string& filePath = "", float size = 12, const GlyphCollection& glyphCollection = GlyphCollection::DYNAMIC,
-               const char* customGlyphCollection = nullptr, bool useDistanceField = false, int outline = 0, bool useItalics = false, bool useBold = false,
-               bool useUnderline = false, bool useStrikethrough = false)
-    : fontFilePath(filePath)
-    , fontSize(size)
-    , glyphs(glyphCollection)
-    , customGlyphs(customGlyphCollection)
-    , distanceFieldEnabled(useDistanceField)
-    , outlineSize(outline)
-    , italics(useItalics)
-    , bold(useBold)
-    , underline(useUnderline)
-    , strikethrough(useStrikethrough)
+    _ttfConfig(const std::string& filePath = "",float size = CC_DEFAULT_FONT_LABEL_SIZE, const GlyphCollection& glyphCollection = GlyphCollection::DYNAMIC,
+        const char *customGlyphCollection = nullptr, bool useDistanceField = false, int outline = 0,
+               bool useItalics = false, bool useBold = false, bool useUnderline = false, bool useStrikethrough = false)
+        : fontFilePath(filePath)
+        , fontSize(size)
+        , glyphs(glyphCollection)
+        , customGlyphs(customGlyphCollection)
+        , distanceFieldEnabled(useDistanceField)
+        , outlineSize(outline)
+        , italics(useItalics)
+        , bold(useBold)
+        , underline(useUnderline)
+        , strikethrough(useStrikethrough)
     {
-        if (outline > 0)
+        if(outline > 0)
         {
             distanceFieldEnabled = false;
         }
     }
 } TTFConfig;
 
-enum class TextFormatter : char
-{
-    NewLine = '\n',
-    CarriageReturn = '\r',
-    NextCharNoChangeX = '\b'
-};
-
 class Sprite;
 class SpriteBatchNode;
 class DrawNode;
 class EventListenerCustom;
+class TextureAtlas;
 
 /**
  * @brief Label is a subclass of Node that knows how to render text labels.
@@ -113,7 +110,7 @@ class CC_DLL Label : public Node, public LabelProtocol, public BlendProtocol
 public:
     enum class Overflow
     {
-        // In NONE mode, the dimensions is (0,0) and the content size will change dynamically to fit the label.
+        //In NONE mode, the dimensions is (0,0) and the content size will change dynamically to fit the label.
         NONE,
         /**
          *In CLAMP mode, when label content goes out of the bounding box, it will be clipped.
@@ -128,14 +125,22 @@ public:
          */
         RESIZE_HEIGHT
     };
+    
+    enum class LabelType {
+        TTF,
+        BMFONT,
+        CHARMAP,
+        STRING_TEXTURE
+    };
+    
     /// @name Creators
     /// @{
 
     /**
-     * Allocates and initializes a Label, with default settings.
-     *
-     * @return An automatically released Label object.
-     */
+    * Allocates and initializes a Label, with default settings.
+    *
+    * @return An automatically released Label object.
+    */
     static Label* create();
 
     /**
@@ -152,84 +157,88 @@ public:
      *
      * @return An automatically released Label object.
      */
-    static Label* createWithSystemFont(const std::string& text, const std::string& font, float fontSize, const Size& dimensions = Size::ZERO,
-                                       TextHAlignment hAlignment = TextHAlignment::LEFT, TextVAlignment vAlignment = TextVAlignment::TOP);
-
-    /**
-     * Allocates and initializes a Label, base on FreeType2.
-     *
-     * @param text The initial text.
-     * @param fontFilePath A font file.
-     * @param fontSize The font size. This value must be > 0.
-     * @param dimensions
-     * @param hAlignment The text horizontal alignment.
-     * @param vAlignment The text vertical alignment.
-     *
-     * @return An automatically released Label object.
-     */
-    static Label* createWithTTF(const std::string& text, const std::string& fontFilePath, float fontSize, const Size& dimensions = Size::ZERO,
-                                TextHAlignment hAlignment = TextHAlignment::LEFT, TextVAlignment vAlignment = TextVAlignment::TOP);
-
-    /**
-     * Allocates and initializes a Label, base on FreeType2.
-     *
-     * @param ttfConfig A pointer to a TTFConfig object.
-     * @param text The initial text.
-     * @param hAlignment The text horizontal alignment.
-     * @param maxLineWidth The max line width.
-     *
-     * @return An automatically released Label object.
-     * @see TTFConfig setTTFConfig setMaxLineWidth
-     */
-    static Label* createWithTTF(const TTFConfig& ttfConfig, const std::string& text, TextHAlignment hAlignment = TextHAlignment::LEFT, int maxLineWidth = 0);
-
-    /**
-     * Allocates and initializes a Label, with a bitmap font file.
-     *
-     * @param bmfontPath A bitmap font file, it's a FNT format.
-     * @param text The initial text.
-     * @param hAlignment Text horizontal alignment.
-     * @param maxLineWidth The max line width.
-     * @param imageOffset
-     *
-     * @return An automatically released Label object.
-     * @see setBMFontFilePath setMaxLineWidth
-     */
-    static Label* createWithBMFont(const std::string& bmfontPath, const std::string& text, const TextHAlignment& hAlignment = TextHAlignment::LEFT,
-                                   int maxLineWidth = 0, const Vec2& imageOffset = Vec2::ZERO);
-
-    /**
-     * Allocates and initializes a Label, with char map configuration.
-     *
-     * @param charMapFile A char map file, it's a PNG format.
-     * @param itemWidth The width in points of each element.
-     * @param itemHeight The height in points of each element.
-     * @param startCharMap The starting char of the char map.
-     *
-     * @return An automatically released Label object.
-     */
-    static Label* createWithCharMap(const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap);
-
-    /**
-     * Allocates and initializes a Label, with char map configuration.
-     *
-     * @param texture A pointer to an existing Texture2D object.
-     * @param itemWidth The width in points of each element.
-     * @param itemHeight The height in points of each element.
-     * @param startCharMap The starting char of the char map.
-     *
-     * @return An automatically released Label object.
-     */
-    static Label* createWithCharMap(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap);
-
-    /**
-     * Allocates and initializes a Label, with char map configuration.
-     *
-     * @param plistFile A configuration file of char map.
-     *
-     * @return An automatically released Label object.
-     */
-    static Label* createWithCharMap(const std::string& plistFile);
+    static Label* createWithSystemFont(const std::string& text, const std::string& font, float fontSize,
+        const Size& dimensions = Size::ZERO, TextHAlignment hAlignment = TextHAlignment::LEFT,
+        TextVAlignment vAlignment = TextVAlignment::TOP);
+
+    /**
+    * Allocates and initializes a Label, base on FreeType2.
+    *
+    * @param text The initial text.
+    * @param fontFilePath A font file.
+    * @param fontSize The font size. This value must be > 0.
+    * @param dimensions
+    * @param hAlignment The text horizontal alignment.
+    * @param vAlignment The text vertical alignment.
+    *
+    * @return An automatically released Label object.
+    */
+    static Label * createWithTTF(const std::string& text, const std::string& fontFilePath, float fontSize,
+        const Size& dimensions = Size::ZERO, TextHAlignment hAlignment = TextHAlignment::LEFT,
+        TextVAlignment vAlignment = TextVAlignment::TOP);
+
+    /**
+    * Allocates and initializes a Label, base on FreeType2.
+    *
+    * @param ttfConfig A pointer to a TTFConfig object.
+    * @param text The initial text.
+    * @param hAlignment The text horizontal alignment.
+    * @param maxLineWidth The max line width.
+    *
+    * @return An automatically released Label object.
+    * @see TTFConfig setTTFConfig setMaxLineWidth
+    */
+    static Label* createWithTTF(const TTFConfig& ttfConfig, const std::string& text, 
+        TextHAlignment hAlignment = TextHAlignment::LEFT, int maxLineWidth = 0);
+
+    /**
+    * Allocates and initializes a Label, with a bitmap font file.
+    *
+    * @param bmfontPath A bitmap font file, it's a FNT format.
+    * @param text The initial text.
+    * @param hAlignment Text horizontal alignment.
+    * @param maxLineWidth The max line width.
+    * @param imageOffset
+    *
+    * @return An automatically released Label object.
+    * @see setBMFontFilePath setMaxLineWidth
+    */
+    static Label* createWithBMFont(const std::string& bmfontPath, const std::string& text,
+        const TextHAlignment& hAlignment = TextHAlignment::LEFT, int maxLineWidth = 0,
+        const Vec2& imageOffset = Vec2::ZERO);
+
+    /**
+    * Allocates and initializes a Label, with char map configuration.
+    *
+    * @param charMapFile A char map file, it's a PNG format.
+    * @param itemWidth The width in points of each element.
+    * @param itemHeight The height in points of each element.
+    * @param startCharMap The starting char of the char map.
+    *
+    * @return An automatically released Label object.
+    */
+    static Label * createWithCharMap(const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap);
+
+    /**
+    * Allocates and initializes a Label, with char map configuration.
+    *
+    * @param texture A pointer to an existing Texture2D object.
+    * @param itemWidth The width in points of each element.
+    * @param itemHeight The height in points of each element.
+    * @param startCharMap The starting char of the char map.
+    *
+    * @return An automatically released Label object.
+    */
+    static Label * createWithCharMap(Texture2D* texture, int itemWidth, int itemHeight, int startCharMap);
+
+    /**
+    * Allocates and initializes a Label, with char map configuration.
+    *
+    * @param plistFile A configuration file of char map.
+    *
+    * @return An automatically released Label object.
+    */
+    static Label * createWithCharMap(const std::string& plistFile);
 
     //  end of creators group
     /// @}
@@ -247,13 +256,13 @@ public:
      * Returns the TTF configuration object used by the Label.
      * @see `TTFConfig`
      */
-    virtual const TTFConfig& getTTFConfig() const { return _fontConfig; }
+    virtual const TTFConfig& getTTFConfig() const { return _fontConfig;}
 
     /** Sets a new bitmap font to Label */
     virtual bool setBMFontFilePath(const std::string& bmfontFilePath, const Vec2& imageOffset = Vec2::ZERO, float fontSize = 0);
 
     /** Returns the bitmap font used by the Label.*/
-    const std::string& getBMFontFilePath() const { return _bmFontPath; }
+    const std::string& getBMFontFilePath() const { return _bmFontPath;}
 
     /**
      * Sets a new char map configuration to Label.
@@ -285,18 +294,18 @@ public:
     virtual void setSystemFontName(const std::string& font);
 
     /** Returns the system font used by the Label.*/
-    virtual const std::string& getSystemFontName() const { return _systemFont; }
+    virtual const std::string& getSystemFontName() const { return _systemFont;}
 
     /* Sets the system font size of Label.*/
     virtual void setSystemFontSize(float fontSize);
 
     /** Returns the bitmap font path used by the Label.*/
-    virtual float getSystemFontSize() const { return _systemFontSize; }
+    virtual float getSystemFontSize() const { return _systemFontSize;}
 
     /**
      * @warning This method is not recommended for game developers.
      */
-    virtual void requestSystemFontRefresh() { _systemFontDirty = true; }
+    virtual void requestSystemFontRefresh() { _systemFontDirty = true;}
 
     //  end of font methods
     /// @}
@@ -305,7 +314,7 @@ public:
     virtual void setString(const std::string& text) override;
 
     /** Return the text the Label is currently displaying.*/
-    virtual const std::string& getString() const override { return _utf8Text; }
+    virtual const std::string& getString() const override {  return _utf8Text; }
 
     /**
      * Return the number of lines of text.
@@ -324,28 +333,28 @@ public:
      *
      * @warning Limiting use to only when the Label created with true type font or system font.
      */
-    virtual void setTextColor(const Color4B& color);
+    virtual void setTextColor(const Color4B &color);
 
     /** Returns the text color of the Label.*/
-    const Color4B& getTextColor() const { return _textColor; }
+    const Color4B& getTextColor() const { return _textColor;}
 
     /**
      * Enable shadow effect to Label.
      *
      * @todo Support blur for shadow effect.
      */
-    virtual void enableShadow(const Color4B& shadowColor = Color4B::BLACK, const Size& offset = Size(2, -2), int blurRadius = 0);
+    virtual void enableShadow(const Color4B& shadowColor = Color4B::BLACK,const Size &offset = Size(2,-2), int blurRadius = 0);
 
     /**
      * Enable outline effect to Label.
      * @warning Limiting use to only when the Label created with true type font or system font.
      */
-    virtual void enableOutline(const Color4B& outlineColor, int outlineSize = -1);
+    virtual void enableOutline(const Color4B& outlineColor,int outlineSize = -1);
 
     /**
-     * Enable glow effect to Label.
-     * @warning Limiting use to only when the Label created with true type font.
-     */
+    * Enable glow effect to Label.
+    * @warning Limiting use to only when the Label created with true type font.
+    */
     virtual void enableGlow(const Color4B& glowColor);
 
     /**
@@ -383,57 +392,57 @@ public:
     virtual void disableEffect(LabelEffect effect);
 
     /**
-     * Return whether the shadow effect is enabled.
-     */
+    * Return whether the shadow effect is enabled.
+    */
     bool isShadowEnabled() const { return _shadowEnabled; }
 
     /**
-     * Return shadow effect offset value.
-     */
+    * Return shadow effect offset value.
+    */
     Size getShadowOffset() const { return _shadowOffset; }
 
     /**
-     * Return the shadow effect blur radius.
-     */
+    * Return the shadow effect blur radius.
+    */
     float getShadowBlurRadius() const { return _shadowBlurRadius; }
 
     /**
-     * Return the shadow effect color value.
-     */
+    * Return the shadow effect color value.
+    */
     Color4F getShadowColor() const { return _shadowColor4F; }
 
     /**
-     * Return the outline effect size value.
-     */
-    int getOutlineSize() const { return _outlineSize; }
+    * Return the outline effect size value.
+    */
+    float getOutlineSize() const { return _outlineSize; }
 
     /**
-     * Return current effect type.
-     */
+    * Return current effect type.
+    */
     LabelEffect getLabelEffectType() const { return _currLabelEffect; }
 
     /**
-     * Return current effect color value.
-     */
+    * Return current effect color value.
+    */
     Color4F getEffectColor() const { return _effectColorF; }
 
     /** Sets the Label's text horizontal alignment.*/
-    void setAlignment(TextHAlignment hAlignment) { setAlignment(hAlignment, _vAlignment); }
+    void setAlignment(TextHAlignment hAlignment) { setAlignment(hAlignment,_vAlignment);}
 
     /** Returns the Label's text horizontal alignment.*/
-    TextHAlignment getTextAlignment() const { return _hAlignment; }
+    TextHAlignment getTextAlignment() const { return _hAlignment;}
 
     /** Sets the Label's text alignment.*/
-    void setAlignment(TextHAlignment hAlignment, TextVAlignment vAlignment);
+    void setAlignment(TextHAlignment hAlignment,TextVAlignment vAlignment);
 
     /** Sets the Label's text horizontal alignment.*/
-    void setHorizontalAlignment(TextHAlignment hAlignment) { setAlignment(hAlignment, _vAlignment); }
+    void setHorizontalAlignment(TextHAlignment hAlignment) { setAlignment(hAlignment,_vAlignment); }
 
     /** Returns the Label's text horizontal alignment.*/
     TextHAlignment getHorizontalAlignment() const { return _hAlignment; }
 
     /** Sets the Label's text vertical alignment.*/
-    void setVerticalAlignment(TextVAlignment vAlignment) { setAlignment(_hAlignment, vAlignment); }
+    void setVerticalAlignment(TextVAlignment vAlignment) { setAlignment(_hAlignment,vAlignment); }
 
     /** Returns the Label's text vertical alignment.*/
     TextVAlignment getVerticalAlignment() const { return _vAlignment; }
@@ -464,7 +473,7 @@ public:
      *
      * @return The BMFont size in float value.
      */
-    float getBMFontSize() const;
+    float getBMFontSize()const;
 
     /**
      * Toggle wrap option of the label.
@@ -478,7 +487,7 @@ public:
      * Query the wrap is enabled or not.
      * Note: System font will always return true.
      */
-    bool isWrapEnabled() const;
+    bool isWrapEnabled()const;
 
     /**
      * Change the label's Overflow type, currently only TTF and BMFont support all the valid Overflow type.
@@ -494,13 +503,13 @@ public:
      *
      * @return see `Overflow`
      */
-    Overflow getOverflow() const;
+    Overflow getOverflow()const;
     /**
      * Makes the Label exactly this untransformed width.
      *
      * The Label's width be used for text align if the value not equal zero.
-     */
-    void setWidth(float width) { setDimensions(width, _labelHeight); }
+                                                           */
+    void setWidth(float width) { setDimensions(width,_labelHeight);}
     float getWidth() const { return _labelWidth; }
 
     /**
@@ -509,12 +518,12 @@ public:
      * The Label's height be used for text align if the value not equal zero.
      * The text will display incomplete if the size of Label is not large enough to display all text.
      */
-    void setHeight(float height) { setDimensions(_labelWidth, height); }
+    void setHeight(float height){ setDimensions(_labelWidth, height); }
     float getHeight() const { return _labelHeight; }
 
     /** Sets the untransformed size of the Label in a more efficient way. */
     void setDimensions(float width, float height);
-    const Size& getDimensions() const { return _labelDimensions; }
+    const Size& getDimensions() const{ return _labelDimensions;}
 
     /** Update content immediately.*/
     virtual void updateContent();
@@ -523,7 +532,7 @@ public:
      * Provides a way to treat each character like a Sprite.
      * @warning No support system font.
      */
-    virtual Sprite* getLetter(int lettetIndex);
+    virtual Sprite * getLetter(int lettetIndex);
 
     /** Clips upper and lower margin to reduce height of Label.*/
     void setClipMarginEnabled(bool clipEnabled) { _clipEnabled = clipEnabled; }
@@ -545,6 +554,20 @@ public:
 
     void setLineSpacing(float height);
     float getLineSpacing() const;
+    
+    /**
+     Returns type of label
+     
+     @warning Not support system font.
+     @return the type of label
+     @since v3.18.0
+     */
+    LabelType getLabelType() const { return _currentLabelType; }
+    
+    /**
+     Returns font size
+     */
+    float getRenderingFontSize()const;
 
     /**
      * Sets the additional kerning of the Label.
@@ -562,59 +585,61 @@ public:
      */
     float getAdditionalKerning() const;
 
-    FontAtlas* getFontAtlas() { return _fontAtlas; }
+    /**
+    * set ProgramState of current render command
+    */
+    virtual void setProgramState(backend::ProgramState *programState) override;
 
-    const BlendFunc& getBlendFunc() const override { return _blendFunc; }
-    void setBlendFunc(const BlendFunc& blendFunc) override;
+    FontAtlas* getFontAtlas() { return _fontAtlas; }
 
-    bool isOpacityModifyRGB() const override { return _isOpacityModifyRGB; }
-    void setOpacityModifyRGB(bool isOpacityModifyRGB) override;
-    void updateDisplayedColor(const Color3B& parentColor) override;
-    void updateDisplayedOpacity(GLubyte parentOpacity) override;
+    virtual const BlendFunc& getBlendFunc() const override { return _blendFunc; }
+    virtual void setBlendFunc(const BlendFunc &blendFunc) override;
 
-    std::string getDescription() const override;
+    virtual bool isOpacityModifyRGB() const override { return _isOpacityModifyRGB; }
+    virtual void setOpacityModifyRGB(bool isOpacityModifyRGB) override;
+    virtual void updateDisplayedColor(const Color3B& parentColor) override;
+    virtual void updateDisplayedOpacity(uint8_t parentOpacity) override;
 
-    const Size& getContentSize() const override;
-    Rect getBoundingBox() const override;
+    virtual std::string getDescription() const override;
 
-    void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual const Size& getContentSize() const override;
+    virtual Rect getBoundingBox() const override;
 
-    void setCameraMask(unsigned short mask, bool applyChildren = true) override;
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
-    void removeAllChildrenWithCleanup(bool cleanup) override;
-    void removeChild(Node* child, bool cleanup = true) override;
-    void setGlobalZOrder(float globalZOrder) override;
+    virtual void setCameraMask(unsigned short mask, bool applyChildren = true) override;
 
-    CC_DEPRECATED_ATTRIBUTE static Label* create(const std::string& text, const std::string& font, float fontSize, const Size& dimensions = Size::ZERO,
-                                                 TextHAlignment hAlignment = TextHAlignment::LEFT, TextVAlignment vAlignment = TextVAlignment::TOP);
-    CC_DEPRECATED_ATTRIBUTE virtual void setFontDefinition(const FontDefinition& textDefinition);
-    CC_DEPRECATED_ATTRIBUTE FontDefinition getFontDefinition() const { return _getFontDefinition(); }
-    CC_DEPRECATED_ATTRIBUTE int getCommonLineHeight() const { return static_cast<int>(getLineHeight()); }
+    virtual void removeAllChildrenWithCleanup(bool cleanup) override;
+    virtual void removeChild(Node* child, bool cleanup = true) override;
+    virtual void setGlobalZOrder(float globalZOrder) override;
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * Constructor of Label.
-         * @js NA
-         */
-        Label(TextHAlignment hAlignment = TextHAlignment::LEFT, TextVAlignment vAlignment = TextVAlignment::TOP);
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * Constructor of Label.
+     * @js NA
+     */
+    Label(TextHAlignment hAlignment = TextHAlignment::LEFT,
+      TextVAlignment vAlignment = TextVAlignment::TOP);
 
     /**
      * Destructor of Label.
      * @js NA
      * @lua NA
      */
-    ~Label() override;
+    virtual ~Label();
 
-    bool initWithTTF(const std::string& text, const std::string& fontFilePath, float fontSize, const Size& dimensions = Size::ZERO,
-                     TextHAlignment hAlignment = TextHAlignment::LEFT, TextVAlignment vAlignment = TextVAlignment::TOP);
+    bool initWithTTF(const std::string& text, const std::string& fontFilePath, float fontSize,
+                     const Size& dimensions = Size::ZERO, TextHAlignment hAlignment = TextHAlignment::LEFT,
+                     TextVAlignment vAlignment = TextVAlignment::TOP);
 
-    bool initWithTTF(const TTFConfig& ttfConfig, const std::string& text, TextHAlignment hAlignment = TextHAlignment::LEFT, int maxLineWidth = 0);
+    bool initWithTTF(const TTFConfig& ttfConfig, const std::string& text,
+                     TextHAlignment hAlignment = TextHAlignment::LEFT, int maxLineWidth = 0);
 
 protected:
     struct LetterInfo
     {
-        char16_t utf16Char;
+        char32_t utf32Char;
         bool valid;
         float positionX;
         float positionY;
@@ -622,39 +647,40 @@ protected:
         int lineIndex;
     };
 
-    enum class LabelType
-    {
-        TTF,
-        BMFONT,
-        CHARMAP,
-        STRING_TEXTURE
+    struct BatchCommand {
+        BatchCommand();
+        ~BatchCommand();
+
+        CustomCommand textCommand;
+        CustomCommand outLineCommand;
+        CustomCommand shadowCommand;
+
+        std::array<CustomCommand*, 3> getCommandArray();
     };
 
     virtual void setFontAtlas(FontAtlas* atlas, bool distanceFieldEnabled = false, bool useA8Shader = false);
+    bool getFontLetterDef(char32_t character, FontLetterDefinition& letterDef) const;
 
     void computeStringNumLines();
 
-    void onDraw(const Mat4& transform, bool transformUpdated);
-    void onDrawShadow(GLProgram* glProgram, const Color4F& shadowColor);
     void drawSelf(bool visibleByCamera, Renderer* renderer, uint32_t flags);
 
     bool multilineTextWrapByChar();
     bool multilineTextWrapByWord();
-    bool multilineTextWrap(const std::function<int(const std::u16string&, int, int)>& lambda);
+    bool multilineTextWrap(const std::function<int(const std::u32string&, int, int)>& lambda);
     void shrinkLabelToContentSize(const std::function<bool(void)>& lambda);
     bool isHorizontalClamp();
     bool isVerticalClamp();
-    float getRenderingFontSize() const;
     void rescaleWithOriginalFontSize();
 
     void updateLabelLetters();
     virtual bool alignText();
     void computeAlignmentOffset();
-    bool computeHorizontalKernings(const std::u16string& stringToRender);
-
-    void recordLetterInfo(const cocos2d::Vec2& point, char16_t utf16Char, int letterIndex, int lineIndex);
-    void recordPlaceholderInfo(int letterIndex, char16_t utf16Char);
+    bool computeHorizontalKernings(const std::u32string& stringToRender);
 
+    void recordLetterInfo(const cocos2d::Vec2& point, char32_t utf32Char, int letterIndex, int lineIndex);
+    void recordPlaceholderInfo(int letterIndex, char32_t utf16Char);
+    
     bool updateQuads();
 
     void createSpriteForSystemFont(const FontDefinition& fontDef);
@@ -665,21 +691,29 @@ protected:
     void scaleFontSizeDown(float fontSize);
     bool setTTFConfigInternal(const TTFConfig& ttfConfig);
     void setBMFontSizeInternal(float fontSize);
-    bool isHorizontalClamped(float letterPositionX, int lineInex);
+    bool isHorizontalClamped(float letterPositionX, int lineIndex);
     void restoreFontSize();
     void updateLetterSpriteScale(Sprite* sprite);
-    int getFirstCharLen(const std::u16string& utf16Text, int startIndex, int textLen);
-    int getFirstWordLen(const std::u16string& utf16Text, int startIndex, int textLen);
+    int getFirstCharLen(const std::u32string& utf32Text, int startIndex, int textLen) const;
+    int getFirstWordLen(const std::u32string& utf32Text, int startIndex, int textLen) const;
 
     void reset();
 
     FontDefinition _getFontDefinition() const;
 
     virtual void updateColor() override;
+    
+    void updateUniformLocations();
+    void setVertexLayout(PipelineDescriptor& vertexLayout);
+    void updateBlendState();
+    void updateEffectUniforms(BatchCommand &batch, TextureAtlas* textureAtlas, Renderer *renderer, const Mat4 &transform);
+    void updateBuffer(TextureAtlas* textureAtlas, CustomCommand& customCommand);
+
+    void updateBatchCommand(BatchCommand &batch);
 
     LabelType _currentLabelType;
     bool _contentDirty;
-    std::u16string _utf16Text;
+    std::u32string _utf32Text;
     std::string _utf8Text;
     int _numberOfLines;
 
@@ -698,11 +732,11 @@ protected:
     std::vector<LetterInfo> _lettersInfo;
 
     //! used for optimization
-    Sprite* _reusedLetter;
+    Sprite *_reusedLetter;
     Rect _reusedRect;
     int _lengthOfString;
 
-    // layout relevant properties.
+    //layout relevant properties.
     float _lineHeight;
     float _lineSpacing;
     float _additionalKerning;
@@ -728,20 +762,23 @@ protected:
     Color4F _textColorF;
 
     QuadCommand _quadCommand;
-    CustomCommand _customCommand;
-    Mat4 _shadowTransform;
-    GLuint _uniformEffectColor;
-    GLuint _uniformTextColor;
+
+    std::vector<BatchCommand> _batchCommands;
+    
+    Mat4  _shadowTransform;
+    int  _uniformEffectColor;
+    int  _uniformEffectType; // 0: None, 1: Outline, 2: Shadow; Only used when outline is enabled.
+    int  _uniformTextColor;
     bool _useDistanceField;
     bool _useA8Shader;
 
     bool _shadowDirty;
     bool _shadowEnabled;
     Size _shadowOffset;
-
+    
     Color4F _shadowColor4F;
     Color3B _shadowColor3B;
-    GLubyte _shadowOpacity;
+    uint8_t _shadowOpacity;
     float _shadowBlurRadius;
 
     bool _clipEnabled;
@@ -771,9 +808,18 @@ protected:
     bool _boldEnabled;
     DrawNode* _underlineNode;
     bool _strikethroughEnabled;
+    
+    backend::UniformLocation _mvpMatrixLocation;
+    backend::UniformLocation _textureLocation;
+    backend::UniformLocation _alphaTextureLocation;
+    backend::UniformLocation _textColorLocation;
+    backend::UniformLocation _effectColorLocation;
+    backend::UniformLocation _effectTypeLocation;
+    
+    backend::ProgramState* _programState = nullptr;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(Label)
+    CC_DISALLOW_COPY_AND_ASSIGN(Label);
 };
 
 // end group
@@ -781,4 +827,4 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_LABEL_H
+#endif /*__COCOS2D_CCLABEL_H */
diff --git a/cocos2d/cocos/2d/CCLabelAtlas.cpp b/cocos2d/cocos/2d/CCLabelAtlas.cpp
index 3c4619235f..3348ca0bd3 100644
--- a/cocos2d/cocos/2d/CCLabelAtlas.cpp
+++ b/cocos2d/cocos/2d/CCLabelAtlas.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,42 +26,19 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCLabelAtlas.h>
-
-#include <cocos/2d/CCAtlasNode.h>
+#include <cocos/renderer/CCTextureAtlas.h>
+#include <cocos/platform/CCFileUtils.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCFileUtils.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCTexture2D.h>
-#include <cocos/renderer/CCTextureAtlas.h>
 #include <cocos/renderer/CCTextureCache.h>
 
-#include <cstddef>
-#include <new>
-#include <string>
-
 #if CC_LABELATLAS_DEBUG_DRAW
-#    include <cocos/renderer/CCRenderer.h>
+#include <cocos/renderer/CCRenderer.h>
 #endif
 
 NS_CC_BEGIN
 
-// CCLabelAtlas - Creation & Init
-
-LabelAtlas::LabelAtlas()
-: _string("")
-{
-#if CC_LABELATLAS_DEBUG_DRAW
-    _debugDrawNode = DrawNode::create();
-    addChild(_debugDrawNode);
-#endif
-}
+//CCLabelAtlas - Creation & Init
 
 LabelAtlas* LabelAtlas::create()
 {
@@ -73,14 +51,14 @@ LabelAtlas* LabelAtlas::create()
     {
         CC_SAFE_RELEASE_NULL(ret);
     }
-
+    
     return ret;
 }
 
 LabelAtlas* LabelAtlas::create(const std::string& string, const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap)
 {
     LabelAtlas* ret = new (std::nothrow) LabelAtlas();
-    if (ret && ret->initWithString(string, charMapFile, itemWidth, itemHeight, startCharMap))
+    if(ret && ret->initWithString(string, charMapFile, itemWidth, itemHeight, startCharMap))
     {
         ret->autorelease();
         return ret;
@@ -91,7 +69,7 @@ LabelAtlas* LabelAtlas::create(const std::string& string, const std::string& cha
 
 bool LabelAtlas::initWithString(const std::string& string, const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap)
 {
-    Texture2D* texture = Director::getInstance()->getTextureCache()->addImage(charMapFile);
+    Texture2D *texture = Director::getInstance()->getTextureCache()->addImage(charMapFile);
     return initWithString(string, texture, itemWidth, itemHeight, startCharMap);
 }
 
@@ -107,28 +85,28 @@ bool LabelAtlas::initWithString(const std::string& string, Texture2D* texture, i
 }
 
 LabelAtlas* LabelAtlas::create(const std::string& string, const std::string& fntFile)
-{
-    LabelAtlas* ret = new (std::nothrow) LabelAtlas();
+{    
+    LabelAtlas *ret = new (std::nothrow) LabelAtlas();
     if (ret)
     {
         if (ret->initWithString(string, fntFile))
         {
             ret->autorelease();
         }
-        else
+        else 
         {
             CC_SAFE_RELEASE_NULL(ret);
         }
     }
-
+    
     return ret;
 }
 
 bool LabelAtlas::initWithString(const std::string& theString, const std::string& fntFile)
 {
     std::string pathStr = FileUtils::getInstance()->fullPathForFilename(fntFile);
-    std::string relPathStr = pathStr.substr(0, pathStr.find_last_of("/")) + "/";
-
+    std::string relPathStr = pathStr.substr(0, pathStr.find_last_of('/'))+"/";
+    
     ValueMap dict = FileUtils::getInstance()->getValueMapFromFile(pathStr);
 
     CCASSERT(dict["version"].asInt() == 1, "Unsupported version. Upgrade cocos2d version");
@@ -139,26 +117,27 @@ bool LabelAtlas::initWithString(const std::string& theString, const std::string&
     unsigned int height = dict["itemHeight"].asInt() / CC_CONTENT_SCALE_FACTOR();
     unsigned int startChar = dict["firstChar"].asInt();
 
+
     this->initWithString(theString, textureFilename, width, height, startChar);
 
     return true;
 }
 
-// CCLabelAtlas - Atlas generation
+//CCLabelAtlas - Atlas generation
 void LabelAtlas::updateAtlasValues()
 {
-    if (_itemsPerRow == 0)
+    if(_itemsPerRow == 0)
     {
         return;
     }
 
-    std::size_t n = _string.length();
+    ssize_t n = _string.length();
 
-    const unsigned char* s = reinterpret_cast<unsigned char const*>(_string.c_str());
+    const unsigned char *s = (unsigned char*)_string.c_str();
 
-    Texture2D* texture = _textureAtlas->getTexture();
-    float textureWide = static_cast<float>(texture->getPixelsWide());
-    float textureHigh = static_cast<float>(texture->getPixelsHigh());
+    Texture2D *texture = _textureAtlas->getTexture();
+    float textureWide = (float) texture->getPixelsWide();
+    float textureHigh = (float) texture->getPixelsHigh();
     float itemWidthInPixels = _itemWidth * CC_CONTENT_SCALE_FACTOR();
     float itemHeightInPixels = _itemHeight * CC_CONTENT_SCALE_FACTOR();
     if (_ignoreContentScaleFactor)
@@ -169,23 +148,23 @@ void LabelAtlas::updateAtlasValues()
 
     CCASSERT(n <= _textureAtlas->getCapacity(), "updateAtlasValues: Invalid String length");
     V3F_C4B_T2F_Quad* quads = _textureAtlas->getQuads();
-    for (std::size_t i = 0; i < n; i++)
-    {
+    for(ssize_t i = 0; i < n; i++) {
+
         unsigned char a = s[i] - _mapStartChar;
-        float row = static_cast<float>(a % _itemsPerRow);
-        float col = static_cast<float>(a / _itemsPerRow);
+        float row = (float) (a % _itemsPerRow);
+        float col = (float) (a / _itemsPerRow);
 
 #if CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
         // Issue #938. Don't use texStepX & texStepY
-        float left = (2 * row * itemWidthInPixels + 1) / (2 * textureWide);
-        float right = left + (itemWidthInPixels * 2 - 2) / (2 * textureWide);
-        float top = (2 * col * itemHeightInPixels + 1) / (2 * textureHigh);
-        float bottom = top + (itemHeightInPixels * 2 - 2) / (2 * textureHigh);
+        float left        = (2 * row * itemWidthInPixels + 1) / (2 * textureWide);
+        float right        = left + (itemWidthInPixels * 2 - 2) / (2 * textureWide);
+        float top        = (2 * col * itemHeightInPixels + 1) / (2 * textureHigh);
+        float bottom    = top + (itemHeightInPixels * 2 - 2) / (2 * textureHigh);
 #else
-        float left = row * itemWidthInPixels / textureWide;
-        float right = left + itemWidthInPixels / textureWide;
-        float top = col * itemHeightInPixels / textureHigh;
-        float bottom = top + itemHeightInPixels / textureHigh;
+        float left        = row * itemWidthInPixels / textureWide;
+        float right        = left + itemWidthInPixels / textureWide;
+        float top        = col * itemHeightInPixels / textureHigh;
+        float bottom    = top + itemHeightInPixels / textureHigh;
 #endif // ! CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
 
         quads[i].tl.texCoords.u = left;
@@ -197,17 +176,17 @@ void LabelAtlas::updateAtlasValues()
         quads[i].br.texCoords.u = right;
         quads[i].br.texCoords.v = bottom;
 
-        quads[i].bl.vertices.x = static_cast<float>(i * _itemWidth);
+        quads[i].bl.vertices.x = (float) (i * _itemWidth);
         quads[i].bl.vertices.y = 0;
         quads[i].bl.vertices.z = 0.0f;
-        quads[i].br.vertices.x = static_cast<float>(i * _itemWidth + _itemWidth);
+        quads[i].br.vertices.x = (float)(i * _itemWidth + _itemWidth);
         quads[i].br.vertices.y = 0;
         quads[i].br.vertices.z = 0.0f;
-        quads[i].tl.vertices.x = static_cast<float>(i * _itemWidth);
-        quads[i].tl.vertices.y = static_cast<float>(_itemHeight);
+        quads[i].tl.vertices.x = (float)(i * _itemWidth);
+        quads[i].tl.vertices.y = (float)(_itemHeight);
         quads[i].tl.vertices.z = 0.0f;
-        quads[i].tr.vertices.x = static_cast<float>(i * _itemWidth + _itemWidth);
-        quads[i].tr.vertices.y = static_cast<float>(_itemHeight);
+        quads[i].tr.vertices.x = (float)(i * _itemWidth + _itemWidth);
+        quads[i].tr.vertices.y = (float)(_itemHeight);
         quads[i].tr.vertices.z = 0.0f;
         Color4B c(_displayedColor.r, _displayedColor.g, _displayedColor.b, _displayedOpacity);
         quads[i].tl.colors = c;
@@ -215,21 +194,19 @@ void LabelAtlas::updateAtlasValues()
         quads[i].bl.colors = c;
         quads[i].br.colors = c;
     }
-    if (n > 0)
-    {
+    if (n > 0 ){
         _textureAtlas->setDirty(true);
-        std::size_t totalQuads = _textureAtlas->getTotalQuads();
-        if (n > totalQuads)
-        {
+        ssize_t totalQuads = _textureAtlas->getTotalQuads();
+        if (n > totalQuads) {
             _textureAtlas->increaseTotalQuadsWith(static_cast<int>(n - totalQuads));
         }
     }
 }
 
-// CCLabelAtlas - LabelProtocol
-void LabelAtlas::setString(const std::string& label)
+//CCLabelAtlas - LabelProtocol
+void LabelAtlas::setString(const std::string &label)
 {
-    std::size_t len = label.size();
+    ssize_t len = label.size();
     if (len > _textureAtlas->getTotalQuads())
     {
         _textureAtlas->resizeCapacity(len);
@@ -245,7 +222,7 @@ void LabelAtlas::setString(const std::string& label)
     _quadsToDraw = len;
 }
 
-const std::string& LabelAtlas::getString(void) const
+const std::string& LabelAtlas::getString() const
 {
     return _string;
 }
@@ -254,15 +231,15 @@ void LabelAtlas::updateColor()
 {
     if (_textureAtlas)
     {
-        Color4B color4(_displayedColor.r, _displayedColor.g, _displayedColor.b, _displayedOpacity);
+        Color4B color4( _displayedColor.r, _displayedColor.g, _displayedColor.b, _displayedOpacity );
         if (_isOpacityModifyRGB)
         {
-            color4.r *= _displayedOpacity / 255.0f;
-            color4.g *= _displayedOpacity / 255.0f;
-            color4.b *= _displayedOpacity / 255.0f;
+            color4.r *= _displayedOpacity/255.0f;
+            color4.g *= _displayedOpacity/255.0f;
+            color4.b *= _displayedOpacity/255.0f;
         }
         auto quads = _textureAtlas->getQuads();
-        std::size_t length = _string.length();
+        ssize_t length = _string.length();
         for (int index = 0; index < length; index++)
         {
             quads[index].bl.colors = color4;
@@ -274,15 +251,21 @@ void LabelAtlas::updateColor()
     }
 }
 
-// CCLabelAtlas - draw
+//CCLabelAtlas - draw
 #if CC_LABELATLAS_DEBUG_DRAW
-void LabelAtlas::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void LabelAtlas::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
     AtlasNode::draw(renderer, transform, _transformUpdated);
 
     _debugDrawNode->clear();
     auto size = getContentSize();
-    Vec2 vertices[4] = {Vec2::ZERO, Vec2(size.width, 0), Vec2(size.width, size.height), Vec2(0, size.height)};
+    Vec2 vertices[4]=
+    {
+        Vec2::ZERO,
+        Vec2(size.width, 0),
+        Vec2(size.width, size.height),
+        Vec2(0.0f, size.height)
+    };
     _debugDrawNode->drawPoly(vertices, 4, true, Color4F(1.0, 1.0, 1.0, 1.0));
 }
 #endif
diff --git a/cocos2d/cocos/2d/CCLabelAtlas.h b/cocos2d/cocos/2d/CCLabelAtlas.h
index 4f9ff48350..258f167349 100644
--- a/cocos2d/cocos/2d/CCLabelAtlas.h
+++ b/cocos2d/cocos/2d/CCLabelAtlas.h
@@ -3,7 +3,8 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -24,56 +25,46 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_LABELATLAS_H
-#define CC_2D_LABELATLAS_H
+#ifndef __CCLABEL_ATLAS_H__
+#define __CCLABEL_ATLAS_H__
 
 #include <cocos/2d/CCAtlasNode.h>
-#include <cocos/base/CCProtocols.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
-
 #if CC_LABELATLAS_DEBUG_DRAW
-#    include <cocos/2d/CCDrawNode.h>
-#    include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/2d/CCDrawNode.h>
 #endif
-
 NS_CC_BEGIN
 
-class Texture2D;
-
 /**
  * @addtogroup _2d
  * @{
  */
 
-/**
+/** 
  * @class LabelAtlas
  * @brief LabelAtlas is a subclass of AtlasNode.
  *
  * It can be as a replacement of Label since it is MUCH faster.
- *
+ * 
  * LabelAtlas versus Label:
  * - LabelAtlas is MUCH faster than Label.
  * - LabelAtlas "characters" have a fixed height and width.
  * - LabelAtlas "characters" can be anything you want since they are taken from an image file.
- *
+ * 
  * A more flexible class is LabelBMFont. It supports variable width characters and it also has a nice editor.
  */
 class CC_DLL LabelAtlas : public AtlasNode, public LabelProtocol
 {
 public:
-    /**
+    /** 
      * Creates an empty LabelAtlas.
      * User need to call initWithString(...) later to make this object work properly.
      */
     static LabelAtlas* create();
-
+    
     /** Creates the LabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas. */
     static LabelAtlas* create(const std::string& string, const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap);
-
+    
     /**
      * Creates the LabelAtlas with a string and a configuration file.
      * @since v2.0
@@ -82,37 +73,49 @@ public:
 
     /** Initializes the LabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas. */
     bool initWithString(const std::string& string, const std::string& charMapFile, int itemWidth, int itemHeight, int startCharMap);
-
-    /**
+    
+    /** 
      * Initializes the LabelAtlas with a string and a configuration file.
      * @since v2.0
      */
     bool initWithString(const std::string& string, const std::string& fntFile);
-
+    
     /** Initializes the LabelAtlas with a string, a texture, the width and height in points of each element and the starting char of the atlas */
     bool initWithString(const std::string& string, Texture2D* texture, int itemWidth, int itemHeight, int startCharMap);
+    
+    virtual void setString(const std::string &label) override;
+    virtual const std::string& getString() const override;
 
-    void setString(const std::string& label) override;
-    const std::string& getString(void) const override;
-
-    void updateAtlasValues() override;
-    /**
+    virtual void updateAtlasValues() override;
+	/**
      * @js NA
      */
-    std::string getDescription() const override;
+    virtual std::string getDescription() const override;
 
 #if CC_LABELATLAS_DEBUG_DRAW
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 #endif
 
-    CC_CONSTRUCTOR_ACCESS : LabelAtlas();
-    ~LabelAtlas() override = default;
+CC_CONSTRUCTOR_ACCESS:
+    LabelAtlas()
+    :_string("")
+    {
+#if CC_LABELATLAS_DEBUG_DRAW
+        _debugDrawNode = DrawNode::create();
+        addChild(_debugDrawNode);
+#endif
+    }
 
+    virtual ~LabelAtlas()
+    {
+        _string.clear();
+    }
+    
 protected:
-    void updateColor() override;
+    virtual void updateColor() override;
 
 #if CC_LABELATLAS_DEBUG_DRAW
-    DrawNode* _debugDrawNode;
+    DrawNode *_debugDrawNode;
 #endif
 
     // string to render
@@ -124,6 +127,7 @@ protected:
 // end group
 /// @}
 
+
 NS_CC_END
 
-#endif // CC_2D_LABELATLAS_H
+#endif //__CCLABEL_ATLAS_H__
diff --git a/cocos2d/cocos/2d/CCLabelTextFormatter.cpp b/cocos2d/cocos/2d/CCLabelTextFormatter.cpp
index 1ec6bc339e..06fcf55499 100644
--- a/cocos2d/cocos/2d/CCLabelTextFormatter.cpp
+++ b/cocos2d/cocos/2d/CCLabelTextFormatter.cpp
@@ -1,6 +1,7 @@
 /****************************************************************************
  Copyright (c) 2013      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
  http://www.cocos2d-x.org
 
@@ -23,12 +24,12 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#include <cocos/2d/CCFontAtlas.h>
-#include <cocos/2d/CCFontFNT.h>
 #include <cocos/2d/CCLabel.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/ccUTF8.h>
 #include <vector>
+#include <cocos/base/ccUTF8.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/2d/CCFontAtlas.h>
+#include <cocos/2d/CCFontFNT.h>
 
 NS_CC_BEGIN
 
@@ -37,99 +38,116 @@ void Label::computeAlignmentOffset()
     _linesOffsetX.clear();
     switch (_hAlignment)
     {
-        case cocos2d::TextHAlignment::LEFT:
-            _linesOffsetX.assign(_numberOfLines, 0);
-            break;
-        case cocos2d::TextHAlignment::CENTER:
-            for (auto lineWidth : _linesWidth)
-            {
-                _linesOffsetX.push_back((_contentSize.width - lineWidth) / 2.f);
-            }
-            break;
-        case cocos2d::TextHAlignment::RIGHT:
-            for (auto lineWidth : _linesWidth)
-            {
-                _linesOffsetX.push_back(_contentSize.width - lineWidth);
-            }
-            break;
+    case cocos2d::TextHAlignment::LEFT:
+        _linesOffsetX.assign(_numberOfLines, 0);
+        break;
+    case cocos2d::TextHAlignment::CENTER:
+        for (auto lineWidth : _linesWidth)
+        {
+            _linesOffsetX.push_back((_contentSize.width - lineWidth) / 2.f);
+        }
+        break;
+    case cocos2d::TextHAlignment::RIGHT:
+        for (auto lineWidth : _linesWidth)
+        {
+            _linesOffsetX.push_back(_contentSize.width - lineWidth);
+        }
+        break;
+    default:
+        break;
     }
 
     switch (_vAlignment)
     {
-        case cocos2d::TextVAlignment::TOP:
-            _letterOffsetY = _contentSize.height;
-            break;
-        case cocos2d::TextVAlignment::CENTER:
-            _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2.f;
-            break;
-        case cocos2d::TextVAlignment::BOTTOM:
-            _letterOffsetY = _textDesiredHeight;
-            break;
+    case cocos2d::TextVAlignment::TOP:
+        _letterOffsetY = _contentSize.height;
+        break;
+    case cocos2d::TextVAlignment::CENTER:
+        _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2.f;
+        break;
+    case cocos2d::TextVAlignment::BOTTOM:
+        _letterOffsetY = _textDesiredHeight;
+        break;
+    default:
+        break;
     }
 }
 
-int Label::getFirstCharLen(const std::u16string& utf16Text, int startIndex, int textLen)
+int Label::getFirstCharLen(const std::u32string& /*utf32Text*/, int /*startIndex*/, int /*textLen*/) const
 {
     return 1;
 }
 
-int Label::getFirstWordLen(const std::u16string& utf16Text, int startIndex, int textLen)
+int Label::getFirstWordLen(const std::u32string& utf32Text, int startIndex, int textLen) const
 {
-    auto character = utf16Text[startIndex];
-    if (StringUtils::isCJKUnicode(character) || StringUtils::isUnicodeSpace(character) || character == static_cast<char16_t>(TextFormatter::NewLine))
-    {
-        return 1;
-    }
-
-    int len = 1;
-    FontLetterDefinition letterDef;
+    int len = 0;
     auto nextLetterX = 0;
+    FontLetterDefinition letterDef;
     auto contentScaleFactor = CC_CONTENT_SCALE_FACTOR();
-    for (int index = startIndex + 1; index < textLen; ++index)
+
+    for (int index = startIndex; index < textLen; ++index)
     {
-        character = utf16Text[index];
-        if (_fontAtlas->getLetterDefinitionForChar(character, letterDef) == false)
+        char32_t character = utf32Text[index];
+
+        if (character == StringUtils::UnicodeCharacters::NewLine
+            || (!StringUtils::isUnicodeNonBreaking(character)
+                && (StringUtils::isUnicodeSpace(character)
+                    || StringUtils::isCJKUnicode(character))))
         {
             break;
         }
 
-        auto letterX = (nextLetterX + letterDef.offsetX * _bmfontScale) / contentScaleFactor;
-        if (_maxLineWidth > 0.f && letterX + letterDef.width * _bmfontScale > _maxLineWidth && !StringUtils::isUnicodeSpace(character))
+        if (!getFontLetterDef(character, letterDef))
         {
-            if (len >= 2)
-            {
-                return len - 1;
-            }
+            break;
         }
 
-        nextLetterX += letterDef.xAdvance * _bmfontScale + _additionalKerning;
-
-        if (character == static_cast<char16_t>(TextFormatter::NewLine) || StringUtils::isUnicodeSpace(character) || StringUtils::isCJKUnicode(character))
+        if (_maxLineWidth > 0.f)
         {
-            break;
+            auto letterX = (nextLetterX + letterDef.offsetX * _bmfontScale) / contentScaleFactor;
+
+            if (letterX + letterDef.width * _bmfontScale > _maxLineWidth)
+                break;
         }
+
+        nextLetterX += letterDef.xAdvance * _bmfontScale + _additionalKerning;
+
         len++;
     }
 
+    if (len == 0 && textLen)
+        len = 1;
+
     return len;
 }
 
+bool Label::getFontLetterDef(char32_t character, FontLetterDefinition& letterDef) const
+{
+    if (character == StringUtils::UnicodeCharacters::NoBreakSpace)
+    {
+        // change no-break space to regular space
+        // reason: some fonts have issue with no-break space:
+        //   * no letter definition
+        //   * not normal big width
+        character = StringUtils::UnicodeCharacters::Space;
+    }
+
+    return _fontAtlas->getLetterDefinitionForChar(character, letterDef);
+}
+
 void Label::updateBMFontScale()
 {
     auto font = _fontAtlas->getFont();
-    if (_currentLabelType == LabelType::BMFONT)
-    {
-        FontFNT const* bmFont = static_cast<FontFNT const*>(font);
+    if (_currentLabelType == LabelType::BMFONT) {
+        FontFNT *bmFont = (FontFNT*)font;
         float originalFontSize = bmFont->getOriginalFontSize();
         _bmfontScale = _bmFontSize * CC_CONTENT_SCALE_FACTOR() / originalFontSize;
-    }
-    else
-    {
+    }else{
         _bmfontScale = 1.0f;
     }
 }
 
-bool Label::multilineTextWrap(const std::function<int(const std::u16string&, int, int)>& nextTokenLen)
+bool Label::multilineTextWrap(const std::function<int(const std::u32string&, int, int)>& nextTokenLen)
 {
     int textLen = getStringLength();
     int lineIndex = 0;
@@ -137,6 +155,7 @@ bool Label::multilineTextWrap(const std::function<int(const std::u16string&, int
     float nextTokenY = 0.f;
     float longestLine = 0.f;
     float letterRight = 0.f;
+    float nextWhitespaceWidth = 0.f;
 
     auto contentScaleFactor = CC_CONTENT_SCALE_FACTOR();
     float lineSpacing = _lineSpacing * contentScaleFactor;
@@ -148,59 +167,63 @@ bool Label::multilineTextWrap(const std::function<int(const std::u16string&, int
 
     this->updateBMFontScale();
 
-    for (int index = 0; index < textLen;)
+    for (int index = 0; index < textLen; )
     {
-        auto character = _utf16Text[index];
-        if (character == static_cast<char16_t>(TextFormatter::NewLine))
+        char32_t character = _utf32Text[index];
+        if (character == StringUtils::UnicodeCharacters::NewLine)
         {
             _linesWidth.push_back(letterRight);
             letterRight = 0.f;
             lineIndex++;
             nextTokenX = 0.f;
-            nextTokenY -= _lineHeight * _bmfontScale + lineSpacing;
+            nextTokenY -= _lineHeight*_bmfontScale + lineSpacing;
             recordPlaceholderInfo(index, character);
             index++;
             continue;
         }
 
-        auto tokenLen = nextTokenLen(_utf16Text, index, textLen);
+        auto tokenLen = nextTokenLen(_utf32Text, index, textLen);
         float tokenHighestY = highestY;
         float tokenLowestY = lowestY;
         float tokenRight = letterRight;
         float nextLetterX = nextTokenX;
+        float whitespaceWidth = nextWhitespaceWidth;
         bool newLine = false;
-        for (int tmp = 0; tmp < tokenLen; ++tmp)
+        for (int tmp = 0; tmp < tokenLen;++tmp)
         {
             int letterIndex = index + tmp;
-            character = _utf16Text[letterIndex];
-            if (character == static_cast<char16_t>(TextFormatter::CarriageReturn))
+            character = _utf32Text[letterIndex];
+            if (character == StringUtils::UnicodeCharacters::CarriageReturn)
             {
                 recordPlaceholderInfo(letterIndex, character);
                 continue;
             }
+
             // \b - Next char not change x position
-            if (character == static_cast<char16_t>(TextFormatter::NextCharNoChangeX))
+            if (character == StringUtils::UnicodeCharacters::NextCharNoChangeX)
             {
                 nextChangeSize = false;
                 recordPlaceholderInfo(letterIndex, character);
                 continue;
             }
-            if (_fontAtlas->getLetterDefinitionForChar(character, letterDef) == false)
+
+            if (!getFontLetterDef(character, letterDef))
             {
                 recordPlaceholderInfo(letterIndex, character);
-                CCLOG("LabelTextFormatter error:can't find letter definition in font file for letter: %c", character);
+                CCLOG("LabelTextFormatter error: can't find letter definition in font file for letter: 0x%x", character);
                 continue;
             }
 
             auto letterX = (nextLetterX + letterDef.offsetX * _bmfontScale) / contentScaleFactor;
-            if (_enableWrap && _maxLineWidth > 0.f && nextTokenX > 0.f && letterX + letterDef.width * _bmfontScale > _maxLineWidth &&
-                !StringUtils::isUnicodeSpace(character) && nextChangeSize)
+            if (_enableWrap && _maxLineWidth > 0.f && nextTokenX > 0.f && letterX + letterDef.width * _bmfontScale > _maxLineWidth
+                && !StringUtils::isUnicodeSpace(character) && nextChangeSize)
             {
-                _linesWidth.push_back(letterRight);
+                _linesWidth.push_back(letterRight - whitespaceWidth);
+                nextWhitespaceWidth = 0.f;
                 letterRight = 0.f;
                 lineIndex++;
                 nextTokenX = 0.f;
-                nextTokenY -= (_lineHeight * _bmfontScale + lineSpacing);
+                nextTokenY -= (_lineHeight*_bmfontScale + lineSpacing);
                 newLine = true;
                 break;
             }
@@ -213,11 +236,22 @@ bool Label::multilineTextWrap(const std::function<int(const std::u16string&, int
 
             if (nextChangeSize)
             {
+                float newLetterWidth = 0.f;
                 if (_horizontalKernings && letterIndex < textLen - 1)
-                    nextLetterX += _horizontalKernings[letterIndex + 1];
-                nextLetterX += letterDef.xAdvance * _bmfontScale + _additionalKerning;
+                    newLetterWidth = _horizontalKernings[letterIndex + 1];
+                newLetterWidth += letterDef.xAdvance * _bmfontScale + _additionalKerning;
 
+                nextLetterX += newLetterWidth;
                 tokenRight = nextLetterX / contentScaleFactor;
+
+                if (StringUtils::isUnicodeSpace(character))
+                {
+                    nextWhitespaceWidth += newLetterWidth / contentScaleFactor;
+                }
+                else
+                {
+                    nextWhitespaceWidth = 0;
+                }
             }
             nextChangeSize = true;
 
@@ -238,13 +272,24 @@ bool Label::multilineTextWrap(const std::function<int(const std::u16string&, int
             highestY = tokenHighestY;
         if (lowestY > tokenLowestY)
             lowestY = tokenLowestY;
-        if (longestLine < letterRight)
-            longestLine = letterRight;
 
         index += tokenLen;
     }
 
-    _linesWidth.push_back(letterRight);
+    if (_linesWidth.empty())
+    {
+        _linesWidth.push_back(letterRight);
+        longestLine = letterRight;
+    }
+    else
+    {
+        _linesWidth.push_back(letterRight - nextWhitespaceWidth);
+        for (auto && lineWidth : _linesWidth)
+        {
+            if (longestLine < lineWidth)
+                longestLine = lineWidth;
+        }
+    }
 
     _numberOfLines = lineIndex + 1;
     _textDesiredHeight = (_numberOfLines * _lineHeight * _bmfontScale) / contentScaleFactor;
@@ -269,14 +314,12 @@ bool Label::multilineTextWrap(const std::function<int(const std::u16string&, int
 
 bool Label::multilineTextWrapByWord()
 {
-    return multilineTextWrap(
-        [this](const std::u16string& utf16Text, int startIndex, int textLen) -> int { return getFirstWordLen(utf16Text, startIndex, textLen); });
+    return multilineTextWrap(CC_CALLBACK_3(Label::getFirstWordLen, this));
 }
 
 bool Label::multilineTextWrapByChar()
 {
-    return multilineTextWrap(
-        [this](const std::u16string& utf16Text, int startIndex, int textLen) -> int { return getFirstCharLen(utf16Text, startIndex, textLen); });
+    return multilineTextWrap(CC_CALLBACK_3(Label::getFirstCharLen, this));
 }
 
 bool Label::isVerticalClamp()
@@ -298,30 +341,27 @@ bool Label::isHorizontalClamp()
     {
         if (_lettersInfo[ctr].valid)
         {
-            auto& letterDef = _fontAtlas->_letterDefinitions[_lettersInfo[ctr].utf16Char];
+            auto& letterDef = _fontAtlas->_letterDefinitions[_lettersInfo[ctr].utf32Char];
 
-            auto px = _lettersInfo[ctr].positionX + letterDef.width / 2 * _bmfontScale;
+            auto px = _lettersInfo[ctr].positionX + letterDef.width/2 * _bmfontScale;
             auto lineIndex = _lettersInfo[ctr].lineIndex;
 
-            if (_labelWidth > 0.f)
-            {
-                if (!this->_enableWrap)
-                {
-                    if (px > _contentSize.width)
-                    {
+            if(_labelWidth > 0.f){
+                if(!this->_enableWrap){
+                    if (px > _contentSize.width) {
                         letterClamp = true;
                         break;
                     }
                 }
-                else
-                {
+                else{
                     auto wordWidth = this->_linesWidth[lineIndex];
-                    if (wordWidth > this->_contentSize.width && (px > _contentSize.width))
-                    {
+                    if(wordWidth > this->_contentSize.width && (px > _contentSize.width)){
                         letterClamp = true;
                         break;
                     }
+
                 }
+
             }
         }
     }
@@ -338,13 +378,11 @@ void Label::shrinkLabelToContentSize(const std::function<bool(void)>& lambda)
     auto tempLetterDefinition = letterDefinition;
     float originalLineHeight = _lineHeight;
     bool flag = true;
-    while (lambda())
-    {
+    while (lambda()) {
         ++i;
         float newFontSize = fontSize - i;
         flag = false;
-        if (newFontSize <= 0)
-        {
+        if (newFontSize <= 0) {
             break;
         }
         float scale = newFontSize / fontSize;
@@ -365,16 +403,14 @@ void Label::shrinkLabelToContentSize(const std::function<bool(void)>& lambda)
     this->setLineHeight(originalLineHeight);
     std::swap(_fontAtlas->_letterDefinitions, letterDefinition);
 
-    if (!flag)
-    {
-        if (fontSize - i >= 0)
-        {
+    if (!flag) {
+        if (fontSize - i >= 0) {
             this->scaleFontSizeDown(fontSize - i);
         }
     }
 }
 
-void Label::recordLetterInfo(const cocos2d::Vec2& point, char16_t utf16Char, int letterIndex, int lineIndex)
+void Label::recordLetterInfo(const cocos2d::Vec2& point, char32_t utf32Char, int letterIndex, int lineIndex)
 {
     if (static_cast<std::size_t>(letterIndex) >= _lettersInfo.size())
     {
@@ -382,20 +418,21 @@ void Label::recordLetterInfo(const cocos2d::Vec2& point, char16_t utf16Char, int
         _lettersInfo.push_back(tmpInfo);
     }
     _lettersInfo[letterIndex].lineIndex = lineIndex;
-    _lettersInfo[letterIndex].utf16Char = utf16Char;
-    _lettersInfo[letterIndex].valid = _fontAtlas->_letterDefinitions[utf16Char].validDefinition;
+    _lettersInfo[letterIndex].utf32Char = utf32Char;
+    _lettersInfo[letterIndex].valid = _fontAtlas->_letterDefinitions[utf32Char].validDefinition;
     _lettersInfo[letterIndex].positionX = point.x;
     _lettersInfo[letterIndex].positionY = point.y;
+    _lettersInfo[letterIndex].atlasIndex = -1;
 }
 
-void Label::recordPlaceholderInfo(int letterIndex, char16_t utf16Char)
+void Label::recordPlaceholderInfo(int letterIndex, char32_t utf32Char)
 {
     if (static_cast<std::size_t>(letterIndex) >= _lettersInfo.size())
     {
         LetterInfo tmpInfo;
         _lettersInfo.push_back(tmpInfo);
     }
-    _lettersInfo[letterIndex].utf16Char = utf16Char;
+    _lettersInfo[letterIndex].utf32Char = utf32Char;
     _lettersInfo[letterIndex].valid = false;
 }
 
diff --git a/cocos2d/cocos/2d/CCLabelTextFormatter.h b/cocos2d/cocos/2d/CCLabelTextFormatter.h
index e69de29bb2..f41166c23a 100644
--- a/cocos2d/cocos/2d/CCLabelTextFormatter.h
+++ b/cocos2d/cocos/2d/CCLabelTextFormatter.h
@@ -0,0 +1,24 @@
+/****************************************************************************
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
+ http://www.cocos2d-x.org
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ THE SOFTWARE.
+ ****************************************************************************/
+
diff --git a/cocos2d/cocos/2d/CCLayer.cpp b/cocos2d/cocos/2d/CCLayer.cpp
index f343871dd0..5dfd89b52e 100644
--- a/cocos2d/cocos/2d/CCLayer.cpp
+++ b/cocos2d/cocos/2d/CCLayer.cpp
@@ -3,7 +3,8 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -25,25 +26,28 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
+#include <stdarg.h>
 #include <cocos/2d/CCLayer.h>
-
+#include <cocos/base/CCScriptSupport.h>
+#include <cocos/base/ccUtils.h>
+#include <cocos/platform/CCDevice.h>
+#include <cocos/renderer/CCRenderer.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCEventAcceleration.h>
 #include <cocos/base/CCEventDispatcher.h>
-#include <cocos/base/CCEventKeyboard.h>
-#include <cocos/base/CCEventListenerAcceleration.h>
-#include <cocos/base/CCEventListenerKeyboard.h>
 #include <cocos/base/CCEventListenerTouch.h>
 #include <cocos/base/CCEventTouch.h>
-#include <cocos/base/CCScriptSupport.h>
+#include <cocos/base/CCEventKeyboard.h>
+#include <cocos/base/CCEventListenerKeyboard.h>
+#include <cocos/base/CCEventAcceleration.h>
+#include <cocos/base/CCEventListenerAcceleration.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/platform/CCDevice.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/ccGLStateCache.h>
+#include <cocos/renderer/backend/Buffer.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
-#include <stdarg.h>
+#if (CC_TARGET_PLATFORM == CC_PLATFORM_MAC)
+#include <cocos/platform/desktop/CCGLViewImpl-desktop.h>
+#endif
 
 NS_CC_BEGIN
 
@@ -64,18 +68,19 @@ Layer::Layer()
 
 Layer::~Layer()
 {
+
 }
 
 bool Layer::init()
 {
-    Director* director = Director::getInstance();
+    Director * director = Director::getInstance();
     setContentSize(director->getWinSize());
     return true;
 }
 
-Layer* Layer::create()
+Layer *Layer::create()
 {
-    Layer* ret = new (std::nothrow) Layer();
+    Layer *ret = new (std::nothrow) Layer();
     if (ret && ret->init())
     {
         ret->autorelease();
@@ -97,8 +102,11 @@ int Layer::executeScriptTouchHandler(EventTouch::EventCode eventType, Touch* tou
         ScriptEvent scriptEvent(kTouchEvent, &data);
         return ScriptEngineManager::getInstance()->getScriptEngine()->sendEvent(&scriptEvent);
     }
+#else
+    CC_UNUSED_PARAM(eventType);
+    CC_UNUSED_PARAM(touch);
+    CC_UNUSED_PARAM(event);
 #endif
-    // can not reach it
     return 0;
 }
 
@@ -111,237 +119,160 @@ int Layer::executeScriptTouchesHandler(EventTouch::EventCode eventType, const st
         ScriptEvent scriptEvent(kTouchesEvent, &data);
         return ScriptEngineManager::getInstance()->getScriptEngine()->sendEvent(&scriptEvent);
     }
+#else
+    CC_UNUSED_PARAM(eventType);
+    CC_UNUSED_PARAM(touches);
+    CC_UNUSED_PARAM(event);
 #endif
     return 0;
 }
 
-#if defined(__GNUC__) && ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)))
-#    pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-#elif _MSC_VER >= 1400 // vs 2005 or higher
-#    pragma warning(push)
-#    pragma warning(disable : 4996)
-#endif
-
-/// isTouchEnabled getter
-bool Layer::isTouchEnabled() const
-{
-    return _touchEnabled;
-}
 
-/// isTouchEnabled setter
-void Layer::setTouchEnabled(bool enabled)
+void Layer::onAcceleration(Acceleration* acc, Event* /*unused_event*/)
 {
-    if (_touchEnabled != enabled)
+#if CC_ENABLE_SCRIPT_BINDING
+    if(kScriptTypeNone != _scriptType)
     {
-        _touchEnabled = enabled;
-        if (enabled)
-        {
-            if (_touchListener != nullptr)
-                return;
-
-            if (_touchMode == Touch::DispatchMode::ALL_AT_ONCE)
-            {
-                // Register Touch Event
-                auto listener = EventListenerTouchAllAtOnce::create();
-
-                listener->onTouchesBegan = [this](std::vector<Touch*> const& touches, Event* event) { onTouchesBegan(touches, event); };
-                listener->onTouchesMoved = [this](std::vector<Touch*> const& touches, Event* event) { onTouchesMoved(touches, event); };
-                listener->onTouchesEnded = [this](std::vector<Touch*> const& touches, Event* event) { onTouchesEnded(touches, event); };
-                listener->onTouchesCancelled = [this](std::vector<Touch*> const& touches, Event* event) { onTouchesCancelled(touches, event); };
-
-                _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);
-                _touchListener = listener;
-            }
-            else
-            {
-                // Register Touch Event
-                auto listener = EventListenerTouchOneByOne::create();
-                listener->setSwallowTouches(_swallowsTouches);
-
-                listener->onTouchBegan = [this](Touch* touch, Event* event) -> bool { return onTouchBegan(touch, event); };
-                listener->onTouchMoved = [this](Touch* touch, Event* event) { onTouchMoved(touch, event); };
-                listener->onTouchEnded = [this](Touch* touch, Event* event) { onTouchEnded(touch, event); };
-                listener->onTouchCancelled = [this](Touch* touch, Event* event) { onTouchCancelled(touch, event); };
-
-                _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);
-                _touchListener = listener;
-            }
-        }
-        else
-        {
-            _eventDispatcher->removeEventListener(_touchListener);
-            _touchListener = nullptr;
-        }
+        BasicScriptData data(this,(void*)acc);
+        ScriptEvent event(kAccelerometerEvent,&data);
+        ScriptEngineManager::getInstance()->getScriptEngine()->sendEvent(&event);
     }
+#else
+    CC_UNUSED_PARAM(acc);
+#endif
 }
 
-void Layer::setTouchMode(Touch::DispatchMode mode)
+void Layer::onKeyPressed(EventKeyboard::KeyCode /*keyCode*/, Event* /*unused_event*/)
 {
-    if (_touchMode != mode)
-    {
-        _touchMode = mode;
-
-        if (_touchEnabled)
-        {
-            setTouchEnabled(false);
-            setTouchEnabled(true);
-        }
-    }
 }
 
-void Layer::setSwallowsTouches(bool swallowsTouches)
+void Layer::onKeyReleased(EventKeyboard::KeyCode keyCode, Event* /*unused_event*/)
 {
-    if (_swallowsTouches != swallowsTouches)
+#if CC_ENABLE_SCRIPT_BINDING
+    if(kScriptTypeNone != _scriptType)
     {
-        _swallowsTouches = swallowsTouches;
-
-        if (_touchEnabled)
-        {
-            setTouchEnabled(false);
-            setTouchEnabled(true);
-        }
+        KeypadScriptData data(keyCode, this);
+        ScriptEvent event(kKeypadEvent,&data);
+        ScriptEngineManager::getInstance()->getScriptEngine()->sendEvent(&event);
     }
+#else
+    CC_UNUSED_PARAM(keyCode);
+#endif
 }
 
-Touch::DispatchMode Layer::getTouchMode() const
-{
-    return _touchMode;
-}
-
-bool Layer::isSwallowsTouches() const
-{
-    return _swallowsTouches;
-}
+/// Callbacks
 
-/// isAccelerometerEnabled getter
-bool Layer::isAccelerometerEnabled() const
-{
-    return _accelerometerEnabled;
-}
-/// isAccelerometerEnabled setter
-void Layer::setAccelerometerEnabled(bool enabled)
+bool Layer::onTouchBegan(Touch *touch, Event *event)
 {
-    if (enabled != _accelerometerEnabled)
+#if CC_ENABLE_SCRIPT_BINDING
+    if (kScriptTypeLua == _scriptType)
     {
-        _accelerometerEnabled = enabled;
-
-        Device::setAccelerometerEnabled(enabled);
-
-        _eventDispatcher->removeEventListener(_accelerationListener);
-        _accelerationListener = nullptr;
-
-        if (enabled)
-        {
-            _accelerationListener = EventListenerAcceleration::create([this](Acceleration* acc, Event* event) { onAcceleration(acc, event); });
-            _eventDispatcher->addEventListenerWithSceneGraphPriority(_accelerationListener, this);
-        }
+        return executeScriptTouchHandler(EventTouch::EventCode::BEGAN, touch, event) == 0 ? false : true;
     }
+#else
+    CC_UNUSED_PARAM(touch);
+    CC_UNUSED_PARAM(event);
+#endif
+    CCASSERT(false, "Layer#ccTouchBegan override me");
+    return true;
 }
 
-void Layer::setAccelerometerInterval(double interval)
+void Layer::onTouchMoved(Touch *touch, Event *event)
 {
-    if (_accelerometerEnabled)
+#if CC_ENABLE_SCRIPT_BINDING
+    if (kScriptTypeLua == _scriptType)
     {
-        if (_running)
-        {
-            Device::setAccelerometerInterval(interval);
-        }
+        executeScriptTouchHandler(EventTouch::EventCode::MOVED, touch, event);
+        return;
     }
+#else
+    CC_UNUSED_PARAM(touch);
+    CC_UNUSED_PARAM(event);
+#endif
 }
 
-void Layer::onAcceleration(Acceleration* acc, Event*)
+void Layer::onTouchEnded(Touch *touch, Event *event)
 {
 #if CC_ENABLE_SCRIPT_BINDING
-    if (kScriptTypeNone != _scriptType)
+    if (kScriptTypeLua == _scriptType)
     {
-        BasicScriptData data(this, (void*)acc);
-        ScriptEvent event(kAccelerometerEvent, &data);
-        ScriptEngineManager::getInstance()->getScriptEngine()->sendEvent(&event);
+        executeScriptTouchHandler(EventTouch::EventCode::ENDED, touch, event);
+        return;
     }
+#else
+    CC_UNUSED_PARAM(touch);
+    CC_UNUSED_PARAM(event);
 #endif
 }
 
-void Layer::onKeyPressed(EventKeyboard::KeyCode, Event*)
-{
-}
-
-void Layer::onKeyReleased(EventKeyboard::KeyCode keyCode, Event*)
+void Layer::onTouchCancelled(Touch *touch, Event *event)
 {
 #if CC_ENABLE_SCRIPT_BINDING
-    if (kScriptTypeNone != _scriptType)
+    if (kScriptTypeLua == _scriptType)
     {
-        KeypadScriptData data(keyCode, this);
-        ScriptEvent event(kKeypadEvent, &data);
-        ScriptEngineManager::getInstance()->getScriptEngine()->sendEvent(&event);
+        executeScriptTouchHandler(EventTouch::EventCode::CANCELLED, touch, event);
+        return;
     }
+#else
+    CC_UNUSED_PARAM(touch);
+    CC_UNUSED_PARAM(event);
 #endif
-}
+}    
 
-/// isKeyboardEnabled getter
-bool Layer::isKeyboardEnabled() const
-{
-    return _keyboardEnabled;
-}
-/// isKeyboardEnabled setter
-void Layer::setKeyboardEnabled(bool enabled)
+void Layer::onTouchesBegan(const std::vector<Touch*>& touches, Event *event)
 {
-    if (enabled != _keyboardEnabled)
+#if CC_ENABLE_SCRIPT_BINDING
+    if (kScriptTypeLua == _scriptType)
     {
-        _keyboardEnabled = enabled;
-
-        _eventDispatcher->removeEventListener(_keyboardListener);
-        _keyboardListener = nullptr;
-
-        if (enabled)
-        {
-            auto listener = EventListenerKeyboard::create();
-            listener->onKeyPressed = [this](EventKeyboard::KeyCode keyCode, Event* event) { onKeyPressed(keyCode, event); };
-            listener->onKeyReleased = [this](EventKeyboard::KeyCode keyCode, Event* event) { onKeyReleased(keyCode, event); };
-
-            _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);
-            _keyboardListener = listener;
-        }
+        executeScriptTouchesHandler(EventTouch::EventCode::BEGAN, touches, event);
+        return;
     }
+#else
+    CC_UNUSED_PARAM(touches);
+    CC_UNUSED_PARAM(event);
+#endif
 }
 
-void Layer::setKeypadEnabled(bool enabled)
-{
-    setKeyboardEnabled(enabled);
-}
-/// Callbacks
-
-bool Layer::onTouchBegan(Touch*, Event*)
-{
-    CCASSERT(false, "Layer#ccTouchBegan override me");
-    return true;
-}
-
-void Layer::onTouchMoved(Touch*, Event*)
-{
-}
-
-void Layer::onTouchEnded(Touch*, Event*)
-{
-}
-
-void Layer::onTouchCancelled(Touch*, Event*)
-{
-}
-
-void Layer::onTouchesBegan(const std::vector<Touch*>&, Event*)
-{
-}
-
-void Layer::onTouchesMoved(const std::vector<Touch*>&, Event*)
+void Layer::onTouchesMoved(const std::vector<Touch*>& touches, Event *event)
 {
+#if CC_ENABLE_SCRIPT_BINDING
+    if (kScriptTypeLua == _scriptType)
+    {
+        executeScriptTouchesHandler(EventTouch::EventCode::MOVED, touches, event);
+        return;
+    }
+#else
+    CC_UNUSED_PARAM(touches);
+    CC_UNUSED_PARAM(event);
+#endif
 }
 
-void Layer::onTouchesEnded(const std::vector<Touch*>&, Event*)
+void Layer::onTouchesEnded(const std::vector<Touch*>& touches, Event *event)
 {
+#if CC_ENABLE_SCRIPT_BINDING
+    if (kScriptTypeLua == _scriptType)
+    {
+        executeScriptTouchesHandler(EventTouch::EventCode::ENDED, touches, event);
+        return;
+    }
+#else
+    CC_UNUSED_PARAM(touches);
+    CC_UNUSED_PARAM(event);
+#endif
 }
 
-void Layer::onTouchesCancelled(const std::vector<Touch*>&, Event*)
+void Layer::onTouchesCancelled(const std::vector<Touch*>& touches, Event *event)
 {
+#if CC_ENABLE_SCRIPT_BINDING
+    if (kScriptTypeLua == _scriptType)
+    {
+        executeScriptTouchesHandler(EventTouch::EventCode::CANCELLED, touches, event);
+        return;
+    }
+#else
+    CC_UNUSED_PARAM(touches);
+    CC_UNUSED_PARAM(event);
+#endif
 }
 
 std::string Layer::getDescription() const
@@ -349,39 +280,55 @@ std::string Layer::getDescription() const
     return StringUtils::format("<Layer | Tag = %d>", _tag);
 }
 
-__LayerRGBA::__LayerRGBA()
-{
-    CCLOG("LayerRGBA deprecated.");
-}
-
-__LayerRGBA::~__LayerRGBA()
-{
-}
-
-#if defined(__GNUC__) && ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)))
-#    pragma GCC diagnostic warning "-Wdeprecated-declarations"
-#elif _MSC_VER >= 1400 // vs 2005 or higher
-#    pragma warning(pop)
-#endif
 /// LayerColor
 
 LayerColor::LayerColor()
 {
     // default blend function
     _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
-}
-
+    
+    auto& pipelineDescriptor = _customCommand.getPipelineDescriptor();
+    _programState = new (std::nothrow) backend::ProgramState(positionColor_vert, positionColor_frag);
+    pipelineDescriptor.programState = _programState;
+    
+    auto vertexLayout = _programState->getVertexLayout();
+    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT3, 0, false);
+    }
+    iter = attributeInfo.find("a_color");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_color", iter->second.location, backend::VertexFormat::FLOAT4, sizeof(_vertexData[0].vertices), false);
+    }
+    vertexLayout->setLayout(sizeof(_vertexData[0]));
+    
+    _mvpMatrixLocation = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    
+    _customCommand.createIndexBuffer(CustomCommand::IndexFormat::U_SHORT, 6, CustomCommand::BufferUsage::STATIC);
+    unsigned short indices[] = {0, 1, 2, 2, 1, 3};
+    _customCommand.updateIndexBuffer(indices, sizeof(indices));
+    
+    _customCommand.createVertexBuffer(sizeof(_vertexData[0]), 4, CustomCommand::BufferUsage::DYNAMIC);
+    
+    _customCommand.setDrawType(CustomCommand::DrawType::ELEMENT);
+    _customCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE);
+}
+    
 LayerColor::~LayerColor()
 {
+    CC_SAFE_RELEASE(_programState);
 }
 
 /// blendFunc getter
-const BlendFunc& LayerColor::getBlendFunc() const
+const BlendFunc &LayerColor::getBlendFunc() const
 {
     return _blendFunc;
 }
 /// blendFunc setter
-void LayerColor::setBlendFunc(const BlendFunc& var)
+void LayerColor::setBlendFunc(const BlendFunc &var)
 {
     _blendFunc = var;
 }
@@ -400,10 +347,10 @@ LayerColor* LayerColor::create()
     return ret;
 }
 
-LayerColor* LayerColor::create(const Color4B& color, GLfloat width, GLfloat height)
+LayerColor * LayerColor::create(const Color4B& color, float width, float height)
 {
-    LayerColor* layer = new (std::nothrow) LayerColor();
-    if (layer && layer->initWithColor(color, width, height))
+    LayerColor * layer = new (std::nothrow) LayerColor();
+    if( layer && layer->initWithColor(color,width,height))
     {
         layer->autorelease();
         return layer;
@@ -412,10 +359,10 @@ LayerColor* LayerColor::create(const Color4B& color, GLfloat width, GLfloat heig
     return nullptr;
 }
 
-LayerColor* LayerColor::create(const Color4B& color)
+LayerColor * LayerColor::create(const Color4B& color)
 {
-    LayerColor* layer = new (std::nothrow) LayerColor();
-    if (layer && layer->initWithColor(color))
+    LayerColor * layer = new (std::nothrow) LayerColor();
+    if(layer && layer->initWithColor(color))
     {
         layer->autorelease();
         return layer;
@@ -427,13 +374,14 @@ LayerColor* LayerColor::create(const Color4B& color)
 bool LayerColor::init()
 {
     Size s = Director::getInstance()->getWinSize();
-    return initWithColor(Color4B(0, 0, 0, 0), s.width, s.height);
+    return initWithColor(Color4B(0,0,0,0), s.width, s.height);
 }
 
-bool LayerColor::initWithColor(const Color4B& color, GLfloat w, GLfloat h)
+bool LayerColor::initWithColor(const Color4B& color, float w, float h)
 {
     if (Layer::init())
     {
+
         // default blend function
         _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
 
@@ -442,7 +390,7 @@ bool LayerColor::initWithColor(const Color4B& color, GLfloat w, GLfloat h)
         _displayedColor.b = _realColor.b = color.b;
         _displayedOpacity = _realOpacity = color.a;
 
-        for (size_t i = 0; i < sizeof(_squareVertices) / sizeof(_squareVertices[0]); i++)
+        for (size_t i = 0; i<sizeof(_squareVertices) / sizeof( _squareVertices[0]); i++ )
         {
             _squareVertices[i].x = 0.0f;
             _squareVertices[i].y = 0.0f;
@@ -451,7 +399,6 @@ bool LayerColor::initWithColor(const Color4B& color, GLfloat w, GLfloat h)
         updateColor();
         setContentSize(Size(w, h));
 
-        setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_COLOR_NO_MVP));
         return true;
     }
     return false;
@@ -464,7 +411,7 @@ bool LayerColor::initWithColor(const Color4B& color)
 }
 
 /// override contentSize
-void LayerColor::setContentSize(const Size& size)
+void LayerColor::setContentSize(const Size & size)
 {
     _squareVertices[1].x = size.width;
     _squareVertices[2].y = size.height;
@@ -474,94 +421,62 @@ void LayerColor::setContentSize(const Size& size)
     Layer::setContentSize(size);
 }
 
-void LayerColor::changeWidthAndHeight(GLfloat w, GLfloat h)
+void LayerColor::changeWidthAndHeight(float w ,float h)
 {
     this->setContentSize(Size(w, h));
 }
 
-void LayerColor::changeWidth(GLfloat w)
+void LayerColor::changeWidth(float w)
 {
     this->setContentSize(Size(w, _contentSize.height));
 }
 
-void LayerColor::changeHeight(GLfloat h)
+void LayerColor::changeHeight(float h)
 {
     this->setContentSize(Size(_contentSize.width, h));
 }
 
 void LayerColor::updateColor()
 {
-    for (unsigned int i = 0; i < 4; i++)
+    for (int i = 0; i < 4; i++ )
     {
-        _squareColors[i].r = _displayedColor.r / 255.0f;
-        _squareColors[i].g = _displayedColor.g / 255.0f;
-        _squareColors[i].b = _displayedColor.b / 255.0f;
-        _squareColors[i].a = _displayedOpacity / 255.0f;
+        _vertexData[i].colors.r = _displayedColor.r / 255.0f;
+        _vertexData[i].colors.g = _displayedColor.g / 255.0f;
+        _vertexData[i].colors.b = _displayedColor.b / 255.0f;
+        _vertexData[i].colors.a = _displayedOpacity / 255.0f;
     }
+    updateVertexBuffer();
 }
 
-void LayerColor::draw(Renderer* renderer, Mat4 const& transform, uint32_t flags)
-{
-    _customCommand.init(_globalZOrder, transform, flags);
-    _customCommand.setFunc([this, transform, flags]() { onDraw(transform, flags); });
+void LayerColor::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
+{    
+    _customCommand.init(_globalZOrder, _blendFunc);
     renderer->addCommand(&_customCommand);
-
-    for (int i = 0; i < 4; ++i)
+    
+    cocos2d::Mat4 projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    auto& pipelineDescriptor = _customCommand.getPipelineDescriptor();
+    pipelineDescriptor.programState->setUniform(_mvpMatrixLocation, projectionMat.m, sizeof(projectionMat.m));
+    
+    for(int i = 0; i < 4; ++i)
     {
         Vec4 pos;
-        pos.x = _squareVertices[i].x;
-        pos.y = _squareVertices[i].y;
-        pos.z = _positionZ;
+        pos.x = _squareVertices[i].x; pos.y = _squareVertices[i].y; pos.z = _positionZ;
         pos.w = 1;
-        _modelViewTransform.transformVector(pos);
-        _noMVPVertices[i] = Vec3(pos.x, pos.y, pos.z) / pos.w;
+        _modelViewTransform.transformVector(&pos);
+        _vertexData[i].vertices = Vec3(pos.x,pos.y,pos.z)/pos.w;
     }
+    updateVertexBuffer();
 }
 
-void LayerColor::onDraw(Mat4 const& transform, uint32_t flags)
+void LayerColor::updateVertexBuffer()
 {
-    getGLProgram()->use();
-    getGLProgram()->setUniformsForBuiltins(transform);
-
-    GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POSITION | GL::VERTEX_ATTRIB_FLAG_COLOR);
-
-    //
-    // Attributes
-    //
-#if CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN
-    setGLBufferData(_noMVPVertices, 4 * sizeof(Vec3), 0);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, 0, 0);
-
-    setGLBufferData(_squareColors, 4 * sizeof(Color4F), 1);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_FLOAT, GL_FALSE, 0, 0);
-#else
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, 0, _noMVPVertices);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_FLOAT, GL_FALSE, 0, _squareColors);
-#endif
-
-    GL::blendFunc(_blendFunc.src, _blendFunc.dst);
-
-    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-
-    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, 4);
-}
-
-std::string LayerColor::getDescription() const
-{
-    return StringUtils::format("<LayerColor | Tag = %d>", _tag);
+    _customCommand.updateVertexBuffer(_vertexData, sizeof(_vertexData));
 }
 
 //
 // LayerGradient
 //
 LayerGradient::LayerGradient()
-: _startColor(Color4B::BLACK)
-, _endColor(Color4B::BLACK)
-, _startOpacity(255)
-, _endOpacity(255)
-, _alongVector(Vec2(0, -1))
-, _compressedInterpolation(true)
 {
 }
 
@@ -571,8 +486,8 @@ LayerGradient::~LayerGradient()
 
 LayerGradient* LayerGradient::create(const Color4B& start, const Color4B& end)
 {
-    LayerGradient* layer = new (std::nothrow) LayerGradient();
-    if (layer && layer->initWithColor(start, end))
+    LayerGradient * layer = new (std::nothrow) LayerGradient();
+    if( layer && layer->initWithColor(start, end))
     {
         layer->autorelease();
         return layer;
@@ -583,8 +498,8 @@ LayerGradient* LayerGradient::create(const Color4B& start, const Color4B& end)
 
 LayerGradient* LayerGradient::create(const Color4B& start, const Color4B& end, const Vec2& v)
 {
-    LayerGradient* layer = new (std::nothrow) LayerGradient();
-    if (layer && layer->initWithColor(start, end, v))
+    LayerGradient * layer = new (std::nothrow) LayerGradient();
+    if( layer && layer->initWithColor(start, end, v))
     {
         layer->autorelease();
         return layer;
@@ -619,13 +534,13 @@ bool LayerGradient::initWithColor(const Color4B& start, const Color4B& end)
 
 bool LayerGradient::initWithColor(const Color4B& start, const Color4B& end, const Vec2& v)
 {
-    _endColor.r = end.r;
-    _endColor.g = end.g;
-    _endColor.b = end.b;
+    _endColor.r  = end.r;
+    _endColor.g  = end.g;
+    _endColor.b  = end.b;
 
-    _endOpacity = end.a;
-    _startOpacity = start.a;
-    _alongVector = v;
+    _endOpacity     = end.a;
+    _startOpacity   = start.a;
+    _alongVector    = v;
 
     _compressedInterpolation = true;
 
@@ -646,36 +561,46 @@ void LayerGradient::updateColor()
     // Compressed Interpolation mode
     if (_compressedInterpolation)
     {
-        float h2 = 1 / (fabsf(u.x) + fabsf(u.y));
+        float h2 = 1 / ( fabsf(u.x) + fabsf(u.y) );
         u = u * (h2 * (float)c);
     }
 
     float opacityf = (float)_displayedOpacity / 255.0f;
 
-    Color4F S(_displayedColor.r / 255.0f, _displayedColor.g / 255.0f, _displayedColor.b / 255.0f, _startOpacity * opacityf / 255.0f);
+    Color4F S(
+        _displayedColor.r / 255.0f,
+        _displayedColor.g / 255.0f,
+        _displayedColor.b / 255.0f,
+        _startOpacity * opacityf / 255.0f
+    );
 
-    Color4F E(_endColor.r / 255.0f, _endColor.g / 255.0f, _endColor.b / 255.0f, _endOpacity * opacityf / 255.0f);
+    Color4F E(
+        _endColor.r / 255.0f,
+        _endColor.g / 255.0f,
+        _endColor.b / 255.0f,
+        _endOpacity * opacityf / 255.0f
+    );
 
     // (-1, -1)
-    _squareColors[0].r = E.r + (S.r - E.r) * ((c + u.x + u.y) / (2.0f * c));
-    _squareColors[0].g = E.g + (S.g - E.g) * ((c + u.x + u.y) / (2.0f * c));
-    _squareColors[0].b = E.b + (S.b - E.b) * ((c + u.x + u.y) / (2.0f * c));
-    _squareColors[0].a = E.a + (S.a - E.a) * ((c + u.x + u.y) / (2.0f * c));
-    // (1, -1)
-    _squareColors[1].r = E.r + (S.r - E.r) * ((c - u.x + u.y) / (2.0f * c));
-    _squareColors[1].g = E.g + (S.g - E.g) * ((c - u.x + u.y) / (2.0f * c));
-    _squareColors[1].b = E.b + (S.b - E.b) * ((c - u.x + u.y) / (2.0f * c));
-    _squareColors[1].a = E.a + (S.a - E.a) * ((c - u.x + u.y) / (2.0f * c));
-    // (-1, 1)
-    _squareColors[2].r = E.r + (S.r - E.r) * ((c + u.x - u.y) / (2.0f * c));
-    _squareColors[2].g = E.g + (S.g - E.g) * ((c + u.x - u.y) / (2.0f * c));
-    _squareColors[2].b = E.b + (S.b - E.b) * ((c + u.x - u.y) / (2.0f * c));
-    _squareColors[2].a = E.a + (S.a - E.a) * ((c + u.x - u.y) / (2.0f * c));
-    // (1, 1)
-    _squareColors[3].r = E.r + (S.r - E.r) * ((c - u.x - u.y) / (2.0f * c));
-    _squareColors[3].g = E.g + (S.g - E.g) * ((c - u.x - u.y) / (2.0f * c));
-    _squareColors[3].b = E.b + (S.b - E.b) * ((c - u.x - u.y) / (2.0f * c));
-    _squareColors[3].a = E.a + (S.a - E.a) * ((c - u.x - u.y) / (2.0f * c));
+   _vertexData[0].colors.r = E.r + (S.r - E.r) * ((c + u.x + u.y) / (2.0f * c));
+   _vertexData[0].colors.g = E.g + (S.g - E.g) * ((c + u.x + u.y) / (2.0f * c));
+   _vertexData[0].colors.b = E.b + (S.b - E.b) * ((c + u.x + u.y) / (2.0f * c));
+   _vertexData[0].colors.a = E.a + (S.a - E.a) * ((c + u.x + u.y) / (2.0f * c));
+   // (1, -1)
+   _vertexData[1].colors.r = E.r + (S.r - E.r) * ((c - u.x + u.y) / (2.0f * c));
+   _vertexData[1].colors.g = E.g + (S.g - E.g) * ((c - u.x + u.y) / (2.0f * c));
+   _vertexData[1].colors.b = E.b + (S.b - E.b) * ((c - u.x + u.y) / (2.0f * c));
+   _vertexData[1].colors.a = E.a + (S.a - E.a) * ((c - u.x + u.y) / (2.0f * c));
+   // (-1, 1)
+   _vertexData[2].colors.r = E.r + (S.r - E.r) * ((c + u.x - u.y) / (2.0f * c));
+   _vertexData[2].colors.g = E.g + (S.g - E.g) * ((c + u.x - u.y) / (2.0f * c));
+   _vertexData[2].colors.b = E.b + (S.b - E.b) * ((c + u.x - u.y) / (2.0f * c));
+   _vertexData[2].colors.a = E.a + (S.a - E.a) * ((c + u.x - u.y) / (2.0f * c));
+   // (1, 1)
+   _vertexData[3].colors.r = E.r + (S.r - E.r) * ((c - u.x - u.y) / (2.0f * c));
+   _vertexData[3].colors.g = E.g + (S.g - E.g) * ((c - u.x - u.y) / (2.0f * c));
+   _vertexData[3].colors.b = E.b + (S.b - E.b) * ((c - u.x - u.y) / (2.0f * c));
+   _vertexData[3].colors.a = E.a + (S.a - E.a) * ((c - u.x - u.y) / (2.0f * c));
 }
 
 const Color3B& LayerGradient::getStartColor() const
@@ -699,24 +624,24 @@ const Color3B& LayerGradient::getEndColor() const
     return _endColor;
 }
 
-void LayerGradient::setStartOpacity(GLubyte o)
+void LayerGradient::setStartOpacity(uint8_t o)
 {
     _startOpacity = o;
     updateColor();
 }
 
-GLubyte LayerGradient::getStartOpacity() const
+uint8_t LayerGradient::getStartOpacity() const
 {
     return _startOpacity;
 }
 
-void LayerGradient::setEndOpacity(GLubyte o)
+void LayerGradient::setEndOpacity(uint8_t o)
 {
     _endOpacity = o;
     updateColor();
 }
 
-GLubyte LayerGradient::getEndOpacity() const
+uint8_t LayerGradient::getEndOpacity() const
 {
     return _endOpacity;
 }
@@ -748,46 +673,253 @@ std::string LayerGradient::getDescription() const
     return StringUtils::format("<LayerGradient | Tag = %d>", _tag);
 }
 
-/// MultiplexLayer
+/**
+ * LayerRadialGradient
+ */
+LayerRadialGradient* LayerRadialGradient::create(const Color4B& startColor, const Color4B& endColor, float radius, const Vec2& center, float expand)
+{
+    auto layerGradient = new LayerRadialGradient();
+    if (layerGradient && layerGradient->initWithColor(startColor, endColor, radius, center, expand))
+    {
+        layerGradient->autorelease();
+        return layerGradient;
+    }
+    
+    delete layerGradient;
+    return nullptr;
+}
 
-LayerMultiplex::LayerMultiplex()
-: _enabledLayer(0)
+LayerRadialGradient* LayerRadialGradient::create()
 {
+    auto layerGradient = new LayerRadialGradient();
+    if (layerGradient && layerGradient->initWithColor(Color4B::BLACK, Color4B::BLACK, 0, Vec2(0,0), 0))
+    {
+        layerGradient->autorelease();
+        return layerGradient;
+    }
+    
+    delete layerGradient;
+    return nullptr;
 }
 
-LayerMultiplex::~LayerMultiplex()
+LayerRadialGradient::LayerRadialGradient()
 {
-    for (const auto& layer : _layers)
+    auto& pipelineDescriptor = _customCommand.getPipelineDescriptor();
+    _programState = new (std::nothrow) backend::ProgramState(position_vert, layer_radialGradient_frag);
+    pipelineDescriptor.programState = _programState;
+    _mvpMatrixLocation = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    _startColorLocation = pipelineDescriptor.programState->getUniformLocation("u_startColor");
+    _endColorLocation = pipelineDescriptor.programState->getUniformLocation("u_endColor");
+    _centerLocation = pipelineDescriptor.programState->getUniformLocation("u_center");
+    _radiusLocation = pipelineDescriptor.programState->getUniformLocation("u_radius");
+    _expandLocation = pipelineDescriptor.programState->getUniformLocation("u_expand");
+
+    auto vertexLayout = _programState->getVertexLayout();
+    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
     {
-        layer->cleanup();
+        vertexLayout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT2, 0, false);
     }
+    vertexLayout->setLayout(sizeof(_vertices[0]));
+
+    _customCommand.createVertexBuffer(sizeof(_vertices[0]), sizeof(_vertices) / sizeof(_vertices[0]), CustomCommand::BufferUsage::STATIC);
+    _customCommand.setDrawType(CustomCommand::DrawType::ARRAY);
+    _customCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE_STRIP);
 }
 
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-LayerMultiplex* LayerMultiplex::createVariadic(Layer* layer, ...)
+LayerRadialGradient::~LayerRadialGradient()
 {
-    va_list args;
-    va_start(args, layer);
+    CC_SAFE_RELEASE(_programState);
+}
 
-    LayerMultiplex* multiplexLayer = new (std::nothrow) LayerMultiplex();
-    if (multiplexLayer && multiplexLayer->initWithLayers(layer, args))
+bool LayerRadialGradient::initWithColor(const cocos2d::Color4B &startColor, const cocos2d::Color4B &endColor, float radius, const Vec2& center, float expand)
+{
+    // should do it before Layer::init()
+    for (int i = 0; i < 4; ++i)
+        _vertices[i] = {0.0f, 0.0f};
+    
+    if (Layer::init())
     {
-        multiplexLayer->autorelease();
-        va_end(args);
-        return multiplexLayer;
+        convertColor4B24F(_startColorRend, startColor);
+        _startColor = startColor;
+        
+        convertColor4B24F(_endColorRend, endColor);
+        _endColor = endColor;
+        
+        _expand = expand;
+        
+        setRadius(radius);
+        setCenter(center);
+        
+        return true;
     }
-    va_end(args);
-    CC_SAFE_DELETE(multiplexLayer);
-    return nullptr;
+    
+    return false;
 }
-#else
-LayerMultiplex* LayerMultiplex::create(Layer* layer, ...)
+
+void LayerRadialGradient::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
+{
+    _customCommand.init(_globalZOrder, _blendFunc);
+    renderer->addCommand(&_customCommand);
+
+    const auto& projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    auto programState = _customCommand.getPipelineDescriptor().programState;
+    Mat4 finalMat = projectionMat * transform;
+    programState->setUniform(_mvpMatrixLocation, finalMat.m, sizeof(finalMat.m));
+
+    programState->setUniform(_startColorLocation, &_startColorRend, sizeof(_startColorRend));
+    programState->setUniform(_endColorLocation, &_endColorRend, sizeof(_endColorRend));
+    programState->setUniform(_centerLocation, &_center, sizeof(_center));
+    programState->setUniform(_radiusLocation, &_radius, sizeof(_radius));
+    programState->setUniform(_expandLocation, &_expand, sizeof(_expand));
+}
+
+void LayerRadialGradient::setContentSize(const Size& size)
+{
+    _vertices[1].x = size.width;
+    _vertices[2].y = size.height;
+    _vertices[3].x = size.width;
+    _vertices[3].y = size.height;
+    Layer::setContentSize(size);
+
+    _customCommand.updateVertexBuffer(_vertices, sizeof(_vertices));
+}
+
+void LayerRadialGradient::setStartOpacity(uint8_t opacity)
+{
+    _startColorRend.a = opacity / 255.0f;
+    _startColor.a = opacity;
+}
+
+uint8_t LayerRadialGradient::getStartOpacity() const
+{
+    return _startColor.a;
+}
+
+void LayerRadialGradient::setEndOpacity(uint8_t opacity)
+{
+    _endColorRend.a = opacity / 255.0f;
+    _endColor.a = opacity;
+}
+
+uint8_t LayerRadialGradient::getEndOpacity() const
+{
+    return _endColor.a;
+}
+
+void LayerRadialGradient::setRadius(float radius)
+{
+    _radius = radius;
+}
+
+float LayerRadialGradient::getRadius() const
+{
+    return _radius;
+}
+
+void LayerRadialGradient::setCenter(const Vec2& center)
+{
+    _center = center;
+}
+
+Vec2 LayerRadialGradient::getCenter() const
+{
+    return _center;
+}
+
+void LayerRadialGradient::setExpand(float expand)
+{
+    _expand = expand;
+}
+
+float LayerRadialGradient::getExpand() const
+{
+    return _expand;
+}
+
+void LayerRadialGradient::setStartColor(const Color3B& color)
+{
+    setStartColor(Color4B(color));
+}
+
+void LayerRadialGradient::setStartColor(const cocos2d::Color4B &color)
+{
+    _startColor = color;
+    convertColor4B24F(_startColorRend, _startColor);
+}
+
+Color4B LayerRadialGradient::getStartColor() const
+{
+    return _startColor;
+}
+
+Color3B LayerRadialGradient::getStartColor3B() const
+{
+    return Color3B(_startColor);
+}
+
+void LayerRadialGradient::setEndColor(const Color3B& color)
+{
+    setEndColor(Color4B(color));
+}
+
+void LayerRadialGradient::setEndColor(const cocos2d::Color4B &color)
+{
+    _endColor = color;
+    convertColor4B24F(_endColorRend, _endColor);
+}
+
+Color4B LayerRadialGradient::getEndColor() const
+{
+    return _endColor;
+}
+
+Color3B LayerRadialGradient::getEndColor3B() const
+{
+    return Color3B(_endColor);
+}
+
+void LayerRadialGradient::setBlendFunc(const BlendFunc& blendFunc)
+{
+    _blendFunc = blendFunc;
+}
+
+BlendFunc LayerRadialGradient::getBlendFunc() const
+{
+    return _blendFunc;
+}
+
+void LayerRadialGradient::convertColor4B24F(Color4F& outColor, const Color4B& inColor)
+{
+    outColor.r = inColor.r / 255.0f;
+    outColor.g = inColor.g / 255.0f;
+    outColor.b = inColor.b / 255.0f;
+    outColor.a = inColor.a / 255.0f;
+}
+
+
+/// MultiplexLayer
+
+LayerMultiplex::LayerMultiplex()
+: _enabledLayer(0)
+{
+}
+
+LayerMultiplex::~LayerMultiplex()
+{
+    for(const auto &layer : _layers) {
+        layer->cleanup();
+    }
+}
+
+LayerMultiplex * LayerMultiplex::create(Layer * layer, ...)
 {
     va_list args;
-    va_start(args, layer);
+    va_start(args,layer);
 
-    LayerMultiplex* multiplexLayer = new (std::nothrow) LayerMultiplex();
-    if (multiplexLayer && multiplexLayer->initWithLayers(layer, args))
+    LayerMultiplex * multiplexLayer = new (std::nothrow) LayerMultiplex();
+    if(multiplexLayer && multiplexLayer->initWithLayers(layer, args))
     {
         multiplexLayer->autorelease();
         va_end(args);
@@ -797,9 +929,8 @@ LayerMultiplex* LayerMultiplex::create(Layer* layer, ...)
     CC_SAFE_DELETE(multiplexLayer);
     return nullptr;
 }
-#endif
 
-LayerMultiplex* LayerMultiplex::createWithLayer(Layer* layer)
+LayerMultiplex * LayerMultiplex::createWithLayer(Layer* layer)
 {
     return LayerMultiplex::create(layer, nullptr);
 }
@@ -854,7 +985,7 @@ bool LayerMultiplex::init()
     return false;
 }
 
-bool LayerMultiplex::initWithLayers(Layer* layer, va_list params)
+bool LayerMultiplex::initWithLayers(Layer *layer, va_list params)
 {
     if (Layer::init())
     {
@@ -868,9 +999,8 @@ bool LayerMultiplex::initWithLayers(Layer* layer, va_list params)
 #endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
         _layers.pushBack(layer);
 
-        Layer* l = va_arg(params, Layer*);
-        while (l)
-        {
+        Layer *l = va_arg(params,Layer*);
+        while( l ) {
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
             if (sEngine)
             {
@@ -878,7 +1008,7 @@ bool LayerMultiplex::initWithLayers(Layer* layer, va_list params)
             }
 #endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
             _layers.pushBack(l);
-            l = va_arg(params, Layer*);
+            l = va_arg(params,Layer*);
         }
 
         _enabledLayer = 0;
@@ -897,7 +1027,7 @@ bool LayerMultiplex::initWithArray(const Vector<Layer*>& arrayOfLayers)
         auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
         if (sEngine)
         {
-            for (const auto& layer : arrayOfLayers)
+            for (const auto &layer : arrayOfLayers)
             {
                 if (layer)
                 {
@@ -918,18 +1048,24 @@ bool LayerMultiplex::initWithArray(const Vector<Layer*>& arrayOfLayers)
 
 void LayerMultiplex::switchTo(int n)
 {
-    CCASSERT(n < _layers.size(), "Invalid index in MultiplexLayer switchTo message");
-
-    this->removeChild(_layers.at(_enabledLayer), true);
+    
+    switchTo(n, true);
+}
 
+void LayerMultiplex::switchTo(int n, bool cleanup)
+{
+    CCASSERT( n < _layers.size(), "Invalid index in MultiplexLayer switchTo message" );
+    
+    this->removeChild(_layers.at(_enabledLayer), cleanup);
+    
     _enabledLayer = n;
-
+    
     this->addChild(_layers.at(n));
 }
 
 void LayerMultiplex::switchToAndReleaseMe(int n)
 {
-    CCASSERT(n < _layers.size(), "Invalid index in MultiplexLayer switchTo message");
+    CCASSERT( n < _layers.size(), "Invalid index in MultiplexLayer switchTo message" );
 
     this->removeChild(_layers.at(_enabledLayer), true);
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
@@ -939,7 +1075,7 @@ void LayerMultiplex::switchToAndReleaseMe(int n)
         sEngine->releaseScriptObject(this, _layers.at(_enabledLayer));
     }
 #endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
-
+    
     _layers.replace(_enabledLayer, nullptr);
 
     _enabledLayer = n;
diff --git a/cocos2d/cocos/2d/CCLayer.h b/cocos2d/cocos/2d/CCLayer.h
index 5eceb6be5a..a2442258fc 100644
--- a/cocos2d/cocos/2d/CCLayer.h
+++ b/cocos2d/cocos/2d/CCLayer.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,32 +25,12 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-
-#ifndef CC_2D_LAYER_H
-#define CC_2D_LAYER_H
+#pragma once
 
 #include <cocos/2d/CCNode.h>
-#include <cocos/base/CCEventKeyboard.h>
-#include <cocos/base/CCEventTouch.h>
 #include <cocos/base/CCProtocols.h>
-#include <cocos/base/CCTouch.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformConfig.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 #include <cocos/renderer/CCCustomCommand.h>
 
-#if CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN
-#    include <cocos/2d/CCGLBufferedNode.h>
-#endif
-
-#include <cstdarg>
-#include <cstdint>
-#include <string>
 #include <vector>
 
 NS_CC_BEGIN
@@ -59,16 +40,14 @@ NS_CC_BEGIN
  * @{
  */
 
-class Event;
-class EventListener;
-class EventListenerAcceleration;
-class EventListenerKeyboard;
-class Mat4;
-class Renderer;
-template <typename T>
-class Vector;
 class __Set;
-struct Acceleration;
+class TouchScriptHandlerEntry;
+
+class EventListenerTouch;
+class EventListenerKeyboard;
+class EventListenerAcceleration;
+
+class Touch;
 
 //
 // Layer
@@ -81,32 +60,16 @@ All features from Node are valid, plus the following new features:
 - It can receive Accelerometer input
 */
 class CC_DLL Layer : public Node
-#if CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN
-,
-                     public GLBufferedNode
-#endif
 {
-public:
+public:    
     /** Creates a fullscreen black layer.
      *
      * @return An autoreleased Layer object.
      */
-    static Layer* create();
-
-    // Deprecated touch callbacks.
-    CC_DEPRECATED_ATTRIBUTE virtual bool ccTouchBegan(Touch*, Event*) final { return false; }
-    CC_DEPRECATED_ATTRIBUTE virtual void ccTouchMoved(Touch*, Event*) final {}
-    CC_DEPRECATED_ATTRIBUTE virtual void ccTouchEnded(Touch*, Event*) final {}
-    CC_DEPRECATED_ATTRIBUTE virtual void ccTouchCancelled(Touch*, Event*) final {}
-
-    CC_DEPRECATED_ATTRIBUTE virtual void ccTouchesBegan(__Set*, Event*) final {}
-    CC_DEPRECATED_ATTRIBUTE virtual void ccTouchesMoved(__Set*, Event*) final {}
-    CC_DEPRECATED_ATTRIBUTE virtual void ccTouchesEnded(__Set*, Event*) final {}
-    CC_DEPRECATED_ATTRIBUTE virtual void ccTouchesCancelled(__Set*, Event*) final {}
-
+    static Layer *create();
+    
     /* Callback function should not be deprecated, it will generate lots of warnings.
-       Since 'setTouchEnabled' was deprecated, it will make warnings if developer overrides onTouchXXX and invokes setTouchEnabled(true) instead of using
-       EventDispatcher::addEventListenerWithXXX.
+       Since 'setTouchEnabled' was deprecated, it will make warnings if developer overrides onTouchXXX and invokes setTouchEnabled(true) instead of using EventDispatcher::addEventListenerWithXXX.
     */
     /** Callback function for touch began.
      *
@@ -115,66 +78,60 @@ public:
      * @return if return false, onTouchMoved, onTouchEnded, onTouchCancelled will never called.
      * @js NA
      */
-    virtual bool onTouchBegan(Touch* touch, Event* unused_event);
+    virtual bool onTouchBegan(Touch *touch, Event *unused_event);
     /** Callback function for touch moved.
-     *
-     * @param touch Touch information.
-     * @param unused_event Event information.
-     * @js NA
-     */
-    virtual void onTouchMoved(Touch* touch, Event* unused_event);
+    *
+    * @param touch Touch information.
+    * @param unused_event Event information.
+    * @js NA
+    */
+    virtual void onTouchMoved(Touch *touch, Event *unused_event);
     /** Callback function for touch ended.
-     *
-     * @param touch Touch information.
-     * @param unused_event Event information.
-     * @js NA
-     */
-    virtual void onTouchEnded(Touch* touch, Event* unused_event);
+    *
+    * @param touch Touch information.
+    * @param unused_event Event information.
+    * @js NA
+    */
+    virtual void onTouchEnded(Touch *touch, Event *unused_event);
     /** Callback function for touch cancelled.
-     *
-     * @param touch Touch information.
-     * @param unused_event Event information.
-     * @js NA
-     */
-    virtual void onTouchCancelled(Touch* touch, Event* unused_event);
+    *
+    * @param touch Touch information.
+    * @param unused_event Event information.
+    * @js NA
+    */
+    virtual void onTouchCancelled(Touch *touch, Event *unused_event);
 
     /** Callback function for multiple touches began.
-     *
-     * @param touches Touches information.
-     * @param unused_event Event information.
-     * @js NA
-     */
-    virtual void onTouchesBegan(const std::vector<Touch*>& touches, Event* unused_event);
+    *
+    * @param touches Touches information.
+    * @param unused_event Event information.
+    * @js NA
+    */
+    virtual void onTouchesBegan(const std::vector<Touch*>& touches, Event *unused_event);
     /** Callback function for multiple touches moved.
-     *
-     * @param touches Touches information.
-     * @param unused_event Event information.
-     * @js NA
-     */
-    virtual void onTouchesMoved(const std::vector<Touch*>& touches, Event* unused_event);
+    *
+    * @param touches Touches information.
+    * @param unused_event Event information.
+    * @js NA
+    */
+    virtual void onTouchesMoved(const std::vector<Touch*>& touches, Event *unused_event);
     /** Callback function for multiple touches ended.
-     *
-     * @param touches Touches information.
-     * @param unused_event Event information.
-     * @js NA
-     */
-    virtual void onTouchesEnded(const std::vector<Touch*>& touches, Event* unused_event);
+    *
+    * @param touches Touches information.
+    * @param unused_event Event information.
+    * @js NA
+    */
+    virtual void onTouchesEnded(const std::vector<Touch*>& touches, Event *unused_event);
     /** Callback function for multiple touches cancelled.
-     *
-     * @param touches Touches information.
-     * @param unused_event Event information.
-     * @js NA
-     */
-    virtual void onTouchesCancelled(const std::vector<Touch*>& touches, Event* unused_event);
-    /**
-      @deprecated Please override onAcceleration
-      @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE virtual void didAccelerate(Acceleration* accelerationValue) final {}
+    *
+    * @param touches Touches information.
+    * @param unused_event Event information.
+    * @js NA
+    */
+    virtual void onTouchesCancelled(const std::vector<Touch*>&touches, Event *unused_event);
 
-    /* Callback function should not be deprecated, it will generate lots of warnings.
-    Since 'setAccelerometerEnabled' was deprecated, it will make warnings if developer overrides onAcceleration and invokes setAccelerometerEnabled(true)
-    instead of using EventDispatcher::addEventListenerWithXXX.
+	/* Callback function should not be deprecated, it will generate lots of warnings.
+	Since 'setAccelerometerEnabled' was deprecated, it will make warnings if developer overrides onAcceleration and invokes setAccelerometerEnabled(true) instead of using EventDispatcher::addEventListenerWithXXX.
     */
     /** Callback function for acceleration.
      * @param acc Acceleration information.
@@ -183,71 +140,9 @@ public:
      */
     virtual void onAcceleration(Acceleration* acc, Event* unused_event);
 
-    /** If isTouchEnabled, this method is called onEnter. Override it to change the
-    way Layer receives touch events.
-    ( Default: TouchDispatcher::sharedDispatcher()->addStandardDelegate(this,0); )
-    Example:
-    void Layer::registerWithTouchDispatcher()
-    {
-    TouchDispatcher::sharedDispatcher()->addTargetedDelegate(this,INT_MIN+1,true);
-    }
-    @since v0.8.0
-    @js NA
-    */
-    CC_DEPRECATED_ATTRIBUTE virtual void registerWithTouchDispatcher() final {}
-
-    /** whether or not it will receive Touch events.
-    You can enable / disable touch events with this property.
-    Only the touches of this node will be affected. This "method" is not propagated to it's children.
-    @since v0.8.1
-    @js NA
-    */
-    CC_DEPRECATED_ATTRIBUTE bool isTouchEnabled() const;
-    CC_DEPRECATED_ATTRIBUTE void setTouchEnabled(bool value);
-
-    CC_DEPRECATED_ATTRIBUTE virtual void setTouchMode(Touch::DispatchMode mode);
-    CC_DEPRECATED_ATTRIBUTE virtual Touch::DispatchMode getTouchMode() const;
-
-    /**
-      swallowsTouches of the touch events. Default is true
-      @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE virtual void setSwallowsTouches(bool swallowsTouches);
-    CC_DEPRECATED_ATTRIBUTE virtual bool isSwallowsTouches() const;
 
-    /** whether or not it will receive Accelerometer events
-    You can enable / disable accelerometer events with this property.
-    @since v0.8.1
-    @js NA
-    */
-    CC_DEPRECATED_ATTRIBUTE virtual bool isAccelerometerEnabled() const;
-    CC_DEPRECATED_ATTRIBUTE virtual void setAccelerometerEnabled(bool value);
-    CC_DEPRECATED_ATTRIBUTE virtual void setAccelerometerInterval(double interval);
-
-    /** whether or not it will receive keyboard or keypad events
-    You can enable / disable accelerometer events with this property.
-    it's new in cocos2d-x
-    @js NA
-    */
-
-    CC_DEPRECATED_ATTRIBUTE bool isKeyboardEnabled() const;
-    CC_DEPRECATED_ATTRIBUTE void setKeyboardEnabled(bool value);
-
-    /**
-      Please use onKeyPressed instead.
-      @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE virtual void keyPressed(int keyCode) final {}
-
-    /**
-      Please use onKeyReleased instead.
-      @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE virtual void keyReleased(int keyCode) final {}
-
-    /* Callback function should not be deprecated, it will generate lots of warnings.
-    Since 'setKeyboardEnabled' was deprecated, it will make warnings if developer overrides onKeyXXX and invokes setKeyboardEnabled(true) instead of using
-    EventDispatcher::addEventListenerWithXXX.
+	/* Callback function should not be deprecated, it will generate lots of warnings.
+	Since 'setKeyboardEnabled' was deprecated, it will make warnings if developer overrides onKeyXXX and invokes setKeyboardEnabled(true) instead of using EventDispatcher::addEventListenerWithXXX.
     */
     /** Callback function for key pressed.
      * @param keyCode KeyCode information.
@@ -256,37 +151,25 @@ public:
      */
     virtual void onKeyPressed(EventKeyboard::KeyCode keyCode, Event* event);
     /** Callback function for key released.
-     * @param keyCode KeyCode information.
-     * @param event Event information.
-     * @js NA
-     */
+    * @param keyCode KeyCode information.
+    * @param event Event information.
+    * @js NA
+    */
     virtual void onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event);
 
-    CC_DEPRECATED_ATTRIBUTE virtual bool isKeypadEnabled() const final { return _keyboardEnabled; }
-    CC_DEPRECATED_ATTRIBUTE void setKeypadEnabled(bool value);
-
-    /**
-      @deprecated Please override onKeyReleased and check the keycode of KeyboardEvent::KeyCode::Menu(KEY_BACKSPACE) instead.
-      @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE virtual void keyBackClicked() final {}
-    CC_DEPRECATED_ATTRIBUTE virtual void keyMenuClicked() final {}
-
     // Overrides
-    std::string getDescription() const override;
+    virtual std::string getDescription() const override;
 
-    CC_CONSTRUCTOR_ACCESS : Layer();
-    ~Layer() override;
+CC_CONSTRUCTOR_ACCESS:
+    Layer();
+    virtual ~Layer();
 
-    bool init() override;
+    virtual bool init() override;
 
 protected:
-    // add the api for avoid use deprecated api
-    CC_DEPRECATED_ATTRIBUTE void _addTouchListener() {}
-
-    CC_DEPRECATED_ATTRIBUTE void addTouchListener() {}
-    CC_DEPRECATED_ATTRIBUTE int executeScriptTouchHandler(EventTouch::EventCode eventType, Touch* touch, Event* event);
-    CC_DEPRECATED_ATTRIBUTE int executeScriptTouchesHandler(EventTouch::EventCode eventType, const std::vector<Touch*>& touches, Event* event);
+    
+    int executeScriptTouchHandler(EventTouch::EventCode eventType, Touch* touch, Event* event);
+    int executeScriptTouchesHandler(EventTouch::EventCode eventType, const std::vector<Touch*>& touches, Event* event);
 
     bool _touchEnabled;
     bool _accelerometerEnabled;
@@ -299,48 +182,8 @@ protected:
     bool _swallowsTouches;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(Layer)
-};
-
-/** @class __LayerRGBA
- * @brief LayerRGBA is a subclass of Layer that implements the RGBAProtocol protocol using a solid color as the background.
+    CC_DISALLOW_COPY_AND_ASSIGN(Layer);
 
- All features from Layer are valid, plus the following new features that propagate into children that conform to the RGBAProtocol:
- - opacity
- - RGB colors
- @since 2.1
- @js NA
- */
-class CC_DLL __LayerRGBA : public Layer, public __RGBAProtocol
-{
-public:
-    CREATE_FUNC(__LayerRGBA)
-
-    //
-    // Overrides
-    //
-    inline GLubyte getOpacity() const override { return Layer::getOpacity(); }
-    inline GLubyte getDisplayedOpacity() const override { return Layer::getDisplayedOpacity(); }
-    inline void setOpacity(GLubyte opacity) override { Layer::setOpacity(opacity); }
-    inline void updateDisplayedOpacity(GLubyte parentOpacity) override { Layer::updateDisplayedOpacity(parentOpacity); }
-    inline bool isCascadeOpacityEnabled() const override { return Layer::isCascadeOpacityEnabled(); }
-    inline void setCascadeOpacityEnabled(bool cascadeOpacityEnabled) override { Layer::setCascadeOpacityEnabled(cascadeOpacityEnabled); }
-
-    inline const Color3B& getColor() const override { return Layer::getColor(); }
-    inline const Color3B& getDisplayedColor() const override { return Layer::getDisplayedColor(); }
-    inline void setColor(const Color3B& color) override { Layer::setColor(color); }
-    inline void updateDisplayedColor(const Color3B& parentColor) override { Layer::updateDisplayedColor(parentColor); }
-    inline bool isCascadeColorEnabled() const override { return Layer::isCascadeOpacityEnabled(); }
-    inline void setCascadeColorEnabled(bool cascadeColorEnabled) override { Layer::setCascadeColorEnabled(cascadeColorEnabled); }
-
-    inline void setOpacityModifyRGB(bool bValue) override { Layer::setOpacityModifyRGB(bValue); }
-    inline bool isOpacityModifyRGB() const override { return Layer::isOpacityModifyRGB(); }
-
-    CC_CONSTRUCTOR_ACCESS : __LayerRGBA();
-    ~__LayerRGBA() override;
-
-private:
-    CC_DISALLOW_COPY_AND_ASSIGN(__LayerRGBA)
 };
 
 //
@@ -356,6 +199,7 @@ All features from Layer are valid, plus the following new features:
 class CC_DLL LayerColor : public Layer, public BlendProtocol
 {
 public:
+
     /** Creates a fullscreen black layer.
      *
      * @return An autoreleased LayerColor object.
@@ -368,74 +212,76 @@ public:
      * @param height The height of layer.
      * @return An autoreleased LayerColor object.
      */
-    static LayerColor* create(const Color4B& color, GLfloat width, GLfloat height);
+    static LayerColor * create(const Color4B& color, float width, float height);
     /** Creates a Layer with color. Width and height are the window size.
      *
      * @param color The color of layer.
      * @return An autoreleased LayerColor object.
      */
-    static LayerColor* create(const Color4B& color);
+    static LayerColor * create(const Color4B& color);
 
     /** Change width in Points.
-     *
+     * 
      * @param w The width of layer.
      */
-    void changeWidth(GLfloat w);
+    void changeWidth(float w);
     /** Change height in Points.
      *
      * @param h The height of layer.
      */
-    void changeHeight(GLfloat h);
+    void changeHeight(float h);
     /** Change width and height in Points.
-     *
+     * 
      * @param w The width of layer.
      * @param h The Height of layer.
     @since v0.8
     */
-    void changeWidthAndHeight(GLfloat w, GLfloat h);
+    void changeWidthAndHeight(float w, float h);
 
     //
     // Overrides
     //
-    void draw(Renderer* renderer, const Mat4& transform, std::uint32_t flags) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
-    void setContentSize(const Size& var) override;
+    virtual void setContentSize(const Size & var) override;
     /** BlendFunction. Conforms to BlendProtocol protocol */
     /**
-     * @lua NA
-     */
-    const BlendFunc& getBlendFunc() const override;
+    * @lua NA
+    */
+    virtual const BlendFunc& getBlendFunc() const override;
     /**
-     *@code
-     *When this function bound into js or lua,the parameter will be changed
-     *In js: var setBlendFunc(var src, var dst)
-     *In lua: local setBlendFunc(local src, local dst)
-     *@endcode
-     */
-    void setBlendFunc(const BlendFunc& blendFunc) override;
-
-    std::string getDescription() const override;
-
-    CC_CONSTRUCTOR_ACCESS : LayerColor();
-    ~LayerColor() override;
-
+    *@code
+    *When this function bound into js or lua,the parameter will be changed
+    *In js: var setBlendFunc(var src, var dst)
+    *In lua: local setBlendFunc(local src, local dst)
+    *@endcode
+    */
+    virtual void setBlendFunc(const BlendFunc& blendFunc) override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    LayerColor();
+    virtual ~LayerColor();
+    
     bool init() override;
-    bool initWithColor(const Color4B& color, GLfloat width, GLfloat height);
+    bool initWithColor(const Color4B& color, float width, float height);
     bool initWithColor(const Color4B& color);
 
 protected:
-    void onDraw(const Mat4& transform, std::uint32_t flags);
 
-    void updateColor() override;
+    virtual void updateColor() override;
+    void updateVertexBuffer();
 
     BlendFunc _blendFunc;
     Vec2 _squareVertices[4];
-    Color4F _squareColors[4];
     CustomCommand _customCommand;
-    Vec3 _noMVPVertices[4];
 
+    V3F_C4F _vertexData[4];
+    
+    backend::UniformLocation _mvpMatrixLocation;
+    backend::ProgramState* _programState = nullptr;
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(LayerColor)
+    CC_DISALLOW_COPY_AND_ASSIGN(LayerColor);
+
 };
 
 //
@@ -486,7 +332,7 @@ public:
      * @return An autoreleased LayerGradient object.
      */
     static LayerGradient* create(const Color4B& start, const Color4B& end, const Vec2& v);
-
+    
     /** Whether or not the interpolation will be compressed in order to display all the colors of the gradient both in canonical and non canonical vectors.
      Default: true.
      *
@@ -500,10 +346,10 @@ public:
     bool isCompressedInterpolation() const;
 
     /** Sets the start color of the gradient.
-     *
+     * 
      * @param startColor The start color.
      */
-    void setStartColor(const Color3B& startColor);
+    void setStartColor( const Color3B& startColor );
     /** Returns the start color of the gradient.
      *
      * @return The start color.
@@ -514,7 +360,7 @@ public:
      *
      * @param endColor The end color.
      */
-    void setEndColor(const Color3B& endColor);
+    void setEndColor( const Color3B& endColor );
     /** Returns the end color of the gradient.
      *
      * @return The end color.
@@ -525,26 +371,26 @@ public:
      *
      * @param startOpacity The start opacity, from 0 to 255.
      */
-    void setStartOpacity(GLubyte startOpacity);
+    void setStartOpacity(uint8_t startOpacity );
     /** Returns the start opacity of the gradient.
      *
      * @return The start opacity.
      */
-    GLubyte getStartOpacity() const;
+    uint8_t getStartOpacity() const;
 
     /** Returns the end opacity of the gradient.
      *
      * @param endOpacity The end opacity, from 0 to 255.
      */
-    void setEndOpacity(GLubyte endOpacity);
+    void setEndOpacity(uint8_t endOpacity );
     /** Returns the end opacity of the gradient.
      *
      * @return The end opacity.
      */
-    GLubyte getEndOpacity() const;
+    uint8_t getEndOpacity() const;
 
     /** Sets the directional vector that will be used for the gradient.
-    The default value is vertical direction (0,-1).
+    The default value is vertical direction (0,-1). 
      *
      * @param alongVector The direction of gradient.
      */
@@ -555,18 +401,19 @@ public:
      */
     const Vec2& getVector() const;
 
-    std::string getDescription() const override;
-
-    CC_CONSTRUCTOR_ACCESS : LayerGradient();
-    ~LayerGradient() override;
-
-    bool init() override;
+    virtual std::string getDescription() const override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    LayerGradient();
+    virtual ~LayerGradient();
+    
+    virtual bool init() override;
     /** Initializes the Layer with a gradient between start and end.
      * @js init
      * @lua init
      */
     bool initWithColor(const Color4B& start, const Color4B& end);
-
+    
     /** Initializes the Layer with a gradient between start and end in the direction of v.
      * @js init
      * @lua init
@@ -574,16 +421,102 @@ public:
     bool initWithColor(const Color4B& start, const Color4B& end, const Vec2& v);
 
 protected:
-    void updateColor() override;
-
-    Color3B _startColor;
-    Color3B _endColor;
-    GLubyte _startOpacity;
-    GLubyte _endOpacity;
-    Vec2 _alongVector;
-    bool _compressedInterpolation;
+    virtual void updateColor() override;
+
+    Color3B _startColor = Color3B::BLACK;
+    Color3B _endColor = Color3B::BLACK;
+    uint8_t _startOpacity = 255;
+    uint8_t _endOpacity = 255;
+    Vec2   _alongVector = {0.0f, -1.0f};
+    bool    _compressedInterpolation = true;
 };
 
+
+/** @class LayerRadialGradient
+ * @brief LayerRadialGradient is a subclass of Layer that draws radial gradients across the background.
+ @since v3.16
+ */
+class CC_DLL LayerRadialGradient : public Layer
+{
+public:
+    /** Create a LayerRadialGradient
+     * @param startColor the inner color of the gradient
+     * @param endColor the out color of the gradient
+     * @param radius the radius of the gradient(length from center of gradient to outer color)
+     * @param center the position of the center of the gradient
+     * @param expand an alpha value(0.f-1.f) that specifies how much of that radius in only inner color(the gradient
+                     starts outside of that amount)
+     */
+    static LayerRadialGradient* create(const Color4B& startColor, const Color4B& endColor, float radius, const Vec2& center, float expand);
+    static LayerRadialGradient* create();
+    
+    //
+    // overrides
+    //
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
+    virtual void setContentSize(const Size& size) override;
+    
+    void setStartOpacity(uint8_t opacity);
+    uint8_t getStartOpacity() const;
+    
+    void setEndOpacity(uint8_t opacity);
+    uint8_t getEndOpacity() const;
+    
+    void setRadius(float radius);
+    float getRadius() const;
+    
+    void setCenter(const Vec2& center);
+    Vec2 getCenter() const;
+    
+    void setExpand(float expand);
+    float getExpand() const;
+    
+    void setStartColor(const Color3B& color);
+    void setStartColor(const Color4B& color);
+    Color4B getStartColor() const;
+    Color3B getStartColor3B() const;
+    
+    void setEndColor(const Color3B& color);
+    void setEndColor(const Color4B& color);
+    Color4B getEndColor() const;
+    Color3B getEndColor3B() const;
+    
+    void setBlendFunc(const BlendFunc& blendFunc);
+    BlendFunc getBlendFunc() const;
+    
+CC_CONSTRUCTOR_ACCESS:
+    LayerRadialGradient();
+    virtual ~LayerRadialGradient();
+    
+    bool initWithColor(const Color4B& startColor, const Color4B& endColor, float radius, const Vec2& center, float expand);
+    
+private:
+    void convertColor4B24F(Color4F& outColor, const Color4B& inColor);
+    
+    Color4B _startColor = Color4B::BLACK;
+    Color4F _startColorRend = Color4F::BLACK; // start color used in shader
+    
+    Color4B _endColor = Color4B::BLACK;
+    Color4F _endColorRend = Color4F::BLACK; // end color used in shader
+
+    Vec2 _vertices[4];
+    Vec2 _center;
+    float _radius = 0.f;
+    float _expand = 0.f;
+    CustomCommand _customCommand;
+    
+    BlendFunc _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
+    
+    backend::UniformLocation _mvpMatrixLocation;
+    backend::UniformLocation _startColorLocation;
+    backend::UniformLocation _endColorLocation;
+    backend::UniformLocation _centerLocation;
+    backend::UniformLocation _radiusLocation;
+    backend::UniformLocation _expandLocation;
+    backend::ProgramState* _programState = nullptr;
+};
+
+
 /** @class LayerMultiplex
  * @brief MultipleLayer is a Layer with the ability to multiplex it's children.
 Features:
@@ -595,7 +528,7 @@ class CC_DLL LayerMultiplex : public Layer
 public:
     /** Creates and initializes a LayerMultiplex object.
      * @lua NA
-     *
+     * 
      * @return An autoreleased LayerMultiplex object.
      */
     static LayerMultiplex* create();
@@ -616,34 +549,7 @@ public:
      * In lua:local create(...)
      * @endcode
      */
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-    // VS2013 does not support nullptr in variable args lists and variadic templates are also not supported
-    typedef Layer* M;
-    static LayerMultiplex* create(M m1, std::nullptr_t listEnd) { return createVariadic(m1, NULL); }
-    static LayerMultiplex* create(M m1, M m2, std::nullptr_t listEnd) { return createVariadic(m1, m2, NULL); }
-    static LayerMultiplex* create(M m1, M m2, M m3, std::nullptr_t listEnd) { return createVariadic(m1, m2, m3, NULL); }
-    static LayerMultiplex* create(M m1, M m2, M m3, M m4, std::nullptr_t listEnd) { return createVariadic(m1, m2, m3, m4, NULL); }
-    static LayerMultiplex* create(M m1, M m2, M m3, M m4, M m5, std::nullptr_t listEnd) { return createVariadic(m1, m2, m3, m4, m5, NULL); }
-    static LayerMultiplex* create(M m1, M m2, M m3, M m4, M m5, M m6, std::nullptr_t listEnd) { return createVariadic(m1, m2, m3, m4, m5, m6, NULL); }
-    static LayerMultiplex* create(M m1, M m2, M m3, M m4, M m5, M m6, M m7, std::nullptr_t listEnd) { return createVariadic(m1, m2, m3, m4, m5, m6, m7, NULL); }
-    static LayerMultiplex* create(M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, std::nullptr_t listEnd)
-    {
-        return createVariadic(m1, m2, m3, m4, m5, m6, m7, m8, NULL);
-    }
-    static LayerMultiplex* create(M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, M m9, std::nullptr_t listEnd)
-    {
-        return createVariadic(m1, m2, m3, m4, m5, m6, m7, m8, m9, NULL);
-    }
-    static LayerMultiplex* create(M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, M m9, M m10, std::nullptr_t listEnd)
-    {
-        return createVariadic(m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, NULL);
-    }
-
-    // On WP8 for variable argument lists longer than 10 items, use createWithArray or createVariadic with NULL as the last argument
-    static LayerMultiplex* createVariadic(Layer* item, ...) CC_REQUIRES_NULL_TERMINATION;
-#else
-    static LayerMultiplex* create(Layer* layer, ...);
-#endif
+    static LayerMultiplex * create(Layer* layer, ... );
 
     /** Creates a LayerMultiplex with one layer.
      * Lua script can not init with undetermined number of variables
@@ -654,7 +560,8 @@ public:
      * @param layer A certain layer.
      * @return An autoreleased LayerMultiplex object.
      */
-    static LayerMultiplex* createWithLayer(Layer* layer);
+    static LayerMultiplex * createWithLayer(Layer* layer);
+
 
     /** Add a certain layer to LayerMultiplex.
      *
@@ -668,6 +575,9 @@ public:
      * @param n The layer indexed by n will display.
      */
     void switchTo(int n);
+    /** The same as switchTo(int), but has a parameter to set if need to clean up child.
+     */
+    void switchTo(int n, bool cleanup);
     /** release the current layer and switches to another layer indexed by n.
     The current (old) layer will be removed from it's parent with 'cleanup=true'.
      *
@@ -675,26 +585,26 @@ public:
      */
     void switchToAndReleaseMe(int n);
 
-    std::string getDescription() const override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        LayerMultiplex();
+    virtual std::string getDescription() const override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    LayerMultiplex();
     /**
      * @js NA
      * @lua NA
      */
-    ~LayerMultiplex() override;
-
-    bool init() override;
+    virtual ~LayerMultiplex();
+    
+    virtual bool init() override;
     /** initializes a MultiplexLayer with one or more layers using a variable argument list.
      * @js NA
      * @lua NA
      */
     bool initWithLayers(Layer* layer, va_list params);
-
+    
     /** initializes a MultiplexLayer with an array of layers
      @since v2.1
      */
@@ -702,15 +612,14 @@ public:
 
 protected:
     unsigned int _enabledLayer;
-    Vector<Layer*> _layers;
+    Vector<Layer*>    _layers;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(LayerMultiplex)
+    CC_DISALLOW_COPY_AND_ASSIGN(LayerMultiplex);
 };
 
+
 // end of _2d group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_LAYER_H
diff --git a/cocos2d/cocos/2d/CCLight.cpp b/cocos2d/cocos/2d/CCLight.cpp
index f70d8a7342..1a89813dfc 100644
--- a/cocos2d/cocos/2d/CCLight.cpp
+++ b/cocos2d/cocos/2d/CCLight.cpp
@@ -1,21 +1,29 @@
-#include <cocos/2d/CCLight.h>
+/****************************************************************************
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
+ http://www.cocos2d-x.org
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ THE SOFTWARE.
+ ****************************************************************************/
 
-#include <cocos/2d/CCNode.h>
+#include <cocos/2d/CCLight.h>
 #include <cocos/2d/CCScene.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <algorithm>
-#include <cmath>
-#include <new>
-#include <vector>
-
-namespace cocos2d
-{
-    struct Color3B;
-}
 
 NS_CC_BEGIN
 
@@ -30,7 +38,7 @@ void BaseLight::onEnter()
     auto scene = getScene();
     if (scene)
     {
-        auto& lights = scene->_lights;
+        auto &lights = scene->_lights;
         auto iter = std::find(lights.begin(), lights.end(), this);
         if (iter == lights.end())
             lights.push_back(this);
@@ -42,7 +50,7 @@ void BaseLight::onExit()
     auto scene = getScene();
     if (scene)
     {
-        auto& lights = scene->_lights;
+        auto &lights = scene->_lights;
         auto iter = std::find(lights.begin(), lights.end(), this);
         if (iter != lights.end())
             lights.erase(iter);
@@ -50,7 +58,7 @@ void BaseLight::onExit()
     Node::onExit();
 }
 
-void BaseLight::setRotationFromDirection(const Vec3& direction)
+void BaseLight::setRotationFromDirection( const Vec3 &direction )
 {
     float projLen = sqrt(direction.x * direction.x + direction.z * direction.z);
     float rotY = CC_RADIANS_TO_DEGREES(atan2f(-direction.x, -direction.z));
@@ -63,13 +71,16 @@ BaseLight::BaseLight()
 , _lightFlag(LightFlag::LIGHT0)
 , _enabled(true)
 {
+    
 }
 BaseLight::~BaseLight()
 {
+    
 }
 
+
 ////////////////////////////////////////////////////////////////////
-DirectionLight* DirectionLight::create(const Vec3& direction, const Color3B& color)
+DirectionLight* DirectionLight::create(const Vec3 &direction, const Color3B &color)
 {
     auto light = new (std::nothrow) DirectionLight();
     light->setRotationFromDirection(direction);
@@ -78,7 +89,7 @@ DirectionLight* DirectionLight::create(const Vec3& direction, const Color3B& col
     return light;
 }
 
-void DirectionLight::setDirection(const Vec3& dir)
+void DirectionLight::setDirection(const Vec3 &dir)
 {
     setRotationFromDirection(dir);
 }
@@ -94,13 +105,15 @@ Vec3 DirectionLight::getDirectionInWorld() const
 }
 DirectionLight::DirectionLight()
 {
+    
 }
 DirectionLight::~DirectionLight()
 {
+    
 }
 
 //////////////////////////////////////////////////////////////////
-PointLight* PointLight::create(const Vec3& position, const Color3B& color, float range)
+PointLight* PointLight::create(const Vec3 &position, const Color3B &color, float range)
 {
     auto light = new (std::nothrow) PointLight();
     light->setPosition3D(position);
@@ -112,13 +125,15 @@ PointLight* PointLight::create(const Vec3& position, const Color3B& color, float
 
 PointLight::PointLight()
 {
+    
 }
 PointLight::~PointLight()
 {
+    
 }
 
 //////////////////////////////////////////////////////////////
-SpotLight* SpotLight::create(const Vec3& direction, const Vec3& position, const Color3B& color, float innerAngle, float outerAngle, float range)
+SpotLight* SpotLight::create(const Vec3 &direction, const Vec3 &position, const Color3B &color, float innerAngle, float outerAngle, float range)
 {
     auto light = new (std::nothrow) SpotLight();
     light->setRotationFromDirection(direction);
@@ -131,7 +146,7 @@ SpotLight* SpotLight::create(const Vec3& direction, const Vec3& position, const
     return light;
 }
 
-void SpotLight::setDirection(const Vec3& dir)
+void SpotLight::setDirection(const Vec3 &dir)
 {
     setRotationFromDirection(dir);
 }
@@ -162,15 +177,17 @@ void SpotLight::setOuterAngle(float angle)
 
 SpotLight::SpotLight()
 {
+
 }
 
 SpotLight::~SpotLight()
 {
+
 }
 
 /////////////////////////////////////////////////////////////
 
-AmbientLight* AmbientLight::create(const Color3B& color)
+AmbientLight* AmbientLight::create( const Color3B &color )
 {
     auto light = new (std::nothrow) AmbientLight();
     light->setColor(color);
@@ -180,10 +197,12 @@ AmbientLight* AmbientLight::create(const Color3B& color)
 
 AmbientLight::AmbientLight()
 {
+
 }
 
 AmbientLight::~AmbientLight()
 {
+
 }
 
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCLight.h b/cocos2d/cocos/2d/CCLight.h
index 9fc5814c0c..0a977ae417 100644
--- a/cocos2d/cocos/2d/CCLight.h
+++ b/cocos2d/cocos/2d/CCLight.h
@@ -1,5 +1,6 @@
 /****************************************************************************
- Copyright (c) 2014 Chukong Technologies Inc.
+ Copyright (c) 2014-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
  http://www.cocos2d-x.org
 
@@ -22,19 +23,13 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_LIGHT_H
-#define CC_2D_LIGHT_H
+#ifndef __CCLIGHT_H__
+#define __CCLIGHT_H__
 
 #include <cocos/2d/CCNode.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 
 NS_CC_BEGIN
 
-struct Color3B;
-
 enum class LightType
 {
     DIRECTIONAL = 0,
@@ -69,40 +64,42 @@ enum class LightFlag
 class CC_DLL BaseLight : public Node
 {
 public:
+    
     /**
      * Get the light type,light type MUST be one of LightType::DIRECTIONAL ,
      * LightType::POINT, LightType::SPOT, LightType::AMBIENT.
      */
     virtual LightType getLightType() const = 0;
-
+    
     /** intensity getter and setter */
     float getIntensity() const { return _intensity; }
     void setIntensity(float intensity);
-
+    
     /**light flag getter and setter*/
     LightFlag getLightFlag() const { return _lightFlag; }
     void setLightFlag(LightFlag flag) { _lightFlag = flag; }
-
+    
     /**
      * light enabled getter and setter.
      */
     void setEnabled(bool enabled) { _enabled = enabled; }
     bool isEnabled() const { return _enabled; }
-
-    // override
+    
+    //override
     virtual void onEnter() override;
     virtual void onExit() override;
-
-    CC_CONSTRUCTOR_ACCESS : BaseLight();
-    ~BaseLight() override;
-
+    
+CC_CONSTRUCTOR_ACCESS:
+    BaseLight();
+    virtual ~BaseLight();
+    
 protected:
-    void setRotationFromDirection(const Vec3& direction);
-
+    void setRotationFromDirection( const Vec3 &direction );
+    
 protected:
-    float _intensity;
-    LightFlag _lightFlag;
-    bool _enabled;
+    float       _intensity;
+    LightFlag   _lightFlag;
+    bool        _enabled;
 };
 
 /**
@@ -118,30 +115,32 @@ public:
      *
      * @return The new direction light.
      */
-    static DirectionLight* create(const Vec3& direction, const Color3B& color);
-
-    // get light type
+    static DirectionLight* create(const Vec3 &direction, const Color3B &color);
+    
+    //get light type
     virtual LightType getLightType() const override { return LightType::DIRECTIONAL; }
-
+    
     /**
      * Sets the Direction in parent.
      *
      * @param dir The Direction in parent.
      */
-    void setDirection(const Vec3& dir);
-
+    void setDirection(const Vec3 &dir);
+    
     /**
      * Returns the Direction in parent.
      */
     Vec3 getDirection() const;
-
+    
     /**
      * Returns direction in world.
      */
     Vec3 getDirectionInWorld() const;
-
-    CC_CONSTRUCTOR_ACCESS : DirectionLight();
-    ~DirectionLight() override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    DirectionLight();
+    virtual ~DirectionLight();
+    
 };
 
 /**
@@ -158,18 +157,19 @@ public:
      *
      * @return The new point light.
      */
-    static PointLight* create(const Vec3& position, const Color3B& color, float range);
-
-    // get light type
+    static PointLight* create(const Vec3 &position, const Color3B &color, float range);
+    
+    //get light type
     virtual LightType getLightType() const override { return LightType::POINT; }
-
+    
     /** get or set range */
     float getRange() const { return _range; }
     void setRange(float range) { _range = range; }
-
-    CC_CONSTRUCTOR_ACCESS : PointLight();
-    ~PointLight() override;
-
+    
+CC_CONSTRUCTOR_ACCESS:
+    PointLight();
+    virtual ~PointLight();
+    
 protected:
     float _range;
 };
@@ -191,35 +191,35 @@ public:
      *
      * @return The new spot light.
      */
-    static SpotLight* create(const Vec3& direction, const Vec3& position, const Color3B& color, float innerAngle, float outerAngle, float range);
-
-    // get light type
+    static SpotLight* create(const Vec3 &direction, const Vec3 &position, const Color3B &color, float innerAngle, float outerAngle, float range);
+    
+    //get light type
     virtual LightType getLightType() const override { return LightType::SPOT; }
-
+    
     /**
      * Sets the Direction in parent.
      *
      * @param dir The Direction in parent.
      */
-    void setDirection(const Vec3& dir);
-
+    void setDirection(const Vec3 &dir);
+    
     /**
      * Returns the Direction in parent.
      */
     Vec3 getDirection() const;
-
+    
     /**
      * Returns direction in world.
      */
     Vec3 getDirectionInWorld() const;
-
+    
     /**
      * Sets the range of point or spot light.
      *
      * @param range The range of point or spot light.
      */
     void setRange(float range) { _range = range; }
-
+    
     /**
      * Returns the range of point or spot light.
      *
@@ -232,33 +232,34 @@ public:
      * @param angle The angle of spot light (in radians).
      */
     void setInnerAngle(float angle);
-
+    
     /**
      * Returns the inner angle the spot light (in radians).
      */
     float getInnerAngle() const { return _innerAngle; }
-
+    
     /** get cos innerAngle */
     float getCosInnerAngle() const { return _cosInnerAngle; }
-
+    
     /**
      * Sets the outer angle of a spot light (in radians).
      *
      * @param outerAngle The angle of spot light (in radians).
      */
     void setOuterAngle(float outerAngle);
-
+    
     /**
      * Returns the outer angle of the spot light (in radians).
      */
     float getOuterAngle() const { return _outerAngle; }
-
+    
     /** get cos outAngle */
     float getCosOuterAngle() const { return _cosOuterAngle; }
-
-    CC_CONSTRUCTOR_ACCESS : SpotLight();
-    ~SpotLight() override;
-
+    
+CC_CONSTRUCTOR_ACCESS:
+    SpotLight();
+    virtual ~SpotLight();
+    
 protected:
     float _range;
     float _innerAngle;
@@ -279,15 +280,16 @@ public:
      *
      * @return The new ambient light.
      */
-    static AmbientLight* create(const Color3B& color);
-
-    // get light type
+    static AmbientLight* create(const Color3B &color);
+    
+    //get light type
     virtual LightType getLightType() const override { return LightType::AMBIENT; }
-
-    CC_CONSTRUCTOR_ACCESS : AmbientLight();
-    ~AmbientLight() override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    AmbientLight();
+    virtual ~AmbientLight();
 };
 
 NS_CC_END
 
-#endif // CC_2D_LIGHT_H
+#endif
diff --git a/cocos2d/cocos/2d/CCMenu.cpp b/cocos2d/cocos/2d/CCMenu.cpp
index cb0f014079..d3158b75c8 100644
--- a/cocos2d/cocos/2d/CCMenu.cpp
+++ b/cocos2d/cocos/2d/CCMenu.cpp
@@ -2,6 +2,7 @@
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,13 +25,13 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCMenu.h>
-
 #include <cocos/2d/CCCamera.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCEventDispatcher.h>
-#include <cocos/base/CCEventListenerTouch.h>
 #include <cocos/base/CCTouch.h>
+#include <cocos/base/CCEventListenerTouch.h>
+#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/ccUTF8.h>
+#include <cocos/platform/CCStdC.h>
 
 #include <vector>
 
@@ -38,13 +39,13 @@ using namespace std;
 
 NS_CC_BEGIN
 
-enum
+enum 
 {
-    kDefaultPadding = 5,
+    kDefaultPadding =  5,
 };
 
 //
-// CCMenu
+//CCMenu
 //
 
 Menu::~Menu()
@@ -52,37 +53,23 @@ Menu::~Menu()
     CCLOGINFO("In the destructor of Menu. %p", this);
 }
 
+
 Menu* Menu::create()
 {
     return Menu::create(nullptr, nullptr);
 }
 
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-Menu* Menu::variadicCreate(MenuItem* item, ...)
-{
-    va_list args;
-    va_start(args, item);
-
-    Menu* ret = Menu::createWithItems(item, args);
-
-    va_end(args);
-
-    return ret;
-}
-#else
-
-Menu* Menu::create(MenuItem* item, ...)
+Menu * Menu::create(MenuItem* item, ...)
 {
     va_list args;
-    va_start(args, item);
-
-    Menu* ret = Menu::createWithItems(item, args);
-
+    va_start(args,item);
+    
+    Menu *ret = Menu::createWithItems(item, args);
+    
     va_end(args);
-
+    
     return ret;
 }
-#endif
 
 Menu* Menu::createWithArray(const Vector<MenuItem*>& arrayOfItems)
 {
@@ -95,24 +82,24 @@ Menu* Menu::createWithArray(const Vector<MenuItem*>& arrayOfItems)
     {
         CC_SAFE_DELETE(ret);
     }
-
+    
     return ret;
 }
 
 Menu* Menu::createWithItems(MenuItem* item, va_list args)
 {
     Vector<MenuItem*> items;
-    if (item)
+    if( item )
     {
         items.pushBack(item);
-        MenuItem* i = va_arg(args, MenuItem*);
-        while (i)
+        MenuItem *i = va_arg(args, MenuItem*);
+        while(i)
         {
             items.pushBack(i);
             i = va_arg(args, MenuItem*);
         }
     }
-
+    
     return Menu::createWithArray(items);
 }
 
@@ -138,60 +125,61 @@ bool Menu::initWithArray(const Vector<MenuItem*>& arrayOfItems)
         setAnchorPoint(Vec2(0.5f, 0.5f));
         this->setContentSize(s);
 
-        setPosition(s.width / 2, s.height / 2);
-
-        int z = 0;
-
+        setPosition(s.width/2, s.height/2);
+        
+        int z=0;
+        
         for (auto& item : arrayOfItems)
         {
             this->addChild(item, z);
             z++;
         }
-
+    
         _selectedItem = nullptr;
         _state = Menu::State::WAITING;
-
+        
         // enable cascade color and opacity on menus
         setCascadeColorEnabled(true);
         setCascadeOpacityEnabled(true);
-
+        
+        
         auto touchListener = EventListenerTouchOneByOne::create();
         touchListener->setSwallowTouches(true);
-
-        touchListener->onTouchBegan = [this](Touch* touch, Event* evt) -> bool { return onTouchBegan(touch, evt); };
-        touchListener->onTouchMoved = [this](Touch* touch, Event* evt) { onTouchMoved(touch, evt); };
-        touchListener->onTouchEnded = [this](Touch* touch, Event* evt) { onTouchEnded(touch, evt); };
-        touchListener->onTouchCancelled = [this](Touch* touch, Event* evt) { onTouchCancelled(touch, evt); };
-
+        
+        touchListener->onTouchBegan = CC_CALLBACK_2(Menu::onTouchBegan, this);
+        touchListener->onTouchMoved = CC_CALLBACK_2(Menu::onTouchMoved, this);
+        touchListener->onTouchEnded = CC_CALLBACK_2(Menu::onTouchEnded, this);
+        touchListener->onTouchCancelled = CC_CALLBACK_2(Menu::onTouchCancelled, this);
+        
         _eventDispatcher->addEventListenerWithSceneGraphPriority(touchListener, this);
-
+        
         return true;
     }
     return false;
 }
 
 /*
- * override add:
- */
-void Menu::addChild(Node* child)
+* override add:
+*/
+void Menu::addChild(Node * child)
 {
     Layer::addChild(child);
 }
 
-void Menu::addChild(Node* child, int zOrder)
+void Menu::addChild(Node * child, int zOrder)
 {
     Layer::addChild(child, zOrder);
 }
 
-void Menu::addChild(Node* child, int zOrder, int tag)
+void Menu::addChild(Node * child, int zOrder, int tag)
 {
-    CCASSERT(dynamic_cast<MenuItem*>(child) != nullptr, "Menu only supports MenuItem objects as children");
+    CCASSERT( dynamic_cast<MenuItem*>(child) != nullptr, "Menu only supports MenuItem objects as children");
     Layer::addChild(child, zOrder, tag);
 }
 
-void Menu::addChild(Node* child, int zOrder, const std::string& name)
+void Menu::addChild(Node * child, int zOrder, const std::string &name)
 {
-    CCASSERT(dynamic_cast<MenuItem*>(child) != nullptr, "Menu only supports MenuItem objects as children");
+    CCASSERT( dynamic_cast<MenuItem*>(child) != nullptr, "Menu only supports MenuItem objects as children");
     Layer::addChild(child, zOrder, name);
 }
 
@@ -204,7 +192,7 @@ void Menu::onEnter()
             return;
     }
 #endif
-
+    
     Layer::onEnter();
 }
 
@@ -217,7 +205,7 @@ void Menu::onExit()
             return;
     }
 #endif
-
+    
     if (_state == Menu::State::TRACKING_TOUCH)
     {
         if (_selectedItem)
@@ -225,7 +213,7 @@ void Menu::onExit()
             _selectedItem->unselected();
             _selectedItem = nullptr;
         }
-
+        
         _state = Menu::State::WAITING;
     }
 
@@ -235,26 +223,26 @@ void Menu::onExit()
 void Menu::removeChild(Node* child, bool cleanup)
 {
     CCASSERT(dynamic_cast<MenuItem*>(child) != nullptr, "Menu only supports MenuItem objects as children");
-
+    
     if (_selectedItem == child)
     {
         _selectedItem = nullptr;
     }
-
+    
     Node::removeChild(child, cleanup);
 }
 
-// Menu - Events
+//Menu - Events
 
-bool Menu::onTouchBegan(Touch* touch, Event* event)
+bool Menu::onTouchBegan(Touch* touch, Event* /*event*/)
 {
     auto camera = Camera::getVisitingCamera();
-    if (_state != Menu::State::WAITING || !_visible || !_enabled || !camera)
+    if (_state != Menu::State::WAITING || ! _visible || !_enabled || !camera)
     {
         return false;
     }
-
-    for (Node* c = this->_parent; c != nullptr; c = c->getParent())
+    
+    for (Node *c = this->_parent; c != nullptr; c = c->getParent())
     {
         if (c->isVisible() == false)
         {
@@ -268,14 +256,14 @@ bool Menu::onTouchBegan(Touch* touch, Event* event)
         _state = Menu::State::TRACKING_TOUCH;
         _selectedWithCamera = camera;
         _selectedItem->selected();
-
+        
         return true;
     }
-
+    
     return false;
 }
 
-void Menu::onTouchEnded(Touch* touch, Event* event)
+void Menu::onTouchEnded(Touch* /*touch*/, Event* /*event*/)
 {
     CCASSERT(_state == Menu::State::TRACKING_TOUCH, "[Menu ccTouchEnded] -- invalid state");
     this->retain();
@@ -289,7 +277,7 @@ void Menu::onTouchEnded(Touch* touch, Event* event)
     this->release();
 }
 
-void Menu::onTouchCancelled(Touch* touch, Event* event)
+void Menu::onTouchCancelled(Touch* /*touch*/, Event* /*event*/)
 {
     CCASSERT(_state == Menu::State::TRACKING_TOUCH, "[Menu ccTouchCancelled] -- invalid state");
     this->retain();
@@ -301,10 +289,10 @@ void Menu::onTouchCancelled(Touch* touch, Event* event)
     this->release();
 }
 
-void Menu::onTouchMoved(Touch* touch, Event* event)
+void Menu::onTouchMoved(Touch* touch, Event* /*event*/)
 {
     CCASSERT(_state == Menu::State::TRACKING_TOUCH, "[Menu ccTouchMoved] -- invalid state");
-    MenuItem* currentItem = this->getItemForTouch(touch, _selectedWithCamera);
+    MenuItem *currentItem = this->getItemForTouch(touch, _selectedWithCamera);
     if (currentItem != _selectedItem)
     {
         if (_selectedItem)
@@ -319,7 +307,7 @@ void Menu::onTouchMoved(Touch* touch, Event* event)
     }
 }
 
-// Menu - Alignment
+//Menu - Alignment
 void Menu::alignItemsVertically()
 {
     this->alignItemsVerticallyWithPadding(kDefaultPadding);
@@ -329,19 +317,18 @@ void Menu::alignItemsVerticallyWithPadding(float padding)
 {
     float height = -padding;
 
-    for (const auto& child : _children)
+    for(const auto &child : _children)
         height += child->getContentSize().height * child->getScaleY() + padding;
 
     float y = height / 2.0f;
-
-    for (const auto& child : _children)
-    {
+    
+    for(const auto &child : _children) {
         child->setPosition(0, y - child->getContentSize().height * child->getScaleY() / 2.0f);
         y -= child->getContentSize().height * child->getScaleY() + padding;
     }
 }
 
-void Menu::alignItemsHorizontally(void)
+void Menu::alignItemsHorizontally()
 {
     this->alignItemsHorizontallyWithPadding(kDefaultPadding);
 }
@@ -349,13 +336,12 @@ void Menu::alignItemsHorizontally(void)
 void Menu::alignItemsHorizontallyWithPadding(float padding)
 {
     float width = -padding;
-    for (const auto& child : _children)
+    for(const auto &child : _children)
         width += child->getContentSize().width * child->getScaleX() + padding;
 
     float x = -width / 2.0f;
-
-    for (const auto& child : _children)
-    {
+    
+    for(const auto &child : _children) {
         child->setPosition(x + child->getContentSize().width * child->getScaleX() / 2.0f, 0);
         x += child->getContentSize().width * child->getScaleX() + padding;
     }
@@ -391,22 +377,21 @@ void Menu::alignItemsInColumnsWithArray(const ValueVector& rows)
     int columnsOccupied = 0;
     int rowColumns = 0;
 
-    for (const auto& child : _children)
-    {
+    for(const auto &child : _children) {
         CCASSERT(row < rows.size(), "row should less than rows.size()!");
-
+        
         rowColumns = rows[row].asInt();
         // can not have zero columns on a row
         CCASSERT(rowColumns, "rowColumns can't be 0.");
-
+        
         float tmp = child->getContentSize().height;
         rowHeight = (unsigned int)((rowHeight >= tmp || isnan(tmp)) ? rowHeight : tmp);
-
+        
         ++columnsOccupied;
         if (columnsOccupied >= rowColumns)
         {
             height += rowHeight + 5;
-
+            
             columnsOccupied = 0;
             rowHeight = 0;
             ++row;
@@ -414,9 +399,9 @@ void Menu::alignItemsInColumnsWithArray(const ValueVector& rows)
     }
 
     // check if too many rows/columns for available menu items
-    CCASSERT(!columnsOccupied, "columnsOccupied should be 0.");
+    CCASSERT(! columnsOccupied, "columnsOccupied should be 0.");
 
-    Size winSize = Director::getInstance()->getWinSize();
+    Size winSize = getContentSize();
 
     row = 0;
     rowHeight = 0;
@@ -425,8 +410,7 @@ void Menu::alignItemsInColumnsWithArray(const ValueVector& rows)
     float x = 0.0;
     float y = (float)(height / 2);
 
-    for (const auto& child : _children)
-    {
+    for(const auto &child : _children) {
         if (rowColumns == 0)
         {
             rowColumns = rows[row].asInt();
@@ -437,7 +421,8 @@ void Menu::alignItemsInColumnsWithArray(const ValueVector& rows)
         float tmp = child->getContentSize().height;
         rowHeight = (unsigned int)((rowHeight >= tmp || isnan(tmp)) ? rowHeight : tmp);
 
-        child->setPosition(x - winSize.width / 2, y - child->getContentSize().height / 2);
+        child->setPosition(x - winSize.width / 2,
+                               y - child->getContentSize().height / 2);
 
         x += w;
         ++columnsOccupied;
@@ -487,8 +472,7 @@ void Menu::alignItemsInRowsWithArray(const ValueVector& columns)
     int rowsOccupied = 0;
     int columnRows;
 
-    for (const auto& child : _children)
-    {
+    for(const auto &child : _children) {
         // check if too many menu items for the amount of rows/columns
         CCASSERT(column < columns.size(), "column should be less than columns.size().");
 
@@ -517,9 +501,9 @@ void Menu::alignItemsInRowsWithArray(const ValueVector& columns)
     }
 
     // check if too many rows/columns for available menu items.
-    CCASSERT(!rowsOccupied, "rowsOccupied should be 0.");
+    CCASSERT(! rowsOccupied, "rowsOccupied should be 0.");
 
-    Size winSize = Director::getInstance()->getWinSize();
+    Size winSize = getContentSize();
 
     column = 0;
     columnWidth = 0;
@@ -527,19 +511,19 @@ void Menu::alignItemsInRowsWithArray(const ValueVector& columns)
     float x = (float)(-width / 2);
     float y = 0.0;
 
-    for (const auto& child : _children)
-    {
+    for(const auto &child : _children) {
         if (columnRows == 0)
         {
             columnRows = columns[column].asInt();
-            y = (float)columnHeights[column];
+            y = (float) columnHeights[column];
         }
 
         // columnWidth = fmaxf(columnWidth, [item contentSize].width);
         float tmp = child->getContentSize().width;
         columnWidth = (unsigned int)((columnWidth >= tmp || isnan(tmp)) ? columnWidth : tmp);
 
-        child->setPosition(x + columnWidths[column] / 2, y - winSize.height / 2);
+        child->setPosition(x + columnWidths[column] / 2,
+                               y - winSize.height / 2);
 
         y -= child->getContentSize().height + 10;
         ++rowsOccupied;
@@ -555,10 +539,10 @@ void Menu::alignItemsInRowsWithArray(const ValueVector& columns)
     }
 }
 
-MenuItem* Menu::getItemForTouch(Touch* touch, const Camera* camera)
+MenuItem* Menu::getItemForTouch(Touch *touch, const Camera *camera)
 {
     Vec2 touchLocation = touch->getLocation();
-    for (const auto& item : _children)
+    for (const auto &item: _children)
     {
         MenuItem* child = dynamic_cast<MenuItem*>(item);
         if (nullptr == child || false == child->isVisible() || false == child->isEnabled())
@@ -575,6 +559,14 @@ MenuItem* Menu::getItemForTouch(Touch* touch, const Camera* camera)
     return nullptr;
 }
 
+void Menu::setOpacityModifyRGB(bool /*value*/)
+{}
+
+bool Menu::isOpacityModifyRGB() const
+{
+    return false;
+}
+
 std::string Menu::getDescription() const
 {
     return StringUtils::format("<Menu | Tag = %d>", _tag);
diff --git a/cocos2d/cocos/2d/CCMenu.h b/cocos2d/cocos/2d/CCMenu.h
index 73d2dbdbae..adb85688b7 100644
--- a/cocos2d/cocos/2d/CCMenu.h
+++ b/cocos2d/cocos/2d/CCMenu.h
@@ -2,6 +2,7 @@
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -23,11 +24,11 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_MENU_H
-#define CC_2D_MENU_H
+#ifndef __CCMENU_H_
+#define __CCMENU_H_
 
-#include <cocos/2d/CCLayer.h>
 #include <cocos/2d/CCMenuItem.h>
+#include <cocos/2d/CCLayer.h>
 #include <cocos/base/CCValue.h>
 
 NS_CC_BEGIN
@@ -38,12 +39,14 @@ class Touch;
  * @{
  */
 
+
+
 /** @brief A Menu for touch handling.
- *
- * Features and Limitation:
- *  - You can add MenuItem objects in runtime using addChild.
- *  - But the only accepted children are MenuItem objects.
- */
+* 
+* Features and Limitation:
+*  - You can add MenuItem objects in runtime using addChild.
+*  - But the only accepted children are MenuItem objects.
+*/
 class CC_DLL Menu : public Layer
 {
 public:
@@ -55,57 +58,33 @@ public:
         WAITING,
         TRACKING_TOUCH,
     };
-
+    
     /**
      *@brief Creates an empty Menu.
      */
     static Menu* create();
-
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-    // VS2013 does not support nullptr in variable args lists and variadic templates are also not supported.
-    typedef MenuItem* M;
-    static Menu* create(M m1, std::nullptr_t listEnd) { return variadicCreate(m1, NULL); }
-    static Menu* create(M m1, M m2, std::nullptr_t listEnd) { return variadicCreate(m1, m2, NULL); }
-    static Menu* create(M m1, M m2, M m3, std::nullptr_t listEnd) { return variadicCreate(m1, m2, m3, NULL); }
-    static Menu* create(M m1, M m2, M m3, M m4, std::nullptr_t listEnd) { return variadicCreate(m1, m2, m3, m4, NULL); }
-    static Menu* create(M m1, M m2, M m3, M m4, M m5, std::nullptr_t listEnd) { return variadicCreate(m1, m2, m3, m4, m5, NULL); }
-    static Menu* create(M m1, M m2, M m3, M m4, M m5, M m6, std::nullptr_t listEnd) { return variadicCreate(m1, m2, m3, m4, m5, m6, NULL); }
-    static Menu* create(M m1, M m2, M m3, M m4, M m5, M m6, M m7, std::nullptr_t listEnd) { return variadicCreate(m1, m2, m3, m4, m5, m6, m7, NULL); }
-    static Menu* create(M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, std::nullptr_t listEnd) { return variadicCreate(m1, m2, m3, m4, m5, m6, m7, m8, NULL); }
-    static Menu* create(M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, M m9, std::nullptr_t listEnd)
-    {
-        return variadicCreate(m1, m2, m3, m4, m5, m6, m7, m8, m9, NULL);
-    }
-    static Menu* create(M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, M m9, M m10, std::nullptr_t listEnd)
-    {
-        return variadicCreate(m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, NULL);
-    }
-
-    // On WP8 for lists longer than 10 items, use createWithArray or variadicCreate with NULL as the last argument.
-    static Menu* variadicCreate(MenuItem* item, ...);
-#else
+    
     /** Creates a Menu with MenuItem objects. */
     static Menu* create(MenuItem* item, ...) CC_REQUIRES_NULL_TERMINATION;
-#endif
 
-    /**
+    /** 
      * Creates a Menu with a Array of MenuItem objects.
      * @js NA
      */
     static Menu* createWithArray(const Vector<MenuItem*>& arrayOfItems);
 
     /**
-     * Creates a Menu with it's item, then use addChild() to add
+     * Creates a Menu with it's item, then use addChild() to add 
      * other items. It is used for script, it can't be initialized with undetermined
      * number of variables.
      * @js NA
      */
     static Menu* createWithItem(MenuItem* item);
-
+    
     /** Creates a Menu with MenuItem objects.
      * @js NA
      */
-    static Menu* createWithItems(MenuItem* firstItem, va_list args);
+    static Menu* createWithItems(MenuItem *firstItem, va_list args);
 
     /** Align items vertically. */
     void alignItemsVertically();
@@ -117,7 +96,7 @@ public:
 
     /** Align items horizontally. */
     void alignItemsHorizontally();
-
+    
     /** Align items horizontally with padding.
     @since v0.7.2
     */
@@ -125,10 +104,10 @@ public:
 
     /** Align items in rows of columns. */
     void alignItemsInColumns(int columns, ...) CC_REQUIRES_NULL_TERMINATION;
-
+    
     /** Align items in rows of columns. */
     void alignItemsInColumns(int columns, va_list args);
-
+    
     /** Align items in array of columns.
      * @js NA
      */
@@ -136,10 +115,10 @@ public:
 
     /** Align items in columns of rows. */
     void alignItemsInRows(int rows, ...) CC_REQUIRES_NULL_TERMINATION;
-
+    
     /** Align items in columns of rows. */
     void alignItemsInRows(int rows, va_list args);
-
+    
     /** Align items in array of rows.
      * @js NA
      */
@@ -153,43 +132,39 @@ public:
     virtual bool isEnabled() const { return _enabled; }
 
     /**
-     * Set whether the menu is visible. If set false, interacting with the menu
+     * Set whether the menu is enabled. If set to false, interacting with the menu
      * will have no effect.
-     * The default value is true, a menu is default to visible.
-     *@param value true if menu is to be enabled, false if menu is to be disabled.
+     * The default value is true, a menu is enabled by default.
+     * @param value true if menu is to be enabled, false if menu is to be disabled.
      */
-    virtual void setEnabled(bool value) { _enabled = value; }
+    virtual void setEnabled(bool value) { _enabled = value; };
 
     virtual bool onTouchBegan(Touch* touch, Event* event) override;
     virtual void onTouchEnded(Touch* touch, Event* event) override;
     virtual void onTouchCancelled(Touch* touch, Event* event) override;
     virtual void onTouchMoved(Touch* touch, Event* event) override;
-
+    
     // overrides
     virtual void removeChild(Node* child, bool cleanup) override;
-
-    virtual void addChild(Node* child) override;
-    virtual void addChild(Node* child, int zOrder) override;
-    virtual void addChild(Node* child, int zOrder, int tag) override;
-    virtual void addChild(Node* child, int zOrder, const std::string& name) override;
-
+    
+    virtual void addChild(Node * child) override;
+    virtual void addChild(Node * child, int zOrder) override;
+    virtual void addChild(Node * child, int zOrder, int tag) override;
+    virtual void addChild(Node * child, int zOrder, const std::string &name) override;
+    
     virtual void onEnter() override;
     virtual void onExit() override;
-    virtual void setOpacityModifyRGB(bool) override {}
-    virtual bool isOpacityModifyRGB(void) const override { return false; }
+    virtual void setOpacityModifyRGB(bool value) override;
+    virtual bool isOpacityModifyRGB() const override;
 
     virtual std::string getDescription() const override;
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        Menu()
-    : _selectedItem(nullptr)
-    , _selectedWithCamera(nullptr)
-    {
-    }
-    ~Menu() override;
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    Menu() : _selectedItem(nullptr), _selectedWithCamera(nullptr) {}
+    virtual ~Menu();
 
     /** initializes an empty Menu */
     bool init() override;
@@ -198,16 +173,18 @@ public:
     bool initWithArray(const Vector<MenuItem*>& arrayOfItems);
 
 protected:
+
+
+
     /** whether or not the menu will receive events */
     bool _enabled;
 
-    virtual MenuItem* getItemForTouch(Touch* touch, const Camera* camera);
+    virtual MenuItem* getItemForTouch(Touch * touch, const Camera *camera);
     State _state;
-    MenuItem* _selectedItem;
-    const Camera* _selectedWithCamera;
-
+    MenuItem *_selectedItem;
+    const Camera *_selectedWithCamera;
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(Menu)
+    CC_DISALLOW_COPY_AND_ASSIGN(Menu);
 };
 
 // end of _2d group
@@ -215,4 +192,4 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_MENU_H
+#endif//__CCMENU_H_
diff --git a/cocos2d/cocos/2d/CCMenuItem.cpp b/cocos2d/cocos/2d/CCMenuItem.cpp
index 667e9d5ab6..faedc602ca 100644
--- a/cocos2d/cocos/2d/CCMenuItem.cpp
+++ b/cocos2d/cocos/2d/CCMenuItem.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -26,24 +27,22 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCMenuItem.h>
-
 #include <cocos/2d/CCActionInterval.h>
-#include <cocos/2d/CCLabel.h>
-#include <cocos/2d/CCLabelAtlas.h>
 #include <cocos/2d/CCSprite.h>
+#include <cocos/2d/CCLabelAtlas.h>
+#include <cocos/2d/CCLabel.h>
 #include <cocos/base/ccUTF8.h>
-
-#include <cstdarg>
+#include <stdarg.h>
 
 using namespace std::chrono_literals;
 
 NS_CC_BEGIN
-
+    
 static int _globalFontSize = kItemSize;
 static std::string _globalFontName = "Marker Felt";
 static bool _globalFontNameRelease = false;
 
-const unsigned int kZoomActionTag = 0xc0c05002;
+const unsigned int    kZoomActionTag = 0xc0c05002;
 
 //
 // MenuItem
@@ -54,29 +53,14 @@ MenuItem* MenuItem::create()
     return MenuItem::create((const ccMenuCallback&)nullptr);
 }
 
-// FIXME: deprecated
-MenuItem* MenuItem::create(Ref* target, SEL_MenuHandler selector)
-{
-    MenuItem* ret = new (std::nothrow) MenuItem();
-    ret->initWithCallback(std::bind(selector, target, std::placeholders::_1));
-    ret->autorelease();
-    return ret;
-}
-
-MenuItem* MenuItem::create(const ccMenuCallback& callback)
+MenuItem* MenuItem::create( const ccMenuCallback& callback)
 {
-    MenuItem* ret = new (std::nothrow) MenuItem();
+    MenuItem *ret = new (std::nothrow) MenuItem();
     ret->initWithCallback(callback);
     ret->autorelease();
     return ret;
 }
 
-// FIXME: deprecated
-bool MenuItem::initWithTarget(cocos2d::Ref* target, SEL_MenuHandler selector)
-{
-    return initWithCallback(std::bind(selector, target, std::placeholders::_1));
-}
-
 bool MenuItem::initWithCallback(const ccMenuCallback& callback)
 {
     setAnchorPoint(Vec2(0.5f, 0.5f));
@@ -104,7 +88,7 @@ void MenuItem::activate()
 {
     if (_enabled)
     {
-        if (_callback)
+        if( _callback )
         {
             _callback(this);
         }
@@ -131,7 +115,9 @@ bool MenuItem::isEnabled() const
 
 Rect MenuItem::rect() const
 {
-    return Rect(_position.x - _contentSize.width * _anchorPoint.x, _position.y - _contentSize.height * _anchorPoint.y, _contentSize.width, _contentSize.height);
+    return Rect( _position.x - _contentSize.width * _anchorPoint.x,
+                      _position.y - _contentSize.height * _anchorPoint.y,
+                      _contentSize.width, _contentSize.height);
 }
 
 bool MenuItem::isSelected() const
@@ -139,12 +125,6 @@ bool MenuItem::isSelected() const
     return _selected;
 }
 
-// FIXME: deprecated
-void MenuItem::setTarget(Ref* target, SEL_MenuHandler selector)
-{
-    setCallback(std::bind(selector, target, std::placeholders::_1));
-}
-
 void MenuItem::setCallback(const ccMenuCallback& callback)
 {
     _callback = callback;
@@ -156,7 +136,7 @@ std::string MenuItem::getDescription() const
 }
 
 //
-// CCMenuItemLabel
+//CCMenuItemLabel
 //
 
 void MenuItemLabel::setLabel(Node* var)
@@ -164,55 +144,40 @@ void MenuItemLabel::setLabel(Node* var)
     if (var)
     {
         var->setAnchorPoint(Vec2::ANCHOR_BOTTOM_LEFT);
-        setContentSize(var->getContentSize());
+        setContentSize(var->getContentSize()); 
         addChild(var);
     }
-
+    
     if (_label)
     {
         removeChild(_label, true);
     }
-
+    
     _label = var;
 }
 
-// FIXME:: deprecated
-MenuItemLabel* MenuItemLabel::create(Node* label, Ref* target, SEL_MenuHandler selector)
+MenuItemLabel * MenuItemLabel::create(Node*label, const ccMenuCallback& callback)
 {
-    MenuItemLabel* ret = new (std::nothrow) MenuItemLabel();
-    ret->initWithLabel(label, std::bind(selector, target, std::placeholders::_1));
-    ret->autorelease();
-    return ret;
-}
-
-MenuItemLabel* MenuItemLabel::create(Node* label, const ccMenuCallback& callback)
-{
-    MenuItemLabel* ret = new (std::nothrow) MenuItemLabel();
+    MenuItemLabel *ret = new (std::nothrow) MenuItemLabel();
     ret->initWithLabel(label, callback);
     ret->autorelease();
     return ret;
 }
 
-MenuItemLabel* MenuItemLabel::create(Node* label)
+MenuItemLabel* MenuItemLabel::create(Node *label)
 {
-    MenuItemLabel* ret = new (std::nothrow) MenuItemLabel();
-    ret->initWithLabel(label, (const ccMenuCallback&)nullptr);
+    MenuItemLabel *ret = new (std::nothrow) MenuItemLabel();
+    ret->initWithLabel(label, (const ccMenuCallback&) nullptr);
     ret->autorelease();
     return ret;
 }
 
-// FIXME:: deprecated
-bool MenuItemLabel::initWithLabel(Node* label, Ref* target, SEL_MenuHandler selector)
-{
-    return initWithLabel(label, std::bind(selector, target, std::placeholders::_1));
-}
-
 bool MenuItemLabel::initWithLabel(Node* label, const ccMenuCallback& callback)
 {
     MenuItem::initWithCallback(callback);
     _originalScale = 1.0f;
     _colorBackup = Color3B::WHITE;
-    setDisabledColor(Color3B(126, 126, 126));
+    setDisabledColor(Color3B(126,126,126));
     this->setLabel(label);
 
     setCascadeColorEnabled(true);
@@ -221,6 +186,7 @@ bool MenuItemLabel::initWithLabel(Node* label, const ccMenuCallback& callback)
     return true;
 }
 
+
 MenuItemLabel::~MenuItemLabel()
 {
 }
@@ -239,10 +205,10 @@ std::string MenuItemLabel::getString() const
 
 void MenuItemLabel::activate()
 {
-    if (_enabled)
+    if(_enabled)
     {
         this->stopAllActions();
-        this->setScale(_originalScale);
+        this->setScale( _originalScale );
         MenuItem::activate();
     }
 }
@@ -250,11 +216,11 @@ void MenuItemLabel::activate()
 void MenuItemLabel::selected()
 {
     // subclass to change the default action
-    if (_enabled)
+    if(_enabled)
     {
         MenuItem::selected();
-
-        Action* action = getActionByTag(kZoomActionTag);
+        
+        Action *action = getActionByTag(kZoomActionTag);
         if (action)
         {
             this->stopAction(action);
@@ -263,8 +229,8 @@ void MenuItemLabel::selected()
         {
             _originalScale = this->getScale();
         }
-
-        Action* zoomAction = ScaleTo::create(100ms, _originalScale * 1.2f);
+        
+        Action *zoomAction = ScaleTo::create(100ms, _originalScale * 1.2f);
         zoomAction->setTag(kZoomActionTag);
         this->runAction(zoomAction);
     }
@@ -273,11 +239,11 @@ void MenuItemLabel::selected()
 void MenuItemLabel::unselected()
 {
     // subclass to change the default action
-    if (_enabled)
+    if(_enabled)
     {
         MenuItem::unselected();
         this->stopAllActionsByTag(kZoomActionTag);
-        Action* zoomAction = ScaleTo::create(100ms, _originalScale);
+        Action *zoomAction = ScaleTo::create(100ms, _originalScale);
         zoomAction->setTag(kZoomActionTag);
         this->runAction(zoomAction);
     }
@@ -285,9 +251,9 @@ void MenuItemLabel::unselected()
 
 void MenuItemLabel::setEnabled(bool enabled)
 {
-    if (_enabled != enabled)
+    if( _enabled != enabled ) 
     {
-        if (enabled == false)
+        if(enabled == false)
         {
             _colorBackup = this->getColor();
             this->setColor(_disabledColor);
@@ -301,49 +267,26 @@ void MenuItemLabel::setEnabled(bool enabled)
 }
 
 //
-// CCMenuItemAtlasFont
+//CCMenuItemAtlasFont
 //
 
-MenuItemAtlasFont::~MenuItemAtlasFont()
-{
-}
-
-MenuItemAtlasFont* MenuItemAtlasFont::create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap)
+MenuItemAtlasFont * MenuItemAtlasFont::create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap)
 {
     return MenuItemAtlasFont::create(value, charMapFile, itemWidth, itemHeight, startCharMap, (const ccMenuCallback&)nullptr);
 }
 
-// FIXME:: deprecated
-MenuItemAtlasFont* MenuItemAtlasFont::create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap,
-                                             Ref* target, SEL_MenuHandler selector)
+MenuItemAtlasFont * MenuItemAtlasFont::create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap, const ccMenuCallback& callback)
 {
-    MenuItemAtlasFont* ret = new (std::nothrow) MenuItemAtlasFont();
-    ret->initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap, std::bind(selector, target, std::placeholders::_1));
-    ret->autorelease();
-    return ret;
-}
-
-MenuItemAtlasFont* MenuItemAtlasFont::create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap,
-                                             const ccMenuCallback& callback)
-{
-    MenuItemAtlasFont* ret = new (std::nothrow) MenuItemAtlasFont();
+    MenuItemAtlasFont *ret = new (std::nothrow) MenuItemAtlasFont();
     ret->initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap, callback);
     ret->autorelease();
     return ret;
 }
 
-// FIXME:: deprecated
-bool MenuItemAtlasFont::initWithString(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap, Ref* target,
-                                       SEL_MenuHandler selector)
-{
-    return initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap, std::bind(selector, target, std::placeholders::_1));
-}
-
-bool MenuItemAtlasFont::initWithString(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap,
-                                       const ccMenuCallback& callback)
+bool MenuItemAtlasFont::initWithString(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap, const ccMenuCallback& callback)
 {
-    CCASSERT(value.size() != 0, "value length must be greater than 0");
-    LabelAtlas* label = LabelAtlas::create();
+    CCASSERT( value.size() != 0, "value length must be greater than 0");
+    LabelAtlas *label = LabelAtlas::create();
     label->initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap);
     if (MenuItemLabel::initWithLabel(label, callback))
     {
@@ -353,7 +296,7 @@ bool MenuItemAtlasFont::initWithString(const std::string& value, const std::stri
 }
 
 //
-// CCMenuItemFont
+//CCMenuItemFont
 //
 
 void MenuItemFont::setFontSize(int s)
@@ -381,58 +324,40 @@ const std::string& MenuItemFont::getFontName()
     return _globalFontName;
 }
 
-// FIXME:: deprecated
-MenuItemFont* MenuItemFont::create(const std::string& value, Ref* target, SEL_MenuHandler selector)
+MenuItemFont * MenuItemFont::create(const std::string& value, const ccMenuCallback& callback)
 {
-    MenuItemFont* ret = new (std::nothrow) MenuItemFont();
-    ret->initWithString(value, std::bind(selector, target, std::placeholders::_1));
-    ret->autorelease();
-    return ret;
-}
-
-MenuItemFont* MenuItemFont::create(const std::string& value, const ccMenuCallback& callback)
-{
-    MenuItemFont* ret = new (std::nothrow) MenuItemFont();
+    MenuItemFont *ret = new (std::nothrow) MenuItemFont();
     ret->initWithString(value, callback);
     ret->autorelease();
     return ret;
 }
 
-MenuItemFont* MenuItemFont::create(const std::string& value)
+
+MenuItemFont * MenuItemFont::create(const std::string& value)
 {
-    MenuItemFont* ret = new (std::nothrow) MenuItemFont();
+    MenuItemFont *ret = new (std::nothrow) MenuItemFont();
     ret->initWithString(value, (const ccMenuCallback&)nullptr);
     ret->autorelease();
     return ret;
 }
 
 MenuItemFont::MenuItemFont()
-: _fontSize(0)
-, _fontName("")
-{
-}
+ : _fontSize(0), _fontName("")
+{}
 
 MenuItemFont::~MenuItemFont()
 {
     CCLOGINFO("In the destructor of MenuItemFont (%p).", this);
 }
 
-// FIXME:: deprecated
-bool MenuItemFont::initWithString(const std::string& value, Ref* target, SEL_MenuHandler selector)
-{
-    CCASSERT(!value.empty(), "Value length must be greater than 0");
-
-    return initWithString(value, std::bind(selector, target, std::placeholders::_1));
-}
-
 bool MenuItemFont::initWithString(const std::string& value, const ccMenuCallback& callback)
 {
-    CCASSERT(!value.empty(), "Value length must be greater than 0");
+    CCASSERT( !value.empty(), "Value length must be greater than 0");
 
     _fontName = _globalFontName;
     _fontSize = _globalFontSize;
 
-    Label* label = Label::createWithSystemFont(value, _fontName, _fontSize);
+    Label *label = Label::createWithSystemFont(value, _fontName, _fontSize);
     if (MenuItemLabel::initWithLabel(label, callback))
     {
         // do something ?
@@ -465,7 +390,7 @@ const std::string& MenuItemFont::getFontNameObj() const
 }
 
 //
-// CCMenuItemSprite
+//CCMenuItemSprite
 //
 
 void MenuItemSprite::setNormalImage(Node* image)
@@ -484,7 +409,10 @@ void MenuItemSprite::setNormalImage(Node* image)
         }
 
         _normalImage = image;
-        this->setContentSize(_normalImage->getContentSize());
+        if (_normalImage != nullptr)
+        {
+            this->setContentSize(_normalImage->getContentSize());
+        }
         this->updateImagesVisibility();
     }
 }
@@ -530,48 +458,27 @@ void MenuItemSprite::setDisabledImage(Node* image)
 }
 
 //
-// CCMenuItemSprite
+//CCMenuItemSprite
 //
 
-MenuItemSprite* MenuItemSprite::create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite)
+MenuItemSprite * MenuItemSprite::create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite)
 {
     return MenuItemSprite::create(normalSprite, selectedSprite, disabledSprite, (const ccMenuCallback&)nullptr);
 }
 
-// FIXME: deprecated
-MenuItemSprite* MenuItemSprite::create(Node* normalSprite, Node* selectedSprite, Ref* target, SEL_MenuHandler selector)
-{
-    return MenuItemSprite::create(normalSprite, selectedSprite, nullptr, std::bind(selector, target, std::placeholders::_1));
-}
-
-MenuItemSprite* MenuItemSprite::create(Node* normalSprite, Node* selectedSprite, const ccMenuCallback& callback)
+MenuItemSprite * MenuItemSprite::create(Node* normalSprite, Node* selectedSprite, const ccMenuCallback& callback)
 {
     return MenuItemSprite::create(normalSprite, selectedSprite, nullptr, callback);
 }
 
-// FIXME: deprecated
-MenuItemSprite* MenuItemSprite::create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, Ref* target, SEL_MenuHandler selector)
-{
-    MenuItemSprite* ret = new (std::nothrow) MenuItemSprite();
-    ret->initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, std::bind(selector, target, std::placeholders::_1));
-    ret->autorelease();
-    return ret;
-}
-
-MenuItemSprite* MenuItemSprite::create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, const ccMenuCallback& callback)
+MenuItemSprite * MenuItemSprite::create(Node *normalSprite, Node *selectedSprite, Node *disabledSprite, const ccMenuCallback& callback)
 {
-    MenuItemSprite* ret = new (std::nothrow) MenuItemSprite();
+    MenuItemSprite *ret = new (std::nothrow) MenuItemSprite();
     ret->initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, callback);
     ret->autorelease();
     return ret;
 }
 
-// FIXME: deprecated
-bool MenuItemSprite::initWithNormalSprite(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, Ref* target, SEL_MenuHandler selector)
-{
-    return initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, std::bind(selector, target, std::placeholders::_1));
-}
-
 bool MenuItemSprite::initWithNormalSprite(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, const ccMenuCallback& callback)
 {
     MenuItem::initWithCallback(callback);
@@ -579,7 +486,7 @@ bool MenuItemSprite::initWithNormalSprite(Node* normalSprite, Node* selectedSpri
     setSelectedImage(selectedSprite);
     setDisabledImage(disabledSprite);
 
-    if (_normalImage)
+    if(_normalImage)
     {
         this->setContentSize(_normalImage->getContentSize());
     }
@@ -624,44 +531,35 @@ void MenuItemSprite::unselected()
 
 void MenuItemSprite::setEnabled(bool bEnabled)
 {
-    if (_enabled != bEnabled)
+    if( _enabled != bEnabled ) 
     {
         MenuItem::setEnabled(bEnabled);
         this->updateImagesVisibility();
     }
 }
 
-// Helper
+// Helper 
 void MenuItemSprite::updateImagesVisibility()
 {
     if (_enabled)
     {
-        if (_normalImage)
-            _normalImage->setVisible(true);
-        if (_selectedImage)
-            _selectedImage->setVisible(false);
-        if (_disabledImage)
-            _disabledImage->setVisible(false);
+        if (_normalImage)   _normalImage->setVisible(true);
+        if (_selectedImage) _selectedImage->setVisible(false);
+        if (_disabledImage) _disabledImage->setVisible(false);
     }
     else
     {
         if (_disabledImage)
         {
-            if (_normalImage)
-                _normalImage->setVisible(false);
-            if (_selectedImage)
-                _selectedImage->setVisible(false);
-            if (_disabledImage)
-                _disabledImage->setVisible(true);
+            if (_normalImage)   _normalImage->setVisible(false);
+            if (_selectedImage) _selectedImage->setVisible(false);
+            if (_disabledImage) _disabledImage->setVisible(true);
         }
         else
         {
-            if (_normalImage)
-                _normalImage->setVisible(true);
-            if (_selectedImage)
-                _selectedImage->setVisible(false);
-            if (_disabledImage)
-                _disabledImage->setVisible(false);
+            if (_normalImage)   _normalImage->setVisible(true);
+            if (_selectedImage) _selectedImage->setVisible(false);
+            if (_disabledImage) _disabledImage->setVisible(false);
         }
     }
 }
@@ -672,7 +570,7 @@ void MenuItemSprite::updateImagesVisibility()
 
 MenuItemImage* MenuItemImage::create()
 {
-    MenuItemImage* ret = new (std::nothrow) MenuItemImage();
+    MenuItemImage *ret = new (std::nothrow) MenuItemImage();
     if (ret && ret->init())
     {
         ret->autorelease();
@@ -682,45 +580,24 @@ MenuItemImage* MenuItemImage::create()
     return nullptr;
 }
 
-bool MenuItemImage::init(void)
+bool MenuItemImage::init()
 {
     return initWithNormalImage("", "", "", (const ccMenuCallback&)nullptr);
 }
 
-MenuItemImage* MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage)
+MenuItemImage * MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage)
 {
     return MenuItemImage::create(normalImage, selectedImage, "", (const ccMenuCallback&)nullptr);
 }
 
-// FIXME: deprecated
-MenuItemImage* MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage, Ref* target, SEL_MenuHandler selector)
-{
-    return MenuItemImage::create(normalImage, selectedImage, "", std::bind(selector, target, std::placeholders::_1));
-}
-
-MenuItemImage* MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage, const ccMenuCallback& callback)
+MenuItemImage * MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage, const ccMenuCallback& callback)
 {
     return MenuItemImage::create(normalImage, selectedImage, "", callback);
 }
 
-// FIXME: deprecated
-MenuItemImage*
-MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage, Ref* target, SEL_MenuHandler selector)
+MenuItemImage * MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage, const ccMenuCallback& callback)
 {
-    MenuItemImage* ret = new (std::nothrow) MenuItemImage();
-    if (ret && ret->initWithNormalImage(normalImage, selectedImage, disabledImage, std::bind(selector, target, std::placeholders::_1)))
-    {
-        ret->autorelease();
-        return ret;
-    }
-    CC_SAFE_DELETE(ret);
-    return nullptr;
-}
-
-MenuItemImage*
-MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage, const ccMenuCallback& callback)
-{
-    MenuItemImage* ret = new (std::nothrow) MenuItemImage();
+    MenuItemImage *ret = new (std::nothrow) MenuItemImage();
     if (ret && ret->initWithNormalImage(normalImage, selectedImage, disabledImage, callback))
     {
         ret->autorelease();
@@ -730,9 +607,9 @@ MenuItemImage::create(const std::string& normalImage, const std::string& selecte
     return nullptr;
 }
 
-MenuItemImage* MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage)
+MenuItemImage * MenuItemImage::create(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage)
 {
-    MenuItemImage* ret = new (std::nothrow) MenuItemImage();
+    MenuItemImage *ret = new (std::nothrow) MenuItemImage();
     if (ret && ret->initWithNormalImage(normalImage, selectedImage, disabledImage, (const ccMenuCallback&)nullptr))
     {
         ret->autorelease();
@@ -742,30 +619,23 @@ MenuItemImage* MenuItemImage::create(const std::string& normalImage, const std::
     return nullptr;
 }
 
-// FIXME:: deprecated
-bool MenuItemImage::initWithNormalImage(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage, Ref* target,
-                                        SEL_MenuHandler selector)
+bool MenuItemImage::initWithNormalImage(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage, const ccMenuCallback& callback)
 {
-    return initWithNormalImage(normalImage, selectedImage, disabledImage, std::bind(selector, target, std::placeholders::_1));
-}
-bool MenuItemImage::initWithNormalImage(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage,
-                                        const ccMenuCallback& callback)
-{
-    Node* normalSprite = nullptr;
-    Node* selectedSprite = nullptr;
-    Node* disabledSprite = nullptr;
+    Node *normalSprite = nullptr;
+    Node *selectedSprite = nullptr;
+    Node *disabledSprite = nullptr;
 
-    if (normalImage.size() > 0)
+    if (normalImage.size() >0)
     {
         normalSprite = Sprite::create(normalImage);
     }
 
-    if (selectedImage.size() > 0)
+    if (selectedImage.size() >0)
     {
         selectedSprite = Sprite::create(selectedImage);
     }
 
-    if (disabledImage.size() > 0)
+    if(disabledImage.size() >0)
     {
         disabledSprite = Sprite::create(disabledImage);
     }
@@ -775,17 +645,17 @@ bool MenuItemImage::initWithNormalImage(const std::string& normalImage, const st
 //
 // Setter of sprite frames
 //
-void MenuItemImage::setNormalSpriteFrame(SpriteFrame* frame)
+void MenuItemImage::setNormalSpriteFrame(SpriteFrame * frame)
 {
     setNormalImage(Sprite::createWithSpriteFrame(frame));
 }
 
-void MenuItemImage::setSelectedSpriteFrame(SpriteFrame* frame)
+void MenuItemImage::setSelectedSpriteFrame(SpriteFrame * frame)
 {
     setSelectedImage(Sprite::createWithSpriteFrame(frame));
 }
 
-void MenuItemImage::setDisabledSpriteFrame(SpriteFrame* frame)
+void MenuItemImage::setDisabledSpriteFrame(SpriteFrame * frame)
 {
     setDisabledImage(Sprite::createWithSpriteFrame(frame));
 }
@@ -794,41 +664,16 @@ void MenuItemImage::setDisabledSpriteFrame(SpriteFrame* frame)
 // MenuItemToggle
 //
 
-// FIXME:: deprecated
-MenuItemToggle* MenuItemToggle::createWithTarget(Ref* target, SEL_MenuHandler selector, const Vector<MenuItem*>& menuItems)
+MenuItemToggle * MenuItemToggle::createWithCallback(const ccMenuCallback &callback, const Vector<MenuItem*>& menuItems)
 {
-    MenuItemToggle* ret = new (std::nothrow) MenuItemToggle();
-    ret->MenuItem::initWithCallback(std::bind(selector, target, std::placeholders::_1));
-    ret->autorelease();
-#if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
-    auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
-    if (sEngine)
-    {
-        for (const auto& item : menuItems)
-        {
-            if (item)
-            {
-                sEngine->retainScriptObject(ret, item);
-            }
-        }
-    }
-#endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
-    ret->_subItems = menuItems;
-    ret->_selectedIndex = UINT_MAX;
-    ret->setSelectedIndex(0);
-    return ret;
-}
-
-MenuItemToggle* MenuItemToggle::createWithCallback(const ccMenuCallback& callback, const Vector<MenuItem*>& menuItems)
-{
-    MenuItemToggle* ret = new (std::nothrow) MenuItemToggle();
+    MenuItemToggle *ret = new (std::nothrow) MenuItemToggle();
     ret->MenuItem::initWithCallback(callback);
     ret->autorelease();
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
     auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
     if (sEngine)
     {
-        for (const auto& item : menuItems)
+        for (const auto &item : menuItems)
         {
             if (item)
             {
@@ -843,68 +688,37 @@ MenuItemToggle* MenuItemToggle::createWithCallback(const ccMenuCallback& callbac
     return ret;
 }
 
-// FIXME:: deprecated
-MenuItemToggle* MenuItemToggle::createWithTarget(Ref* target, SEL_MenuHandler selector, MenuItem* item, ...)
-{
-    va_list args;
-    va_start(args, item);
-    MenuItemToggle* ret = new (std::nothrow) MenuItemToggle();
-    ret->initWithCallback(std::bind(selector, target, std::placeholders::_1), item, args);
-    ret->autorelease();
-    va_end(args);
-    return ret;
-}
-
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-MenuItemToggle* MenuItemToggle::createWithCallbackVA(const ccMenuCallback& callback, MenuItem* item, ...)
-{
-    va_list args;
-    va_start(args, item);
-    MenuItemToggle* ret = new (std::nothrow) MenuItemToggle();
-    ret->initWithCallback(callback, item, args);
-    ret->autorelease();
-    va_end(args);
-    return ret;
-}
-#else
-MenuItemToggle* MenuItemToggle::createWithCallback(const ccMenuCallback& callback, MenuItem* item, ...)
+MenuItemToggle * MenuItemToggle::createWithCallback(const ccMenuCallback &callback, MenuItem* item, ...)
 {
     va_list args;
     va_start(args, item);
-    MenuItemToggle* ret = new (std::nothrow) MenuItemToggle();
+    MenuItemToggle *ret = new (std::nothrow) MenuItemToggle();
     ret->initWithCallback(callback, item, args);
     ret->autorelease();
     va_end(args);
     return ret;
 }
-#endif
 
-MenuItemToggle* MenuItemToggle::create()
+MenuItemToggle * MenuItemToggle::create()
 {
-    MenuItemToggle* ret = new (std::nothrow) MenuItemToggle();
+    MenuItemToggle *ret = new (std::nothrow) MenuItemToggle();
     ret->initWithItem(nullptr);
     ret->autorelease();
     return ret;
 }
 
-// FIXME:: deprecated
-bool MenuItemToggle::initWithTarget(Ref* target, SEL_MenuHandler selector, MenuItem* item, va_list args)
-{
-    return initWithCallback(std::bind(selector, target, std::placeholders::_1), item, args);
-}
-
-bool MenuItemToggle::initWithCallback(const ccMenuCallback& callback, MenuItem* item, va_list args)
+bool MenuItemToggle::initWithCallback(const ccMenuCallback &callback, MenuItem *item, va_list args)
 {
     MenuItem::initWithCallback(callback);
 
     int z = 0;
-    MenuItem* i = item;
-
+    MenuItem *i = item;
+    
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
     auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
 #endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
-
-    while (i)
+    
+    while(i)
     {
         z++;
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
@@ -921,15 +735,15 @@ bool MenuItemToggle::initWithCallback(const ccMenuCallback& callback, MenuItem*
     return true;
 }
 
-MenuItemToggle* MenuItemToggle::create(MenuItem* item)
+MenuItemToggle* MenuItemToggle::create(MenuItem *item)
 {
-    MenuItemToggle* ret = new (std::nothrow) MenuItemToggle();
+    MenuItemToggle *ret = new (std::nothrow) MenuItemToggle();
     ret->initWithItem(item);
     ret->autorelease();
     return ret;
 }
 
-bool MenuItemToggle::initWithItem(MenuItem* item)
+bool MenuItemToggle::initWithItem(MenuItem *item)
 {
     MenuItem::initWithCallback((const ccMenuCallback&)nullptr);
 
@@ -939,14 +753,14 @@ bool MenuItemToggle::initWithItem(MenuItem* item)
     }
     _selectedIndex = UINT_MAX;
     this->setSelectedIndex(0);
-
+    
     setCascadeColorEnabled(true);
     setCascadeOpacityEnabled(true);
-
+    
     return true;
 }
 
-void MenuItemToggle::addSubItem(MenuItem* item)
+void MenuItemToggle::addSubItem(MenuItem *item)
 {
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
     auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
@@ -960,8 +774,7 @@ void MenuItemToggle::addSubItem(MenuItem* item)
 
 void MenuItemToggle::cleanup()
 {
-    for (const auto& item : _subItems)
-    {
+    for(const auto &item : _subItems) {
 #if defined(CC_NATIVE_CONTROL_SCRIPT) && !CC_NATIVE_CONTROL_SCRIPT
         ScriptEngineManager::getInstance()->getScriptEngine()->releaseScriptObject(this, item);
 #endif
@@ -972,7 +785,7 @@ void MenuItemToggle::cleanup()
 
 void MenuItemToggle::setSelectedIndex(unsigned int index)
 {
-    if (index != _selectedIndex && _subItems.size() > 0)
+    if( index != _selectedIndex && _subItems.size() > 0 )
     {
         _selectedIndex = index;
         if (_selectedItem)
@@ -1003,7 +816,7 @@ void MenuItemToggle::unselected()
 void MenuItemToggle::activate()
 {
     // update index
-    if (_enabled)
+    if( _enabled ) 
     {
         unsigned int newIndex = (_selectedIndex + 1) % _subItems.size();
         this->setSelectedIndex(newIndex);
@@ -1016,8 +829,7 @@ void MenuItemToggle::setEnabled(bool enabled)
     {
         MenuItem::setEnabled(enabled);
 
-        for (const auto& item : _subItems)
-        {
+        for(const auto &item : _subItems) {
             item->setEnabled(enabled);
         }
     }
diff --git a/cocos2d/cocos/2d/CCMenuItem.h b/cocos2d/cocos/2d/CCMenuItem.h
index 220ac219c8..46383bd823 100644
--- a/cocos2d/cocos/2d/CCMenuItem.h
+++ b/cocos2d/cocos/2d/CCMenuItem.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,16 +26,16 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_MENUITEM_H
-#define CC_2D_MENUITEM_H
+#ifndef __CCMENU_ITEM_H__
+#define __CCMENU_ITEM_H__
+
+// C++ includes
+#include <functional>
 
 // cocos2d includes
 #include <cocos/2d/CCNode.h>
 #include <cocos/base/CCProtocols.h>
 
-// C++ includes
-#include <functional>
-
 NS_CC_BEGIN
 
 typedef std::function<void(Ref*)> ccMenuCallback;
@@ -44,7 +45,7 @@ class LabelAtlas;
 class Sprite;
 class SpriteFrame;
 #define kItemSize 32
-
+    
 /**
  * @addtogroup _2d
  * @{
@@ -60,8 +61,6 @@ public:
     /** Creates a MenuItem with no target/selector. */
     static MenuItem* create();
     /** Creates a MenuItem with a target/selector. */
-    CC_DEPRECATED_ATTRIBUTE static MenuItem* create(Ref* rec, SEL_MenuHandler selector);
-    /** Creates a MenuItem with a target/selector. */
     static MenuItem* create(const ccMenuCallback& callback);
 
     /** Returns the outside box. */
@@ -80,57 +79,46 @@ public:
     virtual bool isSelected() const;
 
     /** Set the callback to the menu item.
-     * @code
-     * In js,can contain two params,the second param is jsptr.
-     * @endcode
-     * @lua NA
-     */
+    * @code
+    * In js,can contain two params,the second param is jsptr.
+    * @endcode
+    * @lua NA
+    */
     void setCallback(const ccMenuCallback& callback);
 
-    /** Set the target/selector of the menu item.
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE void setTarget(Ref* rec, SEL_MenuHandler selector);
-
     /**
      * @js NA
      */
     virtual std::string getDescription() const override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        MenuItem()
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    MenuItem()
     : _selected(false)
     , _enabled(false)
-    , _callback(nullptr)
-    {
-    }
+	, _callback(nullptr)
+    {}
     /**
      * @js NA
      * @lua NA
      */
-    ~MenuItem() override;
-
+    virtual ~MenuItem();
+    
     /** Initializes a MenuItem with a target/selector.
      * @lua NA
      */
     bool initWithCallback(const ccMenuCallback& callback);
-    /** Initializes a MenuItem with a target/selector.
-     * @js NA
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE bool initWithTarget(Ref* rec, SEL_MenuHandler selector);
 
 protected:
-    bool _selected;
-    bool _enabled;
+    bool            _selected;
+    bool            _enabled;
     // callback
     ccMenuCallback _callback;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(MenuItem)
+    CC_DISALLOW_COPY_AND_ASSIGN(MenuItem);
 };
 
 /** @brief An abstract class for "label" MenuItemLabel items.
@@ -144,14 +132,11 @@ private:
 class CC_DLL MenuItemLabel : public MenuItem
 {
 public:
-    /** Creates a MenuItemLabel with a Label, target and selector. */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemLabel* create(Node* label, Ref* target, SEL_MenuHandler selector);
-
     /** Creates a MenuItemLabel with a Label and a callback. */
-    static MenuItemLabel* create(Node* label, const ccMenuCallback& callback);
+    static MenuItemLabel * create(Node*label, const ccMenuCallback& callback);
 
     /** Creates a MenuItemLabel with a Label. Target and selector will be nil. */
-    static MenuItemLabel* create(Node* label);
+    static MenuItemLabel* create(Node *label);
 
     /** Sets a new string to the inner label. */
     void setString(const std::string& label);
@@ -164,43 +149,39 @@ public:
 
     /** Sets the color that will be used when the item is disabled. */
     void setDisabledColor(const Color3B& color) { _disabledColor = color; }
-
+    
     /** Gets the label that is rendered. */
     Node* getLabel() const { return _label; }
-
+    
     /** Sets the label that is rendered. */
     void setLabel(Node* node);
-
+    
     // Overrides
     virtual void activate() override;
     virtual void selected() override;
     virtual void unselected() override;
     virtual void setEnabled(bool enabled) override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        MenuItemLabel()
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    MenuItemLabel()
     : _originalScale(0.0)
     , _label(nullptr)
-    {
-    }
+    {}
     /**
      * @js NA
      * @lua NA
      */
-    ~MenuItemLabel() override;
-
+    virtual ~MenuItemLabel();
+    
     /** Initializes a MenuItemLabel with a Label, target and selector. */
     bool initWithLabel(Node* label, const ccMenuCallback& callback);
-
-    /** Initializes a MenuItemLabel with a Label, target and selector. */
-    CC_DEPRECATED_ATTRIBUTE bool initWithLabel(Node* label, Ref* target, SEL_MenuHandler selector);
-
+    
 protected:
-    Color3B _colorBackup;
-    float _originalScale;
+    Color3B    _colorBackup;
+    float      _originalScale;
 
     /** The color that will be used to disable the item. */
     Color3B _disabledColor;
@@ -208,9 +189,10 @@ protected:
     Node* _label;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemLabel)
+    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemLabel);
 };
 
+
 /** @brief A MenuItemAtlasFont.
  Helper class that creates a MenuItemLabel class with a LabelAtlas.
  */
@@ -220,34 +202,27 @@ public:
     /** Creates a menu item from a string and atlas with a target/selector. */
     static MenuItemAtlasFont* create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap);
     /** Creates a menu item from a string and atlas. Use it with MenuItemToggle. */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemAtlasFont*
-    create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap, Ref* target, SEL_MenuHandler selector);
-    /** Creates a menu item from a string and atlas. Use it with MenuItemToggle. */
-    static MenuItemAtlasFont*
-    create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap, const ccMenuCallback& callback);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        MenuItemAtlasFont() = default;
+    static MenuItemAtlasFont* create(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap, const ccMenuCallback& callback);
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    MenuItemAtlasFont(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~MenuItemAtlasFont() override;
-
-    /** Initializes a menu item from a string and atlas with a target/selector. */
-    CC_DEPRECATED_ATTRIBUTE bool initWithString(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap,
-                                                Ref* target, SEL_MenuHandler selector);
-
+    virtual ~MenuItemAtlasFont(){}
+    
     /** Initializes a menu item from a string and atlas with a target/selector. */
     bool initWithString(const std::string& value, const std::string& charMapFile, int itemWidth, int itemHeight, char startCharMap, const ccMenuCallback& callback);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemAtlasFont)
+    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemAtlasFont);
 };
 
+
 /** @brief A MenuItemFont.
  Helper class that creates a MenuItemLabel class with a Label.
  */
@@ -255,23 +230,19 @@ class CC_DLL MenuItemFont : public MenuItemLabel
 {
 public:
     /** Creates a menu item from a string without target/selector. To be used with MenuItemToggle. */
-    static MenuItemFont* create(const std::string& value = "");
-    /** Creates a menu item from a string with a target/selector. */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemFont* create(const std::string& value, Ref* target, SEL_MenuHandler selector);
+    static MenuItemFont * create(const std::string& value = "");
     /** Creates a menu item from a string with a target/selector. */
-    static MenuItemFont* create(const std::string& value, const ccMenuCallback& callback);
+    static MenuItemFont * create(const std::string& value, const ccMenuCallback& callback);
 
     /** Set default font size. */
     static void setFontSize(int size);
     /** Get default font size. */
     static int getFontSize();
-    CC_DEPRECATED_ATTRIBUTE static int fontSize() { return MenuItemFont::getFontSize(); }
     /** Set the default font name. */
     static void setFontName(const std::string& name);
     /** Get the default font name. */
     static const std::string& getFontName();
-    CC_DEPRECATED_ATTRIBUTE static const std::string& fontName() { return MenuItemFont::getFontName(); }
-
+    
     /** Set font size.
      * c++ can not overload static and non-static member functions with the same parameter types.
      * so change the name to setFontSizeObj.
@@ -279,14 +250,13 @@ public:
      * @js NA
      */
     void setFontSizeObj(int size);
-
+    
     /** get font size .
      * @js getFontSize
      * @js NA
      */
     int getFontSizeObj() const;
-    CC_DEPRECATED_ATTRIBUTE int fontSizeObj() const { return getFontSizeObj(); }
-
+    
     /**
      * Set the font name .
      * c++ can not overload static and non-static member functions with the same parameter types.
@@ -301,77 +271,66 @@ public:
      * @js NA
      */
     const std::string& getFontNameObj() const;
-
-    /** Deprecated Use getFontNameObj() instead.
-     * @js NA
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
      */
-    CC_DEPRECATED_ATTRIBUTE const std::string& fontNameObj() const { return getFontNameObj(); }
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        MenuItemFont();
+    MenuItemFont();
     /**
      * @js NA
      * @lua NA
      */
     virtual ~MenuItemFont();
-
-    /** Initializes a menu item from a string with a target/selector. */
-    CC_DEPRECATED_ATTRIBUTE bool initWithString(const std::string& value, Ref* target, SEL_MenuHandler selector);
-
+    
     /** Initializes a menu item from a string with a target/selector. */
     bool initWithString(const std::string& value, const ccMenuCallback& callback);
-
+    
 protected:
     int _fontSize;
     std::string _fontName;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemFont)
+    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemFont);
 };
 
+
 /** @brief MenuItemSprite accepts Node<RGBAProtocol> objects as items.
  The images has 3 different states:
  - unselected image
  - selected image
  - disabled image
-
+ 
  @since v0.8.0
  */
 class CC_DLL MenuItemSprite : public MenuItem
 {
 public:
     /** Creates a menu item with a normal, selected and disabled image.*/
-    static MenuItemSprite* create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite = nullptr);
-    /** Creates a menu item with a normal and selected image with target/selector. */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemSprite* create(Node* normalSprite, Node* selectedSprite, Ref* target, SEL_MenuHandler selector);
-    /** Creates a menu item with a normal, selected and disabled image with target/selector. */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemSprite* create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, Ref* target, SEL_MenuHandler selector);
+    static MenuItemSprite * create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite = nullptr);
     /** Creates a menu item with a normal and selected image with a callable object. */
-    static MenuItemSprite* create(Node* normalSprite, Node* selectedSprite, const ccMenuCallback& callback);
+    static MenuItemSprite * create(Node* normalSprite, Node* selectedSprite, const ccMenuCallback& callback);
     /** Creates a menu item with a normal,selected  and disabled image with target/selector. */
-    static MenuItemSprite* create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, const ccMenuCallback& callback);
+    static MenuItemSprite * create(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, const ccMenuCallback& callback);
 
     /** Gets the image used when the item is not selected. */
     Node* getNormalImage() const { return _normalImage; }
-
+    
     /** Sets the image used when the item is not selected. */
     void setNormalImage(Node* image);
-
+    
     /** Gets the image used when the item is selected. */
     Node* getSelectedImage() const { return _selectedImage; }
-
+    
     /** Sets the image used when the item is selected. */
     void setSelectedImage(Node* image);
-
+    
     /** Gets the image used when the item is disabled. */
     Node* getDisabledImage() const { return _disabledImage; }
-
+    
     /** Sets the image used when the item is disabled. */
     void setDisabledImage(Node* image);
-
+    
     /**
      * The item was selected (not activated), similar to "mouse-over".
      @since v0.99.5
@@ -383,20 +342,17 @@ public:
 
     /** Enables or disables the item. */
     virtual void setEnabled(bool bEnabled);
-
-    CC_CONSTRUCTOR_ACCESS : MenuItemSprite()
-    : _normalImage(nullptr)
-    , _selectedImage(nullptr)
-    , _disabledImage(nullptr)
-    {
-    }
-
-    /** Initializes a menu item with a normal, selected and disabled image with target/selector. */
-    CC_DEPRECATED_ATTRIBUTE bool initWithNormalSprite(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, Ref* target, SEL_MenuHandler selector);
+    
+CC_CONSTRUCTOR_ACCESS:
+    MenuItemSprite()
+    :_normalImage(nullptr)
+    ,_selectedImage(nullptr)
+    ,_disabledImage(nullptr)
+    {}
 
     /** Initializes a menu item with a normal, selected and disabled image with a callable object. */
     bool initWithNormalSprite(Node* normalSprite, Node* selectedSprite, Node* disabledSprite, const ccMenuCallback& callback);
-
+    
 protected:
     virtual void updateImagesVisibility();
 
@@ -408,15 +364,16 @@ protected:
     Node* _disabledImage;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemSprite)
+    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemSprite);
 };
 
+
 /** @brief MenuItemImage accepts images as items.
  The images has 3 different states:
  - unselected image
  - selected image
  - disabled image
-
+ 
  For best results try that all images are of the same size.
  */
 class CC_DLL MenuItemImage : public MenuItemSprite
@@ -428,17 +385,10 @@ public:
     static MenuItemImage* create(const std::string& normalImage, const std::string& selectedImage);
     /** Creates a menu item with a normal,selected  and disabled image.*/
     static MenuItemImage* create(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage);
-    /** Creates a menu item with a normal and selected image with target/selector. */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemImage* create(const std::string& normalImage, const std::string& selectedImage, Ref* target, SEL_MenuHandler selector);
     /** Creates a menu item with a normal and selected image with a callable object. */
-    static MenuItemImage* create(const std::string& normalImage, const std::string& selectedImage, const ccMenuCallback& callback);
-
-    /** Creates a menu item with a normal,selected and disabled image with target/selector. */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemImage*
-    create(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage, Ref* target, SEL_MenuHandler selector);
+    static MenuItemImage* create(const std::string&normalImage, const std::string&selectedImage, const ccMenuCallback& callback);
     /** Creates a menu item with a normal,selected and disabled image with a callable object. */
-    static MenuItemImage*
-    create(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage, const ccMenuCallback& callback);
+    static MenuItemImage* create(const std::string&normalImage, const std::string&selectedImage, const std::string&disabledImage, const ccMenuCallback& callback);
 
     /** Sets the sprite frame for the normal image. */
     void setNormalSpriteFrame(SpriteFrame* frame);
@@ -446,33 +396,28 @@ public:
     void setSelectedSpriteFrame(SpriteFrame* frame);
     /** Sets the sprite frame for the disabled image. */
     void setDisabledSpriteFrame(SpriteFrame* frame);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        MenuItemImage()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    MenuItemImage(){}
     /**
      * @js NA
      * @lua NA
      */
-    virtual ~MenuItemImage() {}
-
+    virtual ~MenuItemImage(){}
+    
     bool init();
-
-    /** Initializes a menu item with a normal, selected and disabled image with target/selector. */
-    CC_DEPRECATED_ATTRIBUTE bool initWithNormalImage(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage,
-                                                     Ref* target, SEL_MenuHandler selector);
-
+    
     /** Initializes a menu item with a normal, selected and disabled image with a callable object. */
     bool initWithNormalImage(const std::string& normalImage, const std::string& selectedImage, const std::string& disabledImage, const ccMenuCallback& callback);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemImage)
+    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemImage);
 };
 
+
 /** @brief A MenuItemToggle.
  A simple container class that "toggles" it's inner items.
  The inner items can be any MenuItem.
@@ -480,91 +425,30 @@ private:
 class CC_DLL MenuItemToggle : public MenuItem
 {
 public:
-    /** Creates a menu item from a Array with a target selector.
-     * @js NA
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemToggle* createWithTarget(Ref* target, SEL_MenuHandler selector, const Vector<MenuItem*>& menuItems);
-    /** Creates a menu item from a list of items with a target/selector.
-     * @js NA
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE static MenuItemToggle* createWithTarget(Ref* target, SEL_MenuHandler selector, MenuItem* item, ...) CC_REQUIRES_NULL_TERMINATION;
-
     /**
      *@brief Creates a menu item from a Array with a callable object.
      */
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, const Vector<MenuItem*>& menuItems);
+    static MenuItemToggle * createWithCallback(const ccMenuCallback& callback, const Vector<MenuItem*>& menuItems);
     /** Creates a menu item from a list of items with a callable object. */
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-    // VS2013 does not support nullptr in variable args lists and variadic templates are also not supported.
-    typedef MenuItem* M;
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, std::nullptr_t listEnd) { return createWithCallbackVA(callback, m1, NULL); }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, NULL);
-    }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, M m3, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, m3, NULL);
-    }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, M m3, M m4, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, m3, m4, NULL);
-    }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, M m3, M m4, M m5, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, m3, m4, m5, NULL);
-    }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, M m3, M m4, M m5, M m6, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, m3, m4, m5, m6, NULL);
-    }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, M m3, M m4, M m5, M m6, M m7, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, m3, m4, m5, m6, m7, NULL);
-    }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, m3, m4, m5, m6, m7, m8, NULL);
-    }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, M m9, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, m3, m4, m5, m6, m7, m8, m9, NULL);
-    }
-    static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, M m1, M m2, M m3, M m4, M m5, M m6, M m7, M m8, M m9, M m10, std::nullptr_t listEnd)
-    {
-        return createWithCallbackVA(callback, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, NULL);
-    }
-
-    // On WP8 for lists longer than 10 items, use createWithArray or variadicCreate with NULL as the last argument.
-    static MenuItemToggle* createWithCallbackVA(const ccMenuCallback& callback, M item, ...);
-#else
     static MenuItemToggle* createWithCallback(const ccMenuCallback& callback, MenuItem* item, ...) CC_REQUIRES_NULL_TERMINATION;
-#endif
     /** Creates a menu item with no target/selector and no items. */
     static MenuItemToggle* create();
-
+    
     /** Creates a menu item with a item. */
-    static MenuItemToggle* create(MenuItem* item);
-
+    static MenuItemToggle* create(MenuItem *item);
+    
     /** Add more menu item. */
-    void addSubItem(MenuItem* item);
-
+    void addSubItem(MenuItem *item);
+    
     /** Return the selected item. */
     MenuItem* getSelectedItem();
 
-    /**
-     *@deprecated Use `getSelectedItem` instead.
-     */
-    CC_DEPRECATED_ATTRIBUTE MenuItem* selectedItem() { return getSelectedItem(); }
-
     /** Gets the index of the selected item. */
     unsigned int getSelectedIndex() const { return _selectedIndex; }
-
+    
     /** Sets the index of the selected item. */
     void setSelectedIndex(unsigned int index);
-
+    
     /** Gets the array that contains the subitems.
      *You can add/remove items in runtime, and you can replace the array with a new one.
      * @since v0.7.2
@@ -575,36 +459,31 @@ public:
     Vector<MenuItem*>& getSubItems() { return _subItems; }
 
     /** Sets the array that contains the subitems. */
-    void setSubItems(const Vector<MenuItem*>& items) { _subItems = items; }
-
+    void setSubItems(const Vector<MenuItem*>& items) {
+        _subItems = items;
+    }
+    
     // Overrides
     virtual void activate() override;
     virtual void selected() override;
     virtual void unselected() override;
     virtual void setEnabled(bool var) override;
     virtual void cleanup() override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        MenuItemToggle()
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    MenuItemToggle()
     : _selectedIndex(0)
     , _selectedItem(nullptr)
-    {
-    }
-
-    /** Initializes a menu item from a list of items with a target selector.
-     * @js NA
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE bool initWithTarget(Ref* target, SEL_MenuHandler selector, MenuItem* item, va_list args);
-
+    {}
+    
     /** Initializes a menu item from a list of items with a callable object. */
     bool initWithCallback(const ccMenuCallback& callback, MenuItem* item, va_list args);
-
+    
     /** Initializes a menu item with a item. */
-    bool initWithItem(MenuItem* item);
+    bool initWithItem(MenuItem *item);
 
 protected:
     /** Returns the selected item. */
@@ -617,12 +496,14 @@ protected:
     Vector<MenuItem*> _subItems;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemToggle)
+    CC_DISALLOW_COPY_AND_ASSIGN(MenuItemToggle);
+
 };
 
+
 // end of 2d group
 /// @}
 
 NS_CC_END
 
-#endif // CC_2D_MENUITEM_H
+#endif //__CCMENU_ITEM_H__
diff --git a/cocos2d/cocos/2d/CCMotionStreak.cpp b/cocos2d/cocos/2d/CCMotionStreak.cpp
index a7587dfe35..31a2ba181d 100644
--- a/cocos2d/cocos/2d/CCMotionStreak.cpp
+++ b/cocos2d/cocos/2d/CCMotionStreak.cpp
@@ -2,6 +2,7 @@
 Copyright (c) 2011      ForzeField Studios S.L.
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -23,52 +24,63 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-
 #include <cocos/2d/CCMotionStreak.h>
-
-#include <cocos/base/CCDirector.h>
 #include <cocos/math/CCVertex.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTexture2D.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/base/ccUtils.h>
 #include <cocos/renderer/CCTextureCache.h>
-#include <cocos/renderer/ccGLStateCache.h>
+#include <cocos/renderer/CCTexture2D.h>
+#include <cocos/renderer/CCRenderer.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 
 MotionStreak::MotionStreak()
-: _fastMode(false)
-, _startingPositionInitialized(false)
-, _texture(nullptr)
-, _blendFunc(BlendFunc::ALPHA_NON_PREMULTIPLIED)
-, _stroke(0.0f)
-, _fadeDelta(0.0f)
-, _minSeg(0.0f)
-, _maxPoints(0)
-, _nuPoints(0)
-, _previousNuPoints(0)
-, _pointVertexes(nullptr)
-, _pointState(nullptr)
-, _vertices(nullptr)
-, _colorPointer(nullptr)
-, _texCoords(nullptr)
 {
+    _customCommand.setDrawType(CustomCommand::DrawType::ARRAY);
+    _customCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE_STRIP);
+
+    auto& pipelineDescriptor = _customCommand.getPipelineDescriptor();
+    _programState = new (std::nothrow) backend::ProgramState(positionTextureColor_vert, positionTextureColor_frag);
+    pipelineDescriptor.programState = _programState;
+    _mvpMatrixLocaiton = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    _textureLocation = pipelineDescriptor.programState->getUniformLocation("u_texture");
+    
+    auto vertexLayout = _programState->getVertexLayout();
+    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT2, 0, false);
+    }
+    iter = attributeInfo.find("a_texCoord");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_texCoord", iter->second.location, backend::VertexFormat::FLOAT2, 2 * sizeof(float), false);
+    }
+    iter = attributeInfo.find("a_color");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_color", iter->second.location, backend::VertexFormat::UBYTE4, 4 * sizeof(float), true);
+    }
+    vertexLayout->setLayout(4 * sizeof(float) + 4 * sizeof(uint8_t));
 }
 
 MotionStreak::~MotionStreak()
 {
     CC_SAFE_RELEASE(_texture);
-    CC_SAFE_FREE(_pointState);
-    CC_SAFE_FREE(_pointVertexes);
-    CC_SAFE_FREE(_vertices);
-    CC_SAFE_FREE(_colorPointer);
-    CC_SAFE_FREE(_texCoords);
+    CC_SAFE_DELETE_ARRAY(_pointState);;
+    CC_SAFE_DELETE_ARRAY(_pointVertexes);;
+    CC_SAFE_DELETE_ARRAY(_vertices);;
+    CC_SAFE_DELETE_ARRAY(_colorPointer);;
+    CC_SAFE_DELETE_ARRAY(_texCoords);;
+    CC_SAFE_RELEASE(_programState);
 }
 
 MotionStreak* MotionStreak::create(float fade, float minSeg, float stroke, const Color3B& color, const std::string& path)
 {
-    MotionStreak* ret = new (std::nothrow) MotionStreak();
+    MotionStreak *ret = new (std::nothrow) MotionStreak();
     if (ret && ret->initWithFade(fade, minSeg, stroke, color, path))
     {
         ret->autorelease();
@@ -81,7 +93,7 @@ MotionStreak* MotionStreak::create(float fade, float minSeg, float stroke, const
 
 MotionStreak* MotionStreak::create(float fade, float minSeg, float stroke, const Color3B& color, Texture2D* texture)
 {
-    MotionStreak* ret = new (std::nothrow) MotionStreak();
+    MotionStreak *ret = new (std::nothrow) MotionStreak();
     if (ret && ret->initWithFade(fade, minSeg, stroke, color, texture))
     {
         ret->autorelease();
@@ -96,7 +108,7 @@ bool MotionStreak::initWithFade(float fade, float minSeg, float stroke, const Co
 {
     CCASSERT(!path.empty(), "Invalid filename");
 
-    Texture2D* texture = Director::getInstance()->getTextureCache()->addImage(path);
+    Texture2D *texture = Director::getInstance()->getTextureCache()->addImage(path);
     return initWithFade(fade, minSeg, stroke, color, texture);
 }
 
@@ -109,28 +121,30 @@ bool MotionStreak::initWithFade(float fade, float minSeg, float stroke, const Co
 
     _positionR.setZero();
     _fastMode = true;
-    _minSeg = (minSeg == -1.0f) ? stroke / 5.0f : minSeg;
+    _minSeg = (minSeg == -1.0f) ? stroke/ 5.0f : minSeg;
     _minSeg *= _minSeg;
 
     _stroke = stroke;
     _fadeDelta = 1.0f / fade;
-
+    
     double fps = 1 / Director::getInstance()->getAnimationInterval();
     _maxPoints = (int)(fade * fps) + 2;
-
-    _nuPoints = 0;
-    _pointState = (float*)malloc(sizeof(float) * _maxPoints);
+    
+    _pointState = (float *)malloc(sizeof(float) * _maxPoints);
     _pointVertexes = (Vec2*)malloc(sizeof(Vec2) * _maxPoints);
 
-    _vertices = (Vec2*)malloc(sizeof(Vec2) * _maxPoints * 2);
-    _texCoords = (Tex2F*)malloc(sizeof(Tex2F) * _maxPoints * 2);
-    _colorPointer = (GLubyte*)malloc(sizeof(GLubyte) * _maxPoints * 2 * 4);
+    const size_t VERTEX_SIZE = sizeof(Vec2) + sizeof(Tex2F) + sizeof(uint8_t) * 4;
 
-    // Set blend mode
-    _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
+    _vertexCount = _maxPoints * 2;
+    _vertices = (Vec2*)malloc(sizeof(Vec2) * _vertexCount);
+    _texCoords = (Tex2F*)malloc(sizeof(Tex2F) * _vertexCount);
+    _colorPointer =  (uint8_t*)malloc(sizeof(uint8_t) * 4 * _vertexCount);
+    _customCommand.createVertexBuffer(VERTEX_SIZE, _vertexCount, CustomCommand::BufferUsage::DYNAMIC);
 
-    // shader state
-    setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR, texture));
+    std::vector<uint8_t> zeros;
+    zeros.resize(VERTEX_SIZE * _vertexCount);
+    std::fill(zeros.begin(), zeros.end(), 0);
+    _customCommand.updateVertexBuffer(zeros.data(), zeros.size());
 
     setTexture(texture);
     setColor(color);
@@ -141,8 +155,7 @@ bool MotionStreak::initWithFade(float fade, float minSeg, float stroke, const Co
 
 void MotionStreak::setPosition(const Vec2& position)
 {
-    if (!_startingPositionInitialized)
-    {
+    if (!_startingPositionInitialized) {
         _startingPositionInitialized = true;
     }
     _positionR = position;
@@ -150,8 +163,7 @@ void MotionStreak::setPosition(const Vec2& position)
 
 void MotionStreak::setPosition(float x, float y)
 {
-    if (!_startingPositionInitialized)
-    {
+    if (!_startingPositionInitialized) {
         _startingPositionInitialized = true;
     }
     _positionR.x = x;
@@ -181,8 +193,7 @@ Vec3 MotionStreak::getPosition3D() const
 
 void MotionStreak::setPositionX(float x)
 {
-    if (!_startingPositionInitialized)
-    {
+    if (!_startingPositionInitialized) {
         _startingPositionInitialized = true;
     }
     _positionR.x = x;
@@ -190,13 +201,12 @@ void MotionStreak::setPositionX(float x)
 
 float MotionStreak::getPositionY() const
 {
-    return _positionR.y;
+    return  _positionR.y;
 }
 
 void MotionStreak::setPositionY(float y)
 {
-    if (!_startingPositionInitialized)
-    {
+    if (!_startingPositionInitialized) {
         _startingPositionInitialized = true;
     }
     _positionR.y = y;
@@ -207,18 +217,18 @@ void MotionStreak::tintWithColor(const Color3B& colors)
     setColor(colors);
 
     // Fast assignation
-    for (unsigned int i = 0; i < _nuPoints * 2; i++)
+    for(unsigned int i = 0; i<_nuPoints*2; i++) 
     {
-        *((Color3B*)(_colorPointer + i * 4)) = colors;
+        *((Color3B*) (_colorPointer+i*4)) = colors;
     }
 }
 
-Texture2D* MotionStreak::getTexture(void) const
+Texture2D* MotionStreak::getTexture() const
 {
     return _texture;
 }
 
-void MotionStreak::setTexture(Texture2D* texture)
+void MotionStreak::setTexture(Texture2D *texture)
 {
     if (_texture != texture)
     {
@@ -228,32 +238,32 @@ void MotionStreak::setTexture(Texture2D* texture)
     }
 }
 
-void MotionStreak::setBlendFunc(const BlendFunc& blendFunc)
+void MotionStreak::setBlendFunc(const BlendFunc &blendFunc)
 {
     _blendFunc = blendFunc;
 }
 
-const BlendFunc& MotionStreak::getBlendFunc(void) const
+const BlendFunc& MotionStreak::getBlendFunc() const
 {
     return _blendFunc;
 }
 
-void MotionStreak::setOpacity(GLubyte opacity)
+void MotionStreak::setOpacity(uint8_t /*opacity*/)
 {
     CCASSERT(false, "Set opacity no supported");
 }
 
-GLubyte MotionStreak::getOpacity(void) const
+uint8_t MotionStreak::getOpacity() const
 {
     CCASSERT(false, "Opacity no supported");
     return 0;
 }
 
-void MotionStreak::setOpacityModifyRGB(bool)
+void MotionStreak::setOpacityModifyRGB(bool /*bValue*/)
 {
 }
 
-bool MotionStreak::isOpacityModifyRGB(void) const
+bool MotionStreak::isOpacityModifyRGB() const
 {
     return false;
 }
@@ -261,9 +271,7 @@ bool MotionStreak::isOpacityModifyRGB(void) const
 void MotionStreak::update(float delta)
 {
     if (!_startingPositionInitialized)
-    {
         return;
-    }
 
     delta *= _fadeDelta;
 
@@ -293,24 +301,23 @@ void MotionStreak::update(float delta)
                 i2 = i * 2;
                 newIdx2 = newIdx * 2;
                 _vertices[newIdx2] = _vertices[i2];
-                _vertices[newIdx2 + 1] = _vertices[i2 + 1];
+                _vertices[newIdx2+1] = _vertices[i2+1];
 
                 // Move color
                 i2 *= 4;
                 newIdx2 *= 4;
-                _colorPointer[newIdx2 + 0] = _colorPointer[i2 + 0];
-                _colorPointer[newIdx2 + 1] = _colorPointer[i2 + 1];
-                _colorPointer[newIdx2 + 2] = _colorPointer[i2 + 2];
-                _colorPointer[newIdx2 + 4] = _colorPointer[i2 + 4];
-                _colorPointer[newIdx2 + 5] = _colorPointer[i2 + 5];
-                _colorPointer[newIdx2 + 6] = _colorPointer[i2 + 6];
-            }
-            else
+                _colorPointer[newIdx2+0] = _colorPointer[i2+0];
+                _colorPointer[newIdx2+1] = _colorPointer[i2+1];
+                _colorPointer[newIdx2+2] = _colorPointer[i2+2];
+                _colorPointer[newIdx2+4] = _colorPointer[i2+4];
+                _colorPointer[newIdx2+5] = _colorPointer[i2+5];
+                _colorPointer[newIdx2+6] = _colorPointer[i2+6];
+            }else
                 newIdx2 = newIdx * 8;
 
-            const GLubyte op = (GLubyte)(_pointState[newIdx] * 255.0f);
-            _colorPointer[newIdx2 + 3] = op;
-            _colorPointer[newIdx2 + 7] = op;
+            const uint8_t op = (uint8_t)(_pointState[newIdx] * 255.0f);
+            _colorPointer[newIdx2+3] = op;
+            _colorPointer[newIdx2+7] = op;
         }
     }
     _nuPoints -= mov;
@@ -318,18 +325,13 @@ void MotionStreak::update(float delta)
     // Append new point
     bool appendNewPoint = true;
     if (_nuPoints >= _maxPoints)
-    {
         appendNewPoint = false;
-    }
-
     else if (_nuPoints > 0)
     {
-        bool a1 = _pointVertexes[_nuPoints - 1].getDistanceSq(_positionR) < _minSeg;
-        bool a2 = (_nuPoints == 1) ? false : (_pointVertexes[_nuPoints - 2].getDistanceSq(_positionR) < (_minSeg * 2.0f));
+        bool a1 = _pointVertexes[_nuPoints-1].getDistanceSq(_positionR) < _minSeg;
+        bool a2 = (_nuPoints == 1) ? false : (_pointVertexes[_nuPoints-2].getDistanceSq(_positionR) < (_minSeg * 2.0f));
         if (a1 || a2)
-        {
             appendNewPoint = false;
-        }
     }
 
     if (appendNewPoint)
@@ -340,16 +342,16 @@ void MotionStreak::update(float delta)
         // Color assignment
         const unsigned int offset = _nuPoints * 8;
         *((Color3B*)(_colorPointer + offset)) = _displayedColor;
-        *((Color3B*)(_colorPointer + offset + 4)) = _displayedColor;
+        *((Color3B*)(_colorPointer + offset+4)) = _displayedColor;
 
         // Opacity
-        _colorPointer[offset + 3] = 255;
-        _colorPointer[offset + 7] = 255;
+        _colorPointer[offset+3] = 255;
+        _colorPointer[offset+7] = 255;
 
         // Generate polygon
-        if (_nuPoints > 0 && _fastMode)
+        if (_nuPoints > 0 && _fastMode )
         {
-            if (_nuPoints > 1)
+            if(_nuPoints > 1)
             {
                 ccVertexLineToPolygon(_pointVertexes, _stroke, _vertices, _nuPoints, 1);
             }
@@ -362,19 +364,16 @@ void MotionStreak::update(float delta)
         _nuPoints++;
     }
 
-    if (!_fastMode)
-    {
+
+    if (! _fastMode)
         ccVertexLineToPolygon(_pointVertexes, _stroke, _vertices, 0, _nuPoints);
-    }
 
     // Updated Tex Coords only if they are different than previous step
-    if (_nuPoints && _previousNuPoints != _nuPoints)
-    {
+    if (_nuPoints  && _previousNuPoints != _nuPoints) {
         float texDelta = 1.0f / _nuPoints;
-        for (i = 0; i < _nuPoints; i++)
-        {
-            _texCoords[i * 2] = Tex2F(0, texDelta * i);
-            _texCoords[i * 2 + 1] = Tex2F(1, texDelta * i);
+        for (i = 0; i < _nuPoints; i++) {
+            _texCoords[i*2] = Tex2F(0, texDelta*i);
+            _texCoords[i*2+1] = Tex2F(1, texDelta*i);
         }
 
         _previousNuPoints = _nuPoints;
@@ -386,43 +385,33 @@ void MotionStreak::reset()
     _nuPoints = 0;
 }
 
-void MotionStreak::onDraw(const Mat4& transform, uint32_t flags)
+void MotionStreak::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
-    getGLProgram()->use();
-    getGLProgram()->setUniformsForBuiltins(transform);
-
-    GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
-    GL::blendFunc(_blendFunc.src, _blendFunc.dst);
-
-    GL::bindTexture2D(_texture);
-
-#if CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN
-    // Size calculations from ::initWithFade
-    setGLBufferData(_vertices, (sizeof(Vec2) * _maxPoints * 2), 0);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, 0, 0);
+    if(_nuPoints <= 1)
+        return;
 
-    setGLBufferData(_texCoords, (sizeof(Tex2F) * _maxPoints * 2), 1);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, 0, 0);
+    auto drawCount = _nuPoints * 2;
+        
+    _customCommand.init(_globalZOrder, _blendFunc);
+    _customCommand.setVertexDrawInfo(0, drawCount);
+    renderer->addCommand(&_customCommand);
 
-    setGLBufferData(_colorPointer, (sizeof(GLubyte) * _maxPoints * 2 * 4), 2);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, 0);
-#else
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, 0, _vertices);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, 0, _texCoords);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, _colorPointer);
-#endif
+    auto programState = _customCommand.getPipelineDescriptor().programState;
+    programState->setTexture(_textureLocation, 0, _texture->getBackendTexture());
 
-    glDrawArrays(GL_TRIANGLE_STRIP, 0, (GLsizei)_nuPoints * 2);
-    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, _nuPoints * 2);
-}
+    const auto& projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    Mat4 finalMat = projectionMat * transform;
+    programState->setUniform(_mvpMatrixLocaiton, finalMat.m, sizeof(Mat4));
 
-void MotionStreak::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
-{
-    if (_nuPoints <= 1)
-        return;
-    _customCommand.init(_globalZOrder, transform, flags);
-    _customCommand.setFunc([this, transform, flags]() { onDraw(transform, flags); });
-    renderer->addCommand(&_customCommand);
+    unsigned int offset = 0;
+    unsigned int vertexSize = sizeof(Vec2) + sizeof(Vec2) + sizeof(uint8_t) * 4;
+    for (unsigned int i = 0; i < drawCount; ++i)
+    {
+        offset = i * vertexSize;
+        _customCommand.updateVertexBuffer(&_vertices[i], offset, sizeof(_vertices[0]));
+        _customCommand.updateVertexBuffer(&_texCoords[i], offset + sizeof(_vertices[0]), sizeof(_texCoords[0]) );
+        _customCommand.updateVertexBuffer(&_colorPointer[i * 4], offset + sizeof(_vertices[0]) + sizeof(_texCoords[0]), 4 * sizeof(uint8_t));
+    }
 }
 
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCMotionStreak.h b/cocos2d/cocos/2d/CCMotionStreak.h
index b98cc7968d..d411324008 100644
--- a/cocos2d/cocos/2d/CCMotionStreak.h
+++ b/cocos2d/cocos/2d/CCMotionStreak.h
@@ -2,6 +2,7 @@
 Copyright (c) 2011      ForzeField Studios S.L.
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -23,17 +24,12 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_MOTIONSTREAK_H
-#define CC_2D_MOTIONSTREAK_H
+#pragma once
 
-#include <cocos/2d/CCNode.h>
 #include <cocos/base/CCProtocols.h>
+#include <cocos/2d/CCNode.h>
 #include <cocos/renderer/CCCustomCommand.h>
 
-#if CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN
-#    include <cocos/2d/CCGLBufferedNode.h>
-#endif
-
 NS_CC_BEGIN
 
 class Texture2D;
@@ -46,12 +42,7 @@ class Texture2D;
 /** @class MotionStreak.
  * @brief Creates a trailing path.
  */
-class CC_DLL MotionStreak : public Node,
-                            public TextureProtocol
-#if CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN
-,
-                            public GLBufferedNode
-#endif
+class CC_DLL MotionStreak : public Node, public TextureProtocol
 {
 public:
     /** Creates and initializes a motion streak with fade in seconds, minimum segments, stroke's width, color, texture filename.
@@ -65,7 +56,7 @@ public:
      */
     static MotionStreak* create(float timeToFade, float minSeg, float strokeWidth, const Color3B& strokeColor, const std::string& imagePath);
     /** Creates and initializes a motion streak with fade in seconds, minimum segments, stroke's width, color, texture.
-     *
+     * 
      * @param timeToFade The fade time, in seconds.
      * @param minSeg The minimum segments.
      * @param strokeWidth The width of stroke.
@@ -75,6 +66,42 @@ public:
      */
     static MotionStreak* create(float timeToFade, float minSeg, float strokeWidth, const Color3B& strokeColor, Texture2D* texture);
 
+    // Overrides
+    virtual void setPosition(const Vec2& position) override;
+    virtual void setPosition(float x, float y) override;
+    virtual const Vec2& getPosition() const override;
+    virtual void getPosition(float* x, float* y) const override;
+    virtual void setPositionX(float x) override;
+    virtual void setPositionY(float y) override;
+    virtual float getPositionX() const override;
+    virtual float getPositionY() const override;
+    virtual Vec3 getPosition3D() const override;
+    /**
+    * @js NA
+    * @lua NA
+    */
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
+    /**
+    * @lua NA
+    */
+    virtual void update(float delta) override;
+    virtual Texture2D* getTexture() const override;
+    virtual void setTexture(Texture2D *texture) override;
+    /**
+    * @js NA
+    * @lua NA
+    */
+    virtual void setBlendFunc(const BlendFunc &blendFunc) override;
+    /**
+    * @js NA
+    * @lua NA
+    */
+    virtual const BlendFunc& getBlendFunc() const override;
+    virtual uint8_t getOpacity() const override;
+    virtual void setOpacity(uint8_t opacity) override;
+    virtual void setOpacityModifyRGB(bool value) override;
+    virtual bool isOpacityModifyRGB() const override;
+
     /** Color used for the tint.
      *
      * @param colors The color used for the tint.
@@ -85,8 +112,8 @@ public:
      */
     void reset();
 
-    /** When fast mode is enabled, new points are added faster but with lower precision.
-     *
+    /** When fast mode is enabled, new points are added faster but with lower precision. 
+     * 
      * @return True if fast mode is enabled.
      */
     bool isFastMode() const { return _fastMode; }
@@ -115,91 +142,58 @@ public:
      *
      * @param bStartingPositionInitialized True if initialized the starting position.
      */
-    void setStartingPositionInitialized(bool bStartingPositionInitialized) { _startingPositionInitialized = bStartingPositionInitialized; }
-
-    // Overrides
-    void setPosition(const Vec2& position) override;
-    void setPosition(float x, float y) override;
-    const Vec2& getPosition() const override;
-    void getPosition(float* x, float* y) const override;
-    void setPositionX(float x) override;
-    void setPositionY(float y) override;
-    float getPositionX(void) const override;
-    float getPositionY(void) const override;
-    Vec3 getPosition3D() const override;
-    /**
-     * @js NA
-     * @lua NA
-     */
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
-    /**
-     * @lua NA
-     */
-    void update(float delta) override;
-    Texture2D* getTexture() const override;
-    void setTexture(Texture2D* texture) override;
-    /**
-     * @js NA
-     * @lua NA
-     */
-    void setBlendFunc(const BlendFunc& blendFunc) override;
-    /**
-     * @js NA
-     * @lua NA
-     */
-    const BlendFunc& getBlendFunc() const override;
-    GLubyte getOpacity() const override;
-    void setOpacity(GLubyte opacity) override;
-    void setOpacityModifyRGB(bool value) override;
-    bool isOpacityModifyRGB() const override;
-
-    CC_CONSTRUCTOR_ACCESS : MotionStreak();
-    ~MotionStreak() override;
-
+    void setStartingPositionInitialized(bool bStartingPositionInitialized)
+    {
+        _startingPositionInitialized = bStartingPositionInitialized; 
+    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    MotionStreak();
+    virtual ~MotionStreak();
+    
     /** initializes a motion streak with fade in seconds, minimum segments, stroke's width, color and texture filename */
     bool initWithFade(float fade, float minSeg, float stroke, const Color3B& color, const std::string& path);
-
+    
     /** initializes a motion streak with fade in seconds, minimum segments, stroke's width, color and texture  */
     bool initWithFade(float fade, float minSeg, float stroke, const Color3B& color, Texture2D* texture);
 
 protected:
-    // renderer callback
-    void onDraw(const Mat4& transform, uint32_t flags);
-
-    bool _fastMode;
-    bool _startingPositionInitialized;
+    bool _fastMode = false;
+    bool _startingPositionInitialized = false;
 
     /** texture used for the motion streak */
-    Texture2D* _texture;
-    BlendFunc _blendFunc;
+    Texture2D* _texture = nullptr;
+    BlendFunc _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
     Vec2 _positionR;
 
-    float _stroke;
-    float _fadeDelta;
-    float _minSeg;
+    float _stroke = 0.f;
+    float _fadeDelta = 0.f;
+    float _minSeg = 0.f;
 
-    unsigned int _maxPoints;
-    unsigned int _nuPoints;
-    unsigned int _previousNuPoints;
+    unsigned int _maxPoints = 0;
+    unsigned int _nuPoints = 0;
+    unsigned int _previousNuPoints = 0;
 
     /** Pointers */
-    Vec2* _pointVertexes;
-    float* _pointState;
-
-    // Opengl
-    Vec2* _vertices;
-    GLubyte* _colorPointer;
-    Tex2F* _texCoords;
-
+    Vec2* _pointVertexes = nullptr;
+    float* _pointState = nullptr;
+
+    Vec2* _vertices = nullptr;
+    uint8_t* _colorPointer = nullptr;
+    Tex2F* _texCoords = nullptr;
+    unsigned int _vertexCount = 0;
+    
     CustomCommand _customCommand;
+    
+    backend::UniformLocation _mvpMatrixLocaiton;
+    backend::UniformLocation _textureLocation;
+    backend::ProgramState* _programState = nullptr;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(MotionStreak)
+    CC_DISALLOW_COPY_AND_ASSIGN(MotionStreak);
 };
 
 // end of _2d group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_MOTIONSTREAK_H
diff --git a/cocos2d/cocos/2d/CCNode.cpp b/cocos2d/cocos/2d/CCNode.cpp
index 86495b421c..731cc7cde9 100644
--- a/cocos2d/cocos/2d/CCNode.cpp
+++ b/cocos2d/cocos/2d/CCNode.cpp
@@ -4,6 +4,7 @@ Copyright (c) 2009      Valentin Milea
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -28,41 +29,34 @@ THE SOFTWARE.
 
 #include <cocos/2d/CCNode.h>
 
-#include <cocos/2d/CCAction.h>
-#include <cocos/2d/CCActionManager.h>
-#include <cocos/2d/CCCamera.h>
-#include <cocos/2d/CCComponent.h>
-#include <cocos/2d/CCComponentContainer.h>
-#include <cocos/2d/CCScene.h>
+#include <algorithm>
+#include <string>
+#include <regex>
+
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/CCScheduler.h>
-#include <cocos/base/CCTouch.h>
+#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/MathUtil.h>
-#include <cocos/math/TransformUtils.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
+#include <cocos/2d/CCCamera.h>
+#include <cocos/2d/CCActionManager.h>
+#include <cocos/2d/CCScene.h>
+#include <cocos/2d/CCComponent.h>
 #include <cocos/renderer/CCMaterial.h>
+#include <cocos/math/TransformUtils.h>
+#include <cocos/2d/CCAction.h>
 
-#if CC_USE_PHYSICS
-#    include <cocos/physics/CCPhysicsBody.h>
+#if CC_NODE_RENDER_SUBPIXEL
+#define RENDER_IN_SUBPIXEL
+#else
+#define RENDER_IN_SUBPIXEL(__ARGS__) (ceil(__ARGS__))
 #endif
 
-#include <algorithm>
-#include <cmath>
-#include <limits>
-#include <regex>
-#include <string>
-
-using namespace std::chrono_literals;
-
-static constexpr auto const epsi = std::numeric_limits<float>::epsilon();
 
 NS_CC_BEGIN
 
 // FIXME:: Yes, nodes might have a sort problem once every 30 days if the game runs at 60 FPS and each frame sprites are reordered.
 std::uint32_t Node::s_globalOrderOfArrival = 0;
+int Node::__attachedNodeCount = 0;
 
 // MARK: Constructor, Destructor, Init
 
@@ -79,6 +73,7 @@ Node::Node()
 , _normalizedPositionDirty(false)
 , _skewX(0.0f)
 , _skewY(0.0f)
+, _anchorPoint(0, 0)
 , _contentSize(Size::ZERO)
 , _contentSizeDirty(true)
 , _transformDirty(true)
@@ -88,7 +83,7 @@ Node::Node()
 , _transformUpdated(true)
 // children (lazy allocs)
 // lazy alloc
-, _localZOrderArrival(0LL)
+, _localZOrder$Arrival(0LL)
 , _globalZOrder(0)
 , _parent(nullptr)
 // "whole screen" objects. like Scenes and Layers, should set _ignoreAnchorPointForPosition to true
@@ -98,7 +93,6 @@ Node::Node()
 // userData is always inited as nil
 , _userData(nullptr)
 , _userObject(nullptr)
-, _glProgramState(nullptr)
 , _running(false)
 , _visible(true)
 , _ignoreAnchorPointForPosition(false)
@@ -115,6 +109,10 @@ Node::Node()
 , _cascadeColorEnabled(false)
 , _cascadeOpacityEnabled(false)
 , _cameraMask(1)
+, _onEnterCallback(nullptr)
+, _onExitCallback(nullptr)
+, _onEnterTransitionDidFinishCallback(nullptr)
+, _onExitTransitionDidStartCallback(nullptr)
 #if CC_USE_PHYSICS
 , _physicsBody(nullptr)
 #endif
@@ -127,7 +125,7 @@ Node::Node()
     _scheduler->retain();
     _eventDispatcher = _director->getEventDispatcher();
     _eventDispatcher->retain();
-
+    
 #if CC_ENABLE_SCRIPT_BINDING
     ScriptEngineProtocol* engine = ScriptEngineManager::getInstance()->getScriptEngine();
     _scriptType = engine != nullptr ? engine->getScriptType() : kScriptTypeNone;
@@ -135,9 +133,9 @@ Node::Node()
     _transform = _inverse = Mat4::IDENTITY;
 }
 
-Node* Node::create()
+Node * Node::create()
 {
-    Node* ret = new (std::nothrow) Node();
+    Node * ret = new (std::nothrow) Node();
     if (ret && ret->init())
     {
         ret->autorelease();
@@ -151,8 +149,8 @@ Node* Node::create()
 
 Node::~Node()
 {
-    CCLOGINFO("deallocing Node: %p - tag: %i", this, _tag);
-
+    CCLOGINFO( "deallocing Node: %p - tag: %i", this, _tag );
+    
 #if CC_ENABLE_SCRIPT_BINDING
     if (_updateScriptHandler)
     {
@@ -161,28 +159,25 @@ Node::~Node()
 #endif
 
     // User object has to be released before others, since userObject may have a weak reference of this node
-    // It may invoke `node->stopAllAction();` while `_actionManager` is null if the next line is after `CC_SAFE_RELEASE_NULL(_actionManager)`.
+    // It may invoke `node->stopAllActions();` while `_actionManager` is null if the next line is after `CC_SAFE_RELEASE_NULL(_actionManager)`.
     CC_SAFE_RELEASE_NULL(_userObject);
 
-    // attributes
-    CC_SAFE_RELEASE_NULL(_glProgramState);
-
     for (auto& child : _children)
     {
         child->_parent = nullptr;
     }
 
     removeAllComponents();
-
+    
     CC_SAFE_DELETE(_componentContainer);
-
+    
     stopAllActions();
     unscheduleAllCallbacks();
     CC_SAFE_RELEASE_NULL(_actionManager);
     CC_SAFE_RELEASE_NULL(_scheduler);
-
+    
     _eventDispatcher->removeEventListenersForTarget(this);
-
+    
 #if CC_NODE_DEBUG_VERIFY_EVENT_LISTENERS && COCOS2D_DEBUG > 0
     _eventDispatcher->debugCheckNodeHasNoEventListenersOnDestruction(this);
 #endif
@@ -191,6 +186,7 @@ Node::~Node()
     CC_SAFE_RELEASE(_eventDispatcher);
 
     delete[] _additionalTransform;
+    CC_SAFE_RELEASE(_programState);
 }
 
 bool Node::init()
@@ -211,13 +207,23 @@ void Node::cleanup()
         ScriptEngineManager::sendNodeEventToLua(this, kNodeOnCleanup);
     }
 #endif // #if CC_ENABLE_SCRIPT_BINDING
-
+    
     // actions
     this->stopAllActions();
     // timers
     this->unscheduleAllCallbacks();
 
-    for (const auto& child : _children)
+    // NOTE: Although it was correct that removing event listeners associated with current node in Node::cleanup.
+    // But it broke the compatibility to the versions before v3.16 .
+    // User code may call `node->removeFromParent(true)` which will trigger node's cleanup method, when the node 
+    // is added to scene again, event listeners like EventListenerTouchOneByOne will be lost. 
+    // In fact, user's code should use `node->removeFromParent(false)` in order not to do a cleanup and just remove node
+    // from its parent. For more discussion about why we revert this change is at https://github.com/cocos2d/cocos2d-x/issues/18104.
+    // We need to consider more before we want to correct the old and wrong logic code.
+    // For now, compatiblity is the most important for our users.
+//    _eventDispatcher->removeEventListenersForTarget(this);
+    
+    for( const auto &child: _children)
         child->cleanup();
 }
 
@@ -235,9 +241,9 @@ float Node::getSkewX() const
 
 void Node::setSkewX(float skewX)
 {
-    if (std::abs(_skewX - skewX) < epsi)
+    if (_skewX == skewX)
         return;
-
+    
     _skewX = skewX;
     _transformUpdated = _transformDirty = _inverseDirty = true;
 }
@@ -249,9 +255,9 @@ float Node::getSkewY() const
 
 void Node::setSkewY(float skewY)
 {
-    if (std::abs(_skewY - skewY) < epsi)
+    if (_skewY == skewY)
         return;
-
+    
     _skewY = skewY;
     _transformUpdated = _transformDirty = _inverseDirty = true;
 }
@@ -260,7 +266,7 @@ void Node::setLocalZOrder(std::int32_t z)
 {
     if (getLocalZOrder() == z)
         return;
-
+    
     _setLocalZOrder(z);
     if (_parent)
     {
@@ -284,7 +290,7 @@ void Node::updateOrderOfArrival()
 
 void Node::setGlobalZOrder(float globalZOrder)
 {
-    if (std::abs(_globalZOrder - globalZOrder) > epsi)
+    if (_globalZOrder != globalZOrder)
     {
         _globalZOrder = globalZOrder;
         _eventDispatcher->setDirtyForNode(this);
@@ -294,19 +300,19 @@ void Node::setGlobalZOrder(float globalZOrder)
 /// rotation getter
 float Node::getRotation() const
 {
-    CCASSERT(std::abs(_rotationZ_X - _rotationZ_Y) < epsi, "CCNode#rotation. RotationX != RotationY. Don't know which one to return");
+    CCASSERT(_rotationZ_X == _rotationZ_Y, "CCNode#rotation. RotationX != RotationY. Don't know which one to return");
     return _rotationZ_X;
 }
 
 /// rotation setter
 void Node::setRotation(float rotation)
 {
-    if (std::abs(_rotationZ_X - rotation) < epsi)
+    if (_rotationZ_X == rotation)
         return;
-
+    
     _rotationZ_X = _rotationZ_Y = rotation;
     _transformUpdated = _transformDirty = _inverseDirty = true;
-
+    
     updateRotationQuat();
 }
 
@@ -317,9 +323,11 @@ float Node::getRotationSkewX() const
 
 void Node::setRotation3D(const Vec3& rotation)
 {
-    if (std::abs(_rotationX - rotation.x) < epsi && std::abs(_rotationY - rotation.y) < epsi && std::abs(_rotationZ_X - rotation.z) < epsi)
+    if (_rotationX == rotation.x &&
+        _rotationY == rotation.y &&
+        _rotationZ_X == rotation.z)
         return;
-
+    
     _transformUpdated = _transformDirty = _inverseDirty = true;
 
     _rotationX = rotation.x;
@@ -327,16 +335,16 @@ void Node::setRotation3D(const Vec3& rotation)
 
     // rotation Z is decomposed in 2 to simulate Skew for Flash animations
     _rotationZ_Y = _rotationZ_X = rotation.z;
-
+    
     updateRotationQuat();
 }
 
 Vec3 Node::getRotation3D() const
 {
     // rotation Z is decomposed in 2 to simulate Skew for Flash animations
-    CCASSERT(std::abs(_rotationZ_X - _rotationZ_Y) < epsi, "_rotationZ_X != _rotationZ_Y");
+    CCASSERT(_rotationZ_X == _rotationZ_Y, "_rotationZ_X != _rotationZ_Y");
 
-    return Vec3(_rotationX, _rotationY, _rotationZ_X);
+    return Vec3(_rotationX,_rotationY,_rotationZ_X);
 }
 
 void Node::updateRotationQuat()
@@ -344,10 +352,8 @@ void Node::updateRotationQuat()
     // convert Euler angle to quaternion
     // when _rotationZ_X == _rotationZ_Y, _rotationQuat = RotationZ_X * RotationY * RotationX
     // when _rotationZ_X != _rotationZ_Y, _rotationQuat = RotationY * RotationX
-    float halfRadx = CC_DEGREES_TO_RADIANS(_rotationX / 2.f), halfRady = CC_DEGREES_TO_RADIANS(_rotationY / 2.f),
-          halfRadz = std::abs(_rotationZ_X - _rotationZ_Y) < epsi ? -CC_DEGREES_TO_RADIANS(_rotationZ_X / 2.f) : 0.f;
-    float coshalfRadx = std::cos(halfRadx), sinhalfRadx = std::sin(halfRadx), coshalfRady = std::cos(halfRady), sinhalfRady = std::sin(halfRady),
-          coshalfRadz = std::cos(halfRadz), sinhalfRadz = std::sin(halfRadz);
+    float halfRadx = CC_DEGREES_TO_RADIANS(_rotationX / 2.f), halfRady = CC_DEGREES_TO_RADIANS(_rotationY / 2.f), halfRadz = _rotationZ_X == _rotationZ_Y ? -CC_DEGREES_TO_RADIANS(_rotationZ_X / 2.f) : 0;
+    float coshalfRadx = cosf(halfRadx), sinhalfRadx = sinf(halfRadx), coshalfRady = cosf(halfRady), sinhalfRady = sinf(halfRady), coshalfRadz = cosf(halfRadz), sinhalfRadz = sinf(halfRadz);
     _rotationQuat.x = sinhalfRadx * coshalfRady * coshalfRadz - coshalfRadx * sinhalfRady * sinhalfRadz;
     _rotationQuat.y = coshalfRadx * sinhalfRady * coshalfRadz + sinhalfRadx * coshalfRady * sinhalfRadz;
     _rotationQuat.z = coshalfRadx * coshalfRady * sinhalfRadz - sinhalfRadx * sinhalfRady * coshalfRadz;
@@ -356,14 +362,14 @@ void Node::updateRotationQuat()
 
 void Node::updateRotation3D()
 {
-    // convert quaternion to Euler angle
+    //convert quaternion to Euler angle
     float x = _rotationQuat.x, y = _rotationQuat.y, z = _rotationQuat.z, w = _rotationQuat.w;
-    _rotationX = std::atan2(2.f * (w * x + y * z), 1.f - 2.f * (x * x + y * y));
+    _rotationX = atan2f(2.f * (w * x + y * z), 1.f - 2.f * (x * x + y * y));
     float sy = 2.f * (w * y - z * x);
     sy = clampf(sy, -1, 1);
-    _rotationY = std::asin(sy);
-    _rotationZ_X = std::atan2(2.f * (w * z + x * y), 1.f - 2.f * (y * y + z * z));
-
+    _rotationY = asinf(sy);
+    _rotationZ_X = atan2f(2.f * (w * z + x * y), 1.f - 2.f * (y * y + z * z));
+    
     _rotationX = CC_RADIANS_TO_DEGREES(_rotationX);
     _rotationY = CC_RADIANS_TO_DEGREES(_rotationY);
     _rotationZ_X = _rotationZ_Y = -CC_RADIANS_TO_DEGREES(_rotationZ_X);
@@ -383,12 +389,12 @@ Quaternion Node::getRotationQuat() const
 
 void Node::setRotationSkewX(float rotationX)
 {
-    if (std::abs(_rotationZ_X - rotationX) < epsi)
+    if (_rotationZ_X == rotationX)
         return;
-
+    
     _rotationZ_X = rotationX;
     _transformUpdated = _transformDirty = _inverseDirty = true;
-
+    
     updateRotationQuat();
 }
 
@@ -399,28 +405,28 @@ float Node::getRotationSkewY() const
 
 void Node::setRotationSkewY(float rotationY)
 {
-    if (std::abs(_rotationZ_Y - rotationY) < epsi)
+    if (_rotationZ_Y == rotationY)
         return;
-
+    
     _rotationZ_Y = rotationY;
     _transformUpdated = _transformDirty = _inverseDirty = true;
-
+    
     updateRotationQuat();
 }
 
 /// scale getter
 float Node::getScale() const
 {
-    CCASSERT(std::abs(_scaleX - _scaleY) < std::numeric_limits<float>::epsilon(), "CCNode#scale. ScaleX != ScaleY. Don't know which one to return");
+    CCASSERT( _scaleX == _scaleY, "CCNode#scale. ScaleX != ScaleY. Don't know which one to return");
     return _scaleX;
 }
 
 /// scale setter
 void Node::setScale(float scale)
 {
-    if (std::abs(_scaleX - scale) < epsi && std::abs(_scaleY - scale) < epsi && std::abs(_scaleZ - scale) < epsi)
+    if (_scaleX == scale && _scaleY == scale && _scaleZ == scale)
         return;
-
+    
     _scaleX = _scaleY = _scaleZ = scale;
     _transformUpdated = _transformDirty = _inverseDirty = true;
 }
@@ -432,11 +438,11 @@ float Node::getScaleX() const
 }
 
 /// scale setter
-void Node::setScale(float scaleX, float scaleY)
+void Node::setScale(float scaleX,float scaleY)
 {
-    if (std::abs(_scaleX - scaleX) < epsi && std::abs(_scaleY - scaleY) < epsi)
+    if (_scaleX == scaleX && _scaleY == scaleY)
         return;
-
+    
     _scaleX = scaleX;
     _scaleY = scaleY;
     _transformUpdated = _transformDirty = _inverseDirty = true;
@@ -445,9 +451,9 @@ void Node::setScale(float scaleX, float scaleY)
 /// scaleX setter
 void Node::setScaleX(float scaleX)
 {
-    if (std::abs(_scaleX - scaleX) < epsi)
+    if (_scaleX == scaleX)
         return;
-
+    
     _scaleX = scaleX;
     _transformUpdated = _transformDirty = _inverseDirty = true;
 }
@@ -461,9 +467,9 @@ float Node::getScaleY() const
 /// scaleY setter
 void Node::setScaleZ(float scaleZ)
 {
-    if (std::abs(_scaleZ - scaleZ) < epsi)
+    if (_scaleZ == scaleZ)
         return;
-
+    
     _scaleZ = scaleZ;
     _transformUpdated = _transformDirty = _inverseDirty = true;
 }
@@ -477,13 +483,14 @@ float Node::getScaleZ() const
 /// scaleY setter
 void Node::setScaleY(float scaleY)
 {
-    if (std::abs(_scaleY - scaleY) < epsi)
+    if (_scaleY == scaleY)
         return;
-
+    
     _scaleY = scaleY;
     _transformUpdated = _transformDirty = _inverseDirty = true;
 }
 
+
 /// position getter
 const Vec2& Node::getPosition() const
 {
@@ -504,12 +511,12 @@ void Node::getPosition(float* x, float* y) const
 
 void Node::setPosition(float x, float y)
 {
-    if (std::abs(_position.x - x) < epsi && std::abs(_position.y - y) < epsi)
+    if (_position.x == x && _position.y == y)
         return;
-
+    
     _position.x = x;
     _position.y = y;
-
+    
     _transformUpdated = _transformDirty = _inverseDirty = true;
     _usingNormalizedPosition = false;
 }
@@ -537,7 +544,7 @@ void Node::setPositionX(float x)
 
 float Node::getPositionY() const
 {
-    return _position.y;
+    return  _position.y;
 }
 
 void Node::setPositionY(float y)
@@ -552,22 +559,22 @@ float Node::getPositionZ() const
 
 void Node::setPositionZ(float positionZ)
 {
-    if (std::abs(_positionZ - positionZ) < epsi)
+    if (_positionZ == positionZ)
         return;
-
+    
     _transformUpdated = _transformDirty = _inverseDirty = true;
 
     _positionZ = positionZ;
 }
 
 /// position getter
-const Vec2& Node::getNormalizedPosition() const
+const Vec2& Node::getPositionNormalized() const
 {
     return _normalizedPosition;
 }
 
 /// position setter
-void Node::setNormalizedPosition(const Vec2& position)
+void Node::setPositionNormalized(const Vec2& position)
 {
     if (_normalizedPosition.equals(position))
         return;
@@ -578,18 +585,24 @@ void Node::setNormalizedPosition(const Vec2& position)
     _transformUpdated = _transformDirty = _inverseDirty = true;
 }
 
-std::size_t Node::getChildrenCount() const
+ssize_t Node::getChildrenCount() const
 {
     return _children.size();
 }
 
+/// isVisible getter
+bool Node::isVisible() const
+{
+    return _visible;
+}
+
 /// isVisible setter
 void Node::setVisible(bool visible)
 {
-    if (visible != _visible)
+    if(visible != _visible)
     {
         _visible = visible;
-        if (_visible)
+        if(_visible)
             _transformUpdated = _transformDirty = _inverseDirty = true;
     }
 }
@@ -607,7 +620,7 @@ const Vec2& Node::getAnchorPoint() const
 
 void Node::setAnchorPoint(const Vec2& point)
 {
-    if (!point.equals(_anchorPoint))
+    if (! point.equals(_anchorPoint))
     {
         _anchorPoint = point;
         _anchorPointInPoints.set(_contentSize.width * _anchorPoint.x, _contentSize.height * _anchorPoint.y);
@@ -621,9 +634,9 @@ const Size& Node::getContentSize() const
     return _contentSize;
 }
 
-void Node::setContentSize(const Size& size)
+void Node::setContentSize(const Size & size)
 {
-    if (!size.equals(_contentSize))
+    if (! size.equals(_contentSize))
     {
         _contentSize = size;
 
@@ -639,7 +652,7 @@ bool Node::isRunning() const
 }
 
 /// parent setter
-void Node::setParent(Node* parent)
+void Node::setParent(Node * parent)
 {
     _parent = parent;
     _transformUpdated = _transformDirty = _inverseDirty = true;
@@ -654,7 +667,7 @@ bool Node::isIgnoreAnchorPointForPosition() const
 /// isRelativeAnchorPoint setter
 void Node::setIgnoreAnchorPointForPosition(bool newValue)
 {
-    if (newValue != _ignoreAnchorPointForPosition)
+    if (newValue != _ignoreAnchorPointForPosition) 
     {
         _ignoreAnchorPointForPosition = newValue;
         _transformUpdated = _transformDirty = _inverseDirty = true;
@@ -670,7 +683,7 @@ int Node::getTag() const
 /// tag setter
 void Node::setTag(int tag)
 {
-    _tag = tag;
+    _tag = tag ;
 }
 
 const std::string& Node::getName() const
@@ -686,7 +699,7 @@ void Node::setName(const std::string& name)
 }
 
 /// userData setter
-void Node::setUserData(void* userData)
+void Node::setUserData(void *userData)
 {
     _userData = userData;
 }
@@ -708,46 +721,11 @@ void Node::setUserObject(Ref* userObject)
     _userObject = userObject;
 }
 
-GLProgramState* Node::getGLProgramState() const
-{
-    return _glProgramState;
-}
-
-void Node::setGLProgramState(cocos2d::GLProgramState* glProgramState)
-{
-    if (glProgramState != _glProgramState)
-    {
-        CC_SAFE_RELEASE(_glProgramState);
-        _glProgramState = glProgramState;
-        CC_SAFE_RETAIN(_glProgramState);
-
-        if (_glProgramState)
-            _glProgramState->setNodeBinding(this);
-    }
-}
-
-void Node::setGLProgram(GLProgram* glProgram)
-{
-    if (_glProgramState == nullptr || (_glProgramState && _glProgramState->getGLProgram() != glProgram))
-    {
-        CC_SAFE_RELEASE(_glProgramState);
-        _glProgramState = GLProgramState::getOrCreateWithGLProgram(glProgram);
-        _glProgramState->retain();
-
-        _glProgramState->setNodeBinding(this);
-    }
-}
-
-GLProgram* Node::getGLProgram() const
-{
-    return _glProgramState ? _glProgramState->getGLProgram() : nullptr;
-}
-
 Scene* Node::getScene() const
 {
     if (!_parent)
         return nullptr;
-
+    
     auto sceneNode = _parent;
     while (sceneNode->_parent)
     {
@@ -777,7 +755,7 @@ Node* Node::getChildByTag(int tag) const
 
     for (const auto child : _children)
     {
-        if (child && child->_tag == tag)
+        if(child && child->_tag == tag)
             return child;
     }
     return nullptr;
@@ -786,29 +764,29 @@ Node* Node::getChildByTag(int tag) const
 Node* Node::getChildByName(const std::string& name) const
 {
     CCASSERT(!name.empty(), "Invalid name");
-
+    
     std::hash<std::string> h;
     size_t hash = h(name);
-
+    
     for (const auto& child : _children)
     {
         // Different strings may have the same hash code, but can use it to compare first for speed
-        if (child->_hashOfName == hash && child->_name.compare(name) == 0)
+        if(child->_hashOfName == hash && child->_name.compare(name) == 0)
             return child;
     }
     return nullptr;
 }
 
-void Node::enumerateChildren(const std::string& name, std::function<bool(Node*)> callback) const
+void Node::enumerateChildren(const std::string &name, std::function<bool (Node *)> callback) const
 {
     CCASSERT(!name.empty(), "Invalid name");
     CCASSERT(callback != nullptr, "Invalid callback function");
-
+    
     size_t length = name.length();
-
-    size_t subStrStartPos = 0; // sub string start index
+    
+    size_t subStrStartPos = 0;  // sub string start index
     size_t subStrlength = length; // sub string length
-
+    
     // Starts with '//'?
     bool searchRecursively = false;
     if (length > 2 && name[0] == '/' && name[1] == '/')
@@ -817,15 +795,18 @@ void Node::enumerateChildren(const std::string& name, std::function<bool(Node*)>
         subStrStartPos = 2;
         subStrlength -= 2;
     }
-
+    
     // End with '/..'?
     bool searchFromParent = false;
-    if (length > 3 && name[length - 3] == '/' && name[length - 2] == '.' && name[length - 1] == '.')
+    if (length > 3 &&
+        name[length-3] == '/' &&
+        name[length-2] == '.' &&
+        name[length-1] == '.')
     {
         searchFromParent = true;
         subStrlength -= 3;
     }
-
+    
     // Remove '//', '/..' if exist
     std::string newName = name.substr(subStrStartPos, subStrlength);
 
@@ -833,7 +814,8 @@ void Node::enumerateChildren(const std::string& name, std::function<bool(Node*)>
     {
         newName.insert(0, "[[:alnum:]]+/");
     }
-
+    
+    
     if (searchRecursively)
     {
         // name is '//xxx'
@@ -846,10 +828,10 @@ void Node::enumerateChildren(const std::string& name, std::function<bool(Node*)>
     }
 }
 
-bool Node::doEnumerateRecursive(const Node* node, const std::string& name, std::function<bool(Node*)> callback) const
+bool Node::doEnumerateRecursive(const Node* node, const std::string &name, std::function<bool (Node *)> callback) const
 {
-    bool ret = false;
-
+    bool ret =false;
+    
     if (node->doEnumerate(name, callback))
     {
         // search itself
@@ -867,11 +849,11 @@ bool Node::doEnumerateRecursive(const Node* node, const std::string& name, std::
             }
         }
     }
-
+    
     return ret;
 }
 
-bool Node::doEnumerate(std::string name, std::function<bool(Node*)> callback) const
+bool Node::doEnumerate(std::string name, std::function<bool (Node *)> callback) const
 {
     // name may be xxx/yyy, should find its parent
     size_t pos = name.find('/');
@@ -880,10 +862,10 @@ bool Node::doEnumerate(std::string name, std::function<bool(Node*)> callback) co
     if (pos != name.npos)
     {
         searchName = name.substr(0, pos);
-        name.erase(0, pos + 1);
+        name.erase(0, pos+1);
         needRecursive = true;
     }
-
+    
     bool ret = false;
     for (const auto& child : getChildren())
     {
@@ -906,49 +888,64 @@ bool Node::doEnumerate(std::string name, std::function<bool(Node*)> callback) co
             }
         }
     }
-
+    
     return ret;
 }
 
 /* "add" logic MUST only be on this method
- * If a class want's to extend the 'addChild' behavior it only needs
- * to override this method
- */
-void Node::addChild(Node* child, int localZOrder, int tag)
-{
-    CCASSERT(child != nullptr, "Argument must be non-nil");
-    CCASSERT(child->_parent == nullptr, "child already added. It can't be added again");
+* If a class want's to extend the 'addChild' behavior it only needs
+* to override this method
+*/
+void Node::addChild(Node *child, int localZOrder, int tag)
+{    
+    CCASSERT( child != nullptr, "Argument must be non-nil");
+    CCASSERT( child->_parent == nullptr, "child already added. It can't be added again");
 
     addChildHelper(child, localZOrder, tag, "", true);
 }
 
-void Node::addChild(Node* child, int localZOrder, const std::string& name)
+void Node::addChild(Node* child, int localZOrder, const std::string &name)
 {
     CCASSERT(child != nullptr, "Argument must be non-nil");
     CCASSERT(child->_parent == nullptr, "child already added. It can't be added again");
-
+    
     addChildHelper(child, localZOrder, INVALID_TAG, name, false);
 }
 
-void Node::addChildHelper(Node* child, int localZOrder, int tag, const std::string& name, bool setTag)
-{
+void Node::addChildHelper(Node* child, int localZOrder, int tag, const std::string &name, bool setTag)
+{
+    auto assertNotSelfChild
+        ( [ this, child ]() -> bool
+          {
+              for ( Node* parent( getParent() ); parent != nullptr;
+                    parent = parent->getParent() )
+                  if ( parent == child )
+                      return false;
+              
+              return true;
+          } );
+    (void)assertNotSelfChild;
+    
+    CCASSERT( assertNotSelfChild(),
+              "A node cannot be the child of his own children" );
+    
     if (_children.empty())
     {
         this->childrenAlloc();
     }
-
+    
     this->insertChild(child, localZOrder);
-
+    
     if (setTag)
         child->setTag(tag);
     else
         child->setName(name);
-
+    
     child->setParent(this);
 
     child->updateOrderOfArrival();
 
-    if (_running)
+    if( _running )
     {
         child->onEnter();
         // prevent onEnterTransitionDidFinish to be called twice when a node is added in onEnter
@@ -957,27 +954,27 @@ void Node::addChildHelper(Node* child, int localZOrder, int tag, const std::stri
             child->onEnterTransitionDidFinish();
         }
     }
-
+    
     if (_cascadeColorEnabled)
     {
         updateCascadeColor();
     }
-
+    
     if (_cascadeOpacityEnabled)
     {
         updateCascadeOpacity();
     }
 }
 
-void Node::addChild(Node* child, int zOrder)
+void Node::addChild(Node *child, int zOrder)
 {
-    CCASSERT(child != nullptr, "Argument must be non-nil");
+    CCASSERT( child != nullptr, "Argument must be non-nil");
     this->addChild(child, zOrder, child->_name);
 }
 
-void Node::addChild(Node* child)
+void Node::addChild(Node *child)
 {
-    CCASSERT(child != nullptr, "Argument must be non-nil");
+    CCASSERT( child != nullptr, "Argument must be non-nil");
     this->addChild(child, child->getLocalZOrder(), child->_name);
 }
 
@@ -990,14 +987,14 @@ void Node::removeFromParentAndCleanup(bool cleanup)
 {
     if (_parent != nullptr)
     {
-        _parent->removeChild(this, cleanup);
-    }
+        _parent->removeChild(this,cleanup);
+    } 
 }
 
 /* "remove" logic MUST only be on this method
- * If a class want's to extend the 'removeChild' behavior it only needs
- * to override this method
- */
+* If a class want's to extend the 'removeChild' behavior it only needs
+* to override this method
+*/
 void Node::removeChild(Node* child, bool cleanup /* = true */)
 {
     // explicit nil handling
@@ -1006,16 +1003,16 @@ void Node::removeChild(Node* child, bool cleanup /* = true */)
         return;
     }
 
-    std::size_t index = _children.getIndex(child);
-    if (index != CC_INVALID_INDEX)
-        this->detachChild(child, index, cleanup);
+    ssize_t index = _children.getIndex(child);
+    if( index != CC_INVALID_INDEX )
+        this->detachChild( child, index, cleanup );
 }
 
-void Node::removeChildByTag(int tag, bool cleanup /* = true */)
+void Node::removeChildByTag(int tag, bool cleanup/* = true */)
 {
-    CCASSERT(tag != Node::INVALID_TAG, "Invalid tag");
+    CCASSERT( tag != Node::INVALID_TAG, "Invalid tag");
 
-    Node* child = this->getChildByTag(tag);
+    Node *child = this->getChildByTag(tag);
 
     if (child == nullptr)
     {
@@ -1027,12 +1024,12 @@ void Node::removeChildByTag(int tag, bool cleanup /* = true */)
     }
 }
 
-void Node::removeChildByName(const std::string& name, bool cleanup)
+void Node::removeChildByName(const std::string &name, bool cleanup)
 {
     CCASSERT(!name.empty(), "Invalid name");
-
-    Node* child = this->getChildByName(name);
-
+    
+    Node *child = this->getChildByName(name);
+    
     if (child == nullptr)
     {
         CCLOG("cocos2d: removeChildByName(name = %s): child not found!", name.c_str());
@@ -1056,7 +1053,7 @@ void Node::removeAllChildrenWithCleanup(bool cleanup)
         // IMPORTANT:
         //  -1st do onExit
         //  -2nd cleanup
-        if (_running)
+        if(_running)
         {
             child->onExitTransitionDidStart();
             child->onExit();
@@ -1072,15 +1069,15 @@ void Node::removeAllChildrenWithCleanup(bool cleanup)
         {
             sEngine->releaseScriptObject(this, child);
         }
-#endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS \
-// set parent nil at the end
+#endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
+        // set parent nil at the end
         child->setParent(nullptr);
     }
-
+    
     _children.clear();
 }
 
-void Node::detachChild(Node* child, std::size_t childIndex, bool doCleanup)
+void Node::detachChild(Node *child, ssize_t childIndex, bool doCleanup)
 {
     // IMPORTANT:
     //  -1st do onExit
@@ -1097,7 +1094,7 @@ void Node::detachChild(Node* child, std::size_t childIndex, bool doCleanup)
     {
         child->cleanup();
     }
-
+    
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
     auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
     if (sEngine)
@@ -1111,6 +1108,7 @@ void Node::detachChild(Node* child, std::size_t childIndex, bool doCleanup)
     _children.erase(childIndex);
 }
 
+
 // helper used by reorderChild & add
 void Node::insertChild(Node* child, int z)
 {
@@ -1127,9 +1125,9 @@ void Node::insertChild(Node* child, int z)
     child->_setLocalZOrder(z);
 }
 
-void Node::reorderChild(Node* child, int zOrder)
+void Node::reorderChild(Node *child, int zOrder)
 {
-    CCASSERT(child != nullptr, "Child must be non-nil");
+    CCASSERT( child != nullptr, "Child must be non-nil");
     _reorderChildDirty = true;
     child->updateOrderOfArrival();
     child->_setLocalZOrder(zOrder);
@@ -1141,6 +1139,7 @@ void Node::sortAllChildren()
     {
         sortNodes(_children);
         _reorderChildDirty = false;
+        _eventDispatcher->setDirtyForNode(this);
     }
 }
 
@@ -1149,10 +1148,10 @@ void Node::sortAllChildren()
 void Node::draw()
 {
     auto renderer = _director->getRenderer();
-    draw(renderer, _modelViewTransform, true);
+    draw(renderer, _modelViewTransform, FLAGS_TRANSFORM_DIRTY);
 }
 
-void Node::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void Node::draw(Renderer* /*renderer*/, const Mat4 & /*transform*/, uint32_t /*flags*/)
 {
 }
 
@@ -1160,14 +1159,14 @@ void Node::visit()
 {
     auto renderer = _director->getRenderer();
     auto& parentTransform = _director->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
-    visit(renderer, parentTransform, true);
+    visit(renderer, parentTransform, FLAGS_TRANSFORM_DIRTY);
 }
 
 uint32_t Node::processParentFlags(const Mat4& parentTransform, uint32_t parentFlags)
 {
-    if (_usingNormalizedPosition)
+    if(_usingNormalizedPosition)
     {
-        CCASSERT(_parent, "setNormalizedPosition() doesn't work with orphan nodes");
+        CCASSERT(_parent, "setPositionNormalized() doesn't work with orphan nodes");
         if ((parentFlags & FLAGS_CONTENT_SIZE_DIRTY) || _normalizedPositionDirty)
         {
             auto& s = _parent->getContentSize();
@@ -1186,10 +1185,11 @@ uint32_t Node::processParentFlags(const Mat4& parentTransform, uint32_t parentFl
     uint32_t flags = parentFlags;
     flags |= (_transformUpdated ? FLAGS_TRANSFORM_DIRTY : 0);
     flags |= (_contentSizeDirty ? FLAGS_CONTENT_SIZE_DIRTY : 0);
+    
 
-    if (flags & FLAGS_DIRTY_MASK)
+    if(flags & FLAGS_DIRTY_MASK)
         _modelViewTransform = this->transform(parentTransform);
-
+    
     _transformUpdated = false;
     _contentSizeDirty = false;
 
@@ -1199,11 +1199,11 @@ uint32_t Node::processParentFlags(const Mat4& parentTransform, uint32_t parentFl
 bool Node::isVisitableByVisitingCamera() const
 {
     auto camera = Camera::getVisitingCamera();
-    bool visibleByCamera = camera ? (static_cast<unsigned short>(camera->getCameraFlag()) & _cameraMask) != 0 : true;
+    bool visibleByCamera = camera ? ((unsigned short)camera->getCameraFlag() & _cameraMask) != 0 : true;
     return visibleByCamera;
 }
 
-void Node::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void Node::visit(Renderer* renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     // quick return if not visible. children won't be drawn.
     if (!_visible)
@@ -1218,16 +1218,16 @@ void Node::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t paren
     // but it is deprecated and your code should not rely on it
     _director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
     _director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform);
-
+    
     bool visibleByCamera = isVisitableByVisitingCamera();
 
-    std::size_t i = 0;
+    int i = 0;
 
-    if (!_children.empty())
+    if(!_children.empty())
     {
         sortAllChildren();
         // draw children zOrder < 0
-        for (; i < _children.size(); i++)
+        for(auto size = _children.size(); i < size; ++i)
         {
             auto node = _children.at(i);
 
@@ -1240,7 +1240,7 @@ void Node::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t paren
         if (visibleByCamera)
             this->draw(renderer, _modelViewTransform, flags);
 
-        for (auto it = _children.cbegin() + i; it != _children.cend(); ++it)
+        for(auto it=_children.cbegin()+i, itCend = _children.cend(); it != itCend; ++it)
             (*it)->visit(renderer, _modelViewTransform, flags);
     }
     else if (visibleByCamera)
@@ -1249,7 +1249,7 @@ void Node::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t paren
     }
 
     _director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
-
+    
     // FIX ME: Why need to set _orderOfArrival to 0??
     // Please refer to https://github.com/cocos2d/cocos2d-x/pull/6920
     // reset for next frame
@@ -1265,6 +1265,10 @@ Mat4 Node::transform(const Mat4& parentTransform)
 
 void Node::onEnter()
 {
+    if (!_running)
+    {
+        ++__attachedNodeCount;
+    }
 #if CC_ENABLE_SCRIPT_BINDING
     if (_scriptType == kScriptTypeJavascript)
     {
@@ -1272,7 +1276,7 @@ void Node::onEnter()
             return;
     }
 #endif
-
+    
     if (_onEnterCallback)
         _onEnterCallback();
 
@@ -1280,16 +1284,16 @@ void Node::onEnter()
     {
         _componentContainer->onEnter();
     }
-
+    
     _isTransitionFinished = false;
-
-    for (const auto& child : _children)
+    
+    for( const auto &child: _children)
         child->onEnter();
-
+    
     this->resume();
-
+    
     _running = true;
-
+    
 #if CC_ENABLE_SCRIPT_BINDING
     if (_scriptType == kScriptTypeLua)
     {
@@ -1307,14 +1311,14 @@ void Node::onEnterTransitionDidFinish()
             return;
     }
 #endif
-
+    
     if (_onEnterTransitionDidFinishCallback)
         _onEnterTransitionDidFinishCallback();
 
     _isTransitionFinished = true;
-    for (const auto& child : _children)
+    for( const auto &child: _children)
         child->onEnterTransitionDidFinish();
-
+    
 #if CC_ENABLE_SCRIPT_BINDING
     if (_scriptType == kScriptTypeLua)
     {
@@ -1332,13 +1336,13 @@ void Node::onExitTransitionDidStart()
             return;
     }
 #endif
-
+    
     if (_onExitTransitionDidStartCallback)
         _onExitTransitionDidStartCallback();
-
-    for (const auto& child : _children)
+    
+    for( const auto &child: _children)
         child->onExitTransitionDidStart();
-
+    
 #if CC_ENABLE_SCRIPT_BINDING
     if (_scriptType == kScriptTypeLua)
     {
@@ -1349,6 +1353,10 @@ void Node::onExitTransitionDidStart()
 
 void Node::onExit()
 {
+    if (_running)
+    {
+        --__attachedNodeCount;
+    }
 #if CC_ENABLE_SCRIPT_BINDING
     if (_scriptType == kScriptTypeJavascript)
     {
@@ -1356,22 +1364,22 @@ void Node::onExit()
             return;
     }
 #endif
-
+    
     if (_onExitCallback)
         _onExitCallback();
-
+    
     if (_componentContainer && !_componentContainer->isEmpty())
     {
         _componentContainer->onExit();
     }
-
+    
     this->pause();
-
+    
     _running = false;
-
-    for (const auto& child : _children)
+    
+    for( const auto &child: _children)
         child->onExit();
-
+    
 #if CC_ENABLE_SCRIPT_BINDING
     if (_scriptType == kScriptTypeLua)
     {
@@ -1393,7 +1401,7 @@ void Node::setEventDispatcher(EventDispatcher* dispatcher)
 
 void Node::setActionManager(ActionManager* actionManager)
 {
-    if (actionManager != _actionManager)
+    if( actionManager != _actionManager )
     {
         this->stopAllActions();
         CC_SAFE_RETAIN(actionManager);
@@ -1404,9 +1412,9 @@ void Node::setActionManager(ActionManager* actionManager)
 
 // MARK: actions
 
-Action* Node::runAction(Action* action)
+Action * Node::runAction(Action* action)
 {
-    CCASSERT(action != nullptr, "Argument must be non-nil");
+    CCASSERT( action != nullptr, "Argument must be non-nil");
     _actionManager->addAction(action, this, !_running);
     return action;
 }
@@ -1423,7 +1431,7 @@ void Node::stopAction(Action* action)
 
 void Node::stopAllActionsByTag(int tag)
 {
-    CCASSERT(tag != Action::INVALID_TAG, "Invalid tag");
+    CCASSERT( tag != Action::INVALID_TAG, "Invalid tag");
     _actionManager->removeAllActionsByTag(tag, this);
 }
 
@@ -1435,22 +1443,22 @@ void Node::stopActionsByFlags(unsigned int flags)
     }
 }
 
-Action* Node::getActionByTag(int tag) const
+Action * Node::getActionByTag(int tag)
 {
-    CCASSERT(tag != Action::INVALID_TAG, "Invalid tag");
-    return _actionManager->getActionByTag(tag, const_cast<Node*>(this));
+    CCASSERT( tag != Action::INVALID_TAG, "Invalid tag");
+    return _actionManager->getActionByTag(tag, this);
 }
 
-std::size_t Node::getNumberOfRunningActions() const
+ssize_t Node::getNumberOfRunningActions()
 {
-    return _actionManager->getNumberOfRunningActionsInTarget(const_cast<Node*>(this));
+    return _actionManager->getNumberOfRunningActionsInTarget(this);
 }
 
 // MARK: Callbacks
 
 void Node::setScheduler(Scheduler* scheduler)
 {
-    if (scheduler != _scheduler)
+    if( scheduler != _scheduler )
     {
         this->unscheduleAllCallbacks();
         CC_SAFE_RETAIN(scheduler);
@@ -1459,12 +1467,12 @@ void Node::setScheduler(Scheduler* scheduler)
     }
 }
 
-bool Node::isScheduled(SEL_SCHEDULE selector)
+bool Node::isScheduled(SEL_SCHEDULE selector) const
 {
     return _scheduler->isScheduled(selector, this);
 }
 
-bool Node::isScheduled(const std::string& key)
+bool Node::isScheduled(const std::string &key) const
 {
     return _scheduler->isScheduled(key, this);
 }
@@ -1482,18 +1490,18 @@ void Node::scheduleUpdateWithPriority(int priority)
 void Node::scheduleUpdateWithPriorityLua(int nHandler, int priority)
 {
     unscheduleUpdate();
-
+    
 #if CC_ENABLE_SCRIPT_BINDING
     _updateScriptHandler = nHandler;
 #endif
-
+    
     _scheduler->scheduleUpdate(this, priority, !_running);
 }
 
 void Node::unscheduleUpdate()
 {
     _scheduler->unscheduleUpdate(this);
-
+    
 #if CC_ENABLE_SCRIPT_BINDING
     if (_updateScriptHandler)
     {
@@ -1505,46 +1513,45 @@ void Node::unscheduleUpdate()
 
 void Node::schedule(SEL_SCHEDULE selector)
 {
-    this->schedule(selector, 0ms, CC_REPEAT_FOREVER, 0ms);
+    this->schedule(selector, 0.0f, CC_REPEAT_FOREVER, 0.0f);
 }
 
-void Node::schedule(SEL_SCHEDULE selector, std::chrono::milliseconds interval)
+void Node::schedule(SEL_SCHEDULE selector, float interval)
 {
-    this->schedule(selector, interval, CC_REPEAT_FOREVER, 0ms);
+    this->schedule(selector, interval, CC_REPEAT_FOREVER, 0.0f);
 }
 
-void Node::schedule(SEL_SCHEDULE selector, std::chrono::milliseconds interval, unsigned int repeat, std::chrono::milliseconds delay)
+void Node::schedule(SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay)
 {
-    CCASSERT(selector, "Argument must be non-nil");
-    CCASSERT(interval >= 0ms, "Argument must be positive");
+    CCASSERT( selector, "Argument must be non-nil");
+    CCASSERT( interval >=0, "Argument must be positive");
 
-    _scheduler->schedule(selector, this, interval, repeat, delay, !_running);
+    _scheduler->schedule(selector, this, interval , repeat, delay, !_running);
 }
 
-void Node::schedule(const std::function<void(float)>& callback, const std::string& key)
+void Node::schedule(const std::function<void(float)> &callback, const std::string &key)
 {
-    _scheduler->schedule(callback, this, 0ms, !_running, key);
+    _scheduler->schedule(callback, this, 0, !_running, key);
 }
 
-void Node::schedule(const std::function<void(float)>& callback, std::chrono::milliseconds interval, const std::string& key)
+void Node::schedule(const std::function<void(float)> &callback, float interval, const std::string &key)
 {
     _scheduler->schedule(callback, this, interval, !_running, key);
 }
 
-void Node::schedule(const std::function<void(float)>& callback, std::chrono::milliseconds interval, unsigned int repeat, std::chrono::milliseconds delay,
-                    const std::string& key)
+void Node::schedule(const std::function<void(float)>& callback, float interval, unsigned int repeat, float delay, const std::string &key)
 {
     _scheduler->schedule(callback, this, interval, repeat, delay, !_running, key);
 }
 
-void Node::scheduleOnce(SEL_SCHEDULE selector, std::chrono::milliseconds delay)
+void Node::scheduleOnce(SEL_SCHEDULE selector, float delay)
 {
-    this->schedule(selector, 0ms, 0, delay);
+    this->schedule(selector, 0.0f, 0, delay);
 }
 
-void Node::scheduleOnce(const std::function<void(float)>& callback, std::chrono::milliseconds delay, const std::string& key)
+void Node::scheduleOnce(const std::function<void(float)> &callback, float delay, const std::string &key)
 {
-    _scheduler->schedule(callback, this, 0ms, 0, delay, !_running, key);
+    _scheduler->schedule(callback, this, 0, 0, delay, !_running, key);
 }
 
 void Node::unschedule(SEL_SCHEDULE selector)
@@ -1552,11 +1559,11 @@ void Node::unschedule(SEL_SCHEDULE selector)
     // explicit null handling
     if (selector == nullptr)
         return;
-
+    
     _scheduler->unschedule(selector, this);
 }
 
-void Node::unschedule(const std::string& key)
+void Node::unschedule(const std::string &key)
 {
     _scheduler->unschedule(key, this);
 }
@@ -1580,29 +1587,19 @@ void Node::pause()
     _eventDispatcher->pauseEventListenersForTarget(this);
 }
 
-void Node::resumeSchedulerAndActions()
-{
-    resume();
-}
-
-void Node::pauseSchedulerAndActions()
-{
-    pause();
-}
-
 // override me
 void Node::update(float fDelta)
 {
 #if CC_ENABLE_SCRIPT_BINDING
     if (0 != _updateScriptHandler)
     {
-        // only lua use
-        SchedulerScriptData data(_updateScriptHandler, fDelta);
-        ScriptEvent event(kScheduleEvent, &data);
+        //only lua use
+        SchedulerScriptData data(_updateScriptHandler,fDelta);
+        ScriptEvent event(kScheduleEvent,&data);
         ScriptEngineManager::getInstance()->getScriptEngine()->sendEvent(&event);
     }
 #endif
-
+    
     if (_componentContainer && !_componentContainer->isEmpty())
     {
         _componentContainer->visit(fDelta);
@@ -1619,11 +1616,12 @@ AffineTransform Node::getNodeToParentAffineTransform() const
     return ret;
 }
 
+
 Mat4 Node::getNodeToParentTransform(Node* ancestor) const
 {
     Mat4 t(this->getNodeToParentTransform());
 
-    for (Node* p = _parent; p != nullptr && p != ancestor; p = p->getParent())
+    for (Node *p = _parent;  p != nullptr && p != ancestor ; p = p->getParent())
     {
         t = p->getNodeToParentTransform() * t;
     }
@@ -1635,7 +1633,7 @@ AffineTransform Node::getNodeToParentAffineTransform(Node* ancestor) const
 {
     AffineTransform t(this->getNodeToParentAffineTransform());
 
-    for (Node* p = _parent; p != nullptr && p != ancestor; p = p->getParent())
+    for (Node *p = _parent; p != nullptr && p != ancestor; p = p->getParent())
         t = AffineTransformConcat(t, p->getNodeToParentAffineTransform());
 
     return t;
@@ -1648,44 +1646,35 @@ const Mat4& Node::getNodeToParentTransform() const
         float x = _position.x;
         float y = _position.y;
         float z = _positionZ;
-
+        
         if (_ignoreAnchorPointForPosition)
         {
             x += _anchorPointInPoints.x;
             y += _anchorPointInPoints.y;
         }
-
-        bool needsSkewMatrix = (_skewX || _skewY);
-
-        Vec2 anchorPoint(_anchorPointInPoints.x * _scaleX, _anchorPointInPoints.y * _scaleY);
-
-        // calculate real position
-        if (!needsSkewMatrix && !_anchorPointInPoints.isZero())
-        {
-            x += -anchorPoint.x;
-            y += -anchorPoint.y;
-        }
+        
+        bool needsSkewMatrix = ( _skewX || _skewY );
 
         // Build Transform Matrix = translation * rotation * scale
         Mat4 translation;
-        // move to anchor point first, then rotate
-        Mat4::createTranslation(x + anchorPoint.x, y + anchorPoint.y, z, translation);
-
-        Mat4::createRotation(_rotationQuat, _transform);
-
-        if (std::abs(_rotationZ_X - _rotationZ_Y) > epsi)
+        //move to anchor point first, then rotate
+        Mat4::createTranslation(x, y, z, &translation);
+        
+        Mat4::createRotation(_rotationQuat, &_transform);
+        
+        if (_rotationZ_X != _rotationZ_Y)
         {
             // Rotation values
             // Change rotation code to handle X and Y
             // If we skew with the exact same value for both x and y then we're simply just rotating
-            float const radiansX = -CC_DEGREES_TO_RADIANS(_rotationZ_X);
-            float const radiansY = -CC_DEGREES_TO_RADIANS(_rotationZ_Y);
-            float const cx = std::cos(radiansX);
-            float const sx = std::sin(radiansX);
-            float const cy = std::cos(radiansY);
-            float const sy = std::sin(radiansY);
-
-            float const m0 = _transform.m[0], m1 = _transform.m[1], m4 = _transform.m[4], m5 = _transform.m[5], m8 = _transform.m[8], m9 = _transform.m[9];
+            float radiansX = -CC_DEGREES_TO_RADIANS(_rotationZ_X);
+            float radiansY = -CC_DEGREES_TO_RADIANS(_rotationZ_Y);
+            float cx = cosf(radiansX);
+            float sx = sinf(radiansX);
+            float cy = cosf(radiansY);
+            float sy = sinf(radiansY);
+            
+            float m0 = _transform.m[0], m1 = _transform.m[1], m4 = _transform.m[4], m5 = _transform.m[5], m8 = _transform.m[8], m9 = _transform.m[9];
             _transform.m[0] = cy * m0 - sx * m1;
             _transform.m[4] = cy * m4 - sx * m5;
             _transform.m[8] = cy * m8 - sx * m9;
@@ -1694,60 +1683,50 @@ const Mat4& Node::getNodeToParentTransform() const
             _transform.m[9] = sy * m8 + cx * m9;
         }
         _transform = translation * _transform;
-        // move by (-anchorPoint.x, -anchorPoint.y, 0) after rotation
-        _transform.translate(-anchorPoint.x, -anchorPoint.y, 0);
 
-        if (std::abs(_scaleX - 1.f) > epsi)
+        if (_scaleX != 1.f)
         {
             _transform.m[0] *= _scaleX;
             _transform.m[1] *= _scaleX;
-            _transform.m[2] *= _scaleX;
+             _transform.m[2] *= _scaleX;
         }
-        if (std::abs(_scaleY - 1.f) > epsi)
+        if (_scaleY != 1.f)
         {
             _transform.m[4] *= _scaleY;
             _transform.m[5] *= _scaleY;
             _transform.m[6] *= _scaleY;
         }
-        if (std::abs(_scaleZ - 1.f) > epsi)
+        if (_scaleZ != 1.f)
         {
             _transform.m[8] *= _scaleZ;
             _transform.m[9] *= _scaleZ;
             _transform.m[10] *= _scaleZ;
         }
-
+        
         // FIXME:: Try to inline skew
         // If skew is needed, apply skew and then anchor point
         if (needsSkewMatrix)
         {
-            float skewMatArray[16] = {1,
-                                      std::tan(CC_DEGREES_TO_RADIANS(_skewY)),
-                                      0.f,
-                                      0.f,
-                                      std::tan(CC_DEGREES_TO_RADIANS(_skewX)),
-                                      1.f,
-                                      0.f,
-                                      0.f,
-                                      0.f,
-                                      0.f,
-                                      1.f,
-                                      0.f,
-                                      0.f,
-                                      0.f,
-                                      0.f,
-                                      1.f};
+            float skewMatArray[16] =
+            {
+                1, (float)tanf(CC_DEGREES_TO_RADIANS(_skewY)), 0, 0,
+                (float)tanf(CC_DEGREES_TO_RADIANS(_skewX)), 1, 0, 0,
+                0,  0,  1, 0,
+                0,  0,  0, 1
+            };
             Mat4 skewMatrix(skewMatArray);
-
+            
             _transform = _transform * skewMatrix;
+        }
 
-            // adjust anchor point
-            if (!_anchorPointInPoints.isZero())
-            {
-                // FIXME:: Argh, Mat4 needs a "translate" method.
-                // FIXME:: Although this is faster than multiplying a vec4 * mat4
-                _transform.m[12] += _transform.m[0] * -_anchorPointInPoints.x + _transform.m[4] * -_anchorPointInPoints.y;
-                _transform.m[13] += _transform.m[1] * -_anchorPointInPoints.x + _transform.m[5] * -_anchorPointInPoints.y;
-            }
+        // adjust anchor point
+        if (!_anchorPointInPoints.isZero())
+        {
+            // FIXME:: Argh, Mat4 needs a "translate" method.
+            // FIXME:: Although this is faster than multiplying a vec4 * mat4
+            _transform.m[12] += _transform.m[0] * -_anchorPointInPoints.x + _transform.m[4] * -_anchorPointInPoints.y;
+            _transform.m[13] += _transform.m[1] * -_anchorPointInPoints.x + _transform.m[5] * -_anchorPointInPoints.y;
+            _transform.m[14] += _transform.m[2] * -_anchorPointInPoints.x + _transform.m[6] * -_anchorPointInPoints.y;
         }
     }
 
@@ -1793,16 +1772,13 @@ void Node::setAdditionalTransform(const Mat4* additionalTransform)
 {
     if (additionalTransform == nullptr)
     {
-        if (_additionalTransform)
-            _transform = _additionalTransform[1];
-
+        if(_additionalTransform)  _transform = _additionalTransform[1];
         delete[] _additionalTransform;
         _additionalTransform = nullptr;
     }
     else
     {
-        if (!_additionalTransform)
-        {
+        if (!_additionalTransform) {
             _additionalTransform = new Mat4[2];
 
             // _additionalTransform[1] is used as a backup for _transform
@@ -1823,13 +1799,13 @@ AffineTransform Node::getParentToNodeAffineTransform() const
 {
     AffineTransform ret;
 
-    GLToCGAffine(getParentToNodeTransform().m, &ret);
+    GLToCGAffine(getParentToNodeTransform().m,&ret);
     return ret;
 }
 
 const Mat4& Node::getParentToNodeTransform() const
 {
-    if (_inverseDirty)
+    if ( _inverseDirty )
     {
         _inverse = getNodeToParentTransform().getInversed();
         _inverseDirty = false;
@@ -1838,6 +1814,7 @@ const Mat4& Node::getParentToNodeTransform() const
     return _inverse;
 }
 
+
 AffineTransform Node::getNodeToWorldAffineTransform() const
 {
     return this->getNodeToParentAffineTransform(nullptr);
@@ -1858,12 +1835,13 @@ Mat4 Node::getWorldToNodeTransform() const
     return getNodeToWorldTransform().getInversed();
 }
 
+
 Vec2 Node::convertToNodeSpace(const Vec2& worldPoint) const
 {
     Mat4 tmp = getWorldToNodeTransform();
     Vec3 vec3(worldPoint.x, worldPoint.y, 0);
     Vec3 ret;
-    tmp.transformPoint(vec3, ret);
+    tmp.transformPoint(vec3,&ret);
     return Vec2(ret.x, ret.y);
 }
 
@@ -1872,8 +1850,9 @@ Vec2 Node::convertToWorldSpace(const Vec2& nodePoint) const
     Mat4 tmp = getNodeToWorldTransform();
     Vec3 vec3(nodePoint.x, nodePoint.y, 0);
     Vec3 ret;
-    tmp.transformPoint(vec3, ret);
+    tmp.transformPoint(vec3,&ret);
     return Vec2(ret.x, ret.y);
+
 }
 
 Vec2 Node::convertToNodeSpaceAR(const Vec2& worldPoint) const
@@ -1894,12 +1873,12 @@ Vec2 Node::convertToWindowSpace(const Vec2& nodePoint) const
 }
 
 // convenience methods which take a Touch instead of Vec2
-Vec2 Node::convertTouchToNodeSpace(Touch* touch) const
+Vec2 Node::convertTouchToNodeSpace(Touch *touch) const
 {
     return this->convertToNodeSpace(touch->getLocation());
 }
 
-Vec2 Node::convertTouchToNodeSpaceAR(Touch* touch) const
+Vec2 Node::convertTouchToNodeSpaceAR(Touch *touch) const
 {
     Vec2 point = touch->getLocation();
     return this->convertToNodeSpaceAR(point);
@@ -1908,7 +1887,7 @@ Vec2 Node::convertTouchToNodeSpaceAR(Touch* touch) const
 void Node::updateTransform()
 {
     // Recursively iterate over children
-    for (const auto& child : _children)
+    for( const auto &child: _children)
         child->updateTransform();
 }
 
@@ -1918,19 +1897,19 @@ Component* Node::getComponent(const std::string& name)
 {
     if (_componentContainer)
         return _componentContainer->get(name);
-
+    
     return nullptr;
 }
 
-bool Node::addComponent(Component* component)
+bool Node::addComponent(Component *component)
 {
     // lazy alloc
     if (!_componentContainer)
         _componentContainer = new (std::nothrow) ComponentContainer(this);
-
+    
     // should enable schedule update, then all components can receive this call back
     scheduleUpdate();
-
+    
     return _componentContainer->add(component);
 }
 
@@ -1938,17 +1917,17 @@ bool Node::removeComponent(const std::string& name)
 {
     if (_componentContainer)
         return _componentContainer->remove(name);
-
+    
     return false;
 }
 
-bool Node::removeComponent(Component* component)
+bool Node::removeComponent(Component *component)
 {
     if (_componentContainer)
     {
         return _componentContainer->remove(component);
     }
-
+    
     return false;
 }
 
@@ -1960,31 +1939,31 @@ void Node::removeAllComponents()
 
 // MARK: Opacity and Color
 
-GLubyte Node::getOpacity() const
+uint8_t Node::getOpacity() const
 {
     return _realOpacity;
 }
 
-GLubyte Node::getDisplayedOpacity() const
+uint8_t Node::getDisplayedOpacity() const
 {
     return _displayedOpacity;
 }
 
-void Node::setOpacity(GLubyte opacity)
+void Node::setOpacity(uint8_t opacity)
 {
     _displayedOpacity = _realOpacity = opacity;
-
+    
     updateCascadeOpacity();
 }
 
-void Node::updateDisplayedOpacity(GLubyte parentOpacity)
+void Node::updateDisplayedOpacity(uint8_t parentOpacity)
 {
-    _displayedOpacity = _realOpacity * parentOpacity / 255.0;
+    _displayedOpacity = _realOpacity * parentOpacity/255.0;
     updateColor();
-
+    
     if (_cascadeOpacityEnabled)
     {
-        for (const auto& child : _children)
+        for(const auto& child : _children)
         {
             child->updateDisplayedOpacity(_displayedOpacity);
         }
@@ -2002,9 +1981,9 @@ void Node::setCascadeOpacityEnabled(bool cascadeOpacityEnabled)
     {
         return;
     }
-
+    
     _cascadeOpacityEnabled = cascadeOpacityEnabled;
-
+    
     if (cascadeOpacityEnabled)
     {
         updateCascadeOpacity();
@@ -2017,26 +1996,34 @@ void Node::setCascadeOpacityEnabled(bool cascadeOpacityEnabled)
 
 void Node::updateCascadeOpacity()
 {
-    GLubyte parentOpacity = 255;
-
+    uint8_t parentOpacity = 255;
+    
     if (_parent != nullptr && _parent->isCascadeOpacityEnabled())
     {
         parentOpacity = _parent->getDisplayedOpacity();
     }
-
+    
     updateDisplayedOpacity(parentOpacity);
 }
 
 void Node::disableCascadeOpacity()
 {
     _displayedOpacity = _realOpacity;
-
-    for (const auto& child : _children)
+    
+    for(const auto& child : _children)
     {
         child->updateDisplayedOpacity(255);
     }
 }
 
+void Node::setOpacityModifyRGB(bool /*value*/)
+{}
+
+bool Node::isOpacityModifyRGB() const
+{
+    return false;
+}
+
 const Color3B& Node::getColor() const
 {
     return _realColor;
@@ -2050,20 +2037,20 @@ const Color3B& Node::getDisplayedColor() const
 void Node::setColor(const Color3B& color)
 {
     _displayedColor = _realColor = color;
-
+    
     updateCascadeColor();
 }
 
 void Node::updateDisplayedColor(const Color3B& parentColor)
 {
-    _displayedColor.r = _realColor.r * parentColor.r / 255.0;
-    _displayedColor.g = _realColor.g * parentColor.g / 255.0;
-    _displayedColor.b = _realColor.b * parentColor.b / 255.0;
+    _displayedColor.r = _realColor.r * parentColor.r/255.0;
+    _displayedColor.g = _realColor.g * parentColor.g/255.0;
+    _displayedColor.b = _realColor.b * parentColor.b/255.0;
     updateColor();
-
+    
     if (_cascadeColorEnabled)
     {
-        for (const auto& child : _children)
+        for(const auto &child : _children)
         {
             child->updateDisplayedColor(_displayedColor);
         }
@@ -2081,9 +2068,9 @@ void Node::setCascadeColorEnabled(bool cascadeColorEnabled)
     {
         return;
     }
-
+    
     _cascadeColorEnabled = cascadeColorEnabled;
-
+    
     if (_cascadeColorEnabled)
     {
         updateCascadeColor();
@@ -2101,37 +2088,37 @@ void Node::updateCascadeColor()
     {
         parentColor = _parent->getDisplayedColor();
     }
-
+    
     updateDisplayedColor(parentColor);
 }
 
 void Node::disableCascadeColor()
 {
-    for (const auto& child : _children)
+    for(const auto& child : _children)
     {
         child->updateDisplayedColor(Color3B::WHITE);
     }
 }
 
-bool isScreenPointInRect(const Vec2& pt, const Camera* camera, const Mat4& w2l, const Rect& rect, Vec3* p)
+bool isScreenPointInRect(const Vec2 &pt, const Camera* camera, const Mat4& w2l, const Rect& rect, Vec3 *p)
 {
     if (nullptr == camera || rect.size.width <= 0 || rect.size.height <= 0)
     {
         return false;
     }
-
+    
     // first, convert pt to near/far plane, get Pn and Pf
     Vec3 Pn(pt.x, pt.y, -1), Pf(pt.x, pt.y, 1);
     Pn = camera->unprojectGL(Pn);
     Pf = camera->unprojectGL(Pf);
-
+    
     //  then convert Pn and Pf to node space
-    w2l.transformPoint(Pn);
-    w2l.transformPoint(Pf);
+    w2l.transformPoint(&Pn);
+    w2l.transformPoint(&Pf);
 
     // Pn and Pf define a line Q(t) = D + t * E which D = Pn
     auto E = Pf - Pn;
-
+    
     // second, get three points which define content plane
     //  these points define a plane P(u, w) = A + uB + wC
     Vec3 A = Vec3(rect.origin.x, rect.origin.y, 0);
@@ -2139,23 +2126,21 @@ bool isScreenPointInRect(const Vec2& pt, const Camera* camera, const Mat4& w2l,
     Vec3 C(rect.origin.x, rect.origin.y + rect.size.height, 0);
     B = B - A;
     C = C - A;
-
+    
     //  the line Q(t) intercept with plane P(u, w)
     //  calculate the intercept point P = Q(t)
     //      (BxC).A - (BxC).D
     //  t = -----------------
     //          (BxC).E
     Vec3 BxC;
-    Vec3::cross(B, C, BxC);
-    float BxCdotE = BxC.dot(E);
-    if (std::abs(BxCdotE) < epsi)
-    {
+    Vec3::cross(B, C, &BxC);
+    auto BxCdotE = BxC.dot(E);
+    if (BxCdotE == 0) {
         return false;
     }
     auto t = (BxC.dot(A) - BxC.dot(Pn)) / BxCdotE;
     Vec3 P = Pn + t * E;
-    if (p)
-    {
+    if (p) {
         *p = P;
     }
     return rect.containsPoint(Vec2(P.x, P.y));
@@ -2174,15 +2159,24 @@ void Node::setCameraMask(unsigned short mask, bool applyChildren)
     }
 }
 
-// MARK: Deprecated
+int Node::getAttachedNodeCount()
+{
+    return __attachedNodeCount;
+}
 
-__NodeRGBA::__NodeRGBA()
+void Node::setProgramState(backend::ProgramState* programState)
 {
-    CCLOG("NodeRGBA deprecated.");
+    if (_programState != programState)
+    {
+        CC_SAFE_RELEASE(_programState);
+        _programState = programState;
+        CC_SAFE_RETAIN(programState);
+    }
 }
 
-__NodeRGBA::~__NodeRGBA()
+backend::ProgramState* Node::getProgramState() const
 {
+    return _programState;
 }
 
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCNode.h b/cocos2d/cocos/2d/CCNode.h
index 732fa13979..ef52370387 100644
--- a/cocos2d/cocos/2d/CCNode.h
+++ b/cocos2d/cocos/2d/CCNode.h
@@ -4,6 +4,7 @@
  Copyright (c) 2010-2012 cocos2d-x.org
  Copyright (c) 2011      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
  http://www.cocos2d-x.org
 
@@ -26,58 +27,51 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_NODE_H
-#define CC_2D_NODE_H
+#ifndef __CCNODE_H__
+#define __CCNODE_H__
 
-#include <cocos/base/CCProtocols.h>
-#include <cocos/base/CCRef.h>
+#include <cstdint>
+#include <cocos/base/ccMacros.h>
 #include <cocos/base/CCVector.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccTypes.h>
+#include <cocos/base/CCProtocols.h>
+#include <cocos/base/CCScriptSupport.h>
 #include <cocos/math/CCAffineTransform.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Quaternion.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <algorithm>
-#include <chrono>
-#include <cstddef>
-#include <cstdint>
-#include <functional>
-#include <string>
+#include <cocos/math/CCMath.h>
+#include <cocos/2d/CCComponentContainer.h>
+#include <cocos/2d/CCComponent.h>
+
+#if CC_USE_PHYSICS
+#include "physics/CCPhysicsBody.h"
+#endif
 
 NS_CC_BEGIN
 
+class GridBase;
+class Touch;
 class Action;
+class LabelProtocol;
+class Scheduler;
 class ActionManager;
-class Camera;
 class Component;
 class ComponentContainer;
-class Director;
 class EventDispatcher;
-class GLProgram;
-class GLProgramState;
-class Renderer;
 class Scene;
-class Scheduler;
-class Touch;
-class Vec3;
-
-#if CC_USE_PHYSICS
+class Renderer;
+class Director;
+class Material;
+class Camera;
 class PhysicsBody;
-#endif
+
+namespace backend{
+    class ProgramState;
+}
 
 /**
  * @addtogroup _2d
  * @{
  */
 
-enum
-{
+enum {
     kNodeOnEnter,
     kNodeOnExit,
     kNodeOnEnterTransitionDidFinish,
@@ -85,6 +79,8 @@ enum
     kNodeOnCleanup
 };
 
+class EventListener;
+
 /** @class Node
 * @brief Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subclasses of it.
  The most common Node objects are: Scene, Layer, Sprite, Menu, Label.
@@ -118,8 +114,7 @@ public:
     /** Default tag used for all the nodes */
     static const int INVALID_TAG = -1;
 
-    enum
-    {
+    enum {
         FLAGS_TRANSFORM_DIRTY = (1 << 0),
         FLAGS_CONTENT_SIZE_DIRTY = (1 << 1),
         FLAGS_RENDER_AS_3D = (1 << 3),
@@ -133,8 +128,14 @@ public:
      * Allocates and initializes a node.
      * @return A initialized node which is marked as "autorelease".
      */
-    static Node* create();
+    static Node * create();
 
+    /**
+     * Gets count of nodes those are attached to scene graph.
+     */
+    static int getAttachedNodeCount();
+public:
+    
     /**
      * Gets the description string. It makes debugging easier.
      * @return A string
@@ -145,6 +146,8 @@ public:
 
     /// @} end of initializers
 
+
+
     /// @{
     /// @name Setters & Getters for Graphic Properties
 
@@ -153,36 +156,34 @@ public:
 
      The Node's parent will sort all its children based on the LocalZOrder value.
      If two nodes have the same LocalZOrder, then the node that was added first to the children's array will be in front of the other node in the array.
-
+     
      Also, the Scene Graph is traversed using the "In-Order" tree traversal algorithm ( http://en.wikipedia.org/wiki/Tree_traversal#In-order )
      And Nodes that have LocalZOrder values < 0 are the "left" subtree
      While Nodes with LocalZOrder >=0 are the "right" subtree.
-
+     
      @see `setGlobalZOrder`
      @see `setVertexZ`
      *
      * @param localZOrder The local Z order value.
      */
     virtual void setLocalZOrder(std::int32_t localZOrder);
-
-    CC_DEPRECATED_ATTRIBUTE virtual void setZOrder(std::int32_t localZOrder) { setLocalZOrder(localZOrder); }
-
-    /*
+    
+    /* 
      Helper function used by `setLocalZOrder`. Don't use it unless you know what you are doing.
      @js NA
      */
     virtual void _setLocalZOrder(std::int32_t z);
 
     /** !!! ONLY FOR INTERNAL USE
-     * Sets the arrival order when this node has a same ZOrder with other children.
-     *
-     * A node which called addChild subsequently will take a larger arrival order,
-     * If two children have the same Z order, the child with larger arrival order will be drawn later.
-     *
-     * @warning This method is used internally for localZOrder sorting, don't change this manually
-     *
-     * @param orderOfArrival   The arrival order.
-     */
+    * Sets the arrival order when this node has a same ZOrder with other children.
+    *
+    * A node which called addChild subsequently will take a larger arrival order,
+    * If two children have the same Z order, the child with larger arrival order will be drawn later.
+    *
+    * @warning This method is used internally for localZOrder sorting, don't change this manually
+    *
+    * @param orderOfArrival   The arrival order.
+    */
     void updateOrderOfArrival();
 
     /**
@@ -195,19 +196,17 @@ public:
 
     virtual std::int32_t getLocalZOrder() const { return _localZOrder; }
 
-    CC_DEPRECATED_ATTRIBUTE virtual std::int32_t getZOrder() const { return getLocalZOrder(); }
-
     /**
      Defines the order in which the nodes are renderer.
      Nodes that have a Global Z Order lower, are renderer first.
-
+     
      In case two or more nodes have the same Global Z Order, the order is not guaranteed.
      The only exception if the Nodes have a Global Z Order == 0. In that case, the Scene Graph order is used.
-
+     
      By default, all nodes have a Global Z Order = 0. That means that by default, the Scene Graph order is used to render the nodes.
-
+     
      Global Z Order is useful when you need to render nodes in an order different than the Scene Graph order.
-
+     
      Limitations: Global Z Order can't be used by Nodes that have SpriteBatchNode as one of their ancestors.
      And if ClippingNode is one of the ancestors, then "global Z order" will be relative to the ClippingNode.
 
@@ -247,6 +246,7 @@ public:
      */
     virtual float getScaleX() const;
 
+
     /**
      * Sets the scale (y) of the node.
      *
@@ -285,6 +285,7 @@ public:
      */
     virtual float getScaleZ() const;
 
+
     /**
      * Sets the scale (x,y,z) of the node.
      *
@@ -305,7 +306,7 @@ public:
      */
     virtual float getScale() const;
 
-    /**
+     /**
      * Sets the scale (x,y) of the node.
      *
      * It is a scaling factor that multiplies the width and height of the node and its children.
@@ -329,7 +330,7 @@ public:
      *
      * @param position  The position (x,y) of the node in OpenGL coordinates.
      */
-    virtual void setPosition(const Vec2& position);
+    virtual void setPosition(const Vec2 &position);
 
     /** Sets the position (x,y) using values between 0 and 1.
      The positions in pixels is calculated like the following:
@@ -343,7 +344,9 @@ public:
      *
      * @param position The normalized position (x,y) of the node, using value between 0 and 1.
      */
-    virtual void setNormalizedPosition(const Vec2& position);
+    virtual void setPositionNormalized(const Vec2 &position);
+    // FIXME: should get deprecated in v4.0
+    virtual void setNormalizedPosition(const Vec2 &position) { setPositionNormalized(position); }
 
     /**
      * Gets the position (x,y) of the node in its parent's coordinate system.
@@ -358,10 +361,12 @@ public:
     virtual const Vec2& getPosition() const;
 
     /** Returns the normalized position.
-     *
+     * 
      * @return The normalized position.
      */
-    virtual const Vec2& getNormalizedPosition() const;
+    virtual const Vec2& getPositionNormalized() const;
+    // FIXME: should get deprecated in v4.0
+    virtual const Vec2& getNormalizedPosition() const { return getPositionNormalized(); }
 
     /**
      * Sets the position (x,y) of the node in its parent's coordinate system.
@@ -398,7 +403,7 @@ public:
      *
      * @param x The x coordinate of the node.
      */
-    virtual void setPositionX(float x);
+    virtual void  setPositionX(float x);
     /** Gets the x coordinate of the node in its parent's coordinate system.
      *
      * @return The x coordinate of the node.
@@ -408,7 +413,7 @@ public:
      *
      * @param y The y coordinate of the node.
      */
-    virtual void setPositionY(float y);
+    virtual void  setPositionY(float y);
     /** Gets the y coordinate of the node in its parent's coordinate system.
      *
      * @return The y coordinate of the node.
@@ -417,7 +422,7 @@ public:
 
     /**
      * Sets the position (X, Y, and Z) in its parent's coordinate system.
-     *
+     * 
      * @param position The position (X, Y, and Z) in its parent's coordinate system.
      * @js NA
      */
@@ -444,7 +449,6 @@ public:
      * @js setVertexZ
      */
     virtual void setPositionZ(float positionZ);
-    CC_DEPRECATED_ATTRIBUTE virtual void setVertexZ(float vertexZ) { setPositionZ(vertexZ); }
 
     /**
      * Gets position Z coordinate of this node.
@@ -455,7 +459,6 @@ public:
      * @js getVertexZ
      */
     virtual float getPositionZ() const;
-    CC_DEPRECATED_ATTRIBUTE virtual float getVertexZ() const { return getPositionZ(); }
 
     /**
      * Changes the X skew angle of the node in degrees.
@@ -481,6 +484,7 @@ public:
      */
     virtual float getSkewX() const;
 
+
     /**
      * Changes the Y skew angle of the node in degrees.
      *
@@ -505,6 +509,7 @@ public:
      */
     virtual float getSkewY() const;
 
+
     /**
      * Sets the anchor point in percent.
      *
@@ -512,7 +517,7 @@ public:
      * It's like a pin in the node where it is "attached" to its parent.
      * The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner.
      * But you can use values higher than (1,1) and lower than (0,0) too.
-     * The default anchorPoint is (0.5,0.5), so it starts in the center of the node.
+     * The default anchorPoint is (0,0), so it starts in the lower left corner of the node.
      * @note If node has a physics body, the anchor must be in the middle, you can't change this to other value.
      *
      * @param anchorPoint   The anchor point of node.
@@ -536,6 +541,7 @@ public:
      */
     virtual const Vec2& getAnchorPointInPoints() const;
 
+
     /**
      * Sets the untransformed size of the node.
      *
@@ -554,6 +560,7 @@ public:
      */
     virtual const Size& getContentSize() const;
 
+
     /**
      * Sets whether the node is visible.
      *
@@ -569,7 +576,8 @@ public:
      *
      * @return true if the node is visible, false if the node is hidden.
      */
-    inline bool isVisible() const noexcept { return _visible; }
+    virtual bool isVisible() const;
+
 
     /**
      * Sets the rotation (angle) of the node in degrees.
@@ -601,12 +609,12 @@ public:
     virtual void setRotation3D(const Vec3& rotation);
     /**
      * Returns the rotation (X,Y,Z) in degrees.
-     *
+     * 
      * @return The rotation of the node in 3d.
      * @js NA
      */
     virtual Vec3 getRotation3D() const;
-
+    
     /**
      * Set rotation by quaternion. You should make sure the quaternion is normalized.
      *
@@ -614,7 +622,7 @@ public:
      * @js NA
      */
     virtual void setRotationQuat(const Quaternion& quat);
-
+    
     /**
      * Return the rotation by quaternion, Note that when _rotationZ_X == _rotationZ_Y, the returned quaternion equals to RotationZ_X * RotationY * RotationX,
      * it equals to RotationY * RotationX otherwise.
@@ -639,7 +647,6 @@ public:
      * @js setRotationX
      */
     virtual void setRotationSkewX(float rotationX);
-    CC_DEPRECATED_ATTRIBUTE virtual void setRotationX(float rotationX) { return setRotationSkewX(rotationX); }
 
     /**
      * Gets the X rotation (angle) of the node in degrees which performs a horizontal rotation skew.
@@ -647,10 +654,9 @@ public:
      * @see `setRotationSkewX(float)`
      *
      * @return The X rotation in degrees.
-     * @js getRotationX
+     * @js getRotationX 
      */
     virtual float getRotationSkewX() const;
-    CC_DEPRECATED_ATTRIBUTE virtual float getRotationX() const { return getRotationSkewX(); }
 
     /**
      * Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.
@@ -667,7 +673,6 @@ public:
      * @js setRotationY
      */
     virtual void setRotationSkewY(float rotationY);
-    CC_DEPRECATED_ATTRIBUTE virtual void setRotationY(float rotationY) { return setRotationSkewY(rotationY); }
 
     /**
      * Gets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.
@@ -678,18 +683,6 @@ public:
      * @js getRotationY
      */
     virtual float getRotationSkewY() const;
-    CC_DEPRECATED_ATTRIBUTE virtual float getRotationY() const { return getRotationSkewY(); }
-
-    /** @deprecated No longer needed
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE void setGLServerState(int serverState)
-    { /* ignore */
-    }
-    /** @deprecated No longer needed
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE int getGLServerState() const { return 0; }
 
     /**
      * Sets whether the anchor point will be (0,0) when you position this node.
@@ -700,8 +693,7 @@ public:
      * @param ignore    true if anchor point will be (0,0) when you position this node.
      */
     virtual void setIgnoreAnchorPointForPosition(bool ignore);
-    CC_DEPRECATED_ATTRIBUTE virtual void ignoreAnchorPointForPosition(bool ignore) { setIgnoreAnchorPointForPosition(ignore); }
-
+    
     /**
      * Gets whether the anchor point will be (0,0) when you position this node.
      *
@@ -713,6 +705,7 @@ public:
 
     /// @}  end of Setters & Getters for Graphic Properties
 
+
     /// @{
     /// @name Children and Parent
 
@@ -723,7 +716,7 @@ public:
      *
      * @param child A child node.
      */
-    virtual void addChild(Node* child);
+    virtual void addChild(Node * child);
     /**
      * Adds a child to the container with a local z-order.
      *
@@ -732,7 +725,7 @@ public:
      * @param child     A child node.
      * @param localZOrder    Z order for drawing priority. Please refer to `setLocalZOrder(int)`.
      */
-    virtual void addChild(Node* child, int localZOrder);
+    virtual void addChild(Node * child, int localZOrder);
     /**
      * Adds a child to the container with z order and tag.
      *
@@ -741,10 +734,10 @@ public:
      * @param child         A child node.
      * @param localZOrder   Z order for drawing priority. Please refer to `setLocalZOrder(int)`.
      * @param tag           An integer to identify the node easily. Please refer to `setTag(int)`.
-     *
+     * 
      * Please use `addChild(Node* child, int localZOrder, const std::string &name)` instead.
      */
-    virtual void addChild(Node* child, int localZOrder, int tag);
+     virtual void addChild(Node* child, int localZOrder, int tag);
     /**
      * Adds a child to the container with z order and tag
      *
@@ -755,7 +748,7 @@ public:
      * @param name      A string to identify the node easily. Please refer to `setName(int)`.
      *
      */
-    virtual void addChild(Node* child, int localZOrder, const std::string& name);
+    virtual void addChild(Node* child, int localZOrder, const std::string &name);
     /**
      * Gets a child from the container with its tag.
      *
@@ -765,21 +758,18 @@ public:
      *
      * Please use `getChildByName()` instead.
      */
-    virtual Node* getChildByTag(int tag) const;
-
-    /**
+     virtual Node * getChildByTag(int tag) const;
+    
+     /**
      * Gets a child from the container with its tag that can be cast to Type T.
      *
      * @param tag   An identifier to find the child node.
      *
      * @return a Node with the given tag that can be cast to Type T.
-     */
+    */
     template <typename T>
-    T getChildByTag(int tag) const
-    {
-        return static_cast<T>(getChildByTag(tag));
-    }
-
+    T getChildByTag(int tag) const { return static_cast<T>(getChildByTag(tag)); }
+    
     /**
      * Gets a child from the container with its name.
      *
@@ -796,12 +786,9 @@ public:
      * @param name   An identifier to find the child node.
      *
      * @return a Node with the given name that can be cast to Type T.
-     */
+    */
     template <typename T>
-    T getChildByName(const std::string& name) const
-    {
-        return static_cast<T>(getChildByName(name));
-    }
+    T getChildByName(const std::string& name) const { return static_cast<T>(getChildByName(name)); }
     /** Search the children of the receiving node to perform processing for nodes which share a name.
      *
      * @param name The name to search for, supports c++11 regular expression.
@@ -823,13 +810,13 @@ public:
      * @warning Only support alpha or number for name, and not support unicode.
      *
      * @param callback A callback function to execute on nodes that match the `name` parameter. The function takes the following arguments:
-     *  `node`
+     *  `node` 
      *      A node that matches the name
      *  And returns a boolean result. Your callback can return `true` to terminate the enumeration.
      *
      * @since v3.2
      */
-    virtual void enumerateChildren(const std::string& name, std::function<bool(Node* node)> callback) const;
+    virtual void enumerateChildren(const std::string &name, std::function<bool(Node* node)> callback) const;
     /**
      * Returns the array of the node's children.
      *
@@ -837,13 +824,13 @@ public:
      */
     virtual Vector<Node*>& getChildren() { return _children; }
     virtual const Vector<Node*>& getChildren() const { return _children; }
-
-    /**
+    
+    /** 
      * Returns the amount of children.
      *
      * @return The amount of children.
      */
-    virtual std::size_t getChildrenCount() const;
+    virtual ssize_t getChildrenCount() const;
 
     /**
      * Sets the parent node.
@@ -861,6 +848,7 @@ public:
     virtual Node* getParent() { return _parent; }
     virtual const Node* getParent() const { return _parent; }
 
+
     ////// REMOVES //////
 
     /**
@@ -894,14 +882,14 @@ public:
      *
      * Please use `removeChildByName` instead.
      */
-    virtual void removeChildByTag(int tag, bool cleanup = true);
+     virtual void removeChildByTag(int tag, bool cleanup = true);
     /**
      * Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.
      *
      * @param name       A string that identifies a child node.
      * @param cleanup   True if all running actions and callbacks on the child node will be cleanup, false otherwise.
      */
-    virtual void removeChildByName(const std::string& name, bool cleanup = true);
+    virtual void removeChildByName(const std::string &name, bool cleanup = true);
     /**
      * Removes all children from the container with a cleanup.
      *
@@ -923,25 +911,27 @@ public:
      * @param child     An already added child node. It MUST be already added.
      * @param localZOrder Z order for drawing priority. Please refer to setLocalZOrder(int).
      */
-    virtual void reorderChild(Node* child, int localZOrder);
+    virtual void reorderChild(Node * child, int localZOrder);
 
     /**
      * Sorts the children array once before drawing, instead of every time when a child is added or reordered.
-     * This approach can improves the performance massively.
+     * This approach can improve the performance massively.
      * @note Don't call this manually unless a child added needs to be removed in the same frame.
      */
     virtual void sortAllChildren();
 
     /**
-     * Sorts helper function
-     *
-     */
-    template <typename _T>
-    inline static void sortNodes(cocos2d::Vector<_T*>& nodes)
+    * Sorts helper function
+    *
+    */
+    template<typename _T> inline
+    static void sortNodes(cocos2d::Vector<_T*>& nodes)
     {
         static_assert(std::is_base_of<Node, _T>::value, "Node::sortNodes: Only accept derived of Node!");
 #if CC_64BITS
-        std::sort(std::begin(nodes), std::end(nodes), [](_T* n1, _T* n2) { return (n1->_localZOrderArrival < n2->_localZOrderArrival); });
+        std::sort(std::begin(nodes), std::end(nodes), [](_T* n1, _T* n2) {
+            return (n1->_localZOrder$Arrival < n2->_localZOrder$Arrival);
+        });
 #else
         std::sort(std::begin(nodes), std::end(nodes), [](_T* n1, _T* n2) {
             return (n1->_localZOrder == n2->_localZOrder && n1->_orderOfArrival < n2->_orderOfArrival) || n1->_localZOrder < n2->_localZOrder;
@@ -950,7 +940,7 @@ public:
     }
 
     /// @} end of Children and Parent
-
+    
     /// @{
     /// @name Tag & User data
 
@@ -961,7 +951,7 @@ public:
      *
      * Please use `getTag()` instead.
      */
-    virtual int getTag() const;
+     virtual int getTag() const;
     /**
      * Changes the tag that is used to identify the node easily.
      *
@@ -971,11 +961,11 @@ public:
      *
      * Please use `setName()` instead.
      */
-    virtual void setTag(int tag);
-
+     virtual void setTag(int tag);
+    
     /** Returns a string that is used to identify the node.
      * @return A string that identifies the node.
-     *
+     * 
      * @since v3.2
      */
     virtual const std::string& getName() const;
@@ -986,6 +976,7 @@ public:
      */
     virtual void setName(const std::string& name);
 
+    
     /**
      * Returns a custom user data pointer.
      *
@@ -996,8 +987,8 @@ public:
      */
     virtual void* getUserData() { return _userData; }
     /**
-     * @lua NA
-     */
+    * @lua NA
+    */
     virtual const void* getUserData() const { return _userData; }
 
     /**
@@ -1010,7 +1001,7 @@ public:
      * @param userData  A custom user data pointer.
      * @lua NA
      */
-    virtual void setUserData(void* userData);
+    virtual void setUserData(void *userData);
 
     /**
      * Returns a user assigned Object.
@@ -1022,8 +1013,8 @@ public:
      */
     virtual Ref* getUserObject() { return _userObject; }
     /**
-     * @lua NA
-     */
+    * @lua NA
+    */
     virtual const Ref* getUserObject() const { return _userObject; }
 
     /**
@@ -1036,48 +1027,10 @@ public:
      *
      * @param userObject    A user assigned Object.
      */
-    virtual void setUserObject(Ref* userObject);
+    virtual void setUserObject(Ref *userObject);
 
     /// @} end of Tag & User Data
 
-    /// @{
-    /// @name GLProgram
-    /**
-     * Return the GLProgram (shader) currently used for this node.
-     *
-     * @return The GLProgram (shader) currently used for this node.
-     */
-    GLProgram* getGLProgram() const;
-    CC_DEPRECATED_ATTRIBUTE GLProgram* getShaderProgram() const { return getGLProgram(); }
-    /**
-     * Sets the shader program for this node
-     *
-     * Since v2.0, each rendering node must set its shader program.
-     * It should be set in initialize phase.
-     @code
-     node->setGLrProgram(GLProgramCache::getInstance()->getProgram(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR));
-     @endcode
-     *
-     * @param glprogram The shader program.
-     */
-    virtual void setGLProgram(GLProgram* glprogram);
-    CC_DEPRECATED_ATTRIBUTE void setShaderProgram(GLProgram* glprogram) { setGLProgram(glprogram); }
-
-    /**
-     * Return the GLProgramState currently used for this node.
-     *
-     * @return The GLProgramState currently used for this node.
-     */
-    GLProgramState* getGLProgramState() const;
-    /**
-     * Set the GLProgramState for this node.
-     *
-     * @param glProgramState The GLProgramState for this node.
-     */
-    virtual void setGLProgramState(GLProgramState* glProgramState);
-
-    /// @} end of Shader Program
-
     /**
      * Returns whether or not the node is "running".
      *
@@ -1098,6 +1051,7 @@ public:
 
     /// @}  end Script Bindings
 
+
     /// @{
     /// @name Event Callbacks
 
@@ -1135,6 +1089,7 @@ public:
 
     /// @} end of event callbacks.
 
+
     /**
      * Stops all running actions and schedulers
      */
@@ -1149,12 +1104,12 @@ public:
      * - `glEnable(GL_TEXTURE_2D);`
      * AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE
      * But if you enable any other GL state, you should disable it after drawing your node.
-     *
+     * 
      * @param renderer A given renderer.
      * @param transform A transform matrix.
      * @param flags Renderer flag.
      */
-    virtual void draw(Renderer* renderer, const Mat4& transform, std::uint32_t flags);
+    virtual void draw(Renderer *renderer, const Mat4& transform, uint32_t flags);
     virtual void draw() final;
 
     /**
@@ -1164,13 +1119,13 @@ public:
      * @param parentTransform A transform matrix.
      * @param parentFlags Renderer flag.
      */
-    virtual void visit(Renderer* renderer, const Mat4& parentTransform, std::uint32_t parentFlags);
+    virtual void visit(Renderer *renderer, const Mat4& parentTransform, uint32_t parentFlags);
     virtual void visit() final;
 
+
     /** Returns the Scene that contains the Node.
      It returns `nullptr` if the node doesn't belong to any Scene.
-     This function recursively calls parent->getScene() until parent is a Scene object. The results are not cached. It is that the user caches the results in
-     case this functions is being used inside a loop.
+     This function recursively calls parent->getScene() until parent is a Scene object. The results are not cached. It is that the user caches the results in case this functions is being used inside a loop.
      *
      * @return The Scene that contains the node.
      */
@@ -1183,9 +1138,6 @@ public:
      */
     virtual Rect getBoundingBox() const;
 
-    /** @deprecated Use getBoundingBox instead */
-    CC_DEPRECATED_ATTRIBUTE virtual Rect boundingBox() const { return getBoundingBox(); }
-
     /** Set event dispatcher for scene.
      *
      * @param dispatcher The event dispatcher of scene.
@@ -1195,7 +1147,7 @@ public:
      *
      * @return The event dispatcher of scene.
      */
-    virtual EventDispatcher* getEventDispatcher() const { return _eventDispatcher; }
+    virtual EventDispatcher* getEventDispatcher() const { return _eventDispatcher; };
 
     /// @{
     /// @name Actions
@@ -1259,7 +1211,7 @@ public:
      *
      * @return The action object with the given tag.
      */
-    Action* getActionByTag(int tag) const;
+    Action* getActionByTag(int tag);
 
     /**
      * Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).
@@ -1270,13 +1222,11 @@ public:
      *
      * @return The number of actions that are running plus the ones that are schedule to run.
      */
-    std::size_t getNumberOfRunningActions() const;
-
-    /** @deprecated Use getNumberOfRunningActions() instead */
-    CC_DEPRECATED_ATTRIBUTE std::size_t numberOfRunningActions() const { return getNumberOfRunningActions(); }
+    ssize_t getNumberOfRunningActions();
 
     /// @} end of Actions
 
+
     /// @{
     /// @name Scheduler and Timer
 
@@ -1296,6 +1246,7 @@ public:
     virtual Scheduler* getScheduler() { return _scheduler; }
     virtual const Scheduler* getScheduler() const { return _scheduler; }
 
+
     /**
      * Checks whether a selector is scheduled.
      *
@@ -1304,7 +1255,7 @@ public:
      * @js NA
      * @lua NA
      */
-    bool isScheduled(SEL_SCHEDULE selector);
+    bool isScheduled(SEL_SCHEDULE selector) const;
 
     /**
      * Checks whether a lambda function is scheduled.
@@ -1314,7 +1265,7 @@ public:
      * @js NA
      * @lua NA
      */
-    bool isScheduled(const std::string& key);
+    bool isScheduled(const std::string &key) const;
 
     /**
      * Schedules the "update" method.
@@ -1361,7 +1312,7 @@ public:
      * @param delay     The amount of time that the first tick will wait before execution.
      * @lua NA
      */
-    void schedule(SEL_SCHEDULE selector, std::chrono::milliseconds interval, unsigned int repeat, std::chrono::milliseconds delay);
+    void schedule(SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay);
 
     /**
      * Schedules a custom selector with an interval time in seconds.
@@ -1371,7 +1322,7 @@ public:
      * @param interval      Callback interval time in seconds. 0 means tick every frame,
      * @lua NA
      */
-    void schedule(SEL_SCHEDULE selector, std::chrono::milliseconds interval);
+    void schedule(SEL_SCHEDULE selector, float interval);
 
     /**
      * Schedules a selector that runs only once, with a delay of 0 or larger
@@ -1381,7 +1332,7 @@ public:
      * @param delay         The amount of time that the first tick will wait before execution.
      * @lua NA
      */
-    void scheduleOnce(SEL_SCHEDULE selector, std::chrono::milliseconds delay);
+    void scheduleOnce(SEL_SCHEDULE selector, float delay);
 
     /**
      * Schedules a lambda function that runs only once, with a delay of 0 or larger
@@ -1391,7 +1342,7 @@ public:
      * @param key           The key of the lambda function. To be used if you want to unschedule it.
      * @lua NA
      */
-    void scheduleOnce(const std::function<void(float)>& callback, std::chrono::milliseconds delay, const std::string& key);
+    void scheduleOnce(const std::function<void(float)>& callback, float delay, const std::string &key);
 
     /**
      * Schedules a custom selector, the scheduled selector will be ticked every frame.
@@ -1409,7 +1360,7 @@ public:
      * @param key           The key of the lambda function. To be used if you want to unschedule it.
      * @lua NA
      */
-    void schedule(const std::function<void(float)>& callback, const std::string& key);
+    void schedule(const std::function<void(float)>& callback, const std::string &key);
 
     /**
      * Schedules a lambda function. The scheduled lambda function will be called every "interval" seconds
@@ -1419,7 +1370,7 @@ public:
      * @param key           The key of the lambda function. To be used if you want to unschedule it
      * @lua NA
      */
-    void schedule(const std::function<void(float)>& callback, std::chrono::milliseconds interval, const std::string& key);
+    void schedule(const std::function<void(float)>& callback, float interval, const std::string &key);
 
     /**
      * Schedules a lambda function.
@@ -1431,8 +1382,7 @@ public:
      * @param key       The key of the lambda function. To be used if you want to unschedule it.
      * @lua NA
      */
-    void schedule(const std::function<void(float)>& callback, std::chrono::milliseconds interval, unsigned int repeat, std::chrono::milliseconds delay,
-                  const std::string& key);
+    void schedule(const std::function<void(float)>& callback, float interval, unsigned int repeat, float delay, const std::string &key);
 
     /**
      * Unschedules a custom selector.
@@ -1449,7 +1399,7 @@ public:
      * @param key      The key of the lambda function to be unscheduled.
      * @lua NA
      */
-    void unschedule(const std::string& key);
+    void unschedule(const std::string &key);
 
     /**
      * Unschedule all scheduled selectors and lambda functions: custom selectors, and the 'update' selector and lambda functions.
@@ -1458,8 +1408,6 @@ public:
      */
     void unscheduleAllCallbacks();
 
-    CC_DEPRECATED_ATTRIBUTE void unscheduleAllSelectors() { unscheduleAllCallbacks(); }
-
     /**
      * Resumes all scheduled selectors, actions and event listeners.
      * This method is called internally by onEnter.
@@ -1471,17 +1419,6 @@ public:
      */
     virtual void pause();
 
-    /**
-     * Resumes all scheduled selectors, actions and event listeners.
-     * This method is called internally by onEnter.
-     */
-    CC_DEPRECATED_ATTRIBUTE void resumeSchedulerAndActions();
-    /**
-     * Pauses all scheduled selectors, actions and event listeners.
-     * This method is called internally by onExit.
-     */
-    CC_DEPRECATED_ATTRIBUTE void pauseSchedulerAndActions();
-
     /**
      * Update method will be called automatically every frame if "scheduleUpdate" is called, and the node is "live".
      * @param delta In seconds.
@@ -1534,16 +1471,13 @@ public:
      */
     virtual AffineTransform getNodeToParentAffineTransform(Node* ancestor) const;
 
-    /**
+    /** 
      * Sets the transformation matrix manually.
      *
      * @param transform A given transformation matrix.
      */
     virtual void setNodeToParentTransform(const Mat4& transform);
 
-    /** @deprecated use getNodeToParentTransform() instead */
-    CC_DEPRECATED_ATTRIBUTE virtual AffineTransform nodeToParentTransform() const { return getNodeToParentAffineTransform(); }
-
     /**
      * Returns the matrix that transform parent's space coordinates to the node's (local) space coordinates.
      * The matrix is in Pixels.
@@ -1553,9 +1487,6 @@ public:
     virtual const Mat4& getParentToNodeTransform() const;
     virtual AffineTransform getParentToNodeAffineTransform() const;
 
-    /** @deprecated Use getParentToNodeTransform() instead */
-    CC_DEPRECATED_ATTRIBUTE virtual AffineTransform parentToNodeTransform() const { return getParentToNodeAffineTransform(); }
-
     /**
      * Returns the world affine transform matrix. The matrix is in Pixels.
      *
@@ -1564,9 +1495,6 @@ public:
     virtual Mat4 getNodeToWorldTransform() const;
     virtual AffineTransform getNodeToWorldAffineTransform() const;
 
-    /** @deprecated Use getNodeToWorldTransform() instead */
-    CC_DEPRECATED_ATTRIBUTE virtual AffineTransform nodeToWorldTransform() const { return getNodeToWorldAffineTransform(); }
-
     /**
      * Returns the inverse world affine transform matrix. The matrix is in Pixels.
      *
@@ -1575,11 +1503,9 @@ public:
     virtual Mat4 getWorldToNodeTransform() const;
     virtual AffineTransform getWorldToNodeAffineTransform() const;
 
-    /** @deprecated Use getWorldToNodeTransform() instead */
-    CC_DEPRECATED_ATTRIBUTE virtual AffineTransform worldToNodeTransform() const { return getWorldToNodeAffineTransform(); }
-
     /// @} end of Transformations
 
+
     /// @{
     /// @name Coordinate Converters
 
@@ -1623,7 +1549,7 @@ public:
      * @param touch A given touch.
      * @return A point in world space coordinates.
      */
-    Vec2 convertTouchToNodeSpace(Touch* touch) const;
+    Vec2 convertTouchToNodeSpace(Touch * touch) const;
 
     /**
      * converts a Touch (world coordinates) into a local coordinate. This method is AR (Anchor Relative).
@@ -1631,7 +1557,7 @@ public:
      * @param touch A given touch.
      * @return A point in world space coordinates, anchor relative.
      */
-    Vec2 convertTouchToNodeSpaceAR(Touch* touch) const;
+    Vec2 convertTouchToNodeSpaceAR(Touch * touch) const;
 
     /**
      *  Sets an additional transform matrix to the node.
@@ -1649,7 +1575,7 @@ public:
 
     /// @} end of Coordinate Converters
 
-    /// @{
+      /// @{
     /// @name component functions
     /**
      * Gets a component by its name.
@@ -1665,7 +1591,7 @@ public:
      * @param component A given component.
      * @return True if added success.
      */
-    virtual bool addComponent(Component* component);
+    virtual bool addComponent(Component *component);
 
     /**
      * Removes a component by its name.
@@ -1675,42 +1601,42 @@ public:
      */
     virtual bool removeComponent(const std::string& name);
 
-    /**
+    /** 
      * Removes a component by its pointer.
      *
      * @param component A given component.
      * @return True if removed success.
      */
-    virtual bool removeComponent(Component* component);
+    virtual bool removeComponent(Component *component);
     /**
      * Removes all components
      */
     virtual void removeAllComponents();
     /// @} end of component functions
-
+    
     // overrides
     /**
      * Return the node's opacity.
      * @return A GLubyte value.
      */
-    virtual GLubyte getOpacity() const;
+    virtual uint8_t getOpacity() const;
     /**
      * Return the node's display opacity.
      * The difference between opacity and displayedOpacity is:
      * The displayedOpacity is what's the final rendering opacity of node.
      * @return A GLubyte value.
      */
-    virtual GLubyte getDisplayedOpacity() const;
+    virtual uint8_t getDisplayedOpacity() const;
     /**
      * Change node opacity.
      * @param opacity A GLubyte opacity value.
      */
-    virtual void setOpacity(GLubyte opacity);
+    virtual void setOpacity(uint8_t opacity);
     /**
      * Update the displayed opacity of node with it's parent opacity;
      * @param parentOpacity The opacity of parent node.
      */
-    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
+    virtual void updateDisplayedOpacity(uint8_t parentOpacity);
     /**
      * Whether cascadeOpacity is enabled or not.
      * @return A boolean value.
@@ -1758,12 +1684,12 @@ public:
      *  If you want the opacity affect the color property, then set to true.
      * @param value A boolean value.
      */
-    virtual void setOpacityModifyRGB(bool) {}
+    virtual void setOpacityModifyRGB(bool value);
     /**
      * If node opacity will modify the RGB color value, then you should override this method and return true.
      * @return A boolean value, true indicates that opacity will modify color; false otherwise.
      */
-    virtual bool isOpacityModifyRGB() const { return false; }
+    virtual bool isOpacityModifyRGB() const;
 
     /**
      * Set the callback of event onEnter.
@@ -1805,7 +1731,7 @@ public:
      * @return std::function<void()>
      */
     const std::function<void()>& getonExitTransitionDidStartCallback() const { return _onExitTransitionDidStartCallback; }
-
+    
     /**
      * get & set camera mask, the node is visible by the camera whose camera flag & node's camera mask is true
      */
@@ -1817,12 +1743,13 @@ public:
      * @param applyChildren A boolean value to determine whether the mask bit should apply to its children or not.
      */
     virtual void setCameraMask(unsigned short mask, bool applyChildren = true);
+    
+    virtual void setProgramState(backend::ProgramState* programState);
+    virtual backend::ProgramState* getProgramState() const;
 
-    cocos2d::Mat4 getModelViewMatrix() { return _modelViewTransform; }
-
-    CC_CONSTRUCTOR_ACCESS :
-        // Nodes should be created using create();
-        Node();
+CC_CONSTRUCTOR_ACCESS:
+    // Nodes should be created using create();
+    Node();
     virtual ~Node();
 
     virtual bool init();
@@ -1830,167 +1757,158 @@ public:
 protected:
     /// lazy allocs
     void childrenAlloc();
-
+    
     /// helper that reorder a child
     void insertChild(Node* child, int z);
 
     /// Removes a child, call child->onExit(), do cleanup, remove it from children array.
-    void detachChild(Node* child, std::size_t index, bool doCleanup);
+    void detachChild(Node *child, ssize_t index, bool doCleanup);
 
     /// Convert cocos2d coordinates to UI windows coordinate.
     Vec2 convertToWindowSpace(const Vec2& nodePoint) const;
 
-    Mat4 transform(const Mat4& parentTransform);
-    std::uint32_t processParentFlags(const Mat4& parentTransform, std::uint32_t parentFlags);
+    Mat4 transform(const Mat4 &parentTransform);
+    uint32_t processParentFlags(const Mat4& parentTransform, uint32_t parentFlags);
 
     virtual void updateCascadeOpacity();
     virtual void disableCascadeOpacity();
     virtual void updateCascadeColor();
     virtual void disableCascadeColor();
     virtual void updateColor() {}
-
-    bool doEnumerate(std::string name, std::function<bool(Node*)> callback) const;
-    bool doEnumerateRecursive(const Node* node, const std::string& name, std::function<bool(Node*)> callback) const;
-
-    // check whether this camera mask is visible by the current visiting camera
+    
+    bool doEnumerate(std::string name, std::function<bool (Node *)> callback) const;
+    bool doEnumerateRecursive(const Node* node, const std::string &name, std::function<bool (Node *)> callback) const;
+    
+    //check whether this camera mask is visible by the current visiting camera
     bool isVisitableByVisitingCamera() const;
-
+    
     // update quaternion from Rotation3D
     void updateRotationQuat();
     // update Rotation3D from quaternion
     void updateRotation3D();
-
+    
 private:
-    void addChildHelper(Node* child, int localZOrder, int tag, const std::string& name, bool setTag);
-
+    void addChildHelper(Node* child, int localZOrder, int tag, const std::string &name, bool setTag);
+    
 protected:
-    float _rotationX; ///< rotation on the X-axis
-    float _rotationY; ///< rotation on the Y-axis
 
-    // rotation Z is decomposed in 2 to simulate Skew for Flash animations
-    float _rotationZ_X; ///< rotation angle on Z-axis, component X
-    float _rotationZ_Y; ///< rotation angle on Z-axis, component Y
+    float _rotationX;               ///< rotation on the X-axis
+    float _rotationY;               ///< rotation on the Y-axis
 
-    Quaternion _rotationQuat; /// rotation using quaternion, if _rotationZ_X == _rotationZ_Y, _rotationQuat = RotationZ_X * RotationY * RotationX, else
-                              /// _rotationQuat = RotationY * RotationX
+    // rotation Z is decomposed in 2 to simulate Skew for Flash animations
+    float _rotationZ_X;             ///< rotation angle on Z-axis, component X
+    float _rotationZ_Y;             ///< rotation angle on Z-axis, component Y
+    
+    Quaternion _rotationQuat;       ///rotation using quaternion, if _rotationZ_X == _rotationZ_Y, _rotationQuat = RotationZ_X * RotationY * RotationX, else _rotationQuat = RotationY * RotationX
 
-    float _scaleX; ///< scaling factor on x-axis
-    float _scaleY; ///< scaling factor on y-axis
-    float _scaleZ; ///< scaling factor on z-axis
+    float _scaleX;                  ///< scaling factor on x-axis
+    float _scaleY;                  ///< scaling factor on y-axis
+    float _scaleZ;                  ///< scaling factor on z-axis
 
-    Vec2 _position; ///< position of the node
-    float _positionZ; ///< OpenGL real Z position
+    Vec2 _position;                 ///< position of the node
+    float _positionZ;               ///< OpenGL real Z position
     Vec2 _normalizedPosition;
     bool _usingNormalizedPosition;
     bool _normalizedPositionDirty;
 
-    float _skewX; ///< skew angle on x-axis
-    float _skewY; ///< skew angle on y-axis
+    float _skewX;                   ///< skew angle on x-axis
+    float _skewY;                   ///< skew angle on y-axis
 
-    Vec2 _anchorPointInPoints; ///< anchor point in points
-    Vec2 _anchorPoint; ///< anchor point normalized (NOT in points)
+    Vec2 _anchorPointInPoints;      ///< anchor point in points
+    Vec2 _anchorPoint;              ///< anchor point normalized (NOT in points)
 
-    Size _contentSize; ///< untransformed size of the node
-    bool _contentSizeDirty; ///< whether or not the contentSize is dirty
+    Size _contentSize;              ///< untransformed size of the node
+    bool _contentSizeDirty;         ///< whether or not the contentSize is dirty
 
-    Mat4 _modelViewTransform; ///< ModelView transform of the Node.
+    Mat4 _modelViewTransform;       ///< ModelView transform of the Node.
 
     // "cache" variables are allowed to be mutable
-    mutable Mat4 _transform; ///< transform
-    mutable bool _transformDirty; ///< transform dirty flag
-    mutable Mat4 _inverse; ///< inverse transform
-    mutable bool _inverseDirty; ///< inverse transform dirty flag
+    mutable Mat4 _transform;        ///< transform
+    mutable bool _transformDirty;   ///< transform dirty flag
+    mutable Mat4 _inverse;          ///< inverse transform
+    mutable bool _inverseDirty;     ///< inverse transform dirty flag
     mutable Mat4* _additionalTransform; ///< two transforms needed by additional transforms
     mutable bool _additionalTransformDirty; ///< transform dirty ?
-    bool _transformUpdated; ///< Whether or not the Transform object was updated since the last frame
+    bool _transformUpdated;         ///< Whether or not the Transform object was updated since the last frame
 
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
-#pragma clang diagnostic ignored "-Wnested-anon-types"
 #if CC_LITTLE_ENDIAN
-    union
-    {
-        struct
-        {
+    union {
+        struct {
             std::uint32_t _orderOfArrival;
             std::int32_t _localZOrder;
         };
-        std::int64_t _localZOrderArrival;
+        std::int64_t _localZOrder$Arrival;
     };
 #else
-    union
-    {
-        struct
-        {
+    union {
+        struct {
             std::int32_t _localZOrder;
             std::uint32_t _orderOfArrival;
         };
-        std::int64_t _localZOrderArrival;
+        std::int64_t _localZOrder$Arrival;
     };
 #endif
-#pragma clang diagnostic pop
 
-    float _globalZOrder; ///< Global order used to sort the node
+    float _globalZOrder;            ///< Global order used to sort the node
 
     static std::uint32_t s_globalOrderOfArrival;
 
-    Vector<Node*> _children; ///< array of children nodes
-    Node* _parent; ///< weak reference to parent node
-    Director* _director; // cached director pointer to improve rendering performance
-    int _tag; ///< a tag. Can be any number you assigned just to identify this node
-
-    std::string _name; ///< a string label, an user defined string to identify this node
-    std::size_t _hashOfName; ///< hash value of _name, used for speed in getChildByName
-
-    void* _userData; ///< A user assigned void pointer, Can be point to any cpp object
-    Ref* _userObject; ///< A user assigned Object
-
-    GLProgramState* _glProgramState; ///< OpenGL Program State
+    Vector<Node*> _children;        ///< array of children nodes
+    Node *_parent;                  ///< weak reference to parent node
+    Director* _director;            //cached director pointer to improve rendering performance
+    int _tag;                       ///< a tag. Can be any number you assigned just to identify this node
+    
+    std::string _name;              ///<a string label, an user defined string to identify this node
+    size_t _hashOfName;             ///<hash value of _name, used for speed in getChildByName
 
-    Scheduler* _scheduler; ///< scheduler used to schedule timers and updates
+    void *_userData;                ///< A user assigned void pointer, Can be point to any cpp object
+    Ref *_userObject;               ///< A user assigned Object
+    
+    Scheduler *_scheduler;          ///< scheduler used to schedule timers and updates
 
-    ActionManager* _actionManager; ///< a pointer to ActionManager singleton, which is used to handle all the actions
+    ActionManager *_actionManager;  ///< a pointer to ActionManager singleton, which is used to handle all the actions
 
-    EventDispatcher* _eventDispatcher; ///< event dispatcher used to dispatch all kinds of events
+    EventDispatcher* _eventDispatcher;  ///< event dispatcher used to dispatch all kinds of events
 
-    bool _running; ///< is running
+    bool _running;                  ///< is running
 
-    bool _visible; ///< is this node visible
+    bool _visible;                  ///< is this node visible
 
     bool _ignoreAnchorPointForPosition; ///< true if the Anchor Vec2 will be (0,0) when you position the Node, false otherwise.
-    ///< Used by Layer and Scene.
+                                          ///< Used by Layer and Scene.
 
-    bool _reorderChildDirty; ///< children order dirty flag
-    bool _isTransitionFinished; ///< flag to indicate whether the transition was finished
+    bool _reorderChildDirty;          ///< children order dirty flag
+    bool _isTransitionFinished;       ///< flag to indicate whether the transition was finished
 
 #if CC_ENABLE_SCRIPT_BINDING
-    int _scriptHandler; ///< script handler for onEnter() & onExit(), used in Javascript binding and Lua binding.
-    int _updateScriptHandler; ///< script handler for update() callback per frame, which is invoked from lua & javascript.
-    ccScriptType _scriptType; ///< type of script binding, lua or javascript
+    int _scriptHandler;               ///< script handler for onEnter() & onExit(), used in Javascript binding and Lua binding.
+    int _updateScriptHandler;         ///< script handler for update() callback per frame, which is invoked from lua & javascript.
+    ccScriptType _scriptType;         ///< type of script binding, lua or javascript
 #endif
-
-    ComponentContainer* _componentContainer; ///< Dictionary of components
-
+    
+    ComponentContainer *_componentContainer;        ///< Dictionary of components
+    
     // opacity controls
-    GLubyte _displayedOpacity;
-    GLubyte _realOpacity;
-    Color3B _displayedColor;
-    Color3B _realColor;
-    bool _cascadeColorEnabled;
-    bool _cascadeOpacityEnabled;
+    uint8_t     _displayedOpacity;
+    uint8_t     _realOpacity;
+    Color3B     _displayedColor;
+    Color3B     _realColor;
+    bool        _cascadeColorEnabled;
+    bool        _cascadeOpacityEnabled;
 
     // camera mask, it is visible only when _cameraMask & current camera' camera flag is true
     unsigned short _cameraMask;
-
+    
     std::function<void()> _onEnterCallback;
     std::function<void()> _onExitCallback;
     std::function<void()> _onEnterTransitionDidFinishCallback;
     std::function<void()> _onExitTransitionDidStartCallback;
+    
+    backend::ProgramState* _programState = nullptr;
 
-// Physics:remaining backwardly compatible
+//Physics:remaining backwardly compatible  
 #if CC_USE_PHYSICS
     PhysicsBody* _physicsBody;
-
 public:
     void setPhysicsBody(PhysicsBody* physicsBody)
     {
@@ -2006,8 +1924,10 @@ public:
     friend class PhysicsBody;
 #endif
 
+    static int __attachedNodeCount;
+    
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(Node)
+    CC_DISALLOW_COPY_AND_ASSIGN(Node);
 };
 
 /**
@@ -2025,52 +1945,11 @@ private:
  * @parma p         Point to a Vec3 for store the intersect point, if don't need them set to nullptr.
  * @return true if the point is in content rectangle, false otherwise.
  */
-bool CC_DLL isScreenPointInRect(const Vec2& pt, const Camera* camera, const Mat4& w2l, const Rect& rect, Vec3* p);
-
-// NodeRGBA
-
-/** @class __NodeRGBA
- * @brief __NodeRGBA is a subclass of Node that implements the RGBAProtocol protocol.
-
- All features from Node are valid, plus the following new features:
- - opacity
- - RGB colors
-
- Opacity/Color propagates into children that conform to the RGBAProtocol if cascadeOpacity/cascadeColor is enabled.
- @since v2.1
- @js NA
- */
-class CC_DLL __NodeRGBA : public Node, public __RGBAProtocol
-{
-public:
-    // overrides
-    GLubyte getOpacity() const override { return Node::getOpacity(); }
-    GLubyte getDisplayedOpacity() const override { return Node::getDisplayedOpacity(); }
-    void setOpacity(GLubyte opacity) override { return Node::setOpacity(opacity); }
-    void updateDisplayedOpacity(GLubyte parentOpacity) override { return Node::updateDisplayedOpacity(parentOpacity); }
-    bool isCascadeOpacityEnabled() const override { return Node::isCascadeOpacityEnabled(); }
-    void setCascadeOpacityEnabled(bool cascadeOpacityEnabled) override { return Node::setCascadeOpacityEnabled(cascadeOpacityEnabled); }
-
-    const Color3B& getColor() const override { return Node::getColor(); }
-    const Color3B& getDisplayedColor() const override { return Node::getDisplayedColor(); }
-    void setColor(const Color3B& color) override { return Node::setColor(color); }
-    void updateDisplayedColor(const Color3B& parentColor) override { return Node::updateDisplayedColor(parentColor); }
-    bool isCascadeColorEnabled() const override { return Node::isCascadeColorEnabled(); }
-    void setCascadeColorEnabled(bool cascadeColorEnabled) override { return Node::setCascadeColorEnabled(cascadeColorEnabled); }
-
-    void setOpacityModifyRGB(bool bValue) override { return Node::setOpacityModifyRGB(bValue); }
-    bool isOpacityModifyRGB() const override { return Node::isOpacityModifyRGB(); }
-
-    CC_CONSTRUCTOR_ACCESS : __NodeRGBA();
-    ~__NodeRGBA() override;
-
-private:
-    CC_DISALLOW_COPY_AND_ASSIGN(__NodeRGBA)
-};
+bool CC_DLL isScreenPointInRect(const Vec2 &pt, const Camera* camera, const Mat4& w2l, const Rect& rect, Vec3 *p);
 
 // end of _2d group
 /// @}
 
 NS_CC_END
 
-#endif // CC_2D_NODE_H
+#endif // __CCNODE_H__
diff --git a/cocos2d/cocos/2d/CCNodeGrid.cpp b/cocos2d/cocos/2d/CCNodeGrid.cpp
index ddfb66322f..59faf5ee34 100644
--- a/cocos2d/cocos/2d/CCNodeGrid.cpp
+++ b/cocos2d/cocos/2d/CCNodeGrid.cpp
@@ -1,5 +1,6 @@
 /****************************************************************************
  Copyright (c) 2013-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
  http://www.cocos2d-x.org
 
@@ -21,9 +22,7 @@
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  ****************************************************************************/
-
 #include <cocos/2d/CCNodeGrid.h>
-
 #include <cocos/2d/CCGrid.h>
 #include <cocos/renderer/CCRenderer.h>
 
@@ -31,7 +30,7 @@ NS_CC_BEGIN
 
 NodeGrid* NodeGrid::create()
 {
-    NodeGrid* ret = new (std::nothrow) NodeGrid();
+    NodeGrid * ret = new (std::nothrow) NodeGrid();
     if (ret && ret->init())
     {
         ret->autorelease();
@@ -43,20 +42,16 @@ NodeGrid* NodeGrid::create()
     return ret;
 }
 
-NodeGrid* NodeGrid::create(const cocos2d::Rect& rect)
+NodeGrid* NodeGrid::create(const cocos2d::Rect &rect)
 {
     NodeGrid* ret = NodeGrid::create();
-    if (ret)
-    {
+    if (ret) {
         ret->setGridRect(rect);
     }
     return ret;
 }
 
 NodeGrid::NodeGrid()
-: _gridTarget(nullptr)
-, _nodeGrid(nullptr)
-, _gridRect(Rect::ZERO)
 {
 }
 
@@ -93,13 +88,13 @@ void NodeGrid::onGridBeginDraw()
 
 void NodeGrid::onGridEndDraw()
 {
-    if (_nodeGrid && _nodeGrid->isActive())
+    if(_nodeGrid && _nodeGrid->isActive())
     {
         _nodeGrid->afterDraw(this);
     }
 }
 
-void NodeGrid::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void NodeGrid::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     // quick return if not visible. children won't be drawn.
     if (!_visible)
@@ -108,51 +103,45 @@ void NodeGrid::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t p
     }
 
     bool dirty = (parentFlags & FLAGS_TRANSFORM_DIRTY) || _transformUpdated;
-    if (dirty)
+    if(dirty)
         _modelViewTransform = this->transform(parentTransform);
     _transformUpdated = false;
 
-    _groupCommand.init(_globalZOrder);
-    renderer->addCommand(&_groupCommand);
-    renderer->pushGroup(_groupCommand.getRenderQueueID());
-
     // IMPORTANT:
     // To ease the migration to v3.0, we still support the Mat4 stack,
     // but it is deprecated and your code should not rely on it
     Director* director = Director::getInstance();
     CCASSERT(nullptr != director, "Director is null when setting matrix stack");
-
+    
     director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
     director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform);
 
     Director::Projection beforeProjectionType = Director::Projection::DEFAULT;
-    if (_nodeGrid && _nodeGrid->isActive())
+    if(_nodeGrid && _nodeGrid->isActive())
     {
         beforeProjectionType = Director::getInstance()->getProjection();
         _nodeGrid->set2DProjection();
     }
 
-    _gridBeginCommand.init(_globalZOrder);
-    _gridBeginCommand.setFunc([this]() { onGridBeginDraw(); });
-    renderer->addCommand(&_gridBeginCommand);
+    onGridBeginDraw();
 
-    if (_gridTarget)
+    if(_gridTarget)
     {
         _gridTarget->visit(renderer, _modelViewTransform, dirty);
     }
-
-    std::size_t i = 0;
+    
+    int i = 0;
     bool visibleByCamera = isVisitableByVisitingCamera();
 
-    if (!_children.empty())
+    if(!_children.empty())
     {
         sortAllChildren();
         // draw children zOrder < 0
-        for (; i < _children.size(); i++)
+        for(auto size = _children.size(); i < size; ++i)
         {
             auto node = _children.at(i);
 
-            if (node && node->getLocalZOrder() < 0)
+            if ( node && node->getLocalZOrder() < 0 )
                 node->visit(renderer, _modelViewTransform, dirty);
             else
                 break;
@@ -161,8 +150,7 @@ void NodeGrid::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t p
         if (visibleByCamera)
             this->draw(renderer, _modelViewTransform, dirty);
 
-        for (auto it = _children.cbegin() + i; it != _children.cend(); ++it)
-        {
+        for(auto it=_children.cbegin()+i, itCend = _children.cend(); it != itCend; ++it) {
             (*it)->visit(renderer, _modelViewTransform, dirty);
         }
     }
@@ -170,27 +158,23 @@ void NodeGrid::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t p
     {
         this->draw(renderer, _modelViewTransform, dirty);
     }
-
+    
     // FIX ME: Why need to set _orderOfArrival to 0??
     // Please refer to https://github.com/cocos2d/cocos2d-x/pull/6920
     // setOrderOfArrival(0);
-
-    if (_nodeGrid && _nodeGrid->isActive())
+    
+    if(_nodeGrid && _nodeGrid->isActive())
     {
         // restore projection
         director->setProjection(beforeProjectionType);
     }
 
-    _gridEndCommand.init(_globalZOrder);
-    _gridEndCommand.setFunc([this]() { onGridEndDraw(); });
-    renderer->addCommand(&_gridEndCommand);
-
-    renderer->popGroup();
+    onGridEndDraw();
 
     director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
 }
 
-void NodeGrid::setGrid(GridBase* grid)
+void NodeGrid::setGrid(GridBase *grid)
 {
     CC_SAFE_RELEASE(_nodeGrid);
     CC_SAFE_RETAIN(grid);
diff --git a/cocos2d/cocos/2d/CCNodeGrid.h b/cocos2d/cocos/2d/CCNodeGrid.h
index ed31eff28f..2f24725df8 100644
--- a/cocos2d/cocos/2d/CCNodeGrid.h
+++ b/cocos2d/cocos/2d/CCNodeGrid.h
@@ -1,5 +1,6 @@
 /****************************************************************************
  Copyright (c) 2013-2016 Chukong Technologies Inc.
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
  http://www.cocos2d-x.org
 
@@ -21,13 +22,11 @@
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  ****************************************************************************/
-
-#ifndef CC_2D_NODEGRID_H
-#define CC_2D_NODEGRID_H
+#pragma once
 
 #include <cocos/2d/CCNode.h>
-#include <cocos/renderer/CCCustomCommand.h>
 #include <cocos/renderer/CCGroupCommand.h>
+#include <cocos/renderer/CCCustomCommand.h>
 
 NS_CC_BEGIN
 
@@ -49,10 +48,10 @@ public:
      * @return An autorelease Grid Node.
      */
     static NodeGrid* create();
-
+    
     static NodeGrid* create(const Rect& rect);
-
-    /** Get a Grid Node.
+    
+    /** Get a Grid Node. 
      *
      * @return Return a GridBase.
      */
@@ -67,14 +66,14 @@ public:
      *
      * @param grid  A Grid object that is used when applying effects.
      */
-    void setGrid(GridBase* grid);
-
-    /** Set the Grid Target.
+    void setGrid(GridBase *grid);
+    
+    /** Set the Grid Target. 
      *
      * @param target A Node is used to set the Grid Target.
      */
-    void setTarget(Node* target);
-
+    void setTarget(Node *target);
+    
     /**
      * @brief Set the effect grid rect.
      * @param gridRect The effect grid rect.
@@ -87,27 +86,26 @@ public:
     const Rect& getGridRect() const { return _gridRect; }
 
     // overrides
-    void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
 
-    CC_CONSTRUCTOR_ACCESS : NodeGrid();
-    ~NodeGrid() override;
+CC_CONSTRUCTOR_ACCESS:
+    NodeGrid();
+    virtual ~NodeGrid();
 
 protected:
     void onGridBeginDraw();
     void onGridEndDraw();
 
-    Node* _gridTarget;
-    GridBase* _nodeGrid;
+    Node* _gridTarget = nullptr;
+    GridBase* _nodeGrid = nullptr;
     GroupCommand _groupCommand;
     CustomCommand _gridBeginCommand;
     CustomCommand _gridEndCommand;
-
-    Rect _gridRect;
+    
+    Rect _gridRect = Rect::ZERO;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(NodeGrid)
+    CC_DISALLOW_COPY_AND_ASSIGN(NodeGrid);
 };
 /** @} */
 NS_CC_END
-
-#endif // CC_2D_NODEGRID_H
diff --git a/cocos2d/cocos/2d/CCParallaxNode.cpp b/cocos2d/cocos/2d/CCParallaxNode.cpp
index 04e3dcaad4..e9d59a75d6 100644
--- a/cocos2d/cocos/2d/CCParallaxNode.cpp
+++ b/cocos2d/cocos/2d/CCParallaxNode.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,36 +26,21 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCParallaxNode.h>
-
-#include <cocos/2d/CCNode.h>
-#include <cocos/base/CCRef.h>
 #include <cocos/base/ccCArray.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <cstddef>
-#include <new>
-
-namespace cocos2d
-{
-    class Renderer;
-}
 
 NS_CC_BEGIN
 
 class PointObject : public Ref
 {
 public:
-    static PointObject* create(Vec2 ratio, Vec2 offset)
+    static PointObject * create(Vec2 ratio, Vec2 offset)
     {
-        PointObject* ret = new (std::nothrow) PointObject();
+        PointObject *ret = new (std::nothrow) PointObject();
         ret->initWithPoint(ratio, offset);
         ret->autorelease();
         return ret;
     }
-
+    
     bool initWithPoint(Vec2 ratio, Vec2 offset)
     {
         _ratio = ratio;
@@ -62,60 +48,60 @@ public:
         _child = nullptr;
         return true;
     }
-
+    
     const Vec2& getRatio() const { return _ratio; }
     void setRatio(const Vec2& ratio) { _ratio = ratio; }
 
     const Vec2& getOffset() const { return _offset; }
     void setOffset(const Vec2& offset) { _offset = offset; }
-
+    
     Node* getChild() const { return _child; }
     void setChild(Node* child) { _child = child; }
-
+    
 private:
     Vec2 _ratio;
     Vec2 _offset;
-    Node* _child; // weak ref
+    Node *_child; // weak ref
 };
 
 ParallaxNode::ParallaxNode()
 {
-    _parallaxArray = ccArrayNew(5);
+    _parallaxArray = ccArrayNew(5);        
     _lastPosition.set(-100.0f, -100.0f);
 }
 
 ParallaxNode::~ParallaxNode()
 {
-    if (_parallaxArray)
+    if( _parallaxArray )
     {
         ccArrayFree(_parallaxArray);
         _parallaxArray = nullptr;
     }
 }
 
-ParallaxNode* ParallaxNode::create()
+ParallaxNode * ParallaxNode::create()
 {
-    ParallaxNode* ret = new (std::nothrow) ParallaxNode();
+    ParallaxNode *ret = new (std::nothrow) ParallaxNode();
     ret->autorelease();
     return ret;
 }
 
-void ParallaxNode::addChild(Node*, int, int)
+void ParallaxNode::addChild(Node* /*child*/, int /*zOrder*/, int /*tag*/)
 {
-    CCASSERT(0, "ParallaxNode: use addChild:z:parallaxRatio:positionOffset instead");
+    CCASSERT(0,"ParallaxNode: use addChild:z:parallaxRatio:positionOffset instead");
 }
 
-void ParallaxNode::addChild(Node*, int, const std::string&)
+void ParallaxNode::addChild(Node* /*child*/, int /*zOrder*/, const std::string& /*name*/)
 {
-    CCASSERT(0, "ParallaxNode: use addChild:z:parallaxRatio:positionOffset instead");
+    CCASSERT(0,"ParallaxNode: use addChild:z:parallaxRatio:positionOffset instead");
 }
 
-void ParallaxNode::addChild(Node* child, int z, const Vec2& ratio, const Vec2& offset)
+void ParallaxNode::addChild(Node *child, int z, const Vec2& ratio, const Vec2& offset)
 {
-    CCASSERT(child != nullptr, "Argument must be non-nil");
-    PointObject* obj = PointObject::create(ratio, offset);
+    CCASSERT( child != nullptr, "Argument must be non-nil");
+    PointObject *obj = PointObject::create(ratio, offset);
     obj->setChild(child);
-    ccArrayAppendObjectWithResize(_parallaxArray, static_cast<Ref*>(obj));
+    ccArrayAppendObjectWithResize(_parallaxArray, (Ref*)obj);
 
     Vec2 pos = this->absolutePosition();
     pos.x = -pos.x + pos.x * ratio.x + offset.x;
@@ -127,9 +113,9 @@ void ParallaxNode::addChild(Node* child, int z, const Vec2& ratio, const Vec2& o
 
 void ParallaxNode::removeChild(Node* child, bool cleanup)
 {
-    for (std::size_t i = 0; i < _parallaxArray->num; i++)
+    for( int i=0;i < _parallaxArray->num;i++)
     {
-        PointObject* point = static_cast<PointObject*>(_parallaxArray->arr[i]);
+        PointObject *point = (PointObject*)_parallaxArray->arr[i];
         if (point->getChild() == child)
         {
             ccArrayRemoveObjectAtIndex(_parallaxArray, i, true);
@@ -148,7 +134,7 @@ void ParallaxNode::removeAllChildrenWithCleanup(bool cleanup)
 Vec2 ParallaxNode::absolutePosition()
 {
     Vec2 ret = _position;
-    Node* cn = this;
+    Node *cn = this;
     while (cn->getParent() != nullptr)
     {
         cn = cn->getParent();
@@ -162,19 +148,19 @@ The positions are updated at visit because:
 - using a timer is not guaranteed that it will called after all the positions were updated
 - overriding "draw" will only precise if the children have a z > 0
 */
-void ParallaxNode::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void ParallaxNode::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     //    Vec2 pos = position_;
     //    Vec2    pos = [self convertToWorldSpace:Vec2::ZERO];
     Vec2 pos = this->absolutePosition();
-    if (!pos.equals(_lastPosition))
+    if( ! pos.equals(_lastPosition) )
     {
-        for (std::size_t i = 0; i < _parallaxArray->num; i++)
+        for( int i=0; i < _parallaxArray->num; i++ ) 
         {
-            PointObject* point = static_cast<PointObject*>(_parallaxArray->arr[i]);
+            PointObject *point = (PointObject*)_parallaxArray->arr[i];
             float x = -pos.x + pos.x * point->getRatio().x + point->getOffset().x;
-            float y = -pos.y + pos.y * point->getRatio().y + point->getOffset().y;
-            point->getChild()->setPosition(x, y);
+            float y = -pos.y + pos.y * point->getRatio().y + point->getOffset().y;            
+            point->getChild()->setPosition(x,y);
         }
         _lastPosition = pos;
     }
diff --git a/cocos2d/cocos/2d/CCParallaxNode.h b/cocos2d/cocos/2d/CCParallaxNode.h
index 694f743a9f..54b781a920 100644
--- a/cocos2d/cocos/2d/CCParallaxNode.h
+++ b/cocos2d/cocos/2d/CCParallaxNode.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,22 +25,15 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_PARALLAXNODE_H
-#define CC_2D_PARALLAXNODE_H
+#ifndef __CCPARALLAX_NODE_H__
+#define __CCPARALLAX_NODE_H__
 
 #include <cocos/2d/CCNode.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <cstdint>
-#include <iosfwd>
+/*#include "ccArray.h"*/
 
 NS_CC_BEGIN
 
-class Renderer;
+struct _ccArray;
 
 /**
  * @addtogroup _2d
@@ -55,11 +49,11 @@ The children will be moved faster / slower than the parent according the paralla
 class CC_DLL ParallaxNode : public Node
 {
 public:
-    /** Create a Parallax node.
+    /** Create a Parallax node. 
      *
      * @return An autoreleased ParallaxNode object.
      */
-    static ParallaxNode* create();
+    static ParallaxNode * create();
 
     // prevents compiler warning: "Included function hides overloaded virtual functions"
     using Node::addChild;
@@ -71,13 +65,13 @@ public:
      * @param parallaxRatio A given parallax ratio.
      * @param positionOffset A given position offset.
      */
-    void addChild(Node* child, int z, const Vec2& parallaxRatio, const Vec2& positionOffset);
+    void addChild(Node * child, int z, const Vec2& parallaxRatio, const Vec2& positionOffset);
 
     /** Sets an array of layers for the Parallax node.
      *
      * @param parallaxArray An array of layers for the Parallax node.
      */
-    void setParallaxArray(struct _ccArray* parallaxArray) { _parallaxArray = parallaxArray; }
+    void setParallaxArray( struct _ccArray *parallaxArray) { _parallaxArray = parallaxArray; }
     /** Returns the array of layers of the Parallax node.
      *
      * @return An array of layers for the Parallax node.
@@ -88,33 +82,33 @@ public:
     //
     // Overrides
     //
-    void addChild(Node* child, int zOrder, int tag) override;
-    void addChild(Node* child, int zOrder, const std::string& name) override;
-    void removeChild(Node* child, bool cleanup) override;
-    void removeAllChildrenWithCleanup(bool cleanup) override;
-    void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /** Adds a child to the container with a z-order, a parallax ratio and a position offset
-         It returns self, so you can chain several addChilds.
-         @since v0.8
-         * @js ctor
-         */
-        ParallaxNode();
+    virtual void addChild(Node * child, int zOrder, int tag) override;
+    virtual void addChild(Node * child, int zOrder, const std::string &name) override;
+    virtual void removeChild(Node* child, bool cleanup) override;
+    virtual void removeAllChildrenWithCleanup(bool cleanup) override;
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
+
+CC_CONSTRUCTOR_ACCESS:
+    /** Adds a child to the container with a z-order, a parallax ratio and a position offset
+     It returns self, so you can chain several addChilds.
+     @since v0.8
+     * @js ctor
+     */
+    ParallaxNode();
     /**
      * @js NA
      * @lua NA
      */
-    ~ParallaxNode() override;
+    virtual ~ParallaxNode();
 
 protected:
     Vec2 absolutePosition();
 
-    Vec2 _lastPosition;
+    Vec2    _lastPosition;
     struct _ccArray* _parallaxArray;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParallaxNode)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParallaxNode);
 };
 
 // end of _2d group
@@ -122,4 +116,6 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_PARALLAXNODE_H
+#endif //__CCPARALLAX_NODE_H__
+
+
diff --git a/cocos2d/cocos/2d/CCParticleBatchNode.cpp b/cocos2d/cocos/2d/CCParticleBatchNode.cpp
index 624dfa31db..e9b1cb67db 100644
--- a/cocos2d/cocos/2d/CCParticleBatchNode.cpp
+++ b/cocos2d/cocos/2d/CCParticleBatchNode.cpp
@@ -5,6 +5,7 @@
  * Copyright (c) 2011      Zynga Inc.
  * Copyright (c) 2011      Marco Tillemans
  * Copyright (c) 2013-2016 Chukong Technologies Inc.
+ * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
  *
  * http://www.cocos2d-x.org
  *
@@ -27,47 +28,65 @@
  * THE SOFTWARE.
  *
  */
-
 #include <cocos/2d/CCParticleBatchNode.h>
-
-#include <cocos/2d/CCNode.h>
+#include <cocos/2d/CCGrid.h>
 #include <cocos/2d/CCParticleSystem.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCBatchCommand.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
+#include <cocos/renderer/CCTextureCache.h>
+#include <cocos/renderer/CCQuadCommand.h>
 #include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTexture2D.h>
 #include <cocos/renderer/CCTextureAtlas.h>
-#include <cocos/renderer/CCTextureCache.h>
-
-#include <new>
+#include <cocos/base/CCProfiling.h>
+#include <cocos/base/ccUTF8.h>
+#include <cocos/base/ccUtils.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 
 ParticleBatchNode::ParticleBatchNode()
-: _textureAtlas(nullptr)
 {
+    auto& pipelineDescriptor = _customCommand.getPipelineDescriptor();
+    _programState = new (std::nothrow) backend::ProgramState(positionTextureColor_vert, positionTextureColor_frag);
+    pipelineDescriptor.programState = _programState;
+    _mvpMatrixLocaiton = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    _textureLocation = pipelineDescriptor.programState->getUniformLocation("u_texture");
+    
+    auto layout = _programState->getVertexLayout();
+    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
+    {
+        layout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT3, 0, false);
+    }
+    iter = attributeInfo.find("a_texCoord");
+    if(iter != attributeInfo.end())
+    {
+        layout->setAttribute("a_texCoord", iter->second.location, backend::VertexFormat::FLOAT2, offsetof(V3F_C4B_T2F, texCoords), false);
+    }
+    iter = attributeInfo.find("a_color");
+    if(iter != attributeInfo.end())
+    {
+        layout->setAttribute("a_color", iter->second.location, backend::VertexFormat::UBYTE4, offsetof(V3F_C4B_T2F, colors), true);
+    }
+    layout->setLayout(sizeof(V3F_C4B_T2F));
+
+    _customCommand.setDrawType(CustomCommand::DrawType::ELEMENT);
+    _customCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE);
 }
 
 ParticleBatchNode::~ParticleBatchNode()
 {
     CC_SAFE_RELEASE(_textureAtlas);
+    CC_SAFE_RELEASE(_programState);
 }
 /*
  * creation with Texture2D
  */
 
-ParticleBatchNode* ParticleBatchNode::createWithTexture(Texture2D* tex, int capacity /* = kParticleDefaultCapacity*/)
+ParticleBatchNode* ParticleBatchNode::createWithTexture(Texture2D *tex, int capacity/* = kParticleDefaultCapacity*/)
 {
-    ParticleBatchNode* p = new (std::nothrow) ParticleBatchNode();
-    if (p && p->initWithTexture(tex, capacity))
+    ParticleBatchNode * p = new (std::nothrow) ParticleBatchNode();
+    if( p && p->initWithTexture(tex, capacity))
     {
         p->autorelease();
         return p;
@@ -80,10 +99,10 @@ ParticleBatchNode* ParticleBatchNode::createWithTexture(Texture2D* tex, int capa
  * creation with File Image
  */
 
-ParticleBatchNode* ParticleBatchNode::create(const std::string& imageFile, int capacity /* = kParticleDefaultCapacity*/)
+ParticleBatchNode* ParticleBatchNode::create(const std::string& imageFile, int capacity/* = kParticleDefaultCapacity*/)
 {
-    ParticleBatchNode* p = new (std::nothrow) ParticleBatchNode();
-    if (p && p->initWithFile(imageFile, capacity))
+    ParticleBatchNode * p = new (std::nothrow) ParticleBatchNode();
+    if( p && p->initWithFile(imageFile, capacity))
     {
         p->autorelease();
         return p;
@@ -95,17 +114,15 @@ ParticleBatchNode* ParticleBatchNode::create(const std::string& imageFile, int c
 /*
  * init with Texture2D
  */
-bool ParticleBatchNode::initWithTexture(Texture2D* tex, int capacity)
+bool ParticleBatchNode::initWithTexture(Texture2D *tex, int capacity)
 {
     _textureAtlas = new (std::nothrow) TextureAtlas();
     _textureAtlas->initWithTexture(tex, capacity);
 
     _children.reserve(capacity);
-
+    
     _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
 
-    setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR, tex));
-
     return true;
 }
 
@@ -114,7 +131,7 @@ bool ParticleBatchNode::initWithTexture(Texture2D* tex, int capacity)
  */
 bool ParticleBatchNode::initWithFile(const std::string& fileImage, int capacity)
 {
-    Texture2D* tex = Director::getInstance()->getTextureCache()->addImage(fileImage);
+    Texture2D *tex = Director::getInstance()->getTextureCache()->addImage(fileImage);
     return initWithTexture(tex, capacity);
 }
 
@@ -122,7 +139,7 @@ bool ParticleBatchNode::initWithFile(const std::string& fileImage, int capacity)
 
 // override visit.
 // Don't call visit on it's children
-void ParticleBatchNode::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void ParticleBatchNode::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     // CAREFUL:
     // This visit is almost identical to Node#visit
@@ -140,73 +157,72 @@ void ParticleBatchNode::visit(Renderer* renderer, const Mat4& parentTransform, u
 
     if (isVisitableByVisitingCamera())
     {
-        // IMPORTANT:
+        // IMPORTANT:d
         // To ease the migration to v3.0, we still support the Mat4 stack,
         // but it is deprecated and your code should not rely on it
         Director* director = Director::getInstance();
         director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
         director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform);
-
+        
         draw(renderer, _modelViewTransform, flags);
-
+        
         director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
     }
 }
 
 // override addChild:
-void ParticleBatchNode::addChild(Node* aChild, int zOrder, int tag)
+void ParticleBatchNode::addChild(Node * aChild, int zOrder, int tag)
 {
-    CCASSERT(aChild != nullptr, "Argument must be non-nullptr");
-    CCASSERT(dynamic_cast<ParticleSystem*>(aChild) != nullptr, "CCParticleBatchNode only supports QuadParticleSystems as children");
+    CCASSERT( aChild != nullptr, "Argument must be non-nullptr");
+    CCASSERT( dynamic_cast<ParticleSystem*>(aChild) != nullptr, "CCParticleBatchNode only supports QuadParticleSystems as children");
     ParticleSystem* child = static_cast<ParticleSystem*>(aChild);
-    CCASSERT(child->getTexture()->getName() == _textureAtlas->getTexture()->getName(), "CCParticleSystem is not using the same texture id");
-
+    CCASSERT( child->getTexture()->getBackendTexture() == _textureAtlas->getTexture()->getBackendTexture(), "CCParticleSystem is not using the same texture id");
+    
     addChildByTagOrName(child, zOrder, tag, "", true);
 }
 
-void ParticleBatchNode::addChild(Node* aChild, int zOrder, const std::string& name)
+void ParticleBatchNode::addChild(Node * aChild, int zOrder, const std::string &name)
 {
-    CCASSERT(aChild != nullptr, "Argument must be non-nullptr");
-    CCASSERT(dynamic_cast<ParticleSystem*>(aChild) != nullptr, "CCParticleBatchNode only supports QuadParticleSystems as children");
+    CCASSERT( aChild != nullptr, "Argument must be non-nullptr");
+    CCASSERT( dynamic_cast<ParticleSystem*>(aChild) != nullptr, "CCParticleBatchNode only supports QuadParticleSystems as children");
     ParticleSystem* child = static_cast<ParticleSystem*>(aChild);
-    CCASSERT(child->getTexture()->getName() == _textureAtlas->getTexture()->getName(), "CCParticleSystem is not using the same texture id");
-
+    CCASSERT( child->getTexture()->getBackendTexture() == _textureAtlas->getTexture()->getBackendTexture(), "CCParticleSystem is not using the same texture id");
+   
     addChildByTagOrName(child, zOrder, 0, name, false);
 }
 
-void ParticleBatchNode::addChildByTagOrName(ParticleSystem* child, int zOrder, int tag, const std::string& name, bool setTag)
+void ParticleBatchNode::addChildByTagOrName(ParticleSystem* child, int zOrder, int tag, const std::string &name, bool setTag)
 {
     // If this is the 1st children, then copy blending function
     if (_children.empty())
     {
         setBlendFunc(child->getBlendFunc());
     }
-
-    CCASSERT(_blendFunc.src == child->getBlendFunc().src && _blendFunc.dst == child->getBlendFunc().dst,
-             "Can't add a ParticleSystem that uses a different blending function");
-
-    // no lazy sorting, so don't call super addChild, call helper instead
+    
+    CCASSERT( _blendFunc.src  == child->getBlendFunc().src && _blendFunc.dst  == child->getBlendFunc().dst, "Can't add a ParticleSystem that uses a different blending function");
+    
+    //no lazy sorting, so don't call super addChild, call helper instead
     int pos = 0;
     if (setTag)
         pos = addChildHelper(child, zOrder, tag, "", true);
     else
         pos = addChildHelper(child, zOrder, 0, name, false);
-
-    // get new atlasIndex
+    
+    //get new atlasIndex
     int atlasIndex = 0;
-
+    
     if (pos != 0)
     {
-        ParticleSystem* p = static_cast<ParticleSystem*>(_children.at(pos - 1));
+        ParticleSystem* p = static_cast<ParticleSystem*>(_children.at(pos-1));
         atlasIndex = p->getAtlasIndex() + p->getTotalParticles();
     }
     else
     {
         atlasIndex = 0;
     }
-
+    
     insertChild(child, atlasIndex);
-
+    
     // update quad info
     child->setBatchNode(this);
 }
@@ -215,14 +231,14 @@ void ParticleBatchNode::addChildByTagOrName(ParticleSystem* child, int zOrder, i
 // FIXME: research whether lazy sorting + freeing current quads and calloc a new block with size of capacity would be faster
 // FIXME: or possibly using vertexZ for reordering, that would be fastest
 // this helper is almost equivalent to Node's addChild, but doesn't make use of the lazy sorting
-int ParticleBatchNode::addChildHelper(ParticleSystem* child, int z, int aTag, const std::string& name, bool setTag)
+int ParticleBatchNode::addChildHelper(ParticleSystem* child, int z, int aTag, const std::string &name, bool setTag)
 {
-    CCASSERT(child != nullptr, "Argument must be non-nil");
-    CCASSERT(child->getParent() == nullptr, "child already added. It can't be added again");
+    CCASSERT( child != nullptr, "Argument must be non-nil");
+    CCASSERT( child->getParent() == nullptr, "child already added. It can't be added again");
 
     _children.reserve(4);
 
-    // don't use a lazy insert
+    //don't use a lazy insert
     auto pos = searchNewPositionInChildrenForZ(z);
 
     _children.insert(pos, child);
@@ -231,12 +247,12 @@ int ParticleBatchNode::addChildHelper(ParticleSystem* child, int z, int aTag, co
         child->setTag(aTag);
     else
         child->setName(name);
-
+    
     child->setLocalZOrder(z);
 
     child->setParent(this);
 
-    if (_running)
+    if( _running )
     {
         child->onEnter();
         child->onEnterTransitionDidFinish();
@@ -245,15 +261,15 @@ int ParticleBatchNode::addChildHelper(ParticleSystem* child, int z, int aTag, co
 }
 
 // Reorder will be done in this function, no "lazy" reorder to particles
-void ParticleBatchNode::reorderChild(Node* aChild, int zOrder)
+void ParticleBatchNode::reorderChild(Node * aChild, int zOrder)
 {
-    CCASSERT(aChild != nullptr, "Child must be non-nullptr");
-    CCASSERT(dynamic_cast<ParticleSystem*>(aChild) != nullptr, "CCParticleBatchNode only supports QuadParticleSystems as children");
-    CCASSERT(_children.contains(aChild), "Child doesn't belong to batch");
+    CCASSERT( aChild != nullptr, "Child must be non-nullptr");
+    CCASSERT( dynamic_cast<ParticleSystem*>(aChild) != nullptr, "CCParticleBatchNode only supports QuadParticleSystems as children");
+    CCASSERT( _children.contains(aChild), "Child doesn't belong to batch" );
 
     ParticleSystem* child = static_cast<ParticleSystem*>(aChild);
 
-    if (zOrder == child->getLocalZOrder())
+    if( zOrder == child->getLocalZOrder() )
     {
         return;
     }
@@ -265,8 +281,9 @@ void ParticleBatchNode::reorderChild(Node* aChild, int zOrder)
 
         getCurrentIndex(&oldIndex, &newIndex, child, zOrder);
 
-        if (oldIndex != newIndex)
+        if( oldIndex != newIndex )
         {
+
             // reorder _children->array
             child->retain();
             _children.erase(oldIndex);
@@ -280,11 +297,11 @@ void ParticleBatchNode::reorderChild(Node* aChild, int zOrder)
             updateAllAtlasIndexes();
 
             // Find new AtlasIndex
-            std::size_t newAtlasIndex = 0;
-            for (std::size_t i = 0; i < _children.size(); i++)
+            int newAtlasIndex = 0;
+            for (const auto& iter : _children)
             {
-                ParticleSystem* node = static_cast<ParticleSystem*>(_children.at(i));
-                if (node == child)
+                auto node = static_cast<ParticleSystem*>(iter);
+                if( node == child )
                 {
                     newAtlasIndex = child->getAtlasIndex();
                     break;
@@ -306,44 +323,45 @@ void ParticleBatchNode::getCurrentIndex(int* oldIndex, int* newIndex, Node* chil
     bool foundCurrentIdx = false;
     bool foundNewIdx = false;
 
-    int minusOne = 0;
-    auto count = static_cast<int>(_children.size());
+    int  minusOne = 0;
+    auto count = _children.size();
 
-    for (int i = 0; i < count; i++)
+    for( int i=0; i < count; i++ )
     {
         Node* pNode = _children.at(i);
 
         // new index
-        if (pNode->getLocalZOrder() > z && !foundNewIdx)
+        if( pNode->getLocalZOrder() > z &&  ! foundNewIdx )
         {
             *newIndex = i;
             foundNewIdx = true;
 
-            if (foundCurrentIdx && foundNewIdx)
+            if( foundCurrentIdx && foundNewIdx )
             {
                 break;
             }
         }
 
         // current index
-        if (child == pNode)
+        if( child == pNode )
         {
             *oldIndex = i;
             foundCurrentIdx = true;
 
-            if (!foundNewIdx)
+            if( ! foundNewIdx )
             {
                 minusOne = -1;
             }
 
-            if (foundCurrentIdx && foundNewIdx)
+            if( foundCurrentIdx && foundNewIdx )
             {
                 break;
             }
         }
+
     }
 
-    if (!foundNewIdx)
+    if( ! foundNewIdx )
     {
         *newIndex = static_cast<int>(count);
     }
@@ -353,11 +371,11 @@ void ParticleBatchNode::getCurrentIndex(int* oldIndex, int* newIndex, Node* chil
 
 int ParticleBatchNode::searchNewPositionInChildrenForZ(int z)
 {
-    auto count = static_cast<int>(_children.size());
+    auto count = _children.size();
 
-    for (int i = 0; i < count; i++)
+    for( int i=0; i < count; i++ )
     {
-        Node* child = _children.at(i);
+        Node *child = _children.at(i);
         if (child->getLocalZOrder() > z)
         {
             return i;
@@ -367,13 +385,13 @@ int ParticleBatchNode::searchNewPositionInChildrenForZ(int z)
 }
 
 // override removeChild:
-void ParticleBatchNode::removeChild(Node* aChild, bool cleanup)
+void  ParticleBatchNode::removeChild(Node* aChild, bool cleanup)
 {
     // explicit nil handling
     if (aChild == nullptr)
         return;
 
-    CCASSERT(dynamic_cast<ParticleSystem*>(aChild) != nullptr, "CCParticleBatchNode only supports QuadParticleSystems as children");
+    CCASSERT( dynamic_cast<ParticleSystem*>(aChild) != nullptr, "CCParticleBatchNode only supports QuadParticleSystems as children");
     CCASSERT(_children.contains(aChild), "CCParticleBatchNode doesn't contain the sprite. Can't remove it");
 
     ParticleSystem* child = static_cast<ParticleSystem*>(aChild);
@@ -398,7 +416,7 @@ void ParticleBatchNode::removeChildAtIndex(int index, bool doCleanup)
 
 void ParticleBatchNode::removeAllChildrenWithCleanup(bool doCleanup)
 {
-    for (const auto& child : _children)
+    for(const auto &child : _children)
         static_cast<ParticleSystem*>(child)->setBatchNode(nullptr);
 
     Node::removeAllChildrenWithCleanup(doCleanup);
@@ -406,38 +424,58 @@ void ParticleBatchNode::removeAllChildrenWithCleanup(bool doCleanup)
     _textureAtlas->removeAllQuads();
 }
 
-void ParticleBatchNode::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void ParticleBatchNode::draw(Renderer* renderer, const Mat4 & transform, uint32_t flags)
 {
     CC_PROFILER_START("CCParticleBatchNode - draw");
 
-    if (_textureAtlas->getTotalQuads() == 0)
-    {
+    if( _textureAtlas->getTotalQuads() == 0 )
         return;
+    
+    _customCommand.init(_globalZOrder, _blendFunc);
+    
+    // Texture is set in TextureAtlas.
+    const cocos2d::Mat4& projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    Mat4 finalMat = projectionMat * transform;
+    auto programState = _customCommand.getPipelineDescriptor().programState;
+    programState->setUniform(_mvpMatrixLocaiton, finalMat.m, sizeof(finalMat.m));
+    programState->setTexture(_textureLocation, 0, _textureAtlas->getTexture()->getBackendTexture());
+
+    if (_textureAtlas->isDirty())
+    {
+        const auto& quads = _textureAtlas->getQuads();
+        unsigned int capacity = (unsigned int)_textureAtlas->getCapacity();
+        const auto& indices = _textureAtlas->getIndices();
+        
+        _customCommand.createVertexBuffer((unsigned int)(sizeof(quads[0]) ), capacity, CustomCommand::BufferUsage::STATIC);
+        _customCommand.updateVertexBuffer(quads, sizeof(quads[0]) * capacity);
+        
+        _customCommand.createIndexBuffer(CustomCommand::IndexFormat::U_SHORT , capacity * 6, CustomCommand::BufferUsage::STATIC);
+        _customCommand.updateIndexBuffer(indices, sizeof(indices[0]) * capacity * 6);
     }
-    _batchCommand.init(_globalZOrder, getGLProgram(), _blendFunc, _textureAtlas, _modelViewTransform, flags);
-    renderer->addCommand(&_batchCommand);
+        
+    renderer->addCommand(&_customCommand);
+    
     CC_PROFILER_STOP("CCParticleBatchNode - draw");
 }
 
-void ParticleBatchNode::increaseAtlasCapacityTo(std::size_t quantity)
+void ParticleBatchNode::increaseAtlasCapacityTo(ssize_t quantity)
 {
-    CCLOG("cocos2d: ParticleBatchNode: resizing TextureAtlas capacity from [%lu] to [%lu].", static_cast<long>(_textureAtlas->getCapacity()),
-          static_cast<long>(quantity));
+    CCLOG("cocos2d: ParticleBatchNode: resizing TextureAtlas capacity from [%lu] to [%lu].",
+          (long)_textureAtlas->getCapacity(),
+          (long)quantity);
 
-    if (!_textureAtlas->resizeCapacity(quantity))
-    {
+    if( ! _textureAtlas->resizeCapacity(quantity) ) {
         // serious problems
         CCLOGWARN("cocos2d: WARNING: Not enough memory to resize the atlas");
-        CCASSERT(false, "XXX: ParticleBatchNode #increaseAtlasCapacity SHALL handle this assert");
+        CCASSERT(false,"XXX: ParticleBatchNode #increaseAtlasCapacity SHALL handle this assert");
     }
 }
 
-// sets a 0'd quad into the quads array
+//sets a 0'd quad into the quads array
 void ParticleBatchNode::disableParticle(int particleIndex)
 {
     V3F_C4B_T2F_Quad* quad = &((_textureAtlas->getQuads())[particleIndex]);
-    quad->br.vertices.x = quad->br.vertices.y = quad->tr.vertices.x = quad->tr.vertices.y = quad->tl.vertices.x = quad->tl.vertices.y = quad->bl.vertices.x =
-        quad->bl.vertices.y = 0.0f;
+    quad->br.vertices.x = quad->br.vertices.y = quad->tr.vertices.x = quad->tr.vertices.y = quad->tl.vertices.x = quad->tl.vertices.y = quad->bl.vertices.x = quad->bl.vertices.y = 0.0f;
 }
 
 // ParticleBatchNode - add / remove / reorder helper methods
@@ -447,7 +485,7 @@ void ParticleBatchNode::insertChild(ParticleSystem* system, int index)
 {
     system->setAtlasIndex(index);
 
-    if (_textureAtlas->getTotalQuads() + system->getTotalParticles() > _textureAtlas->getCapacity())
+    if(_textureAtlas->getTotalQuads() + system->getTotalParticles() > _textureAtlas->getCapacity())
     {
         increaseAtlasCapacityTo(_textureAtlas->getTotalQuads() + system->getTotalParticles());
 
@@ -456,9 +494,9 @@ void ParticleBatchNode::insertChild(ParticleSystem* system, int index)
     }
 
     // make room for quads, not necessary for last child
-    if ((system->getAtlasIndex() + system->getTotalParticles()) != static_cast<int>(_textureAtlas->getTotalQuads()))
+    if (system->getAtlasIndex() + system->getTotalParticles() != _textureAtlas->getTotalQuads())
     {
-        _textureAtlas->moveQuadsFromIndex(index, index + system->getTotalParticles());
+        _textureAtlas->moveQuadsFromIndex(index, index+system->getTotalParticles());
     }
 
     // increase totalParticles here for new particles, update method of particle-system will fill the quads
@@ -467,13 +505,12 @@ void ParticleBatchNode::insertChild(ParticleSystem* system, int index)
     updateAllAtlasIndexes();
 }
 
-// rebuild atlas indexes
+//rebuild atlas indexes
 void ParticleBatchNode::updateAllAtlasIndexes()
 {
     int index = 0;
-
-    for (const auto& child : _children)
-    {
+    
+    for(const auto &child : _children) {
         ParticleSystem* partiSys = static_cast<ParticleSystem*>(child);
         partiSys->setAtlasIndex(index);
         index += partiSys->getTotalParticles();
@@ -484,7 +521,7 @@ void ParticleBatchNode::updateAllAtlasIndexes()
 
 void ParticleBatchNode::updateBlendFunc()
 {
-    if (!_textureAtlas->getTexture()->hasPremultipliedAlpha())
+    if( ! _textureAtlas->getTexture()->hasPremultipliedAlpha())
         _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
 }
 
@@ -493,7 +530,7 @@ void ParticleBatchNode::setTexture(Texture2D* texture)
     _textureAtlas->setTexture(texture);
 
     // If the new texture has No premultiplied alpha, AND the blendFunc hasn't been changed, then update it
-    if (texture && !texture->hasPremultipliedAlpha() && (_blendFunc.src == CC_BLEND_SRC && _blendFunc.dst == CC_BLEND_DST))
+    if( texture && ! texture->hasPremultipliedAlpha() && ( _blendFunc.src == CC_BLEND_SRC && _blendFunc.dst == CC_BLEND_DST ) )
     {
         _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
     }
@@ -504,7 +541,7 @@ Texture2D* ParticleBatchNode::getTexture() const
     return _textureAtlas->getTexture();
 }
 
-void ParticleBatchNode::setBlendFunc(const BlendFunc& blendFunc)
+void ParticleBatchNode::setBlendFunc(const BlendFunc &blendFunc)
 {
     _blendFunc = blendFunc;
 }
diff --git a/cocos2d/cocos/2d/CCParticleBatchNode.h b/cocos2d/cocos/2d/CCParticleBatchNode.h
index 0b37891722..ff2adde6f5 100644
--- a/cocos2d/cocos/2d/CCParticleBatchNode.h
+++ b/cocos2d/cocos/2d/CCParticleBatchNode.h
@@ -5,6 +5,7 @@
  * Copyright (c) 2011      Zynga Inc.
  * Copyright (c) 2011      Marco Tillemans
  * Copyright (c) 2013-2016 Chukong Technologies Inc.
+ * Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
  *
  * http://www.cocos2d-x.org
  *
@@ -27,28 +28,17 @@
  * THE SOFTWARE.
  *
  */
-#ifndef CC_2D_PARTICLEBATCHNODE_H
-#define CC_2D_PARTICLEBATCHNODE_H
+#pragma once
 
 #include <cocos/2d/CCNode.h>
 #include <cocos/base/CCProtocols.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCBatchCommand.h>
-
-#include <cstddef>
-#include <cstdint>
-#include <iosfwd>
+#include <cocos/renderer/CCCustomCommand.h>
 
 NS_CC_BEGIN
 
-class ParticleSystem;
-class Renderer;
 class Texture2D;
 class TextureAtlas;
+class ParticleSystem;
 
 /**
  * @addtogroup _2d
@@ -87,7 +77,7 @@ public:
      * @return An autoreleased ParticleBatchNode object.
      * @js NA
      */
-    static ParticleBatchNode* createWithTexture(Texture2D* tex, int capacity = kParticleDefaultCapacity);
+    static ParticleBatchNode* createWithTexture(Texture2D *tex, int capacity = kParticleDefaultCapacity);
 
     /** Create the particle system with the name of a file on disk (for a list of supported formats look at the Texture2D class), a capacity of particles.
      *
@@ -123,75 +113,77 @@ public:
      * @return The texture atlas used for drawing the quads.
      */
     TextureAtlas* getTextureAtlas() const { return _textureAtlas; }
-
+    
     /** Sets the texture atlas used for drawing the quads.
      *
      * @param atlas The texture atlas used for drawing the quads.
      */
     void setTextureAtlas(TextureAtlas* atlas) { _textureAtlas = atlas; }
-
+    
     // Overrides
-    virtual void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
 
     using Node::addChild;
-    virtual void addChild(Node* child, int zOrder, int tag) override;
-    virtual void addChild(Node* child, int zOrder, const std::string& name) override;
+    virtual void addChild(Node * child, int zOrder, int tag) override;
+    virtual void addChild(Node * child, int zOrder, const std::string &name) override;
     virtual void removeChild(Node* child, bool cleanup) override;
-    virtual void reorderChild(Node* child, int zOrder) override;
-    virtual void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
-    virtual Texture2D* getTexture(void) const override;
-    virtual void setTexture(Texture2D* texture) override;
+    virtual void reorderChild(Node * child, int zOrder) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
+    virtual Texture2D* getTexture() const override;
+    virtual void setTexture(Texture2D *texture) override;
     /**
-     * @code
-     * When this function bound into js or lua,the parameter will be changed
-     * In js: var setBlendFunc(var src, var dst)
-     * @endcode
-     * @lua NA
-     */
-    virtual void setBlendFunc(const BlendFunc& blendFunc) override;
+    * @code
+    * When this function bound into js or lua,the parameter will be changed
+    * In js: var setBlendFunc(var src, var dst)
+    * @endcode
+    * @lua NA
+    */
+    virtual void setBlendFunc(const BlendFunc &blendFunc) override;
     /**
-     * @js NA
-     * @lua NA
+    * @js NA
+    * @lua NA
+    */
+    virtual const BlendFunc& getBlendFunc() const override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
      */
-    virtual const BlendFunc& getBlendFunc(void) const override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleBatchNode();
+    ParticleBatchNode();
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleBatchNode() override;
-
+    virtual ~ParticleBatchNode();
+    
     /** initializes the particle system with Texture2D, a capacity of particles */
-    bool initWithTexture(Texture2D* tex, int capacity);
-
+    bool initWithTexture(Texture2D *tex, int capacity);
+    
     /** initializes the particle system with the name of a file on disk (for a list of supported formats look at the Texture2D class), a capacity of particles */
     bool initWithFile(const std::string& fileImage, int capacity);
-
+    
 private:
     void updateAllAtlasIndexes();
-    void increaseAtlasCapacityTo(std::size_t quantity);
+    void increaseAtlasCapacityTo(ssize_t quantity);
     int searchNewPositionInChildrenForZ(int z);
     void getCurrentIndex(int* oldIndex, int* newIndex, Node* child, int z);
-    int addChildHelper(ParticleSystem* child, int z, int aTag, const std::string& name, bool setTag);
-    void addChildByTagOrName(ParticleSystem* child, int z, int tag, const std::string& name, bool setTag);
-    void updateBlendFunc(void);
+    int addChildHelper(ParticleSystem* child, int z, int aTag, const std::string &name, bool setTag);
+    void addChildByTagOrName(ParticleSystem* child, int z, int tag, const std::string &name, bool setTag);
+    void updateBlendFunc();
     /** the texture atlas used for drawing the quads */
-    TextureAtlas* _textureAtlas;
+    TextureAtlas* _textureAtlas = nullptr;
 
     /** the blend function used for drawing the quads */
     BlendFunc _blendFunc;
-    // quad command
-    BatchCommand _batchCommand;
+    
+    CustomCommand _customCommand;
+    
+    backend::UniformLocation _mvpMatrixLocaiton;
+    backend::UniformLocation _textureLocation;
+    backend::ProgramState* _programState = nullptr;
 };
 
 // end of _2d group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_PARTICLEBATCHNODE_H
diff --git a/cocos2d/cocos/2d/CCParticleExamples.cpp b/cocos2d/cocos/2d/CCParticleExamples.cpp
index 22050aed88..2eb058f0b7 100644
--- a/cocos2d/cocos/2d/CCParticleExamples.cpp
+++ b/cocos2d/cocos/2d/CCParticleExamples.cpp
@@ -3,7 +3,8 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -26,27 +27,10 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCParticleExamples.h>
-
-#include <cocos/2d/CCParticleSystem.h>
-#include <cocos/2d/CCParticleSystemQuad.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/ccTypes.h>
 #include <cocos/base/firePngData.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCImage.h>
-#include <cocos/platform/CCPlatformMacros.h>
 #include <cocos/renderer/CCTextureCache.h>
 
-#include <chrono>
-#include <iosfwd>
-#include <new>
-
-namespace cocos2d
-{
-    class Texture2D;
-}
-
 using namespace std::chrono_literals;
 
 NS_CC_BEGIN
@@ -58,17 +42,16 @@ static Texture2D* getDefaultTexture()
 {
     Texture2D* texture = nullptr;
     Image* image = nullptr;
-    do
+    do 
     {
-        bool ret = false;
         const std::string key = "/__firePngData";
         texture = Director::getInstance()->getTextureCache()->getTextureForKey(key);
-        CC_BREAK_IF(texture != nullptr);
+        CC_SAFE_DELETE_ARRAY(texture != nullptr);;
 
         image = new (std::nothrow) Image();
-        CC_BREAK_IF(nullptr == image);
-        ret = image->initWithImageData(__firePngData, sizeof(__firePngData));
-        CC_BREAK_IF(!ret);
+        CC_SAFE_DELETE_ARRAY(nullptr == image);;
+        bool ret = image->initWithImageData(__firePngData, sizeof(__firePngData));
+        CC_SAFE_DELETE_ARRAY(!ret);;
 
         texture = Director::getInstance()->getTextureCache()->addImage(image, key);
     } while (0);
@@ -108,10 +91,10 @@ ParticleFire* ParticleFire::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleFire::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) )
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         // Gravity Mode
         this->_emitterMode = Mode::GRAVITY;
@@ -125,7 +108,7 @@ bool ParticleFire::initWithTotalParticles(int numberOfParticles)
 
         // Gravity Mode: speed of particles
         this->modeA.speed = 60;
-        this->modeA.speedVar = 20;
+        this->modeA.speedVar = 20;        
 
         // starting angle
         _angle = 90;
@@ -133,20 +116,21 @@ bool ParticleFire::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2.0f, 60.0f);
+        this->setPosition(winSize.width/2.0f, 60.0f);
         this->_posVar.set(40.0f, 20.0f);
 
         // life of particles
         _life = 3;
         _lifeVar = 0.25f;
 
+
         // size, in pixels
         _startSize = 54.0f;
         _startSizeVar = 10.0f;
         _endSize = START_SIZE_EQUAL_TO_END_SIZE;
 
         // emits per frame
-        _emissionRate = _totalParticles / _life;
+        _emissionRate = _totalParticles/_life;
 
         // color of particles
         _startColor.r = 0.76f;
@@ -171,7 +155,7 @@ bool ParticleFire::initWithTotalParticles(int numberOfParticles)
         {
             setTexture(texture);
         }
-
+        
         // additive
         this->setBlendAdditive(true);
         return true;
@@ -212,10 +196,10 @@ ParticleFireworks* ParticleFireworks::createWithTotalParticles(int numberOfParti
 
 bool ParticleFireworks::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) )
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration= std::chrono::milliseconds{DURATION_INFINITY};
 
         // Gravity Mode
         this->_emitterMode = Mode::GRAVITY;
@@ -233,10 +217,10 @@ bool ParticleFireworks::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height / 2);
+        this->setPosition(winSize.width/2, winSize.height/2);
 
         // angle
-        this->_angle = 90.0f;
+        this->_angle= 90.0f;
         this->_angleVar = 20.0f;
 
         // life of particles
@@ -244,7 +228,7 @@ bool ParticleFireworks::initWithTotalParticles(int numberOfParticles)
         this->_lifeVar = 1.0f;
 
         // emits per frame
-        this->_emissionRate = _totalParticles / _life;
+        this->_emissionRate = _totalParticles/_life;
 
         // color of particles
         _startColor.r = 0.5f;
@@ -313,19 +297,19 @@ ParticleSun* ParticleSun::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleSun::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) )
     {
         // additive
         this->setBlendAdditive(true);
 
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         // Gravity Mode
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(0, 0));
+        setGravity(Vec2(0,0));
 
         // Gravity mode: radial acceleration
         setRadialAccel(0);
@@ -335,13 +319,14 @@ bool ParticleSun::initWithTotalParticles(int numberOfParticles)
         setSpeed(20);
         setSpeedVar(5);
 
+
         // angle
         _angle = 90;
         _angleVar = 360;
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height / 2);
+        this->setPosition(winSize.width/2, winSize.height/2);
         setPosVar(Vec2::ZERO);
 
         // life of particles
@@ -354,7 +339,7 @@ bool ParticleSun::initWithTotalParticles(int numberOfParticles)
         _endSize = START_SIZE_EQUAL_TO_END_SIZE;
 
         // emits per seconds
-        _emissionRate = _totalParticles / _life;
+        _emissionRate = _totalParticles/_life;
 
         // color of particles
         _startColor.r = 0.76f;
@@ -419,16 +404,16 @@ ParticleGalaxy* ParticleGalaxy::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleGalaxy::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) )
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         // Gravity Mode
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(0, 0));
+        setGravity(Vec2(0,0));
 
         // Gravity Mode: speed of particles
         setSpeed(60);
@@ -448,7 +433,7 @@ bool ParticleGalaxy::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height / 2);
+        this->setPosition(winSize.width/2, winSize.height/2);
         setPosVar(Vec2::ZERO);
 
         // life of particles
@@ -461,7 +446,7 @@ bool ParticleGalaxy::initWithTotalParticles(int numberOfParticles)
         _endSize = START_SIZE_EQUAL_TO_END_SIZE;
 
         // emits per second
-        _emissionRate = _totalParticles / _life;
+        _emissionRate = _totalParticles/_life;
 
         // color of particles
         _startColor.r = 0.12f;
@@ -528,16 +513,16 @@ ParticleFlower* ParticleFlower::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleFlower::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) )
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         // Gravity Mode
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(0, 0));
+        setGravity(Vec2(0,0));
 
         // Gravity Mode: speed of particles
         setSpeed(80);
@@ -557,7 +542,7 @@ bool ParticleFlower::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height / 2);
+        this->setPosition(winSize.width/2, winSize.height/2);
         setPosVar(Vec2::ZERO);
 
         // life of particles
@@ -570,7 +555,7 @@ bool ParticleFlower::initWithTotalParticles(int numberOfParticles)
         _endSize = START_SIZE_EQUAL_TO_END_SIZE;
 
         // emits per second
-        _emissionRate = _totalParticles / _life;
+        _emissionRate = _totalParticles/_life;
 
         // color of particles
         _startColor.r = 0.50f;
@@ -606,9 +591,9 @@ bool ParticleFlower::initWithTotalParticles(int numberOfParticles)
 // ParticleMeteor
 //
 
-ParticleMeteor* ParticleMeteor::create()
+ParticleMeteor * ParticleMeteor::create()
 {
-    ParticleMeteor* ret = new (std::nothrow) ParticleMeteor();
+    ParticleMeteor *ret = new (std::nothrow) ParticleMeteor();
     if (ret && ret->init())
     {
         ret->autorelease();
@@ -636,16 +621,16 @@ ParticleMeteor* ParticleMeteor::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleMeteor::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) )
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         // Gravity Mode
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(-200, 200));
+        setGravity(Vec2(-200,200));
 
         // Gravity Mode: speed of particles
         setSpeed(15);
@@ -665,7 +650,7 @@ bool ParticleMeteor::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height / 2);
+        this->setPosition(winSize.width/2, winSize.height/2);
         setPosVar(Vec2::ZERO);
 
         // life of particles
@@ -678,7 +663,7 @@ bool ParticleMeteor::initWithTotalParticles(int numberOfParticles)
         _endSize = START_SIZE_EQUAL_TO_END_SIZE;
 
         // emits per second
-        _emissionRate = _totalParticles / _life;
+        _emissionRate = _totalParticles/_life;
 
         // color of particles
         _startColor.r = 0.2f;
@@ -745,16 +730,16 @@ ParticleSpiral* ParticleSpiral::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleSpiral::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) ) 
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         // Gravity Mode
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(0, 0));
+        setGravity(Vec2(0,0));
 
         // Gravity Mode: speed of particles
         setSpeed(150);
@@ -774,7 +759,7 @@ bool ParticleSpiral::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height / 2);
+        this->setPosition(winSize.width/2, winSize.height/2);
         setPosVar(Vec2::ZERO);
 
         // life of particles
@@ -787,7 +772,7 @@ bool ParticleSpiral::initWithTotalParticles(int numberOfParticles)
         _endSize = START_SIZE_EQUAL_TO_END_SIZE;
 
         // emits per second
-        _emissionRate = _totalParticles / _life;
+        _emissionRate = _totalParticles/_life;
 
         // color of particles
         _startColor.r = 0.5f;
@@ -854,7 +839,7 @@ ParticleExplosion* ParticleExplosion::createWithTotalParticles(int numberOfParti
 
 bool ParticleExplosion::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) ) 
     {
         // duration
         _duration = 100ms;
@@ -862,7 +847,7 @@ bool ParticleExplosion::initWithTotalParticles(int numberOfParticles)
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(0, 0));
+        setGravity(Vec2(0,0));
 
         // Gravity Mode: speed of particles
         setSpeed(70);
@@ -882,7 +867,7 @@ bool ParticleExplosion::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height / 2);
+        this->setPosition(winSize.width/2, winSize.height/2);
         setPosVar(Vec2::ZERO);
 
         // life of particles
@@ -895,7 +880,7 @@ bool ParticleExplosion::initWithTotalParticles(int numberOfParticles)
         _endSize = START_SIZE_EQUAL_TO_END_SIZE;
 
         // emits per second
-        _emissionRate = static_cast<float>(_totalParticles) / (static_cast<float>(_duration.count()) / 1000.f);
+        _emissionRate = _totalParticles * 1000.0f /_duration.count();
 
         // color of particles
         _startColor.r = 0.7f;
@@ -962,16 +947,16 @@ ParticleSmoke* ParticleSmoke::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleSmoke::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) )
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         // Emitter mode: Gravity Mode
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(0, 0));
+        setGravity(Vec2(0,0));
 
         // Gravity Mode: radial acceleration
         setRadialAccel(0);
@@ -987,7 +972,7 @@ bool ParticleSmoke::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, 0);
+        this->setPosition(winSize.width/2, 0);
         setPosVar(Vec2(20, 0));
 
         // life of particles
@@ -1000,7 +985,7 @@ bool ParticleSmoke::initWithTotalParticles(int numberOfParticles)
         _endSize = START_SIZE_EQUAL_TO_END_SIZE;
 
         // emits per frame
-        _emissionRate = _totalParticles / _life;
+        _emissionRate = _totalParticles/_life;
 
         // color of particles
         _startColor.r = 0.8f;
@@ -1067,16 +1052,16 @@ ParticleSnow* ParticleSnow::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleSnow::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) ) 
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         // set gravity mode.
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(0, -1));
+        setGravity(Vec2(0,-1));
 
         // Gravity Mode: speed of particles
         setSpeed(5);
@@ -1092,8 +1077,8 @@ bool ParticleSnow::initWithTotalParticles(int numberOfParticles)
 
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height + 10);
-        setPosVar(Vec2(winSize.width / 2, 0));
+        this->setPosition(winSize.width/2, winSize.height + 10);
+        setPosVar(Vec2(winSize.width/2, 0.0f));
 
         // angle
         _angle = -90;
@@ -1175,15 +1160,15 @@ ParticleRain* ParticleRain::createWithTotalParticles(int numberOfParticles)
 
 bool ParticleRain::initWithTotalParticles(int numberOfParticles)
 {
-    if (ParticleSystemQuad::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystemQuad::initWithTotalParticles(numberOfParticles) )
     {
         // duration
-        _duration = std::chrono::milliseconds::max();
+        _duration = std::chrono::milliseconds{DURATION_INFINITY};
 
         setEmitterMode(Mode::GRAVITY);
 
         // Gravity Mode: gravity
-        setGravity(Vec2(10, -10));
+        setGravity(Vec2(10,-10));
 
         // Gravity Mode: radial
         setRadialAccel(0);
@@ -1201,10 +1186,11 @@ bool ParticleRain::initWithTotalParticles(int numberOfParticles)
         _angle = -90;
         _angleVar = 5;
 
+
         // emitter position
         Size winSize = Director::getInstance()->getWinSize();
-        this->setPosition(winSize.width / 2, winSize.height);
-        setPosVar(Vec2(winSize.width / 2, 0));
+        this->setPosition(winSize.width/2, winSize.height);
+        setPosVar(Vec2(winSize.width/2, 0.0f));
 
         // life of particles
         _life = 4.5f;
diff --git a/cocos2d/cocos/2d/CCParticleExamples.h b/cocos2d/cocos/2d/CCParticleExamples.h
index 9feab3fd26..27a4cd22ea 100644
--- a/cocos2d/cocos/2d/CCParticleExamples.h
+++ b/cocos2d/cocos/2d/CCParticleExamples.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,13 +25,10 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_PARTICLEEXAMPLE_H
-#define CC_2D_PARTICLEEXAMPLE_H
+#ifndef __CCPARTICLE_EXAMPLE_H__
+#define __CCPARTICLE_EXAMPLE_H__
 
 #include <cocos/2d/CCParticleSystemQuad.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 
 NS_CC_BEGIN
 
@@ -57,25 +55,23 @@ public:
      * @js NA
      */
     static ParticleFire* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleFire()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleFire(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleFire() override {}
+    virtual ~ParticleFire(){}
 
     bool init() override { return initWithTotalParticles(250); }
     virtual bool initWithTotalParticles(int numberOfParticles) override;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleFire)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleFire);
 };
 
 /** @class ParticleFireworks
@@ -96,25 +92,24 @@ public:
      * @js NA
      */
     static ParticleFireworks* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleFireworks()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleFireworks(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleFireworks() override {}
+    virtual ~ParticleFireworks(){}
 
-    bool init() override { return initWithTotalParticles(1500); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(1500); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleFireworks)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleFireworks);
+
 };
 
 /** @class ParticleSun
@@ -135,25 +130,24 @@ public:
      * @js NA
      */
     static ParticleSun* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleSun()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleSun(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleSun() override {}
+    virtual ~ParticleSun(){}
 
-    bool init() override { return initWithTotalParticles(350); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(350); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSun)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSun);
+
 };
 
 /** @class ParticleGalaxy
@@ -174,25 +168,24 @@ public:
      * @js NA
      */
     static ParticleGalaxy* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleGalaxy()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleGalaxy(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleGalaxy() override {}
+    virtual ~ParticleGalaxy(){}
 
-    bool init() override { return initWithTotalParticles(200); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(200); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleGalaxy)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleGalaxy);
+
 };
 
 /** @class ParticleFlower
@@ -213,25 +206,23 @@ public:
      * @js NA
      */
     static ParticleFlower* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleFlower()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleFlower(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleFlower() override {}
+    virtual ~ParticleFlower(){}
 
-    bool init() override { return initWithTotalParticles(250); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(250); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleFlower)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleFlower);
 };
 
 /** @class ParticleMeteor
@@ -244,7 +235,7 @@ public:
      *
      * @return An autoreleased ParticleMeteor object.
      */
-    static ParticleMeteor* create();
+    static ParticleMeteor * create();
     /** Create a meteor particle system withe a fixed number of particles.
      *
      * @param numberOfParticles A given number of particles.
@@ -252,25 +243,23 @@ public:
      * @js NA
      */
     static ParticleMeteor* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleMeteor()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleMeteor(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleMeteor() override {}
+    virtual ~ParticleMeteor(){}
 
-    bool init() override { return initWithTotalParticles(150); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(150); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleMeteor)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleMeteor);
 };
 
 /** @class ParticleSpiral
@@ -291,25 +280,24 @@ public:
      * @js NA
      */
     static ParticleSpiral* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleSpiral()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleSpiral(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleSpiral() override {}
+    virtual ~ParticleSpiral(){}
 
-    bool init() override { return initWithTotalParticles(500); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(500); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSpiral)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSpiral);
+
 };
 
 /** @class ParticleExplosion
@@ -330,25 +318,23 @@ public:
      * @js NA
      */
     static ParticleExplosion* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleExplosion()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleExplosion(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleExplosion() override {}
+    virtual ~ParticleExplosion(){}
 
-    bool init() override { return initWithTotalParticles(700); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(700); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleExplosion)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleExplosion);
 };
 
 /** @class ParticleSmoke
@@ -369,25 +355,23 @@ public:
      * @js NA
      */
     static ParticleSmoke* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleSmoke()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleSmoke(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleSmoke() override {}
+    virtual ~ParticleSmoke(){}
 
-    bool init() override { return initWithTotalParticles(200); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(200); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSmoke)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSmoke);
 };
 
 /** @class ParticleSnow
@@ -408,25 +392,23 @@ public:
      * @js NA
      */
     static ParticleSnow* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleSnow()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleSnow(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleSnow() override {}
+    virtual ~ParticleSnow(){}
 
-    bool init() override { return initWithTotalParticles(700); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(700); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSnow)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSnow);
 };
 
 /** @class ParticleRain
@@ -447,25 +429,23 @@ public:
      * @js NA
      */
     static ParticleRain* createWithTotalParticles(int numberOfParticles);
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleRain()
-    {
-    }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleRain(){}
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleRain() override {}
+    virtual ~ParticleRain(){}
 
-    bool init() override { return initWithTotalParticles(1000); }
-    bool initWithTotalParticles(int numberOfParticles) override;
+    bool init(){ return initWithTotalParticles(1000); }
+    virtual bool initWithTotalParticles(int numberOfParticles);
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleRain)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleRain);
 };
 
 // end of _2d group
@@ -473,4 +453,4 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_PARTICLEEXAMPLE_H
+#endif //__CCPARTICLE_EXAMPLE_H__
diff --git a/cocos2d/cocos/2d/CCParticleSystem.cpp b/cocos2d/cocos/2d/CCParticleSystem.cpp
index 3c228c30fe..ae289943fd 100644
--- a/cocos2d/cocos/2d/CCParticleSystem.cpp
+++ b/cocos2d/cocos/2d/CCParticleSystem.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -39,42 +40,25 @@ THE SOFTWARE.
 //
 // IMPORTANT: Particle Designer is supported by cocos2d, but
 // 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guaranteed in cocos2d,
-//  cocos2d uses a another approach, but the results are almost identical.
+//  cocos2d uses a another approach, but the results are almost identical. 
 //
 
 #include <cocos/2d/CCParticleSystem.h>
 
-#include <cocos/2d/CCNode.h>
+#include <string>
+
 #include <cocos/2d/CCParticleBatchNode.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/ZipUtils.h>
+#include <cocos/renderer/CCTextureAtlas.h>
 #include <cocos/base/base64.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/CCMathBase.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCFileUtils.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCImage.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCTexture2D.h>
+#include <cocos/base/ZipUtils.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/base/CCProfiling.h>
+#include <cocos/base/ccUTF8.h>
+#include <cocos/base/ccUtils.h>
 #include <cocos/renderer/CCTextureCache.h>
-
-#include <algorithm>
-#include <cmath>
-#include <cstdint>
-#include <cstdlib>
-#include <cstring>
-#include <limits>
-#include <new>
-#include <string>
-#include <type_traits>
-#include <unordered_map>
+#include <cocos/platform/CCFileUtils.h>
 
 using namespace std;
-using namespace std::chrono_literals;
 
 NS_CC_BEGIN
 
@@ -92,21 +76,22 @@ NS_CC_BEGIN
 //
 // IMPORTANT: Particle Designer is supported by cocos2d, but
 // 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guaranteed in cocos2d,
-//  cocos2d uses a another approach, but the results are almost identical.
+//  cocos2d uses a another approach, but the results are almost identical. 
 //
 
-inline void nomalize_point(float x, float y, particle_point* out)
+
+inline void normalize_point(float x, float y, particle_point* out)
 {
     float n = x * x + y * y;
     // Already normalized.
     if (n == 1.0f)
         return;
-
+    
     n = sqrt(n);
     // Too close to zero.
     if (n < MATH_TOLERANCE)
         return;
-
+    
     n = 1.0f / n;
     out->x = x * n;
     out->y = y * n;
@@ -115,15 +100,13 @@ inline void nomalize_point(float x, float y, particle_point* out)
 /**
  A more effect random number getter function, get from ejoy2d.
  */
-inline static float RANDOM_M11(unsigned int* seed)
-{
-    *seed = static_cast<std::uint32_t>(static_cast<std::uint64_t>(*seed) * 134775813 + 1);
-    union
-    {
-        uint32_t d;
+inline static float RANDOM_M11(unsigned int *seed) {
+    *seed = *seed * 134775813 + 1;
+    union {
+        uint32_t d;                                     
         float f;
     } u;
-    u.d = ((static_cast<uint32_t>(*seed) & 0x7fff) << 8) | 0x40000000;
+    u.d = (((uint32_t)(*seed) & 0x7fff) << 8) | 0x40000000;
     return u.f - 3.0f;
 }
 
@@ -135,72 +118,77 @@ ParticleData::ParticleData()
 bool ParticleData::init(int count)
 {
     maxCount = count;
-
-    posx = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    posy = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    startPosX = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    startPosY = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    colorR = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    colorG = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    colorB = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    colorA = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    deltaColorR = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    deltaColorG = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    deltaColorB = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    deltaColorA = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    size = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    deltaSize = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    rotation = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    deltaRotation = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    timeToLive = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    atlasIndex = reinterpret_cast<unsigned int*>(malloc(count * sizeof(unsigned int)));
-
-    modeA.dirX = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    modeA.dirY = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    modeA.radialAccel = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    modeA.tangentialAccel = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-
-    modeB.angle = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    modeB.degreesPerSecond = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    modeB.deltaRadius = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-    modeB.radius = reinterpret_cast<float*>(malloc(count * sizeof(float)));
-
-    return posx && posy && startPosY && startPosX && colorR && colorG && colorB && colorA && deltaColorR && deltaColorG && deltaColorB && deltaColorA && size &&
-        deltaSize && rotation && deltaRotation && timeToLive && atlasIndex && modeA.dirX && modeA.dirY && modeA.radialAccel && modeA.tangentialAccel &&
-        modeB.angle && modeB.degreesPerSecond && modeB.deltaRadius && modeB.radius;
+    
+    posx= (float*)malloc(count * sizeof(float));
+    posy= (float*)malloc(count * sizeof(float));
+    startPosX= (float*)malloc(count * sizeof(float));
+    startPosY= (float*)malloc(count * sizeof(float));
+    colorR= (float*)malloc(count * sizeof(float));
+    colorG= (float*)malloc(count * sizeof(float));
+    colorB= (float*)malloc(count * sizeof(float));
+    colorA= (float*)malloc(count * sizeof(float));
+    deltaColorR= (float*)malloc(count * sizeof(float));
+    deltaColorG= (float*)malloc(count * sizeof(float));
+    deltaColorB= (float*)malloc(count * sizeof(float));
+    deltaColorA= (float*)malloc(count * sizeof(float));
+    size= (float*)malloc(count * sizeof(float));
+    deltaSize= (float*)malloc(count * sizeof(float));
+    rotation= (float*)malloc(count * sizeof(float));
+    deltaRotation= (float*)malloc(count * sizeof(float));
+    timeToLive= (float*)malloc(count * sizeof(float));
+    atlasIndex= (unsigned int*)malloc(count * sizeof(unsigned int));
+    
+    modeA.dirX= (float*)malloc(count * sizeof(float));
+    modeA.dirY= (float*)malloc(count * sizeof(float));
+    modeA.radialAccel= (float*)malloc(count * sizeof(float));
+    modeA.tangentialAccel= (float*)malloc(count * sizeof(float));
+    
+    modeB.angle= (float*)malloc(count * sizeof(float));
+    modeB.degreesPerSecond= (float*)malloc(count * sizeof(float));
+    modeB.deltaRadius= (float*)malloc(count * sizeof(float));
+    modeB.radius= (float*)malloc(count * sizeof(float));
+    
+    return posx && posy && startPosY && startPosX && colorR && colorG && colorB && colorA &&
+    deltaColorR && deltaColorG && deltaColorB && deltaColorA && size && deltaSize &&
+    rotation && deltaRotation && timeToLive && atlasIndex && modeA.dirX && modeA.dirY &&
+    modeA.radialAccel && modeA.tangentialAccel && modeB.angle && modeB.degreesPerSecond &&
+    modeB.deltaRadius && modeB.radius;
 }
 
 void ParticleData::release()
 {
-    CC_SAFE_FREE(posx);
-    CC_SAFE_FREE(posy);
-    CC_SAFE_FREE(startPosX);
-    CC_SAFE_FREE(startPosY);
-    CC_SAFE_FREE(colorR);
-    CC_SAFE_FREE(colorG);
-    CC_SAFE_FREE(colorB);
-    CC_SAFE_FREE(colorA);
-    CC_SAFE_FREE(deltaColorR);
-    CC_SAFE_FREE(deltaColorG);
-    CC_SAFE_FREE(deltaColorB);
-    CC_SAFE_FREE(deltaColorA);
-    CC_SAFE_FREE(size);
-    CC_SAFE_FREE(deltaSize);
-    CC_SAFE_FREE(rotation);
-    CC_SAFE_FREE(deltaRotation);
-    CC_SAFE_FREE(timeToLive);
-    CC_SAFE_FREE(atlasIndex);
-
-    CC_SAFE_FREE(modeA.dirX);
-    CC_SAFE_FREE(modeA.dirY);
-    CC_SAFE_FREE(modeA.radialAccel);
-    CC_SAFE_FREE(modeA.tangentialAccel);
-
-    CC_SAFE_FREE(modeB.angle);
-    CC_SAFE_FREE(modeB.degreesPerSecond);
-    CC_SAFE_FREE(modeB.deltaRadius);
-    CC_SAFE_FREE(modeB.radius);
-}
+    CC_SAFE_DELETE_ARRAY(posx);;
+    CC_SAFE_DELETE_ARRAY(posy);;
+    CC_SAFE_DELETE_ARRAY(startPosX);;
+    CC_SAFE_DELETE_ARRAY(startPosY);;
+    CC_SAFE_DELETE_ARRAY(colorR);;
+    CC_SAFE_DELETE_ARRAY(colorG);;
+    CC_SAFE_DELETE_ARRAY(colorB);;
+    CC_SAFE_DELETE_ARRAY(colorA);;
+    CC_SAFE_DELETE_ARRAY(deltaColorR);;
+    CC_SAFE_DELETE_ARRAY(deltaColorG);;
+    CC_SAFE_DELETE_ARRAY(deltaColorB);;
+    CC_SAFE_DELETE_ARRAY(deltaColorA);;
+    CC_SAFE_DELETE_ARRAY(size);;
+    CC_SAFE_DELETE_ARRAY(deltaSize);;
+    CC_SAFE_DELETE_ARRAY(rotation);;
+    CC_SAFE_DELETE_ARRAY(deltaRotation);;
+    CC_SAFE_DELETE_ARRAY(timeToLive);;
+    CC_SAFE_DELETE_ARRAY(atlasIndex);;
+    
+    CC_SAFE_DELETE_ARRAY(modeA.dirX);;
+    CC_SAFE_DELETE_ARRAY(modeA.dirY);;
+    CC_SAFE_DELETE_ARRAY(modeA.radialAccel);;
+    CC_SAFE_DELETE_ARRAY(modeA.tangentialAccel);;
+    
+    CC_SAFE_DELETE_ARRAY(modeB.angle);;
+    CC_SAFE_DELETE_ARRAY(modeB.degreesPerSecond);;
+    CC_SAFE_DELETE_ARRAY(modeB.deltaRadius);;
+    CC_SAFE_DELETE_ARRAY(modeB.radius);;
+}
+
+Vector<ParticleSystem*> ParticleSystem::__allInstances;
+float ParticleSystem::__totalParticleCountFactor = 1.0f;
 
 ParticleSystem::ParticleSystem()
 : _isBlendAdditive(false)
@@ -215,7 +203,7 @@ ParticleSystem::ParticleSystem()
 , _allocatedParticles(0)
 , _isActive(true)
 , _particleCount(0)
-, _duration(0ms)
+, _duration(0)
 , _life(0)
 , _lifeVar(0)
 , _angle(0)
@@ -236,8 +224,8 @@ ParticleSystem::ParticleSystem()
 , _opacityModifyRGB(false)
 , _yCoordFlipped(1)
 , _positionType(PositionType::FREE)
-, _bUseSrcPosOnly(false)
 , _paused(false)
+, _sourcePositionCompatible(true) // In the furture this member's default value maybe false or be removed.
 {
     modeA.gravity.setZero();
     modeA.speed = 0;
@@ -250,15 +238,15 @@ ParticleSystem::ParticleSystem()
     modeB.startRadius = 0;
     modeB.startRadiusVar = 0;
     modeB.endRadius = 0;
-    modeB.endRadiusVar = 0;
+    modeB.endRadiusVar = 0;            
     modeB.rotatePerSecond = 0;
     modeB.rotatePerSecondVar = 0;
 }
 // implementation ParticleSystem
 
-ParticleSystem* ParticleSystem::create(const std::string& plistFile)
+ParticleSystem * ParticleSystem::create(const std::string& plistFile)
 {
-    ParticleSystem* ret = new (std::nothrow) ParticleSystem();
+    ParticleSystem *ret = new (std::nothrow) ParticleSystem();
     if (ret && ret->initWithFile(plistFile))
     {
         ret->autorelease();
@@ -270,7 +258,7 @@ ParticleSystem* ParticleSystem::create(const std::string& plistFile)
 
 ParticleSystem* ParticleSystem::createWithTotalParticles(int numberOfParticles)
 {
-    ParticleSystem* ret = new (std::nothrow) ParticleSystem();
+    ParticleSystem *ret = new (std::nothrow) ParticleSystem();
     if (ret && ret->initWithTotalParticles(numberOfParticles))
     {
         ret->autorelease();
@@ -280,6 +268,17 @@ ParticleSystem* ParticleSystem::createWithTotalParticles(int numberOfParticles)
     return ret;
 }
 
+// static
+Vector<ParticleSystem*>& ParticleSystem::getAllParticleSystems()
+{
+    return __allInstances;
+}
+
+void ParticleSystem::setTotalParticleCountFactor(float factor)
+{
+    __totalParticleCountFactor = factor;
+}
+
 bool ParticleSystem::init()
 {
     return initWithTotalParticles(150);
@@ -291,8 +290,8 @@ bool ParticleSystem::initWithFile(const std::string& plistFile)
     _plistFile = FileUtils::getInstance()->fullPathForFilename(plistFile);
     ValueMap dict = FileUtils::getInstance()->getValueMapFromFile(_plistFile);
 
-    CCASSERT(!dict.empty(), "Particles: file not found");
-
+    CCASSERT( !dict.empty(), "Particles: file not found");
+    
     // FIXME: compute path from a path, should define a function somewhere to do it
     string listFilePath = plistFile;
     if (listFilePath.find('/') != string::npos)
@@ -304,7 +303,7 @@ bool ParticleSystem::initWithFile(const std::string& plistFile)
     {
         ret = this->initWithDictionary(dict, "");
     }
-
+    
     return ret;
 }
 
@@ -316,14 +315,14 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary)
 bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string& dirname)
 {
     bool ret = false;
-    unsigned char* buffer = nullptr;
-    unsigned char* deflated = nullptr;
-    Image* image = nullptr;
-    do
+    unsigned char *buffer = nullptr;
+    unsigned char *deflated = nullptr;
+    Image *image = nullptr;
+    do 
     {
         int maxParticles = dictionary["maxParticles"].asInt();
         // self, not super
-        if (this->initWithTotalParticles(maxParticles))
+        if(this->initWithTotalParticles(maxParticles))
         {
             // Emitter name in particle designer 2.0
             _configName = dictionary["configName"].asString();
@@ -333,26 +332,18 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
             _angleVar = dictionary["angleVariance"].asFloat();
 
             // duration
-            auto const duration = dictionary["duration"].asFloat();
-            if (std::abs(duration + 1.f) < std::numeric_limits<float>::epsilon())
-            {
-                _duration = std::chrono::milliseconds::max();
-            }
-            else
-            {
-                _duration = std::chrono::milliseconds(static_cast<std::size_t>(1000.f * duration));
-            }
+            _duration = std::chrono::milliseconds{static_cast<int>(dictionary["duration"].asFloat() * 1000.0f)};
 
-            // blend function
+            // blend function 
             if (!_configName.empty())
             {
-                _blendFunc.src = dictionary["blendFuncSource"].asFloat();
+                _blendFunc.src = ccutils::toBackendBlendFactor((int)dictionary["blendFuncSource"].asFloat());
             }
             else
             {
-                _blendFunc.src = dictionary["blendFuncSource"].asInt();
+                _blendFunc.src = ccutils::toBackendBlendFactor(dictionary["blendFuncSource"].asInt());
             }
-            _blendFunc.dst = dictionary["blendFuncDestination"].asInt();
+            _blendFunc.dst = ccutils::toBackendBlendFactor(dictionary["blendFuncDestination"].asInt());
 
             // color
             _startColor.r = dictionary["startColorRed"].asFloat();
@@ -384,17 +375,22 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
             // position
             float x = dictionary["sourcePositionx"].asFloat();
             float y = dictionary["sourcePositiony"].asFloat();
-            this->setPosition(x, y);
+	    if(!_sourcePositionCompatible) {
+                this->setSourcePosition(Vec2(x, y));
+	    }
+            else {
+		this->setPosition(Vec2(x, y));
+	    }
             _posVar.x = dictionary["sourcePositionVariancex"].asFloat();
             _posVar.y = dictionary["sourcePositionVariancey"].asFloat();
 
             // Spinning
             _startSpin = dictionary["rotationStart"].asFloat();
             _startSpinVar = dictionary["rotationStartVariance"].asFloat();
-            _endSpin = dictionary["rotationEnd"].asFloat();
-            _endSpinVar = dictionary["rotationEndVariance"].asFloat();
+            _endSpin= dictionary["rotationEnd"].asFloat();
+            _endSpinVar= dictionary["rotationEndVariance"].asFloat();
 
-            _emitterMode = static_cast<Mode>(dictionary["emitterType"].asInt());
+            _emitterMode = (Mode) dictionary["emitterType"].asInt();
 
             // Mode A: Gravity + tangential accel + radial accel
             if (_emitterMode == Mode::GRAVITY)
@@ -414,7 +410,7 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
                 // tangential acceleration
                 modeA.tangentialAccel = dictionary["tangentialAcceleration"].asFloat();
                 modeA.tangentialAccelVar = dictionary["tangentialAccelVariance"].asFloat();
-
+                
                 // rotation is dir
                 modeA.rotationIsDir = dictionary["rotationIsDir"].asBool();
             }
@@ -439,7 +435,7 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
                 {
                     modeB.endRadius = dictionary["minRadius"].asFloat();
                 }
-
+                
                 if (dictionary.find("minRadiusVariance") != dictionary.end())
                 {
                     modeB.endRadiusVar = dictionary["minRadiusVariance"].asFloat();
@@ -448,7 +444,7 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
                 {
                     modeB.endRadiusVar = 0.0f;
                 }
-
+                
                 if (!_configName.empty())
                 {
                     modeB.rotatePerSecond = dictionary["rotatePerSecond"].asInt();
@@ -458,11 +454,10 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
                     modeB.rotatePerSecond = dictionary["rotatePerSecond"].asFloat();
                 }
                 modeB.rotatePerSecondVar = dictionary["rotatePerSecondVariance"].asFloat();
-            }
-            else
-            {
-                CCASSERT(false, "Invalid emitterType in config file");
-                CC_BREAK_IF(true);
+
+            } else {
+                CCASSERT( false, "Invalid emitterType in config file");
+                CC_SAFE_DELETE_ARRAY(true);;
             }
 
             // life span
@@ -472,35 +467,35 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
             // emission Rate
             _emissionRate = _totalParticles / _life;
 
-            // don't get the internal texture if a batchNode is used
+            //don't get the internal texture if a batchNode is used
             if (!_batchNode)
             {
                 // Set a compatible default for the alpha transfer
                 _opacityModifyRGB = false;
 
-                // texture
+                // texture        
                 // Try to get the texture from the cache
                 std::string textureName = dictionary["textureFileName"].asString();
-
+                
                 size_t rPos = textureName.rfind('/');
-
+               
                 if (rPos != string::npos)
                 {
                     string textureDir = textureName.substr(0, rPos + 1);
-
+                    
                     if (!dirname.empty() && textureDir != dirname)
                     {
-                        textureName = textureName.substr(rPos + 1);
+                        textureName = textureName.substr(rPos+1);
                         textureName = dirname + textureName;
                     }
                 }
                 else if (!dirname.empty() && !textureName.empty())
                 {
-                    textureName = dirname + textureName;
+                	textureName = dirname + textureName;
                 }
-
-                Texture2D* tex = nullptr;
-
+                
+                Texture2D *tex = nullptr;
+                
                 if (!textureName.empty())
                 {
                     // set not pop-up message box when load image failed
@@ -510,44 +505,43 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
                     // reset the value of UIImage notify
                     FileUtils::getInstance()->setPopupNotify(notify);
                 }
-
+                
                 if (tex)
                 {
                     setTexture(tex);
                 }
-                else if (dictionary.find("textureImageData") != dictionary.end())
-                {
+                else if( dictionary.find("textureImageData") != dictionary.end() )
+                {                        
                     std::string textureData = dictionary.at("textureImageData").asString();
                     CCASSERT(!textureData.empty(), "textureData can't be empty!");
-
+                    
                     auto dataLen = textureData.size();
                     if (dataLen != 0)
                     {
-                        // if it fails, try to get it from the base64-gzipped data
-                        int decodeLen =
-                            base64Decode(reinterpret_cast<unsigned char*>(const_cast<char*>(textureData.c_str())), static_cast<unsigned int>(dataLen), &buffer);
-                        CCASSERT(buffer != nullptr, "CCParticleSystem: error decoding textureImageData");
-                        CC_BREAK_IF(!buffer);
-
-                        std::size_t deflatedLen = ZipUtils::inflateMemory(buffer, decodeLen, &deflated);
-                        CCASSERT(deflated != nullptr, "CCParticleSystem: error ungzipping textureImageData");
-                        CC_BREAK_IF(!deflated);
-
+                        // if it fails, try to get it from the base64-gzipped data    
+                        int decodeLen = base64Decode((unsigned char*)textureData.c_str(), (unsigned int)dataLen, &buffer);
+                        CCASSERT( buffer != nullptr, "CCParticleSystem: error decoding textureImageData");
+                        CC_SAFE_DELETE_ARRAY(!buffer);;
+                        
+                        ssize_t deflatedLen = ZipUtils::inflateMemory(buffer, decodeLen, &deflated);
+                        CCASSERT( deflated != nullptr, "CCParticleSystem: error ungzipping textureImageData");
+                        CC_SAFE_DELETE_ARRAY(!deflated);;
+                        
                         // For android, we should retain it in VolatileTexture::addImage which invoked in Director::getInstance()->getTextureCache()->addUIImage()
                         image = new (std::nothrow) Image();
                         bool isOK = image->initWithImageData(deflated, deflatedLen);
                         CCASSERT(isOK, "CCParticleSystem: error init image with Data");
-                        CC_BREAK_IF(!isOK);
-
+                        CC_SAFE_DELETE_ARRAY(!isOK);;
+                        
                         setTexture(Director::getInstance()->getTextureCache()->addImage(image, _plistFile + textureName));
 
                         image->release();
                     }
                 }
-
+                
                 _yCoordFlipped = dictionary.find("yCoordFlipped") == dictionary.end() ? 1 : dictionary.at("yCoordFlipped").asInt();
 
-                if (!this->_texture)
+                if( !this->_texture)
                     CCLOGWARN("cocos2d: Warning: ParticleSystemQuad system without a texture");
             }
             ret = true;
@@ -561,10 +555,10 @@ bool ParticleSystem::initWithDictionary(ValueMap& dictionary, const std::string&
 bool ParticleSystem::initWithTotalParticles(int numberOfParticles)
 {
     _totalParticles = numberOfParticles;
-
+    
     _particleData.release();
 
-    if (!_particleData.init(_totalParticles))
+    if( !_particleData.init(_totalParticles) )
     {
         CCLOG("Particle system: not enough memory");
         this->release();
@@ -598,9 +592,9 @@ bool ParticleSystem::initWithTotalParticles(int numberOfParticles)
     _isAutoRemoveOnFinish = false;
 
     // Optimization: compile updateParticle method
-    // updateParticleSel = @selector(updateQuadWithParticle:newPosition:);
-    // updateParticleImp = (CC_UPDATE_PARTICLE_IMP) [self methodForSelector:updateParticleSel];
-    // for batchNode
+    //updateParticleSel = @selector(updateQuadWithParticle:newPosition:);
+    //updateParticleImp = (CC_UPDATE_PARTICLE_IMP) [self methodForSelector:updateParticleSel];
+    //for batchNode
     _transformSystemDirty = false;
 
     return true;
@@ -609,8 +603,8 @@ bool ParticleSystem::initWithTotalParticles(int numberOfParticles)
 ParticleSystem::~ParticleSystem()
 {
     // Since the scheduler retains the "target (in this case the ParticleSystem)
-    // it is not needed to call "unscheduleUpdate" here. In fact, it will be called in "cleanup"
-    // unscheduleUpdate();
+	// it is not needed to call "unscheduleUpdate" here. In fact, it will be called in "cleanup"
+    //unscheduleUpdate();
     _particleData.release();
     CC_SAFE_RELEASE(_texture);
 }
@@ -623,60 +617,60 @@ void ParticleSystem::addParticles(int count)
 
     int start = _particleCount;
     _particleCount += count;
-
-    // life
-    for (int i = start; i < _particleCount; ++i)
+    
+    //life
+    for (int i = start; i < _particleCount ; ++i)
     {
         float theLife = _life + _lifeVar * RANDOM_M11(&RANDSEED);
         _particleData.timeToLive[i] = MAX(0, theLife);
     }
-
-    // position
+    
+    //position
     for (int i = start; i < _particleCount; ++i)
     {
         _particleData.posx[i] = _sourcePosition.x + _posVar.x * RANDOM_M11(&RANDSEED);
     }
-
+    
     for (int i = start; i < _particleCount; ++i)
     {
         _particleData.posy[i] = _sourcePosition.y + _posVar.y * RANDOM_M11(&RANDSEED);
     }
-
-    // color
-#define SET_COLOR(c, b, v)                                  \
-    for (int i = start; i < _particleCount; ++i)            \
-    {                                                       \
-        c[i] = clampf(b + v * RANDOM_M11(&RANDSEED), 0, 1); \
-    }
-
+    
+    //color
+#define SET_COLOR(c, b, v)\
+for (int i = start; i < _particleCount; ++i)\
+{\
+c[i] = clampf( b + v * RANDOM_M11(&RANDSEED) , 0 , 1 );\
+}
+    
     SET_COLOR(_particleData.colorR, _startColor.r, _startColorVar.r);
     SET_COLOR(_particleData.colorG, _startColor.g, _startColorVar.g);
     SET_COLOR(_particleData.colorB, _startColor.b, _startColorVar.b);
     SET_COLOR(_particleData.colorA, _startColor.a, _startColorVar.a);
-
+    
     SET_COLOR(_particleData.deltaColorR, _endColor.r, _endColorVar.r);
     SET_COLOR(_particleData.deltaColorG, _endColor.g, _endColorVar.g);
     SET_COLOR(_particleData.deltaColorB, _endColor.b, _endColorVar.b);
     SET_COLOR(_particleData.deltaColorA, _endColor.a, _endColorVar.a);
-
-#define SET_DELTA_COLOR(c, dc)                                \
-    for (int i = start; i < _particleCount; ++i)              \
-    {                                                         \
-        dc[i] = (dc[i] - c[i]) / _particleData.timeToLive[i]; \
-    }
-
+    
+#define SET_DELTA_COLOR(c, dc)\
+for (int i = start; i < _particleCount; ++i)\
+{\
+dc[i] = (dc[i] - c[i]) / _particleData.timeToLive[i];\
+}
+    
     SET_DELTA_COLOR(_particleData.colorR, _particleData.deltaColorR);
     SET_DELTA_COLOR(_particleData.colorG, _particleData.deltaColorG);
     SET_DELTA_COLOR(_particleData.colorB, _particleData.deltaColorB);
     SET_DELTA_COLOR(_particleData.colorA, _particleData.deltaColorA);
-
-    // size
+    
+    //size
     for (int i = start; i < _particleCount; ++i)
     {
         _particleData.size[i] = _startSize + _startSizeVar * RANDOM_M11(&RANDSEED);
         _particleData.size[i] = MAX(0, _particleData.size[i]);
     }
-
+    
     if (_endSize != START_SIZE_EQUAL_TO_END_SIZE)
     {
         for (int i = start; i < _particleCount; ++i)
@@ -693,7 +687,7 @@ void ParticleSystem::addParticles(int count)
             _particleData.deltaSize[i] = 0.0f;
         }
     }
-
+    
     // rotation
     for (int i = start; i < _particleCount; ++i)
     {
@@ -704,7 +698,7 @@ void ParticleSystem::addParticles(int count)
         float endA = _endSpin + _endSpinVar * RANDOM_M11(&RANDSEED);
         _particleData.deltaRotation[i] = (endA - _particleData.rotation[i]) / _particleData.timeToLive[i];
     }
-
+    
     // position
     Vec2 pos;
     if (_positionType == PositionType::FREE)
@@ -723,32 +717,33 @@ void ParticleSystem::addParticles(int count)
     {
         _particleData.startPosY[i] = pos.y;
     }
-
+    
     // Mode Gravity: A
     if (_emitterMode == Mode::GRAVITY)
     {
+        
         // radial accel
         for (int i = start; i < _particleCount; ++i)
         {
             _particleData.modeA.radialAccel[i] = modeA.radialAccel + modeA.radialAccelVar * RANDOM_M11(&RANDSEED);
         }
-
+        
         // tangential accel
         for (int i = start; i < _particleCount; ++i)
         {
             _particleData.modeA.tangentialAccel[i] = modeA.tangentialAccel + modeA.tangentialAccelVar * RANDOM_M11(&RANDSEED);
         }
-
+        
         // rotation is dir
-        if (modeA.rotationIsDir)
+        if( modeA.rotationIsDir )
         {
             for (int i = start; i < _particleCount; ++i)
             {
-                float a = CC_DEGREES_TO_RADIANS(_angle + _angleVar * RANDOM_M11(&RANDSEED));
-                Vec2 v(cosf(a), sinf(a));
+                float a = CC_DEGREES_TO_RADIANS( _angle + _angleVar * RANDOM_M11(&RANDSEED) );
+                Vec2 v(cosf( a ), sinf( a ));
                 float s = modeA.speed + modeA.speedVar * RANDOM_M11(&RANDSEED);
                 Vec2 dir = v * s;
-                _particleData.modeA.dirX[i] = dir.x; // v * s ;
+                _particleData.modeA.dirX[i] = dir.x;//v * s ;
                 _particleData.modeA.dirY[i] = dir.y;
                 _particleData.rotation[i] = -CC_RADIANS_TO_DEGREES(dir.getAngle());
             }
@@ -757,20 +752,21 @@ void ParticleSystem::addParticles(int count)
         {
             for (int i = start; i < _particleCount; ++i)
             {
-                float a = CC_DEGREES_TO_RADIANS(_angle + _angleVar * RANDOM_M11(&RANDSEED));
-                Vec2 v(cosf(a), sinf(a));
+                float a = CC_DEGREES_TO_RADIANS( _angle + _angleVar * RANDOM_M11(&RANDSEED) );
+                Vec2 v(cosf( a ), sinf( a ));
                 float s = modeA.speed + modeA.speedVar * RANDOM_M11(&RANDSEED);
                 Vec2 dir = v * s;
-                _particleData.modeA.dirX[i] = dir.x; // v * s ;
+                _particleData.modeA.dirX[i] = dir.x;//v * s ;
                 _particleData.modeA.dirY[i] = dir.y;
             }
         }
+        
     }
-
+    
     // Mode Radius: B
     else
     {
-        // Need to check by Jacky
+        //Need to check by Jacky
         // Set the default diameter of the particle from the source position
         for (int i = start; i < _particleCount; ++i)
         {
@@ -779,15 +775,15 @@ void ParticleSystem::addParticles(int count)
 
         for (int i = start; i < _particleCount; ++i)
         {
-            _particleData.modeB.angle[i] = CC_DEGREES_TO_RADIANS(_angle + _angleVar * RANDOM_M11(&RANDSEED));
+            _particleData.modeB.angle[i] = CC_DEGREES_TO_RADIANS( _angle + _angleVar * RANDOM_M11(&RANDSEED));
         }
-
+        
         for (int i = start; i < _particleCount; ++i)
         {
             _particleData.modeB.degreesPerSecond[i] = CC_DEGREES_TO_RADIANS(modeB.rotatePerSecond + modeB.rotatePerSecondVar * RANDOM_M11(&RANDSEED));
         }
-
-        if (modeB.endRadius == START_RADIUS_EQUAL_TO_END_RADIUS)
+        
+        if(modeB.endRadius == START_RADIUS_EQUAL_TO_END_RADIUS)
         {
             for (int i = start; i < _particleCount; ++i)
             {
@@ -814,11 +810,13 @@ void ParticleSystem::onEnter()
             return;
     }
 #endif
-
+    
     Node::onEnter();
-
+    
     // update after action in run!
     this->scheduleUpdateWithPriority(1);
+
+    __allInstances.pushBack(this);
 }
 
 void ParticleSystem::onExit()
@@ -830,9 +828,15 @@ void ParticleSystem::onExit()
             return;
     }
 #endif
-
+    
     this->unscheduleUpdate();
     Node::onExit();
+
+    auto iter = std::find(std::begin(__allInstances), std::end(__allInstances), this);
+    if (iter != std::end(__allInstances))
+    {
+        __allInstances.erase(iter);
+    }
 }
 
 void ParticleSystem::stopSystem()
@@ -860,48 +864,40 @@ bool ParticleSystem::isFull()
 // ParticleSystem - MainLoop
 void ParticleSystem::update(float dt)
 {
-    CC_PROFILER_START_CATEGORY(kProfilerCategoryParticles, "CCParticleSystem - update");
-
-    if (_positionType == PositionType::WORLD)
-    {
-        if (_particleCount == 0)
-        {
-            // startup or no particles
-            _currentTransforms = getNodeToWorldTransform();
-        }
-        _previousTransforms = _currentTransforms;
-        _currentTransforms = getNodeToWorldTransform();
-    }
+    CC_PROFILER_START_CATEGORY(kProfilerCategoryParticles , "CCParticleSystem - update");
 
     if (_isActive && _emissionRate)
     {
         float rate = 1.0f / _emissionRate;
-        // issue #1201, prevent bursts of particles, due to too high emitCounter
-        if (_particleCount < _totalParticles)
+        int totalParticles = static_cast<int>(_totalParticles * __totalParticleCountFactor);
+        
+        //issue #1201, prevent bursts of particles, due to too high emitCounter
+        if (_particleCount < totalParticles)
         {
             _emitCounter += dt;
             if (_emitCounter < 0.f)
                 _emitCounter = 0.f;
         }
-
-        int emitCount = MIN(_totalParticles - _particleCount, _emitCounter / rate);
+        
+        int emitCount = MIN(totalParticles - _particleCount, _emitCounter / rate);
         addParticles(emitCount);
-
         _emitCounter -= rate * emitCount;
-
-        _elapsed += std::chrono::milliseconds(static_cast<std::size_t>(1000.f * dt));
-        if (_duration != std::chrono::milliseconds::max() && _duration < _elapsed)
+        
+        _elapsed += std::chrono::milliseconds{static_cast<int>(1000.0f * dt)};
+        if (_elapsed < 0ms)
+            _elapsed = 0ms;
+        if (_duration != std::chrono::milliseconds{DURATION_INFINITY} && _duration < _elapsed)
         {
             this->stopSystem();
         }
     }
-
+    
     {
         for (int i = 0; i < _particleCount; ++i)
         {
             _particleData.timeToLive[i] -= dt;
         }
-
+        
         for (int i = 0; i < _particleCount; ++i)
         {
             if (_particleData.timeToLive[i] <= 0.0f)
@@ -915,15 +911,14 @@ void ParticleSystem::update(float dt)
                 _particleData.copyParticle(i, _particleCount - 1);
                 if (_batchNode)
                 {
-                    // disable the switched particle
+                    //disable the switched particle
                     int currentIndex = _particleData.atlasIndex[i];
                     _batchNode->disableParticle(_atlasIndex + currentIndex);
-                    // switch indexes
+                    //switch indexes
                     _particleData.atlasIndex[_particleCount - 1] = currentIndex;
                 }
                 --_particleCount;
-                if ((_particleCount == 0 && _isAutoRemoveOnFinish && _duration != std::chrono::milliseconds::max()) ||
-                    (_particleCount == 0 && _isAutoRemoveOnFinish && _duration == std::chrono::milliseconds::max() && !_isActive))
+                if( _particleCount == 0 && _isAutoRemoveOnFinish )
                 {
                     this->unscheduleUpdate();
                     _parent->removeChild(this, true);
@@ -931,39 +926,39 @@ void ParticleSystem::update(float dt)
                 }
             }
         }
-
+        
         if (_emitterMode == Mode::GRAVITY)
         {
-            for (int i = 0; i < _particleCount; ++i)
+            for (int i = 0 ; i < _particleCount; ++i)
             {
                 particle_point tmp, radial = {0.0f, 0.0f}, tangential;
-
+                
                 // radial acceleration
                 if (_particleData.posx[i] || _particleData.posy[i])
                 {
-                    nomalize_point(_particleData.posx[i], _particleData.posy[i], &radial);
+                    normalize_point(_particleData.posx[i], _particleData.posy[i], &radial);
                 }
                 tangential = radial;
                 radial.x *= _particleData.modeA.radialAccel[i];
                 radial.y *= _particleData.modeA.radialAccel[i];
-
+                
                 // tangential acceleration
                 std::swap(tangential.x, tangential.y);
-                tangential.x *= -_particleData.modeA.tangentialAccel[i];
+                tangential.x *= - _particleData.modeA.tangentialAccel[i];
                 tangential.y *= _particleData.modeA.tangentialAccel[i];
-
+                
                 // (gravity + radial + tangential) * dt
                 tmp.x = radial.x + tangential.x + modeA.gravity.x;
                 tmp.y = radial.y + tangential.y + modeA.gravity.y;
                 tmp.x *= dt;
                 tmp.y *= dt;
-
+                
                 _particleData.modeA.dirX[i] += tmp.x;
                 _particleData.modeA.dirY[i] += tmp.y;
-
+                
                 // this is cocos2d-x v3.0
                 // if (_configName.length()>0 && _yCoordFlipped != -1)
-
+                
                 // this is cocos2d-x v3.0
                 tmp.x = _particleData.modeA.dirX[i] * dt * _yCoordFlipped;
                 tmp.y = _particleData.modeA.dirY[i] * dt * _yCoordFlipped;
@@ -973,96 +968,85 @@ void ParticleSystem::update(float dt)
         }
         else
         {
-            // Why use so many for-loop separately instead of putting them together?
-            // When the processor needs to read from or write to a location in memory,
-            // it first checks whether a copy of that data is in the cache.
-            // And every property's memory of the particle system is continuous,
-            // for the purpose of improving cache hit rate, we should process only one property in one for-loop AFAP.
-            // It was proved to be effective especially for low-end machine.
+            //Why use so many for-loop separately instead of putting them together?
+            //When the processor needs to read from or write to a location in memory,
+            //it first checks whether a copy of that data is in the cache.
+            //And every property's memory of the particle system is continuous,
+            //for the purpose of improving cache hit rate, we should process only one property in one for-loop AFAP.
+            //It was proved to be effective especially for low-end machine. 
             for (int i = 0; i < _particleCount; ++i)
             {
                 _particleData.modeB.angle[i] += _particleData.modeB.degreesPerSecond[i] * dt;
             }
-
+            
             for (int i = 0; i < _particleCount; ++i)
             {
                 _particleData.modeB.radius[i] += _particleData.modeB.deltaRadius[i] * dt;
             }
-
-            if (_positionType == PositionType::WORLD)
+            
+            for (int i = 0; i < _particleCount; ++i)
             {
-                for (int i = 0; i < _particleCount; ++i)
-                {
-                    _particleData.posx[i] = _particleData.startPosX[i] - cosf(_particleData.modeB.angle[i]) * _particleData.modeB.radius[i];
-                    _particleData.posy[i] = _particleData.startPosY[i] - sinf(_particleData.modeB.angle[i]) * _particleData.modeB.radius[i] * _yCoordFlipped;
-                }
+                _particleData.posx[i] = - cosf(_particleData.modeB.angle[i]) * _particleData.modeB.radius[i];
             }
-            else
+            for (int i = 0; i < _particleCount; ++i)
             {
-                for (int i = 0; i < _particleCount; ++i)
-                {
-                    _particleData.posx[i] = -cosf(_particleData.modeB.angle[i]) * _particleData.modeB.radius[i];
-                }
-                for (int i = 0; i < _particleCount; ++i)
-                {
-                    _particleData.posy[i] = -sinf(_particleData.modeB.angle[i]) * _particleData.modeB.radius[i] * _yCoordFlipped;
-                }
+                _particleData.posy[i] = - sinf(_particleData.modeB.angle[i]) * _particleData.modeB.radius[i] * _yCoordFlipped;
             }
         }
-
-        // color r,g,b,a
-        for (int i = 0; i < _particleCount; ++i)
+        
+        //color r,g,b,a
+        for (int i = 0 ; i < _particleCount; ++i)
         {
             _particleData.colorR[i] += _particleData.deltaColorR[i] * dt;
         }
-
-        for (int i = 0; i < _particleCount; ++i)
+        
+        for (int i = 0 ; i < _particleCount; ++i)
         {
             _particleData.colorG[i] += _particleData.deltaColorG[i] * dt;
         }
-
-        for (int i = 0; i < _particleCount; ++i)
+        
+        for (int i = 0 ; i < _particleCount; ++i)
         {
             _particleData.colorB[i] += _particleData.deltaColorB[i] * dt;
         }
-
-        for (int i = 0; i < _particleCount; ++i)
+        
+        for (int i = 0 ; i < _particleCount; ++i)
         {
             _particleData.colorA[i] += _particleData.deltaColorA[i] * dt;
         }
-        // size
-        for (int i = 0; i < _particleCount; ++i)
+        //size
+        for (int i = 0 ; i < _particleCount; ++i)
         {
             _particleData.size[i] += (_particleData.deltaSize[i] * dt);
             _particleData.size[i] = MAX(0, _particleData.size[i]);
         }
-        // angle
-        for (int i = 0; i < _particleCount; ++i)
+        //angle
+        for (int i = 0 ; i < _particleCount; ++i)
         {
             _particleData.rotation[i] += _particleData.deltaRotation[i] * dt;
         }
-
+        
         updateParticleQuads();
         _transformSystemDirty = false;
     }
 
     // only update gl buffer when visible
-    if (_visible && !_batchNode)
+    if (_visible && ! _batchNode)
     {
         postStep();
     }
 
-    CC_PROFILER_STOP_CATEGORY(kProfilerCategoryParticles, "CCParticleSystem - update");
+    CC_PROFILER_STOP_CATEGORY(kProfilerCategoryParticles , "CCParticleSystem - update");
 }
 
-void ParticleSystem::updateWithNoTime(void)
+void ParticleSystem::updateWithNoTime()
 {
     this->update(0.0f);
 }
 
 void ParticleSystem::updateParticleQuads()
 {
-    // should be overridden
+    //should be overridden
 }
 
 void ParticleSystem::postStep()
@@ -1084,17 +1068,17 @@ void ParticleSystem::setTexture(Texture2D* var)
 
 void ParticleSystem::updateBlendFunc()
 {
-    CCASSERT(!_batchNode, "Can't change blending functions when the particle is being batched");
+    CCASSERT(! _batchNode, "Can't change blending functions when the particle is being batched");
 
-    if (_texture)
+    if(_texture)
     {
         bool premultiplied = _texture->hasPremultipliedAlpha();
-
+        
         _opacityModifyRGB = false;
-
-        if (_texture && (_blendFunc.src == CC_BLEND_SRC && _blendFunc.dst == CC_BLEND_DST))
+        
+        if( _texture && ( _blendFunc.src == CC_BLEND_SRC && _blendFunc.dst == CC_BLEND_DST ) )
         {
-            if (premultiplied)
+            if( premultiplied )
             {
                 _opacityModifyRGB = true;
             }
@@ -1106,7 +1090,7 @@ void ParticleSystem::updateBlendFunc()
     }
 }
 
-Texture2D* ParticleSystem::getTexture() const
+Texture2D * ParticleSystem::getTexture() const
 {
     return _texture;
 }
@@ -1114,34 +1098,34 @@ Texture2D* ParticleSystem::getTexture() const
 // ParticleSystem - Additive Blending
 void ParticleSystem::setBlendAdditive(bool additive)
 {
-    if (additive)
+    if( additive )
     {
         _blendFunc = BlendFunc::ADDITIVE;
     }
     else
     {
-        if (_texture && !_texture->hasPremultipliedAlpha())
+        if( _texture && ! _texture->hasPremultipliedAlpha() )
             _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
-        else
+        else 
             _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
     }
 }
 
 bool ParticleSystem::isBlendAdditive() const
 {
-    return (_blendFunc.src == GL_SRC_ALPHA && _blendFunc.dst == GL_ONE);
+    return( _blendFunc.src == backend::BlendFactor::SRC_ALPHA && _blendFunc.dst == backend::BlendFactor::ONE);
 }
 
-// ParticleSystem - Properties of Gravity Mode
+// ParticleSystem - Properties of Gravity Mode 
 void ParticleSystem::setTangentialAccel(float t)
 {
-    CCASSERT(_emitterMode == Mode::GRAVITY, "Particle Mode should be Gravity");
+    CCASSERT( _emitterMode == Mode::GRAVITY, "Particle Mode should be Gravity");
     modeA.tangentialAccel = t;
 }
 
 float ParticleSystem::getTangentialAccel() const
 {
-    CCASSERT(_emitterMode == Mode::GRAVITY, "Particle Mode should be Gravity");
+    CCASSERT( _emitterMode == Mode::GRAVITY, "Particle Mode should be Gravity");
     return modeA.tangentialAccel;
 }
 
@@ -1155,7 +1139,7 @@ float ParticleSystem::getTangentialAccelVar() const
 {
     CCASSERT(_emitterMode == Mode::GRAVITY, "Particle Mode should be Gravity");
     return modeA.tangentialAccelVar;
-}
+}    
 
 void ParticleSystem::setRadialAccel(float t)
 {
@@ -1314,7 +1298,7 @@ int ParticleSystem::getTotalParticles() const
 
 void ParticleSystem::setTotalParticles(int var)
 {
-    CCASSERT(var <= _allocatedParticles, "Particle: resizing particle array only supported for quads");
+    CCASSERT( var <= _allocatedParticles, "Particle: resizing particle array only supported for quads");
     _totalParticles = var;
 }
 
@@ -1323,10 +1307,9 @@ const BlendFunc& ParticleSystem::getBlendFunc() const
     return _blendFunc;
 }
 
-void ParticleSystem::setBlendFunc(const BlendFunc& blendFunc)
+void ParticleSystem::setBlendFunc(const BlendFunc &blendFunc)
 {
-    if (_blendFunc.src != blendFunc.src || _blendFunc.dst != blendFunc.dst)
-    {
+    if( _blendFunc.src != blendFunc.src || _blendFunc.dst != blendFunc.dst ) {
         _blendFunc = blendFunc;
         this->updateBlendFunc();
     }
@@ -1342,22 +1325,22 @@ void ParticleSystem::setAutoRemoveOnFinish(bool var)
     _isAutoRemoveOnFinish = var;
 }
 
+
 // ParticleSystem - methods for batchNode rendering
 
-ParticleBatchNode* ParticleSystem::getBatchNode(void) const
+ParticleBatchNode* ParticleSystem::getBatchNode() const
 {
     return _batchNode;
 }
 
 void ParticleSystem::setBatchNode(ParticleBatchNode* batchNode)
 {
-    if (_batchNode != batchNode)
-    {
+    if( _batchNode != batchNode ) {
+
         _batchNode = batchNode; // weak reference
 
-        if (batchNode)
-        {
-            // each particle needs a unique index
+        if( batchNode ) {
+            //each particle needs a unique index
             for (int i = 0; i < _totalParticles; i++)
             {
                 _particleData.atlasIndex[i] = i;
@@ -1366,7 +1349,7 @@ void ParticleSystem::setBatchNode(ParticleBatchNode* batchNode)
     }
 }
 
-// don't use a transform matrix, this is faster
+//don't use a transform matrix, this is faster
 void ParticleSystem::setScale(float s)
 {
     _transformSystemDirty = true;
@@ -1416,4 +1399,6 @@ void ParticleSystem::resumeEmissions()
     _paused = false;
 }
 
+
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCParticleSystem.h b/cocos2d/cocos/2d/CCParticleSystem.h
index 1f1006602d..084a79c327 100644
--- a/cocos2d/cocos/2d/CCParticleSystem.h
+++ b/cocos2d/cocos/2d/CCParticleSystem.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,22 +25,12 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_PARTICLESYSTEM_H
-#define CC_2D_PARTICLESYSTEM_H
+#ifndef __CCPARTICLE_SYSTEM_H__
+#define __CCPARTICLE_SYSTEM_H__
 
-#include <cocos/2d/CCNode.h>
 #include <cocos/base/CCProtocols.h>
+#include <cocos/2d/CCNode.h>
 #include <cocos/base/CCValue.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformConfig.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <chrono>
-#include <iosfwd>
 
 NS_CC_BEGIN
 
@@ -72,83 +63,84 @@ public:
     float* colorG;
     float* colorB;
     float* colorA;
-
+    
     float* deltaColorR;
     float* deltaColorG;
     float* deltaColorB;
     float* deltaColorA;
-
+    
     float* size;
     float* deltaSize;
     float* rotation;
     float* deltaRotation;
     float* timeToLive;
     unsigned int* atlasIndex;
-
+    
     //! Mode A: gravity, direction, radial accel, tangential accel
-    struct
-    {
+    struct{
         float* dirX;
         float* dirY;
         float* radialAccel;
         float* tangentialAccel;
     } modeA;
-
+    
     //! Mode B: radius mode
-    struct
-    {
+    struct{
         float* angle;
         float* degreesPerSecond;
         float* radius;
         float* deltaRadius;
     } modeB;
-
+    
     unsigned int maxCount;
     ParticleData();
     bool init(int count);
     void release();
     unsigned int getMaxCount() { return maxCount; }
-
+    
     void copyParticle(int p1, int p2)
     {
         posx[p1] = posx[p2];
         posy[p1] = posy[p2];
         startPosX[p1] = startPosX[p2];
         startPosY[p1] = startPosY[p2];
-
+        
         colorR[p1] = colorR[p2];
         colorG[p1] = colorG[p2];
         colorB[p1] = colorB[p2];
         colorA[p1] = colorA[p2];
-
+        
         deltaColorR[p1] = deltaColorR[p2];
         deltaColorG[p1] = deltaColorG[p2];
         deltaColorB[p1] = deltaColorB[p2];
         deltaColorA[p1] = deltaColorA[p2];
-
+        
         size[p1] = size[p2];
         deltaSize[p1] = deltaSize[p2];
-
+        
         rotation[p1] = rotation[p2];
         deltaRotation[p1] = deltaRotation[p2];
-
+        
         timeToLive[p1] = timeToLive[p2];
-
+        
         atlasIndex[p1] = atlasIndex[p2];
-
+        
         modeA.dirX[p1] = modeA.dirX[p2];
         modeA.dirY[p1] = modeA.dirY[p2];
         modeA.radialAccel[p1] = modeA.radialAccel[p2];
         modeA.tangentialAccel[p1] = modeA.tangentialAccel[p2];
-
+        
         modeB.angle[p1] = modeB.angle[p2];
         modeB.degreesPerSecond[p1] = modeB.degreesPerSecond[p2];
         modeB.radius[p1] = modeB.radius[p2];
         modeB.deltaRadius[p1] = modeB.deltaRadius[p2];
+        
     }
 };
 
-// typedef void (*CC_UPDATE_PARTICLE_IMP)(id, SEL, tParticle*, Vec2);
+
+
+//typedef void (*CC_UPDATE_PARTICLE_IMP)(id, SEL, tParticle*, Vec2);
 
 class Texture2D;
 
@@ -180,7 +172,7 @@ Attributes of a Particle System:
 
 Cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).
 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guaranteed in cocos2d,
-cocos2d uses a another approach, but the results are almost identical.
+cocos2d uses a another approach, but the results are almost identical. 
 
 Cocos2d supports all the variables used by Particle Designer plus a bit more:
 - spinning particles (supported when using ParticleSystemQuad)
@@ -197,12 +189,6 @@ emitter.startSpin = 0;
 
 */
 
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
-#    ifdef RELATIVE
-#        undef RELATIVE
-#    endif
-#endif
-
 class CC_DLL ParticleSystem : public Node, public TextureProtocol, public PlayableProtocol
 {
 public:
@@ -214,7 +200,7 @@ public:
         GRAVITY,
         RADIUS,
     };
-
+    
     /** PositionType
      Possible types of particle positions.
      * @js cc.ParticleSystem.TYPE_FREE
@@ -222,28 +208,26 @@ public:
     enum class PositionType
     {
         FREE, /** Living particles are attached to the world and are unaffected by emitter repositioning. */
-
+        
         RELATIVE, /** Living particles are attached to the world but will follow the emitter repositioning.
                    Use case: Attach an emitter to an sprite, and you want that the emitter follows the sprite.*/
-
+        
         GROUPED, /** Living particles are attached to the emitter and are translated along with it. */
 
-        WORLD, /** Living particles are attached to the world but emition is affected by emitter repositioning and rotations. */
     };
-
+    
     //* @enum
-    enum
-    {
+    enum {
         /** The Particle emitter lives forever. */
         DURATION_INFINITY = -1,
-
+        
         /** The starting size of the particle is equal to the ending size. */
         START_SIZE_EQUAL_TO_END_SIZE = -1,
-
+        
         /** The starting radius of the particle is equal to the ending radius. */
         START_RADIUS_EQUAL_TO_END_RADIUS = -1,
     };
-
+    
     /** Creates an initializes a ParticleSystem from a plist file.
     This plist files can be created manually or with Particle Designer:
     http://particledesigner.71squared.com/
@@ -252,7 +236,7 @@ public:
      * @param plistFile Particle plist file name.
      * @return An autoreleased ParticleSystem object.
      */
-    static ParticleSystem* create(const std::string& plistFile);
+    static ParticleSystem * create(const std::string& plistFile);
 
     /** Create a system with a fixed number of particles.
      *
@@ -262,11 +246,12 @@ public:
      */
     static ParticleSystem* createWithTotalParticles(int numberOfParticles);
 
-    /**
-     * PS: PrettySimple modification: we had to switch to a virtual function
+    /** Gets all ParticleSystem references
      */
-    virtual void addParticles(int count);
-
+    static Vector<ParticleSystem*>& getAllParticleSystems();
+public:
+    void addParticles(int count);
+    
     void stopSystem();
     /** Kill all living particles.
      */
@@ -278,7 +263,7 @@ public:
     bool isFull();
 
     /** Update the verts position data of particle,
-     should be overridden by subclasses.
+     should be overridden by subclasses. 
      */
     virtual void updateParticleQuads();
     /** Update the VBO verts buffer which does not use batch node,
@@ -294,7 +279,7 @@ public:
      * @return True if the particle system removed self on finish.
      */
     virtual bool isAutoRemoveOnFinish() const;
-
+    
     /** Set the particle system auto removed it self on finish.
      *
      * @param var True if the particle system removed self on finish.
@@ -475,256 +460,256 @@ public:
      * @param batchNode The batch node.
      */
     virtual void setBatchNode(ParticleBatchNode* batchNode);
-
+    
     /** Gets the index of system in batch node array.
      *
      * @return The index of system in batch node array.
      */
-    inline int getAtlasIndex() const noexcept { return _atlasIndex; }
+    int getAtlasIndex() const { return _atlasIndex; }
     /** Sets the index of system in batch node array.
      *
      * @param index The index of system in batch node array.
      */
-    inline void setAtlasIndex(int index) noexcept { _atlasIndex = index; }
+    void setAtlasIndex(int index) { _atlasIndex = index; }
 
     /** Gets the Quantity of particles that are being simulated at the moment.
      *
      * @return The Quantity of particles that are being simulated at the moment.
      */
-    inline unsigned int getParticleCount() const noexcept { return _particleCount; }
-
-    /** Gets how many seconds the emitter will run. chrono::milliseconds::max() means 'forever'.
+    unsigned int getParticleCount() const { return _particleCount; }
+    
+    /** Gets how many seconds the emitter will run. -1 means 'forever'.
      *
-     * @return The seconds that the emitter will run. chrono::milliseconds::max() means 'forever'.
+     * @return The seconds that the emitter will run. -1 means 'forever'.
      */
-    inline std::chrono::milliseconds getDuration() const noexcept { return _duration; }
-    /** Sets how many seconds the emitter will run. chrono::milliseconds::max() means 'forever'.
+    std::chrono::milliseconds getDuration() const { return _duration; }
+    /** Sets how many seconds the emitter will run. -1 means 'forever'.
      *
-     * @param duration The seconds that the emitter will run. chrono::milliseconds::max() means 'forever'.
+     * @param duration The seconds that the emitter will run. -1 means 'forever'.
      */
-    inline void setDuration(std::chrono::milliseconds duration) noexcept { _duration = duration; }
-
+    void setDuration(std::chrono::milliseconds duration) { _duration = duration; }
+    
     /** Gets the source position of the emitter.
      *
      * @return The source position of the emitter.
      */
-    inline const Vec2& getSourcePosition() const noexcept { return _sourcePosition; }
+    const Vec2& getSourcePosition() const { return _sourcePosition; }
     /** Sets the source position of the emitter.
      *
      * @param pos The source position of the emitter.
      */
-    inline void setSourcePosition(const Vec2& pos) noexcept { _sourcePosition = pos; }
-
+    void setSourcePosition(const Vec2& pos) { _sourcePosition = pos; }
+    
     /** Gets the position variance of the emitter.
      *
      * @return The position variance of the emitter.
      */
-    inline const Vec2& getPosVar() const noexcept { return _posVar; }
+    const Vec2& getPosVar() const { return _posVar; }
     /** Sets the position variance of the emitter.
      *
      * @param pos The position variance of the emitter.
      */
-    inline void setPosVar(const Vec2& pos) noexcept { _posVar = pos; }
+    void setPosVar(const Vec2& pos) { _posVar = pos; }
 
     /** Gets the life of each particle.
      *
      * @return The life of each particle.
      */
-    inline float getLife() const noexcept { return _life; }
+    float getLife() const { return _life; }
     /** Sets the life of each particle.
      *
      * @param life The life of each particle.
      */
-    inline void setLife(float life) noexcept { _life = life; }
+    void setLife(float life) { _life = life; }
 
     /** Gets the life variance of each particle.
      *
      * @return The life variance of each particle.
      */
-    inline float getLifeVar() const noexcept { return _lifeVar; }
+    float getLifeVar() const { return _lifeVar; }
     /** Sets the life variance of each particle.
      *
      * @param lifeVar The life variance of each particle.
      */
-    inline void setLifeVar(float lifeVar) noexcept { _lifeVar = lifeVar; }
+    void setLifeVar(float lifeVar) { _lifeVar = lifeVar; }
 
-    /** Gets the angle of each particle.
+    /** Gets the angle of each particle. 
      *
      * @return The angle of each particle.
      */
-    inline float getAngle() const noexcept { return _angle; }
+    float getAngle() const { return _angle; }
     /** Sets the angle of each particle.
      *
      * @param angle The angle of each particle.
      */
-    inline void setAngle(float angle) noexcept { _angle = angle; }
+    void setAngle(float angle) { _angle = angle; }
 
     /** Gets the angle variance of each particle.
      *
      * @return The angle variance of each particle.
      */
-    inline float getAngleVar() const noexcept { return _angleVar; }
+    float getAngleVar() const { return _angleVar; }
     /** Sets the angle variance of each particle.
      *
      * @param angleVar The angle variance of each particle.
      */
-    inline void setAngleVar(float angleVar) noexcept { _angleVar = angleVar; }
-
+    void setAngleVar(float angleVar) { _angleVar = angleVar; }
+    
     /** Switch between different kind of emitter modes:
      - kParticleModeGravity: uses gravity, speed, radial and tangential acceleration.
      - kParticleModeRadius: uses radius movement + rotation.
      *
      * @return The mode of the emitter.
      */
-    inline Mode getEmitterMode() const noexcept { return _emitterMode; }
+    Mode getEmitterMode() const { return _emitterMode; }
     /** Sets the mode of the emitter.
      *
      * @param mode The mode of the emitter.
      */
-    inline void setEmitterMode(Mode mode) noexcept { _emitterMode = mode; }
-
+    void setEmitterMode(Mode mode) { _emitterMode = mode; }
+    
     /** Gets the start size in pixels of each particle.
      *
      * @return The start size in pixels of each particle.
      */
-    inline float getStartSize() const noexcept { return _startSize; }
+    float getStartSize() const { return _startSize; }
     /** Sets the start size in pixels of each particle.
      *
      * @param startSize The start size in pixels of each particle.
      */
-    inline void setStartSize(float startSize) noexcept { _startSize = startSize; }
+    void setStartSize(float startSize) { _startSize = startSize; }
 
     /** Gets the start size variance in pixels of each particle.
      *
      * @return The start size variance in pixels of each particle.
      */
-    inline float getStartSizeVar() const noexcept { return _startSizeVar; }
+    float getStartSizeVar() const { return _startSizeVar; }
     /** Sets the start size variance in pixels of each particle.
      *
      * @param sizeVar The start size variance in pixels of each particle.
      */
-    inline void setStartSizeVar(float sizeVar) noexcept { _startSizeVar = sizeVar; }
+    void setStartSizeVar(float sizeVar) { _startSizeVar = sizeVar; }
 
     /** Gets the end size in pixels of each particle.
      *
      * @return The end size in pixels of each particle.
      */
-    inline float getEndSize() const noexcept { return _endSize; }
+    float getEndSize() const { return _endSize; }
     /** Sets the end size in pixels of each particle.
      *
      * @param endSize The end size in pixels of each particle.
      */
-    inline void setEndSize(float endSize) noexcept { _endSize = endSize; }
+    void setEndSize(float endSize) { _endSize = endSize; }
 
     /** Gets the end size variance in pixels of each particle.
      *
      * @return The end size variance in pixels of each particle.
      */
-    inline float getEndSizeVar() const noexcept { return _endSizeVar; }
+    float getEndSizeVar() const { return _endSizeVar; }
     /** Sets the end size variance in pixels of each particle.
      *
      * @param sizeVar The end size variance in pixels of each particle.
      */
-    inline void setEndSizeVar(float sizeVar) noexcept { _endSizeVar = sizeVar; }
+    void setEndSizeVar(float sizeVar) { _endSizeVar = sizeVar; }
 
     /** Gets the start color of each particle.
      *
      * @return The start color of each particle.
      */
-    inline const Color4F& getStartColor() const noexcept { return _startColor; }
+    const Color4F& getStartColor() const { return _startColor; }
     /** Sets the start color of each particle.
      *
      * @param color The start color of each particle.
      */
-    inline void setStartColor(const Color4F& color) noexcept { _startColor = color; }
+    void setStartColor(const Color4F& color) { _startColor = color; }
 
     /** Gets the start color variance of each particle.
      *
      * @return The start color variance of each particle.
      */
-    inline const Color4F& getStartColorVar() const { return _startColorVar; }
+    const Color4F& getStartColorVar() const { return _startColorVar; }
     /** Sets the start color variance of each particle.
      *
      * @param color The start color variance of each particle.
      */
-    void setStartColorVar(const Color4F& color) noexcept { _startColorVar = color; }
+    void setStartColorVar(const Color4F& color) { _startColorVar = color; }
 
     /** Gets the end color and end color variation of each particle.
      *
      * @return The end color and end color variation of each particle.
      */
-    inline const Color4F& getEndColor() const noexcept { return _endColor; }
+    const Color4F& getEndColor() const { return _endColor; }
     /** Sets the end color and end color variation of each particle.
      *
      * @param color The end color and end color variation of each particle.
      */
-    inline void setEndColor(const Color4F& color) noexcept { _endColor = color; }
+    void setEndColor(const Color4F& color) { _endColor = color; }
 
     /** Gets the end color variance of each particle.
      *
      * @return The end color variance of each particle.
      */
-    inline const Color4F& getEndColorVar() const noexcept { return _endColorVar; }
+    const Color4F& getEndColorVar() const { return _endColorVar; }
     /** Sets the end color variance of each particle.
      *
      * @param color The end color variance of each particle.
      */
-    inline void setEndColorVar(const Color4F& color) noexcept { _endColorVar = color; }
+    void setEndColorVar(const Color4F& color) { _endColorVar = color; }
 
     /** Gets the start spin of each particle.
      *
      * @return The start spin of each particle.
      */
-    inline float getStartSpin() const noexcept { return _startSpin; }
+    float getStartSpin() const { return _startSpin; }
     /** Sets the start spin of each particle.
      *
      * @param spin The start spin of each particle.
      */
-    inline void setStartSpin(float spin) noexcept { _startSpin = spin; }
+    void setStartSpin(float spin) { _startSpin = spin; }
 
     /** Gets the start spin variance of each particle.
      *
      * @return The start spin variance of each particle.
      */
-    inline float getStartSpinVar() const noexcept { return _startSpinVar; }
+    float getStartSpinVar() const { return _startSpinVar; }
     /** Sets the start spin variance of each particle.
      *
      * @param pinVar The start spin variance of each particle.
      */
-    inline void setStartSpinVar(float pinVar) noexcept { _startSpinVar = pinVar; }
+    void setStartSpinVar(float pinVar) { _startSpinVar = pinVar; }
 
     /** Gets the end spin of each particle.
      *
      * @return The end spin of each particle.
      */
-    inline float getEndSpin() const noexcept { return _endSpin; }
+    float getEndSpin() const { return _endSpin; }
     /** Sets the end spin of each particle.
      *
      * @param endSpin The end spin of each particle.
      */
-    inline void setEndSpin(float endSpin) noexcept { _endSpin = endSpin; }
+    void setEndSpin(float endSpin) { _endSpin = endSpin; }
 
     /** Gets the end spin variance of each particle.
      *
      * @return The end spin variance of each particle.
      */
-    inline float getEndSpinVar() const noexcept { return _endSpinVar; }
+    float getEndSpinVar() const { return _endSpinVar; }
     /** Sets the end spin variance of each particle.
      *
      * @param endSpinVar The end spin variance of each particle.
      */
-    inline void setEndSpinVar(float endSpinVar) noexcept { _endSpinVar = endSpinVar; }
+    void setEndSpinVar(float endSpinVar) { _endSpinVar = endSpinVar; }
 
     /** Gets the emission rate of the particles.
      *
      * @return The emission rate of the particles.
      */
-    inline float getEmissionRate() const noexcept { return _emissionRate; }
+    float getEmissionRate() const { return _emissionRate; }
     /** Sets the emission rate of the particles.
      *
      * @param rate The emission rate of the particles.
      */
-    inline void setEmissionRate(float rate) noexcept { _emissionRate = rate; }
+    void setEmissionRate(float rate) { _emissionRate = rate; }
 
     /** Gets the maximum particles of the system.
      *
@@ -740,71 +725,61 @@ public:
     /** does the alpha value modify color */
     void setOpacityModifyRGB(bool opacityModifyRGB) override { _opacityModifyRGB = opacityModifyRGB; }
     bool isOpacityModifyRGB() const override { return _opacityModifyRGB; }
-    CC_DEPRECATED_ATTRIBUTE bool getOpacityModifyRGB() const { return isOpacityModifyRGB(); }
-
+    
     /** Gets the particles movement type: Free or Grouped.
      @since v0.8
      *
      * @return The particles movement type.
      */
-    inline PositionType getPositionType() const noexcept { return _positionType; }
+    PositionType getPositionType() const { return _positionType; }
     /** Sets the particles movement type: Free or Grouped.
     @since v0.8
      *
      * @param type The particles movement type.
      */
-    inline void setPositionType(PositionType type) noexcept { _positionType = type; }
-
-    /**
-     * In PositionType::WORLD only
-     *
-     * if true, the emition starts from SourcePosition in world space coordinates (the position of the emitter is discarded).
-     *
-     * had to add this functionality for emitters located inside 3D Nodes (any angles for the 3 axis + z depth) that wouldn't work
-     * properly as they emit in 2D
-     * like this you can set the source Emission directly without worying about the emitter transforms and still keep the emitter in the Node hierarchy.
-     * if true, then you will have to use setSourcePosition() and compute the emission position manually (each time a transform changes in the hierarchy)
-     */
-    inline void setUseSourcePosOnly(bool bUseSrcPosOnly) noexcept { _bUseSrcPosOnly = bUseSrcPosOnly; }
-
+    void setPositionType(PositionType type) { _positionType = type; }
+    
     // Overrides
     virtual void onEnter() override;
     virtual void onExit() override;
     virtual void update(float dt) override;
     virtual Texture2D* getTexture() const override;
-    virtual void setTexture(Texture2D* texture) override;
+    virtual void setTexture(Texture2D *texture) override;
     /**
-     *@code
-     *When this function bound into js or lua,the parameter will be changed
-     *In js: var setBlendFunc(var src, var dst)
-     *In lua: local setBlendFunc(local src, local dst)
-     *@endcode
-     */
-    virtual void setBlendFunc(const BlendFunc& blendFunc) override;
+    *@code
+    *When this function bound into js or lua,the parameter will be changed
+    *In js: var setBlendFunc(var src, var dst)
+    *In lua: local setBlendFunc(local src, local dst)
+    *@endcode
+    */
+    virtual void setBlendFunc(const BlendFunc &blendFunc) override;
     /**
-     * @js NA
-     * @lua NA
-     */
-    virtual const BlendFunc& getBlendFunc() const override;
+    * @js NA
+    * @lua NA
+    */
+    virtual const BlendFunc &getBlendFunc() const override;
 
-    inline const std::string& getResourceFile() const noexcept { return _plistFile; }
+    const std::string& getResourceFile() const { return _plistFile; }
 
     /// @{
     /// @name implement Playable Protocol
     virtual void start() override;
     virtual void stop() override;
-    /// @} end of PlaybleProtocol
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleSystem();
+    /// @} end of PlayableProtocol
+    
+    void setSourcePositionCompatible(bool sourcePositionCompatible) { _sourcePositionCompatible = sourcePositionCompatible; }
+    bool isSourcePositionCompatible() const { return _sourcePositionCompatible; }
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleSystem();
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleSystem() override;
+    virtual ~ParticleSystem();
 
     /** initializes a ParticleSystem*/
     bool init() override;
@@ -814,39 +789,46 @@ public:
      @since v0.99.3
      */
     bool initWithFile(const std::string& plistFile);
-
+    
     /** initializes a QuadParticleSystem from a Dictionary.
      @since v0.99.3
      */
     bool initWithDictionary(ValueMap& dictionary);
-
+    
     /** initializes a particle system from a NSDictionary and the path from where to load the png
      @since v2.1
      */
     bool initWithDictionary(ValueMap& dictionary, const std::string& dirname);
-
+    
     //! Initializes a system with a fixed number of particles
     virtual bool initWithTotalParticles(int numberOfParticles);
-
+    
     /** Are the emissions paused
      @return True if the emissions are paused, else false
      */
     virtual bool isPaused() const;
-
+    
     /* Pause the emissions*/
     virtual void pauseEmissions();
-
+    
     /* UnPause the emissions*/
     virtual void resumeEmissions();
 
 protected:
     virtual void updateBlendFunc();
+    
+private:
+    friend class EngineDataManager;
+    /** Internal use only, it's used by EngineDataManager class for Android platform */
+    static void setTotalParticleCountFactor(float factor);
+    
+protected:
 
     /** whether or not the particles are using blend additive.
      If enabled, the following blending function will be used.
      @code
-     source blend function = GL_SRC_ALPHA;
-     dest blend function = GL_ONE;
+     source blend function = BlendFactor::SRC_ALPHA;
+     dest blend function = BlendFactor::ONE;
      @endcode
      */
     bool _isBlendAdditive;
@@ -863,8 +845,7 @@ protected:
 
     // Different modes
     //! Mode A:Gravity + Tangential Accel + Radial Accel
-    struct
-    {
+    struct {
         /** Gravity value. Only available in 'Gravity' mode. */
         Vec2 gravity;
         /** speed of each particle. Only available in 'Gravity' mode.  */
@@ -884,8 +865,7 @@ protected:
     } modeA;
 
     //! Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)
-    struct
-    {
+    struct {
         /** The starting radius of the particles. Only available in 'Radius' mode. */
         float startRadius;
         /** The starting radius variance of the particles. Only available in 'Radius' mode. */
@@ -899,17 +879,13 @@ protected:
         /** Variance in degrees for rotatePerSecond. Only available in 'Radius' mode. */
         float rotatePerSecondVar;
     } modeB;
-
-    // particle data
+    
+    //particle data
     ParticleData _particleData;
 
-    // Emitter name
+    //Emitter name
     std::string _configName;
 
-    // PS: added for emition interpollation (when the emitter "travels" a lot between 2 frames)
-    Mat4 _previousTransforms;
-    Mat4 _currentTransforms;
-
     // color modulate
     //    BOOL colorModulate;
 
@@ -917,8 +893,8 @@ protected:
     float _emitCounter;
 
     // Optimization
-    // CC_UPDATE_PARTICLE_IMP    updateParticleImp;
-    // SEL                        updateParticleSel;
+    //CC_UPDATE_PARTICLE_IMP    updateParticleImp;
+    //SEL                        updateParticleSel;
 
     /** weak reference to the SpriteBatchNode that renders the Sprite */
     ParticleBatchNode* _batchNode;
@@ -926,16 +902,19 @@ protected:
     // index of system in batch node array
     int _atlasIndex;
 
-    // true if scaled or rotated
+    //true if scaled or rotated
     bool _transformSystemDirty;
     // Number of allocated particles
     int _allocatedParticles;
 
     /** Is the emitter active */
     bool _isActive;
-
+    
     /** Quantity of particles that are being simulated at the moment */
     int _particleCount;
+    /** The factor affects the total particle count, its value should be 0.0f ~ 1.0f, default 1.0f*/
+    static float __totalParticleCountFactor;
+    
     /** How many seconds the emitter will run. -1 means 'forever' */
     std::chrono::milliseconds _duration;
     /** sourcePosition of the emitter */
@@ -994,18 +973,22 @@ protected:
     /** does FlippedY variance of each particle */
     int _yCoordFlipped;
 
-    /** particles movement type: Free, relative, Grouped, or World
+
+    /** particles movement type: Free or Grouped
      @since v0.8
      */
     PositionType _positionType;
-
-    bool _bUseSrcPosOnly;
-
+    
     /** is the emitter paused */
     bool _paused;
+    
+    /** is sourcePosition compatible */
+    bool _sourcePositionCompatible;
 
+    static Vector<ParticleSystem*> __allInstances;
+    
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSystem)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSystem);
 };
 
 // end of _2d group
@@ -1013,4 +996,4 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_PARTICLESYSTEM_H
+#endif //__CCPARTICLE_SYSTEM_H__
diff --git a/cocos2d/cocos/2d/CCParticleSystemQuad.cpp b/cocos2d/cocos/2d/CCParticleSystemQuad.cpp
index b3f01a8be3..ed71e9aee1 100644
--- a/cocos2d/cocos/2d/CCParticleSystemQuad.cpp
+++ b/cocos2d/cocos/2d/CCParticleSystemQuad.cpp
@@ -4,9 +4,10 @@ Copyright (c) 2009      Leonardo Kasperavičius
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
-
+ 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
@@ -26,78 +27,69 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
+
 #include <cocos/2d/CCParticleSystemQuad.h>
 
-#include <cocos/2d/CCParticleBatchNode.h>
-#include <cocos/2d/CCParticleSystem.h>
+#include <algorithm>
+
 #include <cocos/2d/CCSpriteFrame.h>
-#include <cocos/base/CCConfiguration.h>
+#include <cocos/2d/CCParticleBatchNode.h>
+#include <cocos/renderer/CCTextureAtlas.h>
+#include <cocos/renderer/CCRenderer.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
+#include <cocos/base/CCEventType.h>
+#include <cocos/base/CCConfiguration.h>
+#include <cocos/base/CCEventListenerCustom.h>
+#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCQuadCommand.h>
-#include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTexture2D.h>
-#include <cocos/renderer/CCTextureAtlas.h>
-#include <cocos/renderer/ccGLStateCache.h>
-
-#if CC_ENABLE_CACHE_TEXTURE_DATA
-#    include <cocos/base/CCEventDispatcher.h>
-#    include <cocos/base/CCEventListenerCustom.h>
-#    include <cocos/base/CCEventType.h>
-#endif
-
-#include <cmath>
-#include <cstddef>
-#include <cstdlib>
-#include <cstring>
-#include <new>
-#include <type_traits>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 
 ParticleSystemQuad::ParticleSystemQuad()
-: _quads(nullptr)
-, _indices(nullptr)
-, _VAOname(0)
 {
-    memset(_buffersVBO, 0, sizeof(_buffersVBO));
-
-    _currentTransforms.setIdentity();
-    _previousTransforms.setIdentity();
+    auto& pipelieDescriptor = _quadCommand.getPipelineDescriptor();
+    _programState = new (std::nothrow) backend::ProgramState(positionTextureColor_vert, positionTextureColor_frag);
+    pipelieDescriptor.programState = _programState;
+    _mvpMatrixLocaiton = pipelieDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    _textureLocation = pipelieDescriptor.programState->getUniformLocation("u_texture");
+    
+    auto vertexLayout = _programState->getVertexLayout();
+    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT3, 0, false);
+    }
+    iter = attributeInfo.find("a_texCoord");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_texCoord", iter->second.location, backend::VertexFormat::FLOAT2, offsetof(V3F_C4B_T2F, texCoords), false);
+    }
+    iter = attributeInfo.find("a_color");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_color", iter->second.location, backend::VertexFormat::UBYTE4, offsetof(V3F_C4B_T2F, colors), true);
+    }
+    vertexLayout->setLayout(sizeof(V3F_C4B_T2F));
 }
 
 ParticleSystemQuad::~ParticleSystemQuad()
 {
     if (nullptr == _batchNode)
     {
-        CC_SAFE_FREE(_quads);
-        CC_SAFE_FREE(_indices);
-        glDeleteBuffers(2, &_buffersVBO[0]);
-        if (Configuration::getInstance()->supportsShareableVAO())
-        {
-            glDeleteVertexArrays(1, &_VAOname);
-            GL::bindVAO(0);
-        }
+        CC_SAFE_DELETE_ARRAY(_quads);;
+        CC_SAFE_DELETE_ARRAY(_indices);;
     }
+    CC_SAFE_RELEASE(_programState);
 }
 
 // implementation ParticleSystemQuad
 
-ParticleSystemQuad* ParticleSystemQuad::create(const std::string& filename)
+ParticleSystemQuad * ParticleSystemQuad::create(const std::string& filename)
 {
-    ParticleSystemQuad* ret = new (std::nothrow) ParticleSystemQuad();
+    ParticleSystemQuad *ret = new (std::nothrow) ParticleSystemQuad();
     if (ret && ret->initWithFile(filename))
     {
         ret->autorelease();
@@ -107,9 +99,8 @@ ParticleSystemQuad* ParticleSystemQuad::create(const std::string& filename)
     return ret;
 }
 
-ParticleSystemQuad* ParticleSystemQuad::createWithTotalParticles(int numberOfParticles)
-{
-    ParticleSystemQuad* ret = new (std::nothrow) ParticleSystemQuad();
+ParticleSystemQuad * ParticleSystemQuad::createWithTotalParticles(int numberOfParticles) {
+    ParticleSystemQuad *ret = new (std::nothrow) ParticleSystemQuad();
     if (ret && ret->initWithTotalParticles(numberOfParticles))
     {
         ret->autorelease();
@@ -119,9 +110,9 @@ ParticleSystemQuad* ParticleSystemQuad::createWithTotalParticles(int numberOfPar
     return ret;
 }
 
-ParticleSystemQuad* ParticleSystemQuad::create(ValueMap& dictionary)
+ParticleSystemQuad * ParticleSystemQuad::create(ValueMap &dictionary)
 {
-    ParticleSystemQuad* ret = new (std::nothrow) ParticleSystemQuad();
+    ParticleSystemQuad *ret = new (std::nothrow) ParticleSystemQuad();
     if (ret && ret->initWithDictionary(dictionary))
     {
         ret->autorelease();
@@ -131,35 +122,25 @@ ParticleSystemQuad* ParticleSystemQuad::create(ValueMap& dictionary)
     return ret;
 }
 
-// implementation ParticleSystemQuad
+//implementation ParticleSystemQuad
 // overriding the init method
 bool ParticleSystemQuad::initWithTotalParticles(int numberOfParticles)
 {
     // base initialization
-    if (ParticleSystem::initWithTotalParticles(numberOfParticles))
+    if( ParticleSystem::initWithTotalParticles(numberOfParticles) )
     {
         // allocating data space
-        if (!this->allocMemory())
-        {
+        if( ! this->allocMemory() ) {
             this->release();
             return false;
         }
 
         initIndices();
-        if (Configuration::getInstance()->supportsShareableVAO())
-        {
-            setupVBOandVAO();
-        }
-        else
-        {
-            setupVBO();
-        }
-
-        setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP));
+//        setupVBO();
 
 #if CC_ENABLE_CACHE_TEXTURE_DATA
         // Need to listen the event only when not use batchnode, because it will use VBO
-        auto listener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, [this](EventCustom* evt) { listenRendererRecreated(evt); });
+        auto listener = EventListenerCustom::create(EVENT_RENDERER_RECREATED, CC_CALLBACK_1(ParticleSystemQuad::listenRendererRecreated, this));
         _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);
 #endif
 
@@ -173,34 +154,37 @@ void ParticleSystemQuad::initTexCoordsWithRect(const Rect& pointRect)
 {
     // convert to Tex coords
 
-    Rect rect = Rect(pointRect.origin.x * CC_CONTENT_SCALE_FACTOR(), pointRect.origin.y * CC_CONTENT_SCALE_FACTOR(),
-                     pointRect.size.width * CC_CONTENT_SCALE_FACTOR(), pointRect.size.height * CC_CONTENT_SCALE_FACTOR());
+    Rect rect = Rect(
+        pointRect.origin.x * CC_CONTENT_SCALE_FACTOR(),
+        pointRect.origin.y * CC_CONTENT_SCALE_FACTOR(),
+        pointRect.size.width * CC_CONTENT_SCALE_FACTOR(),
+        pointRect.size.height * CC_CONTENT_SCALE_FACTOR());
 
-    GLfloat wide = static_cast<GLfloat>(pointRect.size.width);
-    GLfloat high = static_cast<GLfloat>(pointRect.size.height);
+    float wide = (float) pointRect.size.width;
+    float high = (float) pointRect.size.height;
 
     if (_texture)
     {
-        wide = static_cast<GLfloat>(_texture->getPixelsWide());
-        high = static_cast<GLfloat>(_texture->getPixelsHigh());
+        wide = (float)_texture->getPixelsWide();
+        high = (float)_texture->getPixelsHigh();
     }
 
 #if CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
-    GLfloat left = (rect.origin.x * 2 + 1) / (wide * 2);
-    GLfloat bottom = (rect.origin.y * 2 + 1) / (high * 2);
-    GLfloat right = left + (rect.size.width * 2 - 2) / (wide * 2);
-    GLfloat top = bottom + (rect.size.height * 2 - 2) / (high * 2);
+    float left = (rect.origin.x*2+1) / (wide*2);
+    float bottom = (rect.origin.y*2+1) / (high*2);
+    float right = left + (rect.size.width*2-2) / (wide*2);
+    float top = bottom + (rect.size.height*2-2) / (high*2);
 #else
-    GLfloat left = rect.origin.x / wide;
-    GLfloat bottom = rect.origin.y / high;
-    GLfloat right = left + rect.size.width / wide;
-    GLfloat top = bottom + rect.size.height / high;
+    float left = rect.origin.x / wide;
+    float bottom = rect.origin.y / high;
+    float right = left + rect.size.width / wide;
+    float top = bottom + rect.size.height / high;
 #endif // ! CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
 
     // Important. Texture in cocos2d are inverted, so the Y component should be inverted
     std::swap(top, bottom);
 
-    V3F_C4B_T2F_Quad* quads = nullptr;
+    V3F_C4B_T2F_Quad *quads = nullptr;
     unsigned int start = 0, end = 0;
     if (_batchNode)
     {
@@ -215,7 +199,7 @@ void ParticleSystemQuad::initTexCoordsWithRect(const Rect& pointRect)
         end = _totalParticles;
     }
 
-    for (unsigned int i = start; i < end; i++)
+    for(unsigned int i=start; i<end; i++) 
     {
         // bottom-left vertex:
         quads[i].bl.texCoords.u = left;
@@ -241,10 +225,10 @@ void ParticleSystemQuad::updateTexCoords()
     }
 }
 
-void ParticleSystemQuad::setTextureWithRect(Texture2D* texture, const Rect& rect)
+void ParticleSystemQuad::setTextureWithRect(Texture2D *texture, const Rect& rect)
 {
     // Only update the texture if is different from the current one
-    if (!_texture || texture->getName() != _texture->getName())
+    if( !_texture || texture->getBackendTexture() != _texture->getBackendTexture() )
     {
         ParticleSystem::setTexture(texture);
     }
@@ -258,69 +242,66 @@ void ParticleSystemQuad::setTexture(Texture2D* texture)
     this->setTextureWithRect(texture, Rect(0, 0, s.width, s.height));
 }
 
-void ParticleSystemQuad::setDisplayFrame(SpriteFrame* spriteFrame)
+void ParticleSystemQuad::setDisplayFrame(SpriteFrame *spriteFrame)
 {
-    CCASSERT(spriteFrame->getOffsetInPixels().isZero(), "QuadParticle only supports SpriteFrames with no offsets");
+    CCASSERT(spriteFrame->getOffsetInPixels().isZero(), 
+             "QuadParticle only supports SpriteFrames with no offsets");
 
-    // update texture before updating texture rect
-    if (!_texture || spriteFrame->getTexture()->getName() != _texture->getName())
-    {
-        this->setTexture(spriteFrame->getTexture());
-    }
+    this->setTextureWithRect(spriteFrame->getTexture(), spriteFrame->getRect());
 }
 
 void ParticleSystemQuad::initIndices()
 {
-    for (int i = 0; i < _totalParticles; ++i)
+    for(int i = 0; i < _totalParticles; ++i)
     {
-        const unsigned int i6 = i * 6;
-        const unsigned int i4 = i * 4;
-        _indices[i6 + 0] = static_cast<GLushort>(i4) + 0;
-        _indices[i6 + 1] = static_cast<GLushort>(i4) + 1;
-        _indices[i6 + 2] = static_cast<GLushort>(i4) + 2;
-
-        _indices[i6 + 5] = static_cast<GLushort>(i4) + 1;
-        _indices[i6 + 4] = static_cast<GLushort>(i4) + 2;
-        _indices[i6 + 3] = static_cast<GLushort>(i4) + 3;
+        const unsigned int i6 = i*6;
+        const unsigned int i4 = i*4;
+        _indices[i6+0] = (unsigned short) i4+0;
+        _indices[i6+1] = (unsigned short) i4+1;
+        _indices[i6+2] = (unsigned short) i4+2;
+
+        _indices[i6+5] = (unsigned short) i4+1;
+        _indices[i6+4] = (unsigned short) i4+2;
+        _indices[i6+3] = (unsigned short) i4+3;
     }
 }
 
-inline void updatePosWithParticle(V3F_C4B_T2F_Quad* quad, const Vec2& newPosition, float size, float rotation)
+inline void updatePosWithParticle(V3F_C4B_T2F_Quad *quad, const Vec2& newPosition,float size,float rotation)
 {
     // vertices
-    GLfloat size_2 = size / 2;
-    GLfloat x1 = -size_2;
-    GLfloat y1 = -size_2;
-
-    GLfloat x2 = size_2;
-    GLfloat y2 = size_2;
-    GLfloat x = newPosition.x;
-    GLfloat y = newPosition.y;
-
-    GLfloat r = static_cast<GLfloat>(-CC_DEGREES_TO_RADIANS(rotation));
-    GLfloat cr = std::cos(r);
-    GLfloat sr = std::sin(r);
-    GLfloat ax = x1 * cr - y1 * sr + x;
-    GLfloat ay = x1 * sr + y1 * cr + y;
-    GLfloat bx = x2 * cr - y1 * sr + x;
-    GLfloat by = x2 * sr + y1 * cr + y;
-    GLfloat cx = x2 * cr - y2 * sr + x;
-    GLfloat cy = x2 * sr + y2 * cr + y;
-    GLfloat dx = x1 * cr - y2 * sr + x;
-    GLfloat dy = x1 * sr + y2 * cr + y;
-
+    float size_2 = size/2;
+    float x1 = -size_2;
+    float y1 = -size_2;
+    
+    float x2 = size_2;
+    float y2 = size_2;
+    float x = newPosition.x;
+    float y = newPosition.y;
+    
+    float r = (float)-CC_DEGREES_TO_RADIANS(rotation);
+    float cr = cosf(r);
+    float sr = sinf(r);
+    float ax = x1 * cr - y1 * sr + x;
+    float ay = x1 * sr + y1 * cr + y;
+    float bx = x2 * cr - y1 * sr + x;
+    float by = x2 * sr + y1 * cr + y;
+    float cx = x2 * cr - y2 * sr + x;
+    float cy = x2 * sr + y2 * cr + y;
+    float dx = x1 * cr - y2 * sr + x;
+    float dy = x1 * sr + y2 * cr + y;
+    
     // bottom-left
     quad->bl.vertices.x = ax;
     quad->bl.vertices.y = ay;
-
+    
     // bottom-right vertex:
     quad->br.vertices.x = bx;
     quad->br.vertices.y = by;
-
+    
     // top-left vertex:
     quad->tl.vertices.x = dx;
     quad->tl.vertices.y = dy;
-
+    
     // top-right vertex:
     quad->tr.vertices.x = cx;
     quad->tr.vertices.y = cy;
@@ -328,11 +309,10 @@ inline void updatePosWithParticle(V3F_C4B_T2F_Quad* quad, const Vec2& newPositio
 
 void ParticleSystemQuad::updateParticleQuads()
 {
-    if (_particleCount <= 0)
-    {
+    if (_particleCount <= 0) {
         return;
     }
-
+ 
     Vec2 currentPosition;
     if (_positionType == PositionType::FREE)
     {
@@ -342,12 +322,12 @@ void ParticleSystemQuad::updateParticleQuads()
     {
         currentPosition = _position;
     }
-
-    V3F_C4B_T2F_Quad* startQuad;
+    
+    V3F_C4B_T2F_Quad *startQuad;
     Vec2 pos = Vec2::ZERO;
     if (_batchNode)
     {
-        V3F_C4B_T2F_Quad* batchQuads = _batchNode->getTextureAtlas()->getQuads();
+        V3F_C4B_T2F_Quad *batchQuads = _batchNode->getTextureAtlas()->getQuads();
         startQuad = &(batchQuads[_atlasIndex]);
         pos = _position;
     }
@@ -355,12 +335,12 @@ void ParticleSystemQuad::updateParticleQuads()
     {
         startQuad = &(_quads[0]);
     }
-
-    if (_positionType == PositionType::FREE)
+    
+    if( _positionType == PositionType::FREE )
     {
         Vec3 p1(currentPosition.x, currentPosition.y, 0);
         Mat4 worldToNodeTM = getWorldToNodeTransform();
-        worldToNodeTM.transformPoint(p1);
+        worldToNodeTM.transformPoint(&p1);
         Vec3 p2;
         Vec2 newPos;
         float* startX = _particleData.startPosX;
@@ -370,32 +350,18 @@ void ParticleSystemQuad::updateParticleQuads()
         float* s = _particleData.size;
         float* r = _particleData.rotation;
         V3F_C4B_T2F_Quad* quadStart = startQuad;
-        for (int i = 0; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)
+        for (int i = 0 ; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)
         {
             p2.set(*startX, *startY, 0);
-            worldToNodeTM.transformPoint(p2);
-            newPos.set(*x, *y);
+            worldToNodeTM.transformPoint(&p2);
+            newPos.set(*x,*y);
             p2 = p1 - p2;
             newPos.x -= p2.x - pos.x;
             newPos.y -= p2.y - pos.y;
             updatePosWithParticle(quadStart, newPos, *s, *r);
         }
     }
-    else if (_positionType == PositionType::WORLD)
-    {
-        Vec2 newPos;
-        float* x = _particleData.posx;
-        float* y = _particleData.posy;
-        float* s = _particleData.size;
-        float* r = _particleData.rotation;
-        V3F_C4B_T2F_Quad* quadStart = startQuad;
-        for (int i = 0; i < _particleCount; ++i, ++x, ++y, ++quadStart, ++s, ++r)
-        {
-            newPos.set(*x, *y);
-            updatePosWithParticle(quadStart, newPos, *s, *r);
-        }
-    }
-    else if (_positionType == PositionType::RELATIVE)
+    else if( _positionType == PositionType::RELATIVE )
     {
         Vec2 newPos;
         float* startX = _particleData.startPosX;
@@ -405,7 +371,7 @@ void ParticleSystemQuad::updateParticleQuads()
         float* s = _particleData.size;
         float* r = _particleData.rotation;
         V3F_C4B_T2F_Quad* quadStart = startQuad;
-        for (int i = 0; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)
+        for (int i = 0 ; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)
         {
             newPos.set(*x, *y);
             newPos.x = *x - (currentPosition.x - *startX);
@@ -424,28 +390,28 @@ void ParticleSystemQuad::updateParticleQuads()
         float* s = _particleData.size;
         float* r = _particleData.rotation;
         V3F_C4B_T2F_Quad* quadStart = startQuad;
-        for (int i = 0; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)
+        for (int i = 0 ; i < _particleCount; ++i, ++startX, ++startY, ++x, ++y, ++quadStart, ++s, ++r)
         {
             newPos.set(*x + pos.x, *y + pos.y);
             updatePosWithParticle(quadStart, newPos, *s, *r);
         }
     }
-
-    // set color
-    if (_opacityModifyRGB)
+    
+    //set color
+    if(_opacityModifyRGB)
     {
         V3F_C4B_T2F_Quad* quad = startQuad;
         float* r = _particleData.colorR;
         float* g = _particleData.colorG;
         float* b = _particleData.colorB;
         float* a = _particleData.colorA;
-
-        for (int i = 0; i < _particleCount; ++i, ++quad, ++r, ++g, ++b, ++a)
+        
+        for (int i = 0; i < _particleCount; ++i,++quad,++r,++g,++b,++a)
         {
-            GLubyte colorR = *r * *a * 255;
-            GLubyte colorG = *g * *a * 255;
-            GLubyte colorB = *b * *a * 255;
-            GLubyte colorA = *a * 255;
+            uint8_t colorR = *r * *a * 255;
+            uint8_t colorG = *g * *a * 255;
+            uint8_t colorB = *b * *a * 255;
+            uint8_t colorA = *a * 255;
             quad->bl.colors.set(colorR, colorG, colorB, colorA);
             quad->br.colors.set(colorR, colorG, colorB, colorA);
             quad->tl.colors.set(colorR, colorG, colorB, colorA);
@@ -459,13 +425,13 @@ void ParticleSystemQuad::updateParticleQuads()
         float* g = _particleData.colorG;
         float* b = _particleData.colorB;
         float* a = _particleData.colorA;
-
-        for (int i = 0; i < _particleCount; ++i, ++quad, ++r, ++g, ++b, ++a)
+        
+        for (int i = 0; i < _particleCount; ++i,++quad,++r,++g,++b,++a)
         {
-            GLubyte colorR = *r * 255;
-            GLubyte colorG = *g * 255;
-            GLubyte colorB = *b * 255;
-            GLubyte colorA = *a * 255;
+            uint8_t colorR = *r * 255;
+            uint8_t colorG = *g * 255;
+            uint8_t colorB = *b * 255;
+            uint8_t colorA = *a * 255;
             quad->bl.colors.set(colorR, colorG, colorB, colorA);
             quad->br.colors.set(colorR, colorG, colorB, colorA);
             quad->tl.colors.set(colorR, colorG, colorB, colorA);
@@ -474,35 +440,19 @@ void ParticleSystemQuad::updateParticleQuads()
     }
 }
 
-void ParticleSystemQuad::postStep()
-{
-    glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]);
-
-    // Option 1: Sub Data
-    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(_quads[0]) * _totalParticles, _quads);
-
-    // Option 2: Data
-    //  glBufferData(GL_ARRAY_BUFFER, sizeof(quads_[0]) * particleCount, quads_, GL_DYNAMIC_DRAW);
-
-    // Option 3: Orphaning + glMapBuffer
-    // glBufferData(GL_ARRAY_BUFFER, sizeof(_quads[0])*_totalParticles, nullptr, GL_STREAM_DRAW);
-    // void *buf = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
-    // memcpy(buf, _quads, sizeof(_quads[0])*_totalParticles);
-    // glUnmapBuffer(GL_ARRAY_BUFFER);
-
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-
-    CHECK_GL_ERROR_DEBUG();
-}
-
 // overriding draw method
-void ParticleSystemQuad::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void ParticleSystemQuad::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
-    // quad command
-    if (_particleCount > 0)
-    {
-        _quadCommand.init(_globalZOrder, _texture, getGLProgramState(), _blendFunc, _quads, _particleCount,
-                          _positionType == PositionType::WORLD ? Mat4::IDENTITY : transform, flags);
+    //quad command
+    if(_particleCount > 0)
+    {
+        auto programState = _quadCommand.getPipelineDescriptor().programState;
+        programState->setTexture(_textureLocation, 0, _texture->getBackendTexture());
+        
+        cocos2d::Mat4 projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+        programState->setUniform(_mvpMatrixLocaiton, projectionMat.m, sizeof(projectionMat.m));
+        
+        _quadCommand.init(_globalZOrder, _texture, _blendFunc, _quads, _particleCount, transform, flags);
         renderer->addCommand(&_quadCommand);
     }
 }
@@ -511,7 +461,7 @@ void ParticleSystemQuad::setTotalParticles(int tp)
 {
     // If we are setting the total number of particles to a number higher
     // than what is allocated, we need to allocate new arrays
-    if (tp > _allocatedParticles)
+    if( tp > _allocatedParticles )
     {
         // Allocate new memory
         size_t quadsSize = sizeof(_quads[0]) * tp * 1;
@@ -523,8 +473,8 @@ void ParticleSystemQuad::setTotalParticles(int tp)
             CCLOG("Particle system: not enough memory");
             return;
         }
-        V3F_C4B_T2F_Quad* quadsNew = static_cast<V3F_C4B_T2F_Quad*>(realloc(_quads, quadsSize));
-        GLushort* indicesNew = static_cast<GLushort*>(realloc(_indices, indicesSize));
+        V3F_C4B_T2F_Quad* quadsNew = (V3F_C4B_T2F_Quad*)realloc(_quads, quadsSize);
+        unsigned short* indicesNew = (unsigned short*)realloc(_indices, indicesSize);
 
         if (quadsNew && indicesNew)
         {
@@ -535,16 +485,14 @@ void ParticleSystemQuad::setTotalParticles(int tp)
             // Clear the memory
             memset(_quads, 0, quadsSize);
             memset(_indices, 0, indicesSize);
-
+            
             _allocatedParticles = tp;
         }
         else
         {
             // Out of memory, failed to resize some array
-            if (quadsNew)
-                _quads = quadsNew;
-            if (indicesNew)
-                _indices = indicesNew;
+            if (quadsNew) _quads = quadsNew;
+            if (indicesNew) _indices = indicesNew;
 
             CCLOG("Particle system: out of memory");
             return;
@@ -562,15 +510,8 @@ void ParticleSystemQuad::setTotalParticles(int tp)
         }
 
         initIndices();
-        if (Configuration::getInstance()->supportsShareableVAO())
-        {
-            setupVBOandVAO();
-        }
-        else
-        {
-            setupVBO();
-        }
-
+//        setupVBO();
+        
         // fixed http://www.cocos2d-x.org/issues/3990
         // Updates texture coords.
         updateTexCoords();
@@ -579,159 +520,87 @@ void ParticleSystemQuad::setTotalParticles(int tp)
     {
         _totalParticles = tp;
     }
-
+    
     // fixed issue #5762
     // reset the emission rate
     setEmissionRate(_totalParticles / _life);
-
+    
     resetSystem();
 }
 
-void ParticleSystemQuad::setupVBOandVAO()
+void ParticleSystemQuad::listenRendererRecreated(EventCustom* /*event*/)
 {
-    // clean VAO
-    glDeleteBuffers(2, &_buffersVBO[0]);
-    glDeleteVertexArrays(1, &_VAOname);
-    GL::bindVAO(0);
-
-    glGenVertexArrays(1, &_VAOname);
-    GL::bindVAO(_VAOname);
-
-#define kQuadSize sizeof(_quads[0].bl)
-
-    glGenBuffers(2, &_buffersVBO[0]);
-
-    glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]);
-    glBufferData(GL_ARRAY_BUFFER, sizeof(_quads[0]) * _totalParticles, _quads, GL_DYNAMIC_DRAW);
-
-    GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX, _VAOname);
-    // vertices
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, kQuadSize, reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, vertices)));
-
-    // colors
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, colors)));
-
-    // tex coords
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, kQuadSize, reinterpret_cast<GLvoid*>(offsetof(V3F_C4B_T2F, texCoords)));
-
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _buffersVBO[1]);
-    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(_indices[0]) * _totalParticles * 6, _indices, GL_STATIC_DRAW);
-
-    // Must unbind the VAO before changing the element buffer.
-    GL::bindVAO(0);
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-
-    CHECK_GL_ERROR_DEBUG();
-}
-
-void ParticleSystemQuad::setupVBO()
-{
-    glDeleteBuffers(2, &_buffersVBO[0]);
-
-    glGenBuffers(2, &_buffersVBO[0]);
-
-    glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]);
-    glBufferData(GL_ARRAY_BUFFER, sizeof(_quads[0]) * _totalParticles, _quads, GL_DYNAMIC_DRAW);
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _buffersVBO[1]);
-    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(_indices[0]) * _totalParticles * 6, _indices, GL_STATIC_DRAW);
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-
-    CHECK_GL_ERROR_DEBUG();
-}
-
-void ParticleSystemQuad::listenRendererRecreated(EventCustom* event)
-{
-    // when comes to foreground in android, _buffersVBO and _VAOname is a wild handle
-    // before recreating, we need to reset them to 0
-    memset(_buffersVBO, 0, sizeof(_buffersVBO));
-    if (Configuration::getInstance()->supportsShareableVAO())
-    {
-        _VAOname = 0;
-        setupVBOandVAO();
-    }
-    else
-    {
-        setupVBO();
-    }
+    //when comes to foreground in android, _buffersVBO and _VAOname is a wild handle
+    //before recreating, we need to reset them to 0
+//    memset(_buffersVBO, 0, sizeof(_buffersVBO));
+//    if (Configuration::getInstance()->supportsShareableVAO())
+//    {
+//        _VAOname = 0;
+//        setupVBOandVAO();
+//    }
+//    else
+//    {
+//        setupVBO();
+//    }
 }
 
 bool ParticleSystemQuad::allocMemory()
 {
-    CCASSERT(!_batchNode, "Memory should not be alloced when not using batchNode");
-
-    CC_SAFE_FREE(_quads);
-    CC_SAFE_FREE(_indices);
+    CCASSERT( !_batchNode, "Memory should not be alloced when not using batchNode");
 
-    _quads = static_cast<V3F_C4B_T2F_Quad*>(malloc(_totalParticles * sizeof(V3F_C4B_T2F_Quad)));
-    _indices = static_cast<GLushort*>(malloc(_totalParticles * 6 * sizeof(GLushort)));
+    CC_SAFE_DELETE_ARRAY(_quads);;
+    CC_SAFE_DELETE_ARRAY(_indices);;
 
-    if (!_quads || !_indices)
+    _quads = (V3F_C4B_T2F_Quad*)malloc(_totalParticles * sizeof(V3F_C4B_T2F_Quad));
+    _indices = (unsigned short*)malloc(_totalParticles * 6 * sizeof(unsigned short));
+    
+    if( !_quads || !_indices) 
     {
         CCLOG("cocos2d: Particle system: not enough memory");
-        CC_SAFE_FREE(_quads);
-        CC_SAFE_FREE(_indices);
+        CC_SAFE_DELETE_ARRAY(_quads);;
+        CC_SAFE_DELETE_ARRAY(_indices);;
 
         return false;
     }
 
     memset(_quads, 0, _totalParticles * sizeof(V3F_C4B_T2F_Quad));
-    memset(_indices, 0, _totalParticles * 6 * sizeof(GLushort));
+    memset(_indices, 0, _totalParticles * 6 * sizeof(unsigned short));
 
     return true;
 }
 
-void ParticleSystemQuad::setBatchNode(ParticleBatchNode* batchNode)
+void ParticleSystemQuad::setBatchNode(ParticleBatchNode * batchNode)
 {
-    if (_batchNode != batchNode)
+    if( _batchNode != batchNode ) 
     {
         ParticleBatchNode* oldBatch = _batchNode;
 
         ParticleSystem::setBatchNode(batchNode);
 
         // NEW: is self render ?
-        if (!batchNode)
+        if( ! batchNode ) 
         {
             allocMemory();
             initIndices();
             setTexture(oldBatch->getTexture());
-            if (Configuration::getInstance()->supportsShareableVAO())
-            {
-                setupVBOandVAO();
-            }
-            else
-            {
-                setupVBO();
-            }
+//            setupVBO();
         }
         // OLD: was it self render ? cleanup
-        else if (!oldBatch)
+        else if( !oldBatch )
         {
             // copy current state to batch
-            V3F_C4B_T2F_Quad* batchQuads = _batchNode->getTextureAtlas()->getQuads();
-            V3F_C4B_T2F_Quad* quad = &(batchQuads[_atlasIndex]);
-            memcpy(quad, _quads, _totalParticles * sizeof(_quads[0]));
-
-            CC_SAFE_FREE(_quads);
-            CC_SAFE_FREE(_indices);
+            V3F_C4B_T2F_Quad *batchQuads = _batchNode->getTextureAtlas()->getQuads();
+            V3F_C4B_T2F_Quad *quad = &(batchQuads[_atlasIndex] );
+            memcpy( quad, _quads, _totalParticles * sizeof(_quads[0]) );
 
-            glDeleteBuffers(2, &_buffersVBO[0]);
-            memset(_buffersVBO, 0, sizeof(_buffersVBO));
-            if (Configuration::getInstance()->supportsShareableVAO())
-            {
-                glDeleteVertexArrays(1, &_VAOname);
-                GL::bindVAO(0);
-                _VAOname = 0;
-            }
+            CC_SAFE_DELETE_ARRAY(_quads);;
+            CC_SAFE_DELETE_ARRAY(_indices);;
         }
     }
 }
 
-ParticleSystemQuad* ParticleSystemQuad::create()
-{
-    ParticleSystemQuad* particleSystemQuad = new (std::nothrow) ParticleSystemQuad();
+ParticleSystemQuad * ParticleSystemQuad::create() {
+    ParticleSystemQuad *particleSystemQuad = new (std::nothrow) ParticleSystemQuad();
     if (particleSystemQuad && particleSystemQuad->init())
     {
         particleSystemQuad->autorelease();
diff --git a/cocos2d/cocos/2d/CCParticleSystemQuad.h b/cocos2d/cocos/2d/CCParticleSystemQuad.h
index 4ea1c6190b..843e9abdd4 100644
--- a/cocos2d/cocos/2d/CCParticleSystemQuad.h
+++ b/cocos2d/cocos/2d/CCParticleSystemQuad.h
@@ -4,7 +4,8 @@ Copyright (c) 2009      Leonardo Kasperavičius
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -25,30 +26,15 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_PARTICLESYSTEMQUAD_H
-#define CC_2D_PARTICLESYSTEMQUAD_H
+#pragma once
 
 #include <cocos/2d/CCParticleSystem.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 #include <cocos/renderer/CCQuadCommand.h>
 
-#include <cstdint>
-#include <iosfwd>
-
 NS_CC_BEGIN
 
-class EventCustom;
-class ParticleBatchNode;
-class Rect;
-class Renderer;
 class SpriteFrame;
-class Texture2D;
-struct V3F_C4B_T2F_Quad;
+class EventCustom;
 
 /**
  * @addtogroup _2d
@@ -60,7 +46,7 @@ struct V3F_C4B_T2F_Quad;
 
 It includes all the features of ParticleSystem.
 
-Special features and Limitations:
+Special features and Limitations:    
 - Particle size can be any float number.
 - The system can be scaled.
 - The particles can be rotated.
@@ -72,30 +58,31 @@ Special features and Limitations:
 class CC_DLL ParticleSystemQuad : public ParticleSystem
 {
 public:
+
     /** Creates a Particle Emitter.
      *
      * @return An autoreleased ParticleSystemQuad object.
      */
-    static ParticleSystemQuad* create();
+    static ParticleSystemQuad * create();
     /** Creates a Particle Emitter with a number of particles.
      *
      * @param numberOfParticles A given number of particles.
      * @return An autoreleased ParticleSystemQuad object.
      */
-    static ParticleSystemQuad* createWithTotalParticles(int numberOfParticles);
+    static ParticleSystemQuad * createWithTotalParticles(int numberOfParticles);
     /** Creates an initializes a ParticleSystemQuad from a plist file.
      This plist files can be created manually or with Particle Designer.
      *
      * @param filename Particle plist file name.
      * @return An autoreleased ParticleSystemQuad object.
      */
-    static ParticleSystemQuad* create(const std::string& filename);
+    static ParticleSystemQuad * create(const std::string& filename);
     /** Creates a Particle Emitter with a dictionary.
-     *
+     * 
      * @param dictionary Particle dictionary.
      * @return An autoreleased ParticleSystemQuad object.
      */
-    static ParticleSystemQuad* create(ValueMap& dictionary);
+    static ParticleSystemQuad * create(ValueMap &dictionary);
 
     /** Sets a new SpriteFrame as particle.
     WARNING: this method is experimental. Use setTextureWithRect instead.
@@ -103,7 +90,7 @@ public:
      * @param spriteFrame A given sprite frame as particle texture.
     @since v0.99.4
     */
-    void setDisplayFrame(SpriteFrame* spriteFrame);
+    void setDisplayFrame(SpriteFrame *spriteFrame);
 
     /** Sets a new texture with a rect. The rect is in Points.
      @since v0.99.4
@@ -113,7 +100,7 @@ public:
      * @param texture A given texture.
      8 @param rect A given rect, in points.
      */
-    void setTextureWithRect(Texture2D* texture, const Rect& rect);
+    void setTextureWithRect(Texture2D *texture, const Rect& rect);
 
     /** Listen the event that renderer was recreated on Android/WP8.
      * @js NA
@@ -131,18 +118,13 @@ public:
     /**
      * @js NA
      * @lua NA
-     */
+     */    
     virtual void updateParticleQuads() override;
     /**
      * @js NA
      * @lua NA
      */
-    virtual void postStep() override;
-    /**
-     * @js NA
-     * @lua NA
-     */
-    virtual void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
     /**
      * @js NA
@@ -156,18 +138,18 @@ public:
     virtual void setTotalParticles(int tp) override;
 
     virtual std::string getDescription() const override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ParticleSystemQuad();
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ParticleSystemQuad();
     /**
      * @js NA
      * @lua NA
      */
-    ~ParticleSystemQuad() override;
-
+    virtual ~ParticleSystemQuad();
+    
     // Overrides
     /**
      * @js NA
@@ -178,31 +160,29 @@ public:
 protected:
     /** initializes the indices for the vertices*/
     void initIndices();
-
+    
     /** initializes the texture with a rectangle measured Points */
     void initTexCoordsWithRect(const Rect& rect);
-
+    
     /** Updates texture coords */
     void updateTexCoords();
 
-    void setupVBOandVAO();
-    void setupVBO();
     bool allocMemory();
 
-    V3F_C4B_T2F_Quad* _quads; // quads to be rendered
-    GLushort* _indices; // indices
-    GLuint _VAOname;
-    GLuint _buffersVBO[2]; // 0: vertex  1: indices
-
-    QuadCommand _quadCommand; // quad command
+    V3F_C4B_T2F_Quad    *_quads = nullptr;        // quads to be rendered
+    unsigned short      *_indices = nullptr;      // indices
 
+    QuadCommand _quadCommand;           // quad command
+    
+    backend::UniformLocation _mvpMatrixLocaiton;
+    backend::UniformLocation _textureLocation;
+    backend::ProgramState* _programState = nullptr;
+    
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSystemQuad)
+    CC_DISALLOW_COPY_AND_ASSIGN(ParticleSystemQuad);
 };
 
 // end of _2d group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_PARTICLESYSTEMQUAD_H
diff --git a/cocos2d/cocos/2d/CCProgressTimer.cpp b/cocos2d/cocos/2d/CCProgressTimer.cpp
index fd9b6342d4..01955ec385 100644
--- a/cocos2d/cocos/2d/CCProgressTimer.cpp
+++ b/cocos2d/cocos/2d/CCProgressTimer.cpp
@@ -1,7 +1,8 @@
 /****************************************************************************
 Copyright (c) 2010      Lam Pham
 Copyright (c) 2010-2012 cocos2d-x.org
-Copyright (c) 2013-2016 Chukong Technologies Inc
+Copyright (c) 2013-2017 Chukong Technologies Inc
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,16 +26,15 @@ THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCProgressTimer.h>
 
-#include <cocos/2d/CCSprite.h>
-#include <cocos/base/CCDirector.h>
+#include <algorithm>
+
 #include <cocos/base/ccMacros.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/2d/CCSprite.h>
 #include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/ccGLStateCache.h>
-
-#include <algorithm>
-#include <limits>
+#include <cocos/base/ccUtils.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 
@@ -42,65 +42,100 @@ NS_CC_BEGIN
 //  kProgressTextureCoords holds points {0,1} {0,0} {1,0} {1,1} we can represent it as bits
 const char kProgressTextureCoords = 0x4b;
 
-ProgressTimer::ProgressTimer()
-: _type(Type::RADIAL)
-, _midpoint(0, 0)
-, _barChangeRate(0, 0)
-, _percentage(0.0f)
-, _sprite(nullptr)
-, _vertexDataCount(0)
-, _vertexData(nullptr)
-, _reverseDirection(false)
+namespace
 {
+    backend::ProgramState* initPipelineDescriptor(cocos2d::CustomCommand& command, bool ridal, backend::UniformLocation &locMVP, backend::UniformLocation &locTexture)
+    {
+        auto& pipelieDescriptor = command.getPipelineDescriptor();
+        auto programState = new (std::nothrow) backend::ProgramState(positionTextureColor_vert, positionTextureColor_frag);
+        CC_SAFE_RELEASE(pipelieDescriptor.programState);
+        pipelieDescriptor.programState = programState;
+        
+        //set vertexLayout according to V2F_C4B_T2F structure
+        auto vertexLayout = programState->getVertexLayout();
+        const auto& attributeInfo = programState->getProgram()->getActiveAttributes();
+        auto iter = attributeInfo.find("a_position");
+        if(iter != attributeInfo.end())
+        {
+            vertexLayout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT2, 0, false);
+        }
+        iter = attributeInfo.find("a_texCoord");
+        if(iter != attributeInfo.end())
+        {
+            vertexLayout->setAttribute("a_texCoord", iter->second.location, backend::VertexFormat::FLOAT2, offsetof(V2F_C4B_T2F, texCoords), false);
+        }
+        iter = attributeInfo.find("a_color");
+        if(iter != attributeInfo.end())
+        {
+            vertexLayout->setAttribute("a_color", iter->second.location, backend::VertexFormat::UBYTE4, offsetof(V2F_C4B_T2F, colors), true);
+        }
+        vertexLayout->setLayout(sizeof(V2F_C4B_T2F));
+
+        if (ridal)
+        {
+            command.setDrawType(CustomCommand::DrawType::ELEMENT);
+            command.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE);
+        }
+        else
+        {
+            command.setDrawType(CustomCommand::DrawType::ARRAY);
+            command.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE_STRIP);
+        }
+
+
+        locMVP = programState->getUniformLocation("u_MVPMatrix");
+        locTexture = programState->getUniformLocation("u_texture");
+
+        return programState;
+    }
 }
 
+
 ProgressTimer* ProgressTimer::create(Sprite* sp)
 {
-    ProgressTimer* progressTimer = new (std::nothrow) ProgressTimer();
+    ProgressTimer *progressTimer = new (std::nothrow) ProgressTimer();
     if (progressTimer && progressTimer->initWithSprite(sp))
     {
         progressTimer->autorelease();
         return progressTimer;
     }
-
+    
     delete progressTimer;
     return nullptr;
 }
 
 bool ProgressTimer::initWithSprite(Sprite* sp)
 {
-    setPercentage(0.0f);
-    _vertexData = nullptr;
-    _vertexDataCount = 0;
-
-    setAnchorPoint(Vec2(0.5f, 0.5f));
-    _type = Type::RADIAL;
-    _reverseDirection = false;
+    setAnchorPoint(Vec2(0.5f,0.5f));
     setMidpoint(Vec2(0.5f, 0.5f));
-    setBarChangeRate(Vec2(1, 1));
+    setBarChangeRate(Vec2(1,1));
     setSprite(sp);
 
-    // shader state
-    setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR, sp->getTexture()));
+    CC_SAFE_RELEASE(_programState);
+    CC_SAFE_RELEASE(_programState2);
+    _programState = initPipelineDescriptor(_customCommand, true, _locMVP1, _locTex1); 
+    _programState2 = initPipelineDescriptor(_customCommand2, false, _locMVP2, _locTex2);
+    
     return true;
 }
 
-ProgressTimer::~ProgressTimer(void)
+ProgressTimer::~ProgressTimer()
 {
-    CC_SAFE_FREE(_vertexData);
     CC_SAFE_RELEASE(_sprite);
+    CC_SAFE_RELEASE(_programState);
+    CC_SAFE_RELEASE(_programState2);
 }
 
 void ProgressTimer::setPercentage(float percentage)
 {
-    if (std::abs(_percentage - percentage) > std::numeric_limits<float>::epsilon())
+    if (_percentage != percentage)
     {
         _percentage = clampf(percentage, 0, 100);
         updateProgress();
     }
 }
 
-void ProgressTimer::setSprite(Sprite* sprite)
+void ProgressTimer::setSprite(Sprite *sprite)
 {
     if (_sprite != sprite)
     {
@@ -120,40 +155,42 @@ void ProgressTimer::setSprite(Sprite* sprite)
         setContentSize(_sprite->getContentSize());
 
         //    Every time we set a new sprite, we free the current vertex data
-        if (_vertexData)
+        if (!_vertexData.empty())
         {
-            CC_SAFE_FREE(_vertexData);
-            _vertexDataCount = 0;
+            _vertexData.clear();
             updateProgress();
         }
-    }
+    }        
 }
 
 void ProgressTimer::setType(Type type)
 {
+
+    if (type == Type::RADIAL)
+    {
+        _customCommand.setDrawType(CustomCommand::DrawType::ELEMENT);
+        _customCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE);
+    }
+    else
+    {
+        _customCommand.setPrimitiveType(CustomCommand::PrimitiveType::TRIANGLE_STRIP);
+        _customCommand.setDrawType(CustomCommand::DrawType::ARRAY);
+    }
+
     if (type != _type)
     {
         //    release all previous information
-        if (_vertexData)
-        {
-            CC_SAFE_FREE(_vertexData);
-            _vertexData = nullptr;
-            _vertexDataCount = 0;
-        }
-
+        _vertexData.clear();
         _type = type;
     }
 }
 
 void ProgressTimer::setReverseDirection(bool reverse)
 {
-    if (_reverseDirection != reverse)
-    {
+    if( _reverseDirection != reverse ) {
         _reverseDirection = reverse;
-
         //    release all previous information
-        CC_SAFE_FREE(_vertexData);
-        _vertexDataCount = 0;
+        _vertexData.clear();
     }
 }
 
@@ -165,16 +202,14 @@ void ProgressTimer::setReverseDirection(bool reverse)
 Tex2F ProgressTimer::textureCoordFromAlphaPoint(Vec2 alpha)
 {
     Tex2F ret(0.0f, 0.0f);
-    if (!_sprite)
-    {
+    if (!_sprite) {
         return ret;
     }
     V3F_C4B_T2F_Quad quad = _sprite->getQuad();
-    Vec2 min(quad.bl.texCoords.u, quad.bl.texCoords.v);
-    Vec2 max(quad.tr.texCoords.u, quad.tr.texCoords.v);
+    Vec2 min(quad.bl.texCoords.u,quad.bl.texCoords.v);
+    Vec2 max(quad.tr.texCoords.u,quad.tr.texCoords.v);
     //  Fix bug #1303 so that progress timer handles sprite frame texture rotation
-    if (_sprite->isTextureRectRotated())
-    {
+    if (_sprite->isTextureRectRotated()) {
         std::swap(alpha.x, alpha.y);
     }
     return Tex2F(min.x * (1.f - alpha.x) + max.x * alpha.x, min.y * (1.f - alpha.y) + max.y * alpha.y);
@@ -183,45 +218,44 @@ Tex2F ProgressTimer::textureCoordFromAlphaPoint(Vec2 alpha)
 Vec2 ProgressTimer::vertexFromAlphaPoint(Vec2 alpha)
 {
     Vec2 ret(0.0f, 0.0f);
-    if (!_sprite)
-    {
+    if (!_sprite) {
         return ret;
     }
     V3F_C4B_T2F_Quad quad = _sprite->getQuad();
-    Vec2 min(quad.bl.vertices.x, quad.bl.vertices.y);
-    Vec2 max(quad.tr.vertices.x, quad.tr.vertices.y);
+    Vec2 min(quad.bl.vertices.x,quad.bl.vertices.y);
+    Vec2 max(quad.tr.vertices.x,quad.tr.vertices.y);
     ret.x = min.x * (1.f - alpha.x) + max.x * alpha.x;
     ret.y = min.y * (1.f - alpha.y) + max.y * alpha.y;
     return ret;
 }
 
-void ProgressTimer::updateColor(void)
+void ProgressTimer::updateColor()
 {
     if (!_sprite)
-    {
         return;
-    }
 
-    if (_vertexData)
+    if (!_vertexData.empty())
     {
-        Color4B sc = _sprite->getQuad().tl.colors;
-        for (int i = 0; i < _vertexDataCount; ++i)
+        const Color4B& sc = _sprite->getQuad().tl.colors;
+        for (int i = 0; i < _vertexData.size(); ++i)
         {
             _vertexData[i].colors = sc;
         }
     }
 }
 
-void ProgressTimer::updateProgress(void)
+void ProgressTimer::updateProgress()
 {
     switch (_type)
     {
-        case Type::RADIAL:
-            updateRadial();
-            break;
-        case Type::BAR:
-            updateBar();
-            break;
+    case Type::RADIAL:
+        updateRadial();
+        break;
+    case Type::BAR:
+        updateBar();
+        break;
+    default:
+        break;
     }
 }
 
@@ -235,7 +269,7 @@ Vec2 ProgressTimer::getMidpoint() const
     return _midpoint;
 }
 
-void ProgressTimer::setColor(const Color3B& color)
+void ProgressTimer::setColor(const Color3B &color)
 {
     _sprite->setColor(color);
     updateColor();
@@ -246,13 +280,13 @@ const Color3B& ProgressTimer::getColor() const
     return _sprite->getColor();
 }
 
-void ProgressTimer::setOpacity(GLubyte opacity)
+void ProgressTimer::setOpacity(uint8_t opacity)
 {
     _sprite->setOpacity(opacity);
     updateColor();
 }
 
-GLubyte ProgressTimer::getOpacity() const
+uint8_t ProgressTimer::getOpacity() const
 {
     return _sprite->getOpacity();
 }
@@ -267,19 +301,18 @@ void ProgressTimer::setMidpoint(const Vec2& midPoint)
 //    It now doesn't occur the cost of free/alloc data every update cycle.
 //    It also only changes the percentage point but no other points if they have not
 //    been modified.
-//
+//    
 //    It now deals with flipped texture. If you run into this problem, just use the
 //    sprite property and enable the methods flipX, flipY.
 ///
-void ProgressTimer::updateRadial(void)
+void ProgressTimer::updateRadial()
 {
-    if (!_sprite)
-    {
+    if (!_sprite) {
         return;
     }
     float alpha = _percentage / 100.f;
 
-    float angle = 2.f * static_cast<float>(M_PI) * (_reverseDirection ? alpha : 1.0f - alpha);
+    float angle = 2.f*((float)M_PI) * ( _reverseDirection ? alpha : 1.0f - alpha);
 
     //    We find the vector to do a hit detection based on the percentage
     //    We know the first vector is the one @ 12 o'clock (top,mid) so we rotate
@@ -287,71 +320,60 @@ void ProgressTimer::updateRadial(void)
     Vec2 topMid(_midpoint.x, 1.f);
     Vec2 percentagePt = topMid.rotateByAngle(_midpoint, angle);
 
+
     int index = 0;
     Vec2 hit;
 
-    if (alpha == 0.f)
-    {
+    if (alpha == 0.f) {
         //    More efficient since we don't always need to check intersection
         //    If the alpha is zero then the hit point is top mid and the index is 0.
         hit = topMid;
         index = 0;
-    }
-    else if (alpha == 1.f)
-    {
+    } else if (alpha == 1.f) {
         //    More efficient since we don't always need to check intersection
         //    If the alpha is one then the hit point is top mid and the index is 4.
         hit = topMid;
         index = 4;
-    }
-    else
-    {
+    } else {
         //    We run a for loop checking the edges of the texture to find the
         //    intersection point
         //    We loop through five points since the top is split in half
 
-        float min_t = std::numeric_limits<float>::max();
+        float min_t = FLT_MAX;
 
-        for (int i = 0; i <= kProgressTextureCoordsCount; ++i)
-        {
-            int pIndex = (i + (kProgressTextureCoordsCount - 1)) % kProgressTextureCoordsCount;
+        for (int i = 0; i <= kProgressTextureCoordsCount; ++i) {
+            int pIndex = (i + (kProgressTextureCoordsCount - 1))%kProgressTextureCoordsCount;
 
             Vec2 edgePtA = boundaryTexCoord(i % kProgressTextureCoordsCount);
             Vec2 edgePtB = boundaryTexCoord(pIndex);
 
             //    Remember that the top edge is split in half for the 12 o'clock position
             //    Let's deal with that here by finding the correct endpoints
-            if (i == 0)
-            {
-                edgePtB = edgePtA.lerp(edgePtB, 1 - _midpoint.x);
-            }
-            else if (i == 4)
-            {
-                edgePtA = edgePtA.lerp(edgePtB, 1 - _midpoint.x);
+            if(i == 0){
+                edgePtB = edgePtA.lerp(edgePtB, 1-_midpoint.x);
+            } else if(i == 4){
+                edgePtA = edgePtA.lerp(edgePtB, 1-_midpoint.x);
             }
 
             //    s and t are returned by ccpLineIntersect
             float s = 0, t = 0;
-            if (Vec2::isLineIntersect(edgePtA, edgePtB, _midpoint, percentagePt, &s, &t))
+            if(Vec2::isLineIntersect(edgePtA, edgePtB, _midpoint, percentagePt, &s, &t))
             {
+
                 //    Since our hit test is on rays we have to deal with the top edge
                 //    being in split in half so we have to test as a segment
-                if ((i == 0 || i == 4))
-                {
+                if ((i == 0 || i == 4)) {
                     //    s represents the point between edgePtA--edgePtB
-                    if (!(0.f <= s && s <= 1.f))
-                    {
+                    if (!(0.f <= s && s <= 1.f)) {
                         continue;
                     }
                 }
                 //    As long as our t isn't negative we are at least finding a
                 //    correct hitpoint from _midpoint to percentagePt.
-                if (t >= 0.f)
-                {
+                if (t >= 0.f) {
                     //    Because the percentage line and all the texture edges are
                     //    rays we should only account for the shortest intersection
-                    if (t < min_t)
-                    {
+                    if (t < min_t) {
                         min_t = t;
                         index = i;
                     }
@@ -360,27 +382,26 @@ void ProgressTimer::updateRadial(void)
         }
 
         //    Now that we have the minimum magnitude we can use that to find our intersection
-        hit = _midpoint + ((percentagePt - _midpoint) * min_t);
+        hit = _midpoint+ ((percentagePt - _midpoint) * min_t);
     }
 
+
     //    The size of the vertex data is the index from the hitpoint
     //    the 3 is for the _midpoint, 12 o'clock point and hitpoint position.
 
     bool sameIndexCount = true;
-    if (_vertexDataCount != index + 3)
+    if (_vertexData.size() != index + 3)
     {
         sameIndexCount = false;
-        CC_SAFE_FREE(_vertexData);
-        _vertexDataCount = 0;
+        _vertexData.resize(index + 3);
+        _customCommand.createVertexBuffer(sizeof(_vertexData[0]), (unsigned int)_vertexData.size(),  CustomCommand::BufferUsage::DYNAMIC);
     }
 
-    if (!_vertexData)
+    if (_indexData.size() != 3 + 3 * index)
     {
-        _vertexDataCount = index + 3;
-        _vertexData = static_cast<V2F_C4B_T2F*>(malloc(_vertexDataCount * sizeof(V2F_C4B_T2F)));
-        CCASSERT(_vertexData, "CCProgressTimer. Not enough memory");
+        _indexData.resize(3 + 3 * index);
+        _customCommand.createIndexBuffer(CustomCommand::IndexFormat::U_SHORT, (unsigned int)_indexData.size(), CustomCommand::BufferUsage::STATIC);
     }
-    updateColor();
 
     if (!sameIndexCount)
     {
@@ -392,17 +413,29 @@ void ProgressTimer::updateRadial(void)
         _vertexData[1].texCoords = textureCoordFromAlphaPoint(topMid);
         _vertexData[1].vertices = vertexFromAlphaPoint(topMid);
 
-        for (int i = 0; i < index; ++i)
+        for(int i = 0; i < index; ++i)
         {
             Vec2 alphaPoint = boundaryTexCoord(i);
-            _vertexData[i + 2].texCoords = textureCoordFromAlphaPoint(alphaPoint);
-            _vertexData[i + 2].vertices = vertexFromAlphaPoint(alphaPoint);
+            _vertexData[i+2].texCoords = textureCoordFromAlphaPoint(alphaPoint);
+            _vertexData[i+2].vertices = vertexFromAlphaPoint(alphaPoint);
         }
+
+        for (int i = 0; i < index + 1; i++)
+        {
+            _indexData[i * 3] = 0;
+            _indexData[i * 3 + 1] = i + 2;
+            _indexData[i * 3 + 2] = i + 1;
+        }
+
+        _customCommand.updateIndexBuffer(_indexData.data(), (unsigned int)(_indexData.size() * sizeof(_indexData[0])) );
     }
 
     //    hitpoint will go last
-    _vertexData[_vertexDataCount - 1].texCoords = textureCoordFromAlphaPoint(hit);
-    _vertexData[_vertexDataCount - 1].vertices = vertexFromAlphaPoint(hit);
+    _vertexData[_vertexData.size() - 1].texCoords = textureCoordFromAlphaPoint(hit);
+    _vertexData[_vertexData.size() - 1].vertices = vertexFromAlphaPoint(hit);
+
+    updateColor();
+    _customCommand.updateVertexBuffer(_vertexData.data(), (unsigned int)(sizeof(_vertexData[0]) * _vertexData.size()) );
 }
 
 ///
@@ -410,110 +443,112 @@ void ProgressTimer::updateRadial(void)
 //    It now doesn't occur the cost of free/alloc data every update cycle.
 //    It also only changes the percentage point but no other points if they have not
 //    been modified.
-//
+//    
 //    It now deals with flipped texture. If you run into this problem, just use the
 //    sprite property and enable the methods flipX, flipY.
 ///
-void ProgressTimer::updateBar(void)
+void ProgressTimer::updateBar()
 {
     if (!_sprite)
-    {
         return;
-    }
+    
     float alpha = _percentage / 100.0f;
     Vec2 alphaOffset = Vec2(1.0f * (1.0f - _barChangeRate.x) + alpha * _barChangeRate.x, 1.0f * (1.0f - _barChangeRate.y) + alpha * _barChangeRate.y) * 0.5f;
     Vec2 min = _midpoint - alphaOffset;
     Vec2 max = _midpoint + alphaOffset;
 
-    if (min.x < 0.f)
-    {
+    if (min.x < 0.f) {
         max.x += -min.x;
         min.x = 0.f;
     }
 
-    if (max.x > 1.f)
-    {
+    if (max.x > 1.f) {
         min.x -= max.x - 1.f;
         max.x = 1.f;
     }
 
-    if (min.y < 0.f)
-    {
+    if (min.y < 0.f) {
         max.y += -min.y;
         min.y = 0.f;
     }
 
-    if (max.y > 1.f)
-    {
+    if (max.y > 1.f) {
         min.y -= max.y - 1.f;
         max.y = 1.f;
     }
 
-    if (!_reverseDirection)
-    {
-        if (!_vertexData)
+
+    if (!_reverseDirection) {
+        
+        if (_vertexData.size() != 4)
         {
-            _vertexDataCount = 4;
-            _vertexData = static_cast<V2F_C4B_T2F*>(malloc(_vertexDataCount * sizeof(V2F_C4B_T2F)));
-            CCASSERT(_vertexData, "CCProgressTimer. Not enough memory");
+            _vertexData.resize(4);
+            _customCommand.createVertexBuffer(sizeof(_vertexData[0]),(unsigned int) _vertexData.size(), CustomCommand::BufferUsage::DYNAMIC);
         }
+
         //    TOPLEFT
-        _vertexData[0].texCoords = textureCoordFromAlphaPoint(Vec2(min.x, max.y));
-        _vertexData[0].vertices = vertexFromAlphaPoint(Vec2(min.x, max.y));
+        _vertexData[0].texCoords = textureCoordFromAlphaPoint(Vec2(min.x,max.y));
+        _vertexData[0].vertices = vertexFromAlphaPoint(Vec2(min.x,max.y));
 
         //    BOTLEFT
-        _vertexData[1].texCoords = textureCoordFromAlphaPoint(Vec2(min.x, min.y));
-        _vertexData[1].vertices = vertexFromAlphaPoint(Vec2(min.x, min.y));
+        _vertexData[1].texCoords = textureCoordFromAlphaPoint(Vec2(min.x,min.y));
+        _vertexData[1].vertices = vertexFromAlphaPoint(Vec2(min.x,min.y));
 
         //    TOPRIGHT
-        _vertexData[2].texCoords = textureCoordFromAlphaPoint(Vec2(max.x, max.y));
-        _vertexData[2].vertices = vertexFromAlphaPoint(Vec2(max.x, max.y));
+        _vertexData[2].texCoords = textureCoordFromAlphaPoint(Vec2(max.x,max.y));
+        _vertexData[2].vertices = vertexFromAlphaPoint(Vec2(max.x,max.y));
 
         //    BOTRIGHT
-        _vertexData[3].texCoords = textureCoordFromAlphaPoint(Vec2(max.x, min.y));
-        _vertexData[3].vertices = vertexFromAlphaPoint(Vec2(max.x, min.y));
-    }
-    else
-    {
-        if (!_vertexData)
-        {
-            _vertexDataCount = 8;
-            _vertexData = static_cast<V2F_C4B_T2F*>(malloc(_vertexDataCount * sizeof(V2F_C4B_T2F)));
-            CCASSERT(_vertexData, "CCProgressTimer. Not enough memory");
+        _vertexData[3].texCoords = textureCoordFromAlphaPoint(Vec2(max.x,min.y));
+        _vertexData[3].vertices = vertexFromAlphaPoint(Vec2(max.x,min.y));
+
+        updateColor();
+
+        _customCommand.updateVertexBuffer(_vertexData.data(), (unsigned int)(sizeof(_vertexData[0]) * _vertexData.size()));
+    } else {
+        if(_vertexData.size() != 8) {
+            _vertexData.resize(8);
+            _customCommand.createVertexBuffer(sizeof(_vertexData[0]), (unsigned int)(_vertexData.size() / 2), CustomCommand::BufferUsage::DYNAMIC);
+            _customCommand2.createVertexBuffer(sizeof(_vertexData[0]), (unsigned int)(_vertexData.size() / 2), CustomCommand::BufferUsage::DYNAMIC);
             //    TOPLEFT 1
-            _vertexData[0].texCoords = textureCoordFromAlphaPoint(Vec2(0, 1));
-            _vertexData[0].vertices = vertexFromAlphaPoint(Vec2(0, 1));
+            _vertexData[0].texCoords = textureCoordFromAlphaPoint(Vec2(0,1));
+            _vertexData[0].vertices = vertexFromAlphaPoint(Vec2(0,1));
 
             //    BOTLEFT 1
-            _vertexData[1].texCoords = textureCoordFromAlphaPoint(Vec2(0, 0));
-            _vertexData[1].vertices = vertexFromAlphaPoint(Vec2(0, 0));
+            _vertexData[1].texCoords = textureCoordFromAlphaPoint(Vec2(0,0));
+            _vertexData[1].vertices = vertexFromAlphaPoint(Vec2(0,0));
 
             //    TOPRIGHT 2
-            _vertexData[6].texCoords = textureCoordFromAlphaPoint(Vec2(1, 1));
-            _vertexData[6].vertices = vertexFromAlphaPoint(Vec2(1, 1));
+            _vertexData[6].texCoords = textureCoordFromAlphaPoint(Vec2(1,1));
+            _vertexData[6].vertices = vertexFromAlphaPoint(Vec2(1,1));
 
             //    BOTRIGHT 2
-            _vertexData[7].texCoords = textureCoordFromAlphaPoint(Vec2(1, 0));
-            _vertexData[7].vertices = vertexFromAlphaPoint(Vec2(1, 0));
+            _vertexData[7].texCoords = textureCoordFromAlphaPoint(Vec2(1,0));
+            _vertexData[7].vertices = vertexFromAlphaPoint(Vec2(1,0));
         }
 
         //    TOPRIGHT 1
-        _vertexData[2].texCoords = textureCoordFromAlphaPoint(Vec2(min.x, max.y));
-        _vertexData[2].vertices = vertexFromAlphaPoint(Vec2(min.x, max.y));
+        _vertexData[2].texCoords = textureCoordFromAlphaPoint(Vec2(min.x,max.y));
+        _vertexData[2].vertices = vertexFromAlphaPoint(Vec2(min.x,max.y));
 
         //    BOTRIGHT 1
-        _vertexData[3].texCoords = textureCoordFromAlphaPoint(Vec2(min.x, min.y));
-        _vertexData[3].vertices = vertexFromAlphaPoint(Vec2(min.x, min.y));
+        _vertexData[3].texCoords = textureCoordFromAlphaPoint(Vec2(min.x,min.y));
+        _vertexData[3].vertices = vertexFromAlphaPoint(Vec2(min.x,min.y));
 
         //    TOPLEFT 2
-        _vertexData[4].texCoords = textureCoordFromAlphaPoint(Vec2(max.x, max.y));
-        _vertexData[4].vertices = vertexFromAlphaPoint(Vec2(max.x, max.y));
+        _vertexData[4].texCoords = textureCoordFromAlphaPoint(Vec2(max.x,max.y));
+        _vertexData[4].vertices = vertexFromAlphaPoint(Vec2(max.x,max.y));
 
         //    BOTLEFT 2
-        _vertexData[5].texCoords = textureCoordFromAlphaPoint(Vec2(max.x, min.y));
-        _vertexData[5].vertices = vertexFromAlphaPoint(Vec2(max.x, min.y));
+        _vertexData[5].texCoords = textureCoordFromAlphaPoint(Vec2(max.x,min.y));
+        _vertexData[5].vertices = vertexFromAlphaPoint(Vec2(max.x,min.y));
+
+        updateColor();
+
+        _customCommand.updateVertexBuffer(_vertexData.data(), (unsigned int)(sizeof(_vertexData[0]) * _vertexData.size() / 2));
+        _customCommand2.updateVertexBuffer((char*)_vertexData.data() + sizeof(_vertexData[0]) * _vertexData.size() / 2,
+                                           (unsigned int)(sizeof(_vertexData[0]) * _vertexData.size() / 2));
     }
-    updateColor();
 }
 
 Vec2 ProgressTimer::boundaryTexCoord(char index)
@@ -521,62 +556,48 @@ Vec2 ProgressTimer::boundaryTexCoord(char index)
     if (index < kProgressTextureCoordsCount)
     {
         if (_reverseDirection)
-        {
-            return Vec2((kProgressTextureCoords >> (7 - (index << 1))) & 1, (kProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1);
-        }
+            return Vec2((kProgressTextureCoords>>(7-(index<<1)))&1,(kProgressTextureCoords>>(7-((index<<1)+1)))&1);
         else
-        {
-            return Vec2((kProgressTextureCoords >> ((index << 1) + 1)) & 1, (kProgressTextureCoords >> (index << 1)) & 1);
-        }
+            return Vec2((kProgressTextureCoords>>((index<<1)+1))&1,(kProgressTextureCoords>>(index<<1))&1);
     }
-    return Vec2::ZERO;
+    else
+        return Vec2::ZERO;
 }
 
-void ProgressTimer::onDraw(const Mat4& transform, uint32_t flags)
+void ProgressTimer::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
-    getGLProgram()->use();
-    getGLProgram()->setUniformsForBuiltins(transform);
-
-    GL::blendFunc(_sprite->getBlendFunc().src, _sprite->getBlendFunc().dst);
-
-    GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
-
-    GL::bindTexture2D(_sprite->getTexture());
+    if( _vertexData.empty() || ! _sprite)
+        return;
 
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(_vertexData[0]), &_vertexData[0].vertices);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, sizeof(_vertexData[0]), &_vertexData[0].texCoords);
-    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(_vertexData[0]), &_vertexData[0].colors);
+    const cocos2d::Mat4& projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    Mat4 finalMat = projectionMat * transform;
+    _programState->setUniform(_locMVP1, finalMat.m, sizeof(finalMat.m));
+    _programState->setTexture(_locTex1, 0, _sprite->getTexture()->getBackendTexture());
 
-    if (_type == Type::RADIAL)
-    {
-        glDrawArrays(GL_TRIANGLE_FAN, 0, _vertexDataCount);
-        CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, _vertexDataCount);
-    }
-    else if (_type == Type::BAR)
+    if(_type == Type::BAR)
     {
         if (!_reverseDirection)
         {
-            glDrawArrays(GL_TRIANGLE_STRIP, 0, _vertexDataCount);
-            CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, _vertexDataCount);
+            _customCommand.init(_globalZOrder, _sprite->getBlendFunc());
+            renderer->addCommand(&_customCommand);
         }
         else
         {
-            glDrawArrays(GL_TRIANGLE_STRIP, 0, _vertexDataCount / 2);
-            glDrawArrays(GL_TRIANGLE_STRIP, 4, _vertexDataCount / 2);
-            // 2 draw calls
-            CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(2, _vertexDataCount);
+            _customCommand.init(_globalZOrder, _sprite->getBlendFunc());
+            renderer->addCommand(&_customCommand);
+
+            _customCommand2.init(_globalZOrder, _sprite->getBlendFunc());
+            _programState2->setUniform(_locMVP2, finalMat.m, sizeof(finalMat.m));
+            _programState2->setTexture(_locTex2, 0, _sprite->getTexture()->getBackendTexture());
+            renderer->addCommand(&_customCommand2);
         }
     }
+    else
+    {
+        _customCommand.init(_globalZOrder, _sprite->getBlendFunc());
+        renderer->addCommand(&_customCommand);
+    }
 }
 
-void ProgressTimer::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
-{
-    if (!_vertexData || !_sprite)
-        return;
-
-    _customCommand.init(_globalZOrder, transform, flags);
-    _customCommand.setFunc([this, transform, flags]() { onDraw(transform, flags); });
-    renderer->addCommand(&_customCommand);
-}
 
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCProgressTimer.h b/cocos2d/cocos/2d/CCProgressTimer.h
index 1a723e4c22..4db38e4e79 100644
--- a/cocos2d/cocos/2d/CCProgressTimer.h
+++ b/cocos2d/cocos/2d/CCProgressTimer.h
@@ -2,6 +2,7 @@
 Copyright (c) 2010      Lam Pham
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -23,23 +24,17 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_PROGRESSTIMER_H
-#define CC_2D_PROGRESSTIMER_H
+#pragma once
 
-#include <cocos/2d/CCNode.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 #include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/2d/CCNode.h>
+#include <cocos/renderer/CCPipelineDescriptor.h>
+
+#include <vector>
 
 NS_CC_BEGIN
 
 class Sprite;
-class Renderer;
-class Mat4;
-struct Color3B;
 
 /**
  * @addtogroup _2d
@@ -47,23 +42,23 @@ struct Color3B;
  */
 
 /**
- * @brief ProgressTimer is a subclass of Node.
- * It renders the inner sprite according to the percentage.
- * The progress can be Radial, Horizontal or vertical.
- * @since v0.99.1
- */
+  * @brief ProgressTimer is a subclass of Node.
+  * It renders the inner sprite according to the percentage.
+  * The progress can be Radial, Horizontal or vertical.
+  * @since v0.99.1
+  */
 class CC_DLL ProgressTimer : public Node
 {
 public:
     /** Types of progress
      * @since v0.99.1
      */
-    enum struct Type : std::uint8_t
+    enum class Type
     {
-        RADIAL, /** Radial Counter-Clockwise. */
-        BAR, /** Bar. */
+        RADIAL,/** Radial Counter-Clockwise. */
+        BAR,/** Bar. */
     };
-
+    
     /** Creates a progress timer with the sprite as the shape the timer goes through.
      *
      * @param sp The sprite as the shape the timer goes through.
@@ -71,7 +66,7 @@ public:
      */
     static ProgressTimer* create(Sprite* sp);
 
-    /** Change the percentage to change progress.
+    /** Change the percentage to change progress. 
      *
      * @return A Type
      */
@@ -83,49 +78,42 @@ public:
      */
     float getPercentage() const { return _percentage; }
 
-    /** The image to show the progress percentage, retain.
+    /** The image to show the progress percentage, retain. 
      *
      * @return A sprite.
      */
     Sprite* getSprite() const { return _sprite; }
-
-    /** Set the initial percentage values.
+    
+    /** Set the initial percentage values. 
      *
      * @param percentage The initial percentage values.
      */
     void setPercentage(float percentage);
-
-    /** Set the sprite as the shape.
+    
+    /** Set the sprite as the shape. 
      *
      * @param sprite The sprite as the shape.
      */
-    void setSprite(Sprite* sprite);
-
-    /** Set the ProgressTimer type.
+    void setSprite(Sprite *sprite);
+    
+    /** Set the ProgressTimer type. 
      *
      * @param type Is an Type.
      */
     void setType(Type type);
-
+    
     /** Return the Reverse direction.
      *
      * @return If the direction is Anti-clockwise,it will return true.
      */
-    bool isReverseDirection() { return _reverseDirection; }
-
+    bool isReverseDirection() { return _reverseDirection; };
+    
     /** Set the Reverse direction.
      *
      * @param value If value is false it will clockwise,if is true it will Anti-clockwise.
      */
     void setReverseDirection(bool value);
 
-    /** Set the Reverse direction.
-     * @js setReverseDirection
-     * @lua setReverseDirection
-     * @param reverse If reverse is false it will clockwise,if is true it will Anti-clockwise.
-     */
-    CC_DEPRECATED_ATTRIBUTE void setReverseProgress(bool reverse) { setReverseDirection(reverse); }
-
     /**
      *    Midpoint is used to modify the progress start position.
      *    If you're using radials type then the midpoint changes the center point.
@@ -138,8 +126,8 @@ public:
      * @param point A Vec2 point.
      */
     void setMidpoint(const Vec2& point);
-
-    /** Returns the Midpoint.
+    
+    /** Returns the Midpoint. 
      *
      * @return A Vec2.
      */
@@ -152,8 +140,8 @@ public:
      *    Set the rate to be Vec2(0,1); and set the midpoint to = Vec2(0,.5f).
      * @param barChangeRate A Vec2.
      */
-    void setBarChangeRate(const Vec2& barChangeRate) { _barChangeRate = barChangeRate; }
-
+    void setBarChangeRate(const Vec2& barChangeRate ) { _barChangeRate = barChangeRate; }
+    
     /** Returns the BarChangeRate.
      *
      * @return A barChangeRate.
@@ -161,57 +149,62 @@ public:
     Vec2 getBarChangeRate() const { return _barChangeRate; }
 
     // Overrides
-    void draw(Renderer* renderer, const Mat4& transform, std::uint32_t flags) override;
-    void setAnchorPoint(const Vec2& anchorPoint) override;
-    void setColor(const Color3B& color) override;
-    const Color3B& getColor() const override;
-    void setOpacity(GLubyte opacity) override;
-    GLubyte getOpacity() const override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        ProgressTimer();
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
+    virtual void setAnchorPoint(const Vec2& anchorPoint) override;
+    virtual void setColor(const Color3B &color) override;
+    virtual const Color3B& getColor() const override;
+    virtual void setOpacity(uint8_t opacity) override;
+    virtual uint8_t getOpacity() const override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    ProgressTimer() = default;
     /**
      * @js NA
      * @lua NA
      */
-    ~ProgressTimer() override;
-
+    virtual ~ProgressTimer();
+    
     /** Initializes a progress timer with the sprite as the shape the timer goes through */
     bool initWithSprite(Sprite* sp);
-
+    
 protected:
-    void onDraw(const Mat4& transform, std::uint32_t flags);
-
     Tex2F textureCoordFromAlphaPoint(Vec2 alpha);
     Vec2 vertexFromAlphaPoint(Vec2 alpha);
-    void updateProgress(void);
-    void updateBar(void);
-    void updateRadial(void);
-    void updateColor(void) override;
+    void updateProgress();
+    void updateBar();
+    void updateRadial();
+    virtual void updateColor() override;
     Vec2 boundaryTexCoord(char index);
 
-    Type _type;
+    Type _type = Type::RADIAL;
     Vec2 _midpoint;
     Vec2 _barChangeRate;
-    float _percentage;
-    Sprite* _sprite;
-    int _vertexDataCount;
-    V2F_C4B_T2F* _vertexData;
-
+    float _percentage = 0.0f;
+    Sprite *_sprite = nullptr;
+    std::vector<V2F_C4B_T2F> _vertexData;
+    std::vector<unsigned short> _indexData;
+    bool _reverseDirection = false;
+    
     CustomCommand _customCommand;
+    CustomCommand _customCommand2;
+    
+    backend::ProgramState* _programState = nullptr;
+    backend::ProgramState* _programState2 = nullptr;
 
-    bool _reverseDirection;
+    backend::UniformLocation _locMVP1;
+    backend::UniformLocation _locTex1;
+
+    backend::UniformLocation _locMVP2;
+    backend::UniformLocation _locTex2;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ProgressTimer)
+    CC_DISALLOW_COPY_AND_ASSIGN(ProgressTimer);
 };
 
 // end of misc_nodes group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_PROGRESSTIMER_H
diff --git a/cocos2d/cocos/2d/CCProtectedNode.cpp b/cocos2d/cocos/2d/CCProtectedNode.cpp
index 076075b8f7..f74b9f5abd 100644
--- a/cocos2d/cocos/2d/CCProtectedNode.cpp
+++ b/cocos2d/cocos/2d/CCProtectedNode.cpp
@@ -4,19 +4,20 @@
  Copyright (c) 2010-2012 cocos2d-x.org
  Copyright (c) 2011      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -28,34 +29,24 @@
 
 #include <cocos/2d/CCProtectedNode.h>
 
-#include <cocos/2d/CCNode.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <cstddef>
-#include <new>
+#include <cocos/2d/CCScene.h>
 
 NS_CC_BEGIN
 
-ProtectedNode::ProtectedNode()
-: _reorderProtectedChildDirty(false)
+ProtectedNode::ProtectedNode() : _reorderProtectedChildDirty(false)
 {
 }
 
 ProtectedNode::~ProtectedNode()
 {
-    CCLOGINFO("deallocing ProtectedNode: %p - tag: %i", this, _tag);
+    CCLOGINFO( "deallocing ProtectedNode: %p - tag: %i", this, _tag );
     removeAllProtectedChildren();
 }
 
-ProtectedNode* ProtectedNode::create(void)
+ProtectedNode * ProtectedNode::create()
 {
-    ProtectedNode* ret = new (std::nothrow) ProtectedNode();
+	ProtectedNode * ret = new (std::nothrow) ProtectedNode();
     if (ret && ret->init())
     {
         ret->autorelease();
@@ -64,7 +55,7 @@ ProtectedNode* ProtectedNode::create(void)
     {
         CC_SAFE_DELETE(ret);
     }
-    return ret;
+	return ret;
 }
 
 void ProtectedNode::cleanup()
@@ -76,19 +67,19 @@ void ProtectedNode::cleanup()
             return;
     }
 #endif // #if CC_ENABLE_SCRIPT_BINDING
-
+    
     Node::cleanup();
     // timers
-    for (const auto& child : _protectedChildren)
+    for( const auto &child: _protectedChildren)
         child->cleanup();
 }
 
-void ProtectedNode::addProtectedChild(cocos2d::Node* child)
+void ProtectedNode::addProtectedChild(cocos2d::Node *child)
 {
     addProtectedChild(child, child->getLocalZOrder(), child->getTag());
 }
 
-void ProtectedNode::addProtectedChild(cocos2d::Node* child, int localZOrder)
+void ProtectedNode::addProtectedChild(cocos2d::Node *child, int localZOrder)
 {
     addProtectedChild(child, localZOrder, child->getTag());
 }
@@ -97,39 +88,37 @@ void ProtectedNode::addProtectedChild(cocos2d::Node* child, int localZOrder)
  * If a class want's to extend the 'addChild' behavior it only needs
  * to override this method
  */
-void ProtectedNode::addProtectedChild(Node* child, int zOrder, int tag)
+void ProtectedNode::addProtectedChild(Node *child, int zOrder, int tag)
 {
-    CCASSERT(child != nullptr, "Argument must be non-nil");
-    CCASSERT(child->getParent() == nullptr, "child already added. It can't be added again");
-
+    CCASSERT( child != nullptr, "Argument must be non-nil");
+    CCASSERT( child->getParent() == nullptr, "child already added. It can't be added again");
+    
     if (_protectedChildren.empty())
     {
         _protectedChildren.reserve(4);
     }
-
+    
     this->insertProtectedChild(child, zOrder);
-
+    
     child->setTag(tag);
-
+    child->setGlobalZOrder(_globalZOrder);
     child->setParent(this);
-
     child->updateOrderOfArrival();
-
-    if (_running)
+    
+    if( _running )
     {
         child->onEnter();
         // prevent onEnterTransitionDidFinish to be called twice when a node is added in onEnter
-        if (_isTransitionFinished)
-        {
+        if (_isTransitionFinished) {
             child->onEnterTransitionDidFinish();
         }
     }
-
+    
     if (_cascadeColorEnabled)
     {
         updateCascadeColor();
     }
-
+    
     if (_cascadeOpacityEnabled)
     {
         updateCascadeOpacity();
@@ -138,11 +127,11 @@ void ProtectedNode::addProtectedChild(Node* child, int zOrder, int tag)
 
 Node* ProtectedNode::getProtectedChildByTag(int tag)
 {
-    CCASSERT(tag != Node::INVALID_TAG, "Invalid tag");
-
+    CCASSERT( tag != Node::INVALID_TAG, "Invalid tag");
+    
     for (auto& child : _protectedChildren)
     {
-        if (child && child->getTag() == tag)
+        if(child && child->getTag() == tag)
             return child;
     }
     return nullptr;
@@ -152,17 +141,18 @@ Node* ProtectedNode::getProtectedChildByTag(int tag)
  * If a class want's to extend the 'removeChild' behavior it only needs
  * to override this method
  */
-void ProtectedNode::removeProtectedChild(cocos2d::Node* child, bool cleanup)
+void ProtectedNode::removeProtectedChild(cocos2d::Node *child, bool cleanup)
 {
     // explicit nil handling
     if (_protectedChildren.empty())
     {
         return;
     }
-
-    std::size_t index = _protectedChildren.getIndex(child);
-    if (index != CC_INVALID_INDEX)
+    
+    ssize_t index = _protectedChildren.getIndex(child);
+    if( index != CC_INVALID_INDEX )
     {
+        
         // IMPORTANT:
         //  -1st do onExit
         //  -2nd cleanup
@@ -171,17 +161,17 @@ void ProtectedNode::removeProtectedChild(cocos2d::Node* child, bool cleanup)
             child->onExitTransitionDidStart();
             child->onExit();
         }
-
+        
         // If you don't do cleanup, the child's actions will not get removed and the
         // its scheduledSelectors_ dict will not get released!
         if (cleanup)
         {
             child->cleanup();
         }
-
+        
         // set parent nil at the end
         child->setParent(nullptr);
-
+        
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
         auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
         if (sEngine)
@@ -206,12 +196,12 @@ void ProtectedNode::removeAllProtectedChildrenWithCleanup(bool cleanup)
         // IMPORTANT:
         //  -1st do onExit
         //  -2nd cleanup
-        if (_running)
+        if(_running)
         {
             child->onExitTransitionDidStart();
             child->onExit();
         }
-
+        
         if (cleanup)
         {
             child->cleanup();
@@ -222,20 +212,20 @@ void ProtectedNode::removeAllProtectedChildrenWithCleanup(bool cleanup)
         {
             sEngine->releaseScriptObject(this, child);
         }
-#endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS \
-// set parent nil at the end
+#endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
+        // set parent nil at the end
         child->setParent(nullptr);
     }
-
+    
     _protectedChildren.clear();
 }
 
 void ProtectedNode::removeProtectedChildByTag(int tag, bool cleanup)
 {
-    CCASSERT(tag != Node::INVALID_TAG, "Invalid tag");
-
-    Node* child = this->getProtectedChildByTag(tag);
-
+    CCASSERT( tag != Node::INVALID_TAG, "Invalid tag");
+    
+    Node *child = this->getProtectedChildByTag(tag);
+    
     if (child == nullptr)
     {
         CCLOG("cocos2d: removeChildByTag(tag = %d): child not found!", tag);
@@ -247,7 +237,7 @@ void ProtectedNode::removeProtectedChildByTag(int tag, bool cleanup)
 }
 
 // helper used by reorderChild & add
-void ProtectedNode::insertProtectedChild(cocos2d::Node* child, int z)
+void ProtectedNode::insertProtectedChild(cocos2d::Node *child, int z)
 {
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
     auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
@@ -263,31 +253,30 @@ void ProtectedNode::insertProtectedChild(cocos2d::Node* child, int z)
 
 void ProtectedNode::sortAllProtectedChildren()
 {
-    if (_reorderProtectedChildDirty)
-    {
+    if( _reorderProtectedChildDirty ) {
         sortNodes(_protectedChildren);
         _reorderProtectedChildDirty = false;
     }
 }
 
-void ProtectedNode::reorderProtectedChild(cocos2d::Node* child, int localZOrder)
+void ProtectedNode::reorderProtectedChild(cocos2d::Node *child, int localZOrder)
 {
-    CCASSERT(child != nullptr, "Child must be non-nil");
+    CCASSERT( child != nullptr, "Child must be non-nil");
     _reorderProtectedChildDirty = true;
     child->updateOrderOfArrival();
     child->setLocalZOrder(localZOrder);
 }
 
-void ProtectedNode::visit(Renderer* renderer, const Mat4& parentTransform, std::uint32_t parentFlags)
+void ProtectedNode::visit(Renderer* renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     // quick return if not visible. children won't be drawn.
     if (!_visible)
     {
         return;
     }
-
-    std::uint32_t flags = processParentFlags(parentTransform, parentFlags);
-
+    
+    uint32_t flags = processParentFlags(parentTransform, parentFlags);
+    
     // IMPORTANT:
     // To ease the migration to v3.0, we still support the Mat4 stack,
     // but it is deprecated and your code should not rely on it
@@ -295,55 +284,55 @@ void ProtectedNode::visit(Renderer* renderer, const Mat4& parentTransform, std::
     CCASSERT(nullptr != director, "Director is null when setting matrix stack");
     director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
     director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform);
-
-    std::size_t i = 0; // used by _children
-    std::size_t j = 0; // used by _protectedChildren
-
+    
+    int i = 0;      // used by _children
+    int j = 0;      // used by _protectedChildren
+    
     sortAllChildren();
     sortAllProtectedChildren();
-
+    
     //
     // draw children and protectedChildren zOrder < 0
     //
-    for (; i < _children.size(); i++)
+    for(auto size = _children.size(); i < size; ++i)
     {
         auto node = _children.at(i);
-
-        if (node && node->getLocalZOrder() < 0)
+        
+        if ( node && node->getLocalZOrder() < 0 )
             node->visit(renderer, _modelViewTransform, flags);
         else
             break;
     }
 
-    for (; j < _protectedChildren.size(); j++)
+    for(auto size = _protectedChildren.size(); j < size; ++j)
     {
         auto node = _protectedChildren.at(j);
-
-        if (node && node->getLocalZOrder() < 0)
+        
+        if ( node && node->getLocalZOrder() < 0 )
             node->visit(renderer, _modelViewTransform, flags);
         else
             break;
     }
-
+    
     //
     // draw self
     //
     if (isVisitableByVisitingCamera())
         this->draw(renderer, _modelViewTransform, flags);
-
+    
     //
     // draw children and protectedChildren zOrder >= 0
     //
-    for (auto it = _protectedChildren.cbegin() + j; it != _protectedChildren.cend(); ++it)
+    for(auto it=_protectedChildren.cbegin()+j, itCend = _protectedChildren.cend(); it != itCend; ++it)
         (*it)->visit(renderer, _modelViewTransform, flags);
 
-    for (auto it = _children.cbegin() + i; it != _children.cend(); ++it)
+    for(auto it=_children.cbegin()+i, itCend = _children.cend(); it != itCend; ++it)
         (*it)->visit(renderer, _modelViewTransform, flags);
-
+    
     // FIX ME: Why need to set _orderOfArrival to 0??
     // Please refer to https://github.com/cocos2d/cocos2d-x/pull/6920
     // setOrderOfArrival(0);
-
+    
     director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
 }
 
@@ -356,9 +345,9 @@ void ProtectedNode::onEnter()
             return;
     }
 #endif
-
+    
     Node::onEnter();
-    for (const auto& child : _protectedChildren)
+    for( const auto &child: _protectedChildren)
         child->onEnter();
 }
 
@@ -371,9 +360,9 @@ void ProtectedNode::onEnterTransitionDidFinish()
             return;
     }
 #endif
-
+    
     Node::onEnterTransitionDidFinish();
-    for (const auto& child : _protectedChildren)
+    for( const auto &child: _protectedChildren)
         child->onEnterTransitionDidFinish();
 }
 
@@ -386,9 +375,9 @@ void ProtectedNode::onExitTransitionDidStart()
             return;
     }
 #endif
-
+    
     Node::onExitTransitionDidStart();
-    for (const auto& child : _protectedChildren)
+    for( const auto &child: _protectedChildren)
         child->onExitTransitionDidStart();
 }
 
@@ -401,59 +390,53 @@ void ProtectedNode::onExit()
             return;
     }
 #endif
-
+    
     Node::onExit();
-    for (const auto& child : _protectedChildren)
+    for( const auto &child: _protectedChildren)
         child->onExit();
 }
 
-void ProtectedNode::updateDisplayedOpacity(GLubyte parentOpacity)
+void ProtectedNode::updateDisplayedOpacity(uint8_t parentOpacity)
 {
-    _displayedOpacity = _realOpacity * parentOpacity / 255.0;
+	_displayedOpacity = _realOpacity * parentOpacity/255.0;
     updateColor();
-
+    
     if (_cascadeOpacityEnabled)
     {
-        for (auto child : _children)
-        {
+        for(auto child : _children){
             child->updateDisplayedOpacity(_displayedOpacity);
         }
     }
-
-    for (auto child : _protectedChildren)
-    {
+    
+    for(auto child : _protectedChildren){
         child->updateDisplayedOpacity(_displayedOpacity);
     }
 }
 
 void ProtectedNode::updateDisplayedColor(const Color3B& parentColor)
 {
-    _displayedColor.r = _realColor.r * parentColor.r / 255.0;
-    _displayedColor.g = _realColor.g * parentColor.g / 255.0;
-    _displayedColor.b = _realColor.b * parentColor.b / 255.0;
+	_displayedColor.r = _realColor.r * parentColor.r/255.0;
+	_displayedColor.g = _realColor.g * parentColor.g/255.0;
+	_displayedColor.b = _realColor.b * parentColor.b/255.0;
     updateColor();
-
+    
     if (_cascadeColorEnabled)
     {
-        for (const auto& child : _children)
-        {
+        for(const auto &child : _children){
             child->updateDisplayedColor(_displayedColor);
         }
     }
-    for (const auto& child : _protectedChildren)
-    {
+    for(const auto &child : _protectedChildren){
         child->updateDisplayedColor(_displayedColor);
     }
 }
 
 void ProtectedNode::disableCascadeColor()
 {
-    for (auto child : _children)
-    {
+    for(auto child : _children){
         child->updateDisplayedColor(Color3B::WHITE);
     }
-    for (auto child : _protectedChildren)
-    {
+    for(auto child : _protectedChildren){
         child->updateDisplayedColor(Color3B::WHITE);
     }
 }
@@ -461,14 +444,12 @@ void ProtectedNode::disableCascadeColor()
 void ProtectedNode::disableCascadeOpacity()
 {
     _displayedOpacity = _realOpacity;
-
-    for (auto child : _children)
-    {
+    
+    for(auto child : _children){
         child->updateDisplayedOpacity(255);
     }
-
-    for (auto child : _protectedChildren)
-    {
+    
+    for(auto child : _protectedChildren){
         child->updateDisplayedOpacity(255);
     }
 }
@@ -478,11 +459,19 @@ void ProtectedNode::setCameraMask(unsigned short mask, bool applyChildren)
     Node::setCameraMask(mask, applyChildren);
     if (applyChildren)
     {
-        for (auto& iter : _protectedChildren)
+        for (auto& iter: _protectedChildren)
         {
             iter->setCameraMask(mask);
         }
     }
+    
+}
+
+void ProtectedNode::setGlobalZOrder(float globalZOrder)
+{
+    Node::setGlobalZOrder(globalZOrder);
+    for (auto &child : _protectedChildren)
+        child->setGlobalZOrder(globalZOrder);
 }
 
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCProtectedNode.h b/cocos2d/cocos/2d/CCProtectedNode.h
index 8c11f9f40b..5f64105908 100644
--- a/cocos2d/cocos/2d/CCProtectedNode.h
+++ b/cocos2d/cocos/2d/CCProtectedNode.h
@@ -4,19 +4,20 @@
  Copyright (c) 2010-2012 cocos2d-x.org
  Copyright (c) 2011      Zynga Inc.
  Copyright (c) 2013-2016 Chukong Technologies Inc.
-
+ Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
+ 
  http://www.cocos2d-x.org
-
+ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
-
+ 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
-
+ 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -26,24 +27,14 @@
  THE SOFTWARE.
  ****************************************************************************/
 
-#ifndef CC_2D_PROTECTEDNODE_H
-#define CC_2D_PROTECTEDNODE_H
+#ifndef __CPROTECTEDCNODE_H__
+#define __CPROTECTEDCNODE_H__
 
-#include <cocos/2d/CCNode.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 
-#include <cstdint>
+#include <cocos/2d/CCNode.h>
 
 NS_CC_BEGIN
-
-class Mat4;
-class Renderer;
-struct Color3B;
-
+	
 /**
  * @addtogroup _2d
  * @{
@@ -53,18 +44,18 @@ struct Color3B;
  *@brief A inner node type mainly used for UI module.
  * It is useful for composing complex node type and it's children are protected.
  */
-class CC_DLL ProtectedNode : public Node
+class  CC_DLL ProtectedNode : public Node
 {
 public:
     /**
      * Creates a ProtectedNode with no argument.
      *@return A instance of ProtectedNode.
      */
-    static ProtectedNode* create();
-
+    static ProtectedNode * create();
+    
     /// @{
     /// @name Children and Parent
-
+    
     /**
      * Adds a child to the container with z-order as 0.
      *
@@ -72,7 +63,7 @@ public:
      *
      * @param child A child node
      */
-    virtual void addProtectedChild(Node* child);
+    virtual void addProtectedChild(Node * child);
     /**
      * Adds a child to the container with a local z-order.
      *
@@ -81,7 +72,7 @@ public:
      * @param child     A child node
      * @param localZOrder    Z order for drawing priority. Please refer to `setLocalZOrder(int)`
      */
-    virtual void addProtectedChild(Node* child, int localZOrder);
+    virtual void addProtectedChild(Node * child, int localZOrder);
     /**
      * Adds a child to the container with z order and tag.
      *
@@ -99,10 +90,10 @@ public:
      *
      * @return a Node object whose tag equals to the input parameter.
      */
-    virtual Node* getProtectedChildByTag(int tag);
-
+    virtual Node * getProtectedChildByTag(int tag);
+    
     ////// REMOVES //////
-
+    
     /**
      * Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.
      *
@@ -110,7 +101,7 @@ public:
      * @param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise.
      */
     virtual void removeProtectedChild(Node* child, bool cleanup = true);
-
+    
     /**
      * Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.
      *
@@ -118,7 +109,7 @@ public:
      * @param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise.
      */
     virtual void removeProtectedChildByTag(int tag, bool cleanup = true);
-
+    
     /**
      * Removes all children from the container with a cleanup.
      *
@@ -133,41 +124,41 @@ public:
      * @lua removeAllChildren
      */
     virtual void removeAllProtectedChildrenWithCleanup(bool cleanup);
-
+    
     /**
      * Reorders a child according to a new z value.
      *
      * @param child     An already added child node. It MUST be already added.
      * @param localZOrder Z order for drawing priority. Please refer to setLocalZOrder(int)
      */
-    virtual void reorderProtectedChild(Node* child, int localZOrder);
-
+    virtual void reorderProtectedChild(Node * child, int localZOrder);
+    
     /**
      * Sorts the children array once before drawing, instead of every time when a child is added or reordered.
      * This approach can improves the performance massively.
      * @note Don't call this manually unless a child added needs to be removed in the same frame
      */
     virtual void sortAllProtectedChildren();
-
+    
     /// @} end of Children and Parent
-
+    
     /**
      * @js NA
      */
-    void visit(Renderer* renderer, const Mat4& parentTransform, std::uint32_t parentFlags) override;
-
-    void cleanup() override;
-
-    void onEnter() override;
-
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
+    
+    virtual void cleanup() override;
+    
+    virtual void onEnter() override;
+    
     /** Event callback that is invoked when the Node enters in the 'stage'.
      * If the Node enters the 'stage' with a transition, this event is called when the transition finishes.
      * If you override onEnterTransitionDidFinish, you shall call its parent's one, e.g. Node::onEnterTransitionDidFinish()
      * @js NA
      * @lua NA
      */
-    void onEnterTransitionDidFinish() override;
-
+    virtual void onEnterTransitionDidFinish() override;
+    
     /**
      * Event callback that is invoked every time the Node leaves the 'stage'.
      * If the Node leaves the 'stage' with a transition, this event is called when the transition finishes.
@@ -176,33 +167,36 @@ public:
      * @js NA
      * @lua NA
      */
-    void onExit() override;
-
+    virtual void onExit() override;
+    
     /**
      * Event callback that is called every time the Node leaves the 'stage'.
      * If the Node leaves the 'stage' with a transition, this callback is called when the transition starts.
      * @js NA
      * @lua NA
      */
-    void onExitTransitionDidStart() override;
-
-    void updateDisplayedOpacity(GLubyte parentOpacity) override;
-    void updateDisplayedColor(const Color3B& parentColor) override;
-    void disableCascadeColor() override;
-    void disableCascadeOpacity() override;
-    void setCameraMask(unsigned short mask, bool applyChildren = true) override;
-    CC_CONSTRUCTOR_ACCESS : ProtectedNode();
-    ~ProtectedNode() override;
-
+    virtual void onExitTransitionDidStart() override;
+
+    virtual void updateDisplayedOpacity(uint8_t parentOpacity) override;
+    virtual void updateDisplayedColor(const Color3B& parentColor) override;
+    virtual void disableCascadeColor() override;
+    virtual void disableCascadeOpacity()override;
+    virtual void setCameraMask(unsigned short mask, bool applyChildren = true) override;
+    virtual void setGlobalZOrder(float globalZOrder) override;
+CC_CONSTRUCTOR_ACCESS:
+    ProtectedNode();
+    virtual ~ProtectedNode();
+    
 protected:
+    
     /// helper that reorder a child
     void insertProtectedChild(Node* child, int z);
-
-    Vector<Node*> _protectedChildren; ///< array of children nodes
+    
+    Vector<Node*> _protectedChildren;        ///< array of children nodes
     bool _reorderProtectedChildDirty;
-
+    
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(ProtectedNode)
+    CC_DISALLOW_COPY_AND_ASSIGN(ProtectedNode);
 };
 
 // end of 2d group
@@ -210,4 +204,4 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_PROTECTEDNODE_H
+#endif // __CPROTECTEDCNODE_H__
diff --git a/cocos2d/cocos/2d/CCRenderTexture.cpp b/cocos2d/cocos/2d/CCRenderTexture.cpp
index e3e3790f98..ebf80d0098 100644
--- a/cocos2d/cocos/2d/CCRenderTexture.cpp
+++ b/cocos2d/cocos/2d/CCRenderTexture.cpp
@@ -2,6 +2,7 @@
 Copyright (c) 2009      Jason Booth
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -23,54 +24,33 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-
 #include <cocos/2d/CCRenderTexture.h>
 
-#include <cocos/2d/CCCamera.h>
+#include <cocos/base/ccUtils.h>
+#include <cocos/platform/CCFileUtils.h>
+#include <cocos/base/CCEventType.h>
 #include <cocos/base/CCConfiguration.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/CCEventListenerCustom.h>
-#include <cocos/base/CCEventType.h>
-#include <cocos/base/ccUtils.h>
-#include <cocos/platform/CCFileUtils.h>
+#include <cocos/base/CCEventDispatcher.h>
 #include <cocos/renderer/CCRenderer.h>
+#include <cocos/2d/CCCamera.h>
 #include <cocos/renderer/CCTextureCache.h>
+#include <cocos/renderer/backend/Device.h>
+#include <cocos/renderer/backend/Texture.h>
 
 NS_CC_BEGIN
 
 // implementation RenderTexture
 RenderTexture::RenderTexture()
-: _keepMatrix(false)
-, _rtTextureRect(Rect::ZERO)
-, _fullRect(Rect::ZERO)
-, _fullviewPort(Rect::ZERO)
-, _FBO(0)
-, _depthRenderBufffer(0)
-, _stencilRenderBufffer(0)
-, _oldFBO(0)
-, _texture(nullptr)
-, _textureCopy(nullptr)
-, _UITextureImage(nullptr)
-, _pixelFormat(Texture2D::PixelFormat::RGBA8888)
-#if CC_ENABLE_CACHE_TEXTURE_DATA
-, _destroyedFromContextRecovering(false)
-#endif
-, _clearFlags(0)
-, _clearColor(Color4F(0, 0, 0, 0))
-, _clearDepth(0.0f)
-, _clearStencil(0)
-, _autoDraw(false)
-, _sprite(nullptr)
-, _saveFileCallback(nullptr)
 {
 #if CC_ENABLE_CACHE_TEXTURE_DATA
     // Listen this event to save render texture before come to background.
     // Then it can be restored after coming to foreground on Android.
-    auto toBackgroundListener = EventListenerCustom::create(EVENT_COME_TO_BACKGROUND, [this](EventCustom* evt) { listenToBackground(evt); });
+    auto toBackgroundListener = EventListenerCustom::create(EVENT_COME_TO_BACKGROUND, CC_CALLBACK_1(RenderTexture::listenToBackground, this));
     _eventDispatcher->addEventListenerWithSceneGraphPriority(toBackgroundListener, this);
 
-    auto toForegroundListener = EventListenerCustom::create(EVENT_COME_TO_FOREGROUND, [this](EventCustom* evt) { listenToForeground(evt); });
+    auto toForegroundListener = EventListenerCustom::create(EVENT_COME_TO_FOREGROUND, CC_CALLBACK_1(RenderTexture::listenToForeground, this));
     _eventDispatcher->addEventListenerWithSceneGraphPriority(toForegroundListener, this);
 #endif
 }
@@ -78,86 +58,66 @@ RenderTexture::RenderTexture()
 RenderTexture::~RenderTexture()
 {
     CC_SAFE_RELEASE(_sprite);
-    CC_SAFE_RELEASE(_textureCopy);
-
-    // don't delete frameBuffers as they are already invalidated from the context lost
-#if CC_ENABLE_CACHE_TEXTURE_DATA
-    if (!_destroyedFromContextRecovering)
-#endif
-    {
-        glDeleteFramebuffers(1, &_FBO);
-        if (_depthRenderBufffer)
-        {
-            glDeleteRenderbuffers(1, &_depthRenderBufffer);
-        }
-
-        if (_stencilRenderBufffer)
-        {
-            glDeleteRenderbuffers(1, &_stencilRenderBufffer);
-        }
-    }
-    _depthRenderBufffer = 0;
-    _stencilRenderBufffer = 0;
-
-    CC_SAFE_DELETE(_UITextureImage);
+    CC_SAFE_RELEASE(_texture2DCopy);
+    CC_SAFE_RELEASE(_depthStencilTexture);
+    CC_SAFE_RELEASE(_UITextureImage);
 }
 
-void RenderTexture::listenToBackground(EventCustom* event)
+void RenderTexture::listenToBackground(EventCustom* /*event*/)
 {
     // We have not found a way to dispatch the enter background message before the texture data are destroyed.
     // So we disable this pair of message handler at present.
 #if CC_ENABLE_CACHE_TEXTURE_DATA
-    CC_SAFE_DELETE(_UITextureImage);
-
     // to get the rendered texture data
-    _UITextureImage = newImage(false);
-
-    if (_UITextureImage)
-    {
-        const Size& s = _texture->getContentSizeInPixels();
-        VolatileTextureMgr::addDataTexture(_texture, _UITextureImage->getData(), s.width * s.height * 4, Texture2D::PixelFormat::RGBA8888, s);
+    auto func = [&](Image* uiTextureImage){
+        if (uiTextureImage)
+        {
+            CC_SAFE_RELEASE(_UITextureImage);
+            _UITextureImage = uiTextureImage;
+            CC_SAFE_RETAIN(_UITextureImage);
+            const Size& s = _texture2D->getContentSizeInPixels();
+            VolatileTextureMgr::addDataTexture(_texture2D, uiTextureImage->getData(), s.width * s.height * 4, backend::PixelFormat::RGBA8888, s);
 
-        if (_textureCopy)
+            if ( _texture2DCopy )
+            {
+                VolatileTextureMgr::addDataTexture(_texture2DCopy, uiTextureImage->getData(), s.width * s.height * 4, backend::PixelFormat::RGBA8888, s);
+            }
+        }
+        else
         {
-            VolatileTextureMgr::addDataTexture(_textureCopy, _UITextureImage->getData(), s.width * s.height * 4, Texture2D::PixelFormat::RGBA8888, s);
+            CCLOG("Cache rendertexture failed!");
         }
-    }
-    else
-    {
-        CCLOG("Cache rendertexture failed!");
-    }
+        CC_SAFE_RELEASE(uiTextureImage);
+    };
+    auto callback = std::bind(func, std::placeholders::_1);
+    newImage(callback, false);
 
-    glDeleteFramebuffers(1, &_FBO);
-    _FBO = 0;
 #endif
 }
 
-void RenderTexture::listenToForeground(EventCustom* event)
+void RenderTexture::listenToForeground(EventCustom* /*event*/)
 {
 #if CC_ENABLE_CACHE_TEXTURE_DATA
-    // -- regenerate frame buffer object and attach the texture
-    glGetIntegerv(GL_FRAMEBUFFER_BINDING, &_oldFBO);
-
-    glGenFramebuffers(1, &_FBO);
-    glBindFramebuffer(GL_FRAMEBUFFER, _FBO);
-
-    _texture->setAliasTexParameters();
-
-    if (_textureCopy)
+    const Size& s = _texture2D->getContentSizeInPixels();
+    //TODO new-renderer: field _depthAndStencilFormat removal
+//    if (_depthAndStencilFormat != 0)
+//    {
+//        setupDepthAndStencil(s.width, s.height);
+//    }
+    
+    _texture2D->setAntiAliasTexParameters();
+    if(_texture2DCopy)
     {
-        _textureCopy->setAliasTexParameters();
+        _texture2DCopy->setAntiAliasTexParameters();
     }
-
-    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _texture->getName(), 0);
-    glBindFramebuffer(GL_FRAMEBUFFER, _oldFBO);
 #endif
 }
 
-RenderTexture* RenderTexture::create(int w, int h, Texture2D::PixelFormat eFormat)
+RenderTexture * RenderTexture::create(int w, int h, backend::PixelFormat eFormat)
 {
-    RenderTexture* ret = new (std::nothrow) RenderTexture();
+    RenderTexture *ret = new (std::nothrow) RenderTexture();
 
-    if (ret && ret->initWithWidthAndHeight(w, h, eFormat))
+    if(ret && ret->initWithWidthAndHeight(w, h, eFormat))
     {
         ret->autorelease();
         return ret;
@@ -166,11 +126,11 @@ RenderTexture* RenderTexture::create(int w, int h, Texture2D::PixelFormat eForma
     return nullptr;
 }
 
-RenderTexture* RenderTexture::create(int w, int h, Texture2D::PixelFormat eFormat, GLuint uDepthStencilFormat)
+RenderTexture * RenderTexture::create(int w ,int h, backend::PixelFormat eFormat, PixelFormat uDepthStencilFormat)
 {
-    RenderTexture* ret = new (std::nothrow) RenderTexture();
+    RenderTexture *ret = new (std::nothrow) RenderTexture();
 
-    if (ret && ret->initWithWidthAndHeight(w, h, eFormat, uDepthStencilFormat))
+    if(ret && ret->initWithWidthAndHeight(w, h, eFormat, uDepthStencilFormat))
     {
         ret->autorelease();
         return ret;
@@ -179,11 +139,11 @@ RenderTexture* RenderTexture::create(int w, int h, Texture2D::PixelFormat eForma
     return nullptr;
 }
 
-RenderTexture* RenderTexture::create(int w, int h)
+RenderTexture * RenderTexture::create(int w, int h)
 {
-    RenderTexture* ret = new (std::nothrow) RenderTexture();
+    RenderTexture *ret = new (std::nothrow) RenderTexture();
 
-    if (ret && ret->initWithWidthAndHeight(w, h, Texture2D::PixelFormat::RGBA8888, 0))
+    if(ret && ret->initWithWidthAndHeight(w, h, backend::PixelFormat::RGBA8888, PixelFormat::NONE))
     {
         ret->autorelease();
         return ret;
@@ -192,28 +152,23 @@ RenderTexture* RenderTexture::create(int w, int h)
     return nullptr;
 }
 
-bool RenderTexture::initWithWidthAndHeight(int w, int h, Texture2D::PixelFormat eFormat)
+bool RenderTexture::initWithWidthAndHeight(int w, int h, backend::PixelFormat eFormat)
 {
-    return initWithWidthAndHeight(w, h, eFormat, 0);
+    return initWithWidthAndHeight(w, h, eFormat, PixelFormat::NONE);
 }
 
-bool RenderTexture::initWithWidthAndHeight(int w, int h, Texture2D::PixelFormat format, GLuint depthStencilFormat)
+bool RenderTexture::initWithWidthAndHeight(int w, int h, backend::PixelFormat format, PixelFormat depthStencilFormat)
 {
-    CCASSERT(format != Texture2D::PixelFormat::A8, "only RGB and RGBA formats are valid for a render texture");
+    CCASSERT(format != backend::PixelFormat::A8, "only RGB and RGBA formats are valid for a render texture");
 
     bool ret = false;
-    void* data = nullptr;
     do
     {
-        _fullRect = _rtTextureRect = Rect(0, 0, w, h);
-        // Size size = Director::getInstance()->getWinSizeInPixels();
-        //_fullviewPort = Rect(0,0,size.width,size.height);
-        w = static_cast<int>(w * CC_CONTENT_SCALE_FACTOR());
-        h = static_cast<int>(h * CC_CONTENT_SCALE_FACTOR());
-        _fullviewPort = Rect(0, 0, w, h);
-
-        glGetIntegerv(GL_FRAMEBUFFER_BINDING, &_oldFBO);
-
+        _fullRect = _rtTextureRect = Rect(0,0,w,h);
+        w = (int)(w * CC_CONTENT_SCALE_FACTOR());
+        h = (int)(h * CC_CONTENT_SCALE_FACTOR());
+        _fullviewPort = Rect(0,0,w,h);
+        
         // textures must be power of two squared
         int powW = 0;
         int powH = 0;
@@ -228,172 +183,84 @@ bool RenderTexture::initWithWidthAndHeight(int w, int h, Texture2D::PixelFormat
             powW = ccNextPOT(w);
             powH = ccNextPOT(h);
         }
+        
+        backend::TextureDescriptor descriptor;
+        descriptor.width = powW;
+        descriptor.height = powH;
+        descriptor.textureUsage = TextureUsage::RENDER_TARGET;
+        descriptor.textureFormat = PixelFormat::RGBA8888;
+        auto texture = backend::Device::getInstance()->newTexture(descriptor);
+        if (! texture)
+            break;
 
-        auto dataLen = powW * powH * 4;
-
-        // we shouldn't have to allocate system memory for a render texture
-        // first patch test before spending little more time on it (we keep a dataLen for initWithData() not to triger an exeption)
-        /*    data = malloc(dataLen);
-            CC_BREAK_IF(! data);
-            memset(data, 0, dataLen); */
-
-        _pixelFormat = format;
-
-        _texture = new (std::nothrow) Texture2D();
-        if (_texture)
+        _texture2D = new (std::nothrow) Texture2D();
+        if (_texture2D)
         {
-            _texture->initWithData(data, dataLen, static_cast<Texture2D::PixelFormat>(_pixelFormat), powW, powH,
-                                   Size(static_cast<float>(w), static_cast<float>(h)));
+            _texture2D->initWithBackendTexture(texture, CC_ENABLE_PREMULTIPLIED_ALPHA != 0);
+            _texture2D->setRenderTarget(true);
+            texture->release();
         }
         else
-        {
             break;
-        }
-        GLint oldRBO;
-        glGetIntegerv(GL_RENDERBUFFER_BINDING, &oldRBO);
-
-        if (Configuration::getInstance()->checkForGLExtension("GL_QCOM"))
-        {
-            _textureCopy = new (std::nothrow) Texture2D();
-            if (_textureCopy)
-            {
-                _textureCopy->initWithData(data, dataLen, static_cast<Texture2D::PixelFormat>(_pixelFormat), powW, powH,
-                                           Size(static_cast<float>(w), static_cast<float>(h)));
-            }
-            else
-            {
-                break;
-            }
-        }
 
-        // generate FBO
-        glGenFramebuffers(1, &_FBO);
-        glBindFramebuffer(GL_FRAMEBUFFER, _FBO);
+        _renderTargetFlags = RenderTargetFlag::COLOR;
 
-        // associate texture with FBO
-        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _texture->getName(), 0);
+        clearColorAttachment();
 
-        if (depthStencilFormat != 0)
+        if (PixelFormat::D24S8 == depthStencilFormat)
         {
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)
-            if (Configuration::getInstance()->supportsOESPackedDepthStencil())
-            {
-                // create and attach depth buffer
-                glGenRenderbuffers(1, &_depthRenderBufffer);
-                glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBufffer);
-                glRenderbufferStorage(GL_RENDERBUFFER, depthStencilFormat, (GLsizei)powW, (GLsizei)powH);
-                glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBufffer);
-
-                // if depth format is the one with stencil part, bind same render buffer as stencil attachment
-                if (depthStencilFormat == GL_DEPTH24_STENCIL8)
-                {
-                    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBufffer);
-                }
-            }
-            else
-            {
-                glGenRenderbuffers(1, &_depthRenderBufffer);
-                glGenRenderbuffers(1, &_stencilRenderBufffer);
-                glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBufffer);
-
-                if (Configuration::getInstance()->supportsOESDepth24())
-                {
-                    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24_OES, (GLsizei)powW, (GLsizei)powH);
-                }
-                else
-                {
-                    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, (GLsizei)powW, (GLsizei)powH);
-                }
-
-                glBindRenderbuffer(GL_RENDERBUFFER, _stencilRenderBufffer);
-                glRenderbufferStorage(GL_RENDERBUFFER, GL_STENCIL_INDEX8, (GLsizei)powW, (GLsizei)powH);
-
-                glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBufffer);
-                glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, _stencilRenderBufffer);
-            }
-#elif (CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN)
-            // create and attach depth buffer
-            glGenRenderbuffers(1, &_depthRenderBufffer);
-            glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBufffer);
+            _renderTargetFlags = RenderTargetFlag::ALL;
+            descriptor.textureFormat = depthStencilFormat;
+            texture = backend::Device::getInstance()->newTexture(descriptor);
+            if (! texture)
+                break;
 
-            // if depth format is the one with stencil part, bind same render buffer as stencil attachment
-            if (depthStencilFormat == GL_DEPTH24_STENCIL8)
-            {
-                glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_STENCIL, (GLsizei)powW, (GLsizei)powH);
-                glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBufffer);
-            }
-            else
-            {
-                glRenderbufferStorage(GL_RENDERBUFFER, depthStencilFormat, (GLsizei)powW, (GLsizei)powH);
-                glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBufffer);
-            }
-#else
-            // create and attach depth buffer
-            glGenRenderbuffers(1, &_depthRenderBufffer);
-            glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBufffer);
-            glRenderbufferStorage(GL_RENDERBUFFER, depthStencilFormat, static_cast<GLsizei>(powW), static_cast<GLsizei>(powH));
-            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBufffer);
-
-            // if depth format is the one with stencil part, bind same render buffer as stencil attachment
-            if (depthStencilFormat == GL_DEPTH24_STENCIL8)
+            _depthStencilTexture = new (std::nothrow) Texture2D;
+            if (!_depthStencilTexture)
             {
-                glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBufffer);
+                texture->release();
+                break;
             }
-#endif
-        }
 
-        // check if it worked (probably worth doing :) )
-        CCASSERT(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE, "Could not attach texture to framebuffer");
+            _depthStencilTexture->initWithBackendTexture(texture);
+            texture->release();
+        }
 
-        _texture->setAliasTexParameters();
+        _texture2D->setAntiAliasTexParameters();
+        if (_texture2DCopy)
+        {
+            _texture2DCopy->setAntiAliasTexParameters();
+        }
 
         // retained
-        setSprite(Sprite::createWithTexture(_texture));
+        setSprite(Sprite::createWithTexture(_texture2D));
+
+        _texture2D->release();
 
-        _texture->release();
+#if defined(CC_USE_GL) || defined(CC_USE_GLES)
         _sprite->setFlippedY(true);
+#endif
 
+#if CC_ENABLE_PREMULTIPLIED_ALPHA != 0
         _sprite->setBlendFunc(BlendFunc::ALPHA_PREMULTIPLIED);
         _sprite->setOpacityModifyRGB(true);
-
-        glBindRenderbuffer(GL_RENDERBUFFER, oldRBO);
-        glBindFramebuffer(GL_FRAMEBUFFER, _oldFBO);
-
+#else
+        _sprite->setBlendFunc(BlendFunc::ALPHA_NON_PREMULTIPLIED);
+        _sprite->setOpacityModifyRGB(false);
+#endif
+        
         // Disabled by default.
         _autoDraw = false;
-
+        
         // add sprite for backward compatibility
         addChild(_sprite);
-
+        
         ret = true;
     } while (0);
-
-    CC_SAFE_FREE(data);
-
+    
     return ret;
 }
 
-/**
- *
- * PRETTY SIMPLE CHANGE !!!
- *
- * Flags the Render Texture as PMA
- *
- * cocos hard codes RenderTexture as PMA = false
- * this is wrong (should be at least accessible to allow a choice) in our case as all assets rendered in RTs are pma and we want the Texture2D of the
- * RenderTexture to be PMA
- */
-void RenderTexture::forcePMATrue()
-{
-    _texture->_hasPremultipliedAlpha = true;
-
-    // update blend func accordingly (might be redondant)
-    // (u should note that althought cocos flags the RT as PMA false, it sets blending modes for PMA texture line 334 in the function above)
-
-    _sprite->setBlendFunc(BlendFunc::ALPHA_PREMULTIPLIED);
-    _sprite->setOpacityModifyRGB(true);
-}
-
 void RenderTexture::setSprite(Sprite* sprite)
 {
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
@@ -411,18 +278,6 @@ void RenderTexture::setSprite(Sprite* sprite)
     _sprite = sprite;
 }
 
-#if CC_ENABLE_CACHE_TEXTURE_DATA
-void RenderTexture::setDestroyedFromContextRecovering(bool p_contextRecovered)
-{
-    _destroyedFromContextRecovering = p_contextRecovered;
-}
-#endif
-
-void RenderTexture::setKeepMatrix(bool keepMatrix)
-{
-    _keepMatrix = keepMatrix;
-}
-
 void RenderTexture::setVirtualViewport(const Vec2& rtBegin, const Rect& fullRect, const Rect& fullViewport)
 {
     _rtTextureRect.origin.x = rtBegin.x;
@@ -435,38 +290,29 @@ void RenderTexture::setVirtualViewport(const Vec2& rtBegin, const Rect& fullRect
 
 void RenderTexture::beginWithClear(float r, float g, float b, float a)
 {
-    beginWithClear(r, g, b, a, 0, 0, GL_COLOR_BUFFER_BIT);
+    beginWithClear(r, g, b, a, 0, 0, ClearFlag::COLOR);
 }
 
 void RenderTexture::beginWithClear(float r, float g, float b, float a, float depthValue)
 {
-    beginWithClear(r, g, b, a, depthValue, 0, GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    beginWithClear(r, g, b, a, depthValue, 0, ClearFlag::COLOR | ClearFlag::DEPTH);
 }
 
 void RenderTexture::beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue)
 {
-    beginWithClear(r, g, b, a, depthValue, stencilValue, GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+    beginWithClear(r, g, b, a, depthValue, stencilValue, ClearFlag::ALL);
 }
 
-void RenderTexture::beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue, GLbitfield flags)
+void RenderTexture::beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue, ClearFlag flags)
 {
     setClearColor(Color4F(r, g, b, a));
-
     setClearDepth(depthValue);
-
     setClearStencil(stencilValue);
-
     setClearFlags(flags);
-
-    this->begin();
-
-    // clear screen
-    _beginWithClearCommand.init(_globalZOrder);
-    _beginWithClearCommand.setFunc([this]() { onClear(); });
-    Director::getInstance()->getRenderer()->addCommand(&_beginWithClearCommand);
+    begin();
+    Director::getInstance()->getRenderer()->clear(_clearFlags, _clearColor, _clearDepth, _clearStencil, _globalZOrder);
 }
 
-// TODO: find a better way to clear the screen, there is no need to rebind render buffer there.
 void RenderTexture::clear(float r, float g, float b, float a)
 {
     this->beginWithClear(r, g, b, a);
@@ -476,31 +322,14 @@ void RenderTexture::clear(float r, float g, float b, float a)
 void RenderTexture::clearDepth(float depthValue)
 {
     setClearDepth(depthValue);
-
-    this->begin();
-
-    _clearDepthCommand.init(_globalZOrder);
-    _clearDepthCommand.setFunc([this]() { onClearDepth(); });
-
-    Director::getInstance()->getRenderer()->addCommand(&_clearDepthCommand);
-
-    this->end();
 }
 
 void RenderTexture::clearStencil(int stencilValue)
 {
-    // save old stencil value
-    int stencilClearValue;
-    glGetIntegerv(GL_STENCIL_CLEAR_VALUE, &stencilClearValue);
-
-    glClearStencil(stencilValue);
-    glClear(GL_STENCIL_BUFFER_BIT);
-
-    // restore clear color
-    glClearStencil(stencilClearValue);
+    setClearStencil(stencilValue);
 }
 
-void RenderTexture::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void RenderTexture::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     // override visit.
     // Don't call visit on its children
@@ -508,7 +337,7 @@ void RenderTexture::visit(Renderer* renderer, const Mat4& parentTransform, uint3
     {
         return;
     }
-
+    
     uint32_t flags = processParentFlags(parentTransform, parentFlags);
 
     Director* director = Director::getInstance();
@@ -523,7 +352,7 @@ void RenderTexture::visit(Renderer* renderer, const Mat4& parentTransform, uint3
     {
         draw(renderer, _modelViewTransform, flags);
     }
-
+    
     director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
 
     // FIX ME: Why need to set _orderOfArrival to 0??
@@ -538,142 +367,146 @@ bool RenderTexture::saveToFile(const std::string& filename, bool isRGBA, std::fu
 
     if (basename.find(".png") != std::string::npos)
     {
-        return saveToFile(filename, Image::Format::PNG, isRGBA, callback, flipImage);
+        return saveToFileAsNonPMA(filename, Image::Format::PNG, isRGBA, callback, flipImage);
     }
     else if (basename.find(".jpg") != std::string::npos)
     {
-        if (isRGBA)
-            CCLOG("RGBA is not supported for JPG format.");
-        return saveToFile(filename, Image::Format::JPG, false, callback);
+        if (isRGBA) CCLOG("RGBA is not supported for JPG format.");
+        return saveToFileAsNonPMA(filename, Image::Format::JPG, false, callback, flipImage);
     }
     else
     {
         CCLOG("Only PNG and JPG format are supported now!");
     }
 
-    return saveToFile(filename, Image::Format::JPG, false, callback, flipImage);
+    return saveToFileAsNonPMA(filename, Image::Format::JPG, false, callback, flipImage);
 }
 
-bool RenderTexture::saveToFile(const std::string& fileName, Image::Format format, bool isRGBA,
-                               std::function<void(RenderTexture*, const std::string&, bool)> callback, bool flipImage)
+bool RenderTexture::saveToFileAsNonPMA(const std::string& fileName, Image::Format format, bool isRGBA, std::function<void(RenderTexture*, const std::string&, bool)> callback, bool flipImage)
 {
-    CCASSERT(format == Image::Format::JPG || format == Image::Format::PNG, "the image can only be saved as JPG or PNG format");
-    if (isRGBA && format == Image::Format::JPG)
-        CCLOG("RGBA is not supported for JPG format");
+    CCASSERT(format == Image::Format::JPG || format == Image::Format::PNG,
+        "the image can only be saved as JPG or PNG format");
+    if (isRGBA && format == Image::Format::JPG) CCLOG("RGBA is not supported for JPG format");
 
     _saveFileCallback = callback;
 
-    std::string fullpath;
-    if (fileName.at(0) == '/')
-        fullpath = fileName;
-    else
-        fullpath = FileUtils::getInstance()->getWritablePath() + fileName;
-
+    std::string fullpath = FileUtils::getInstance()->getWritablePath() + fileName;
     _saveToFileCommand.init(_globalZOrder);
-    _saveToFileCommand.setFunc([this, fullpath, isRGBA, flipImage]() { onSaveToFile(fullpath, isRGBA, flipImage); });
+    _saveToFileCommand.func = CC_CALLBACK_0(RenderTexture::onSaveToFile, this, fullpath, isRGBA, true, flipImage);
 
     Director::getInstance()->getRenderer()->addCommand(&_saveToFileCommand);
     return true;
 }
 
-void RenderTexture::onSaveToFile(const std::string& filename, bool isRGBA, bool flipImage)
+
+bool RenderTexture::saveToFile(const std::string& fileName, Image::Format format, bool isRGBA, std::function<void (RenderTexture*, const std::string&, bool)> callback, bool flipImage)
 {
-    Image* image = newImage(flipImage);
-    bool success = false;
-    if (image)
-    {
-        success = image->saveToFile(filename, !isRGBA);
-    }
-    if (_saveFileCallback)
-    {
-        _saveFileCallback(this, filename, success);
-        _saveFileCallback = nullptr;
-    }
-    CC_SAFE_DELETE(image);
+    CCASSERT(format == Image::Format::JPG || format == Image::Format::PNG,
+             "the image can only be saved as JPG or PNG format");
+    if (isRGBA && format == Image::Format::JPG) CCLOG("RGBA is not supported for JPG format");
+    
+    _saveFileCallback = callback;
+    
+    std::string fullpath = FileUtils::getInstance()->getWritablePath() + fileName;
+    _saveToFileCommand.init(_globalZOrder);
+    _saveToFileCommand.func = CC_CALLBACK_0(RenderTexture::onSaveToFile, this, fullpath, isRGBA, false, flipImage);
+    
+    Director::getInstance()->getRenderer()->addCommand(&_saveToFileCommand);
+    return true;
+}
+
+void RenderTexture::onSaveToFile(const std::string& filename, bool isRGBA, bool forceNonPMA, bool flipImage)
+{
+    auto callbackFunc = [&, filename, isRGBA, forceNonPMA](Image* image){
+         bool success = false;
+        if (image)
+        {
+            if (forceNonPMA && image->hasPremultipliedAlpha())
+            {
+                image->reversePremultipliedAlpha();
+            }
+            success = image->saveToFile(filename, !isRGBA);
+        }
+        if(_saveFileCallback)
+        {
+            _saveFileCallback(this, filename, success);
+        }
+        CC_SAFE_DELETE(image);
+    };
+    newImage(callbackFunc, flipImage);
 }
 
 /* get buffer as Image */
-Image* RenderTexture::newImage(bool fliimage)
+void RenderTexture::newImage(std::function<void(Image*)> imageCallback, bool flipImage)
 {
-    CCASSERT(_pixelFormat == Texture2D::PixelFormat::RGBA8888, "only RGBA8888 can be saved as image");
+    CCASSERT(_pixelFormat == backend::PixelFormat::RGBA8888, "only RGBA8888 can be saved as image");
 
-    if (nullptr == _texture)
+    if ((nullptr == _texture2D))
     {
-        return nullptr;
+        return ;
     }
 
-    const Size& s = _texture->getContentSizeInPixels();
+    const Size& s = _texture2D->getContentSizeInPixels();
 
     // to get the image size to save
     //        if the saving image domain exceeds the buffer texture domain,
     //        it should be cut
-    int savedBufferWidth = static_cast<int>(s.width);
-    int savedBufferHeight = static_cast<int>(s.height);
-
-    GLubyte* buffer = nullptr;
-    GLubyte* tempData = nullptr;
-    Image* image = new (std::nothrow) Image();
-
-    do
+    int savedBufferWidth = (int)s.width;
+    int savedBufferHeight = (int)s.height;
+    
+    Image *image = new (std::nothrow) Image();
+    
+    auto initCallback = [&, savedBufferWidth, savedBufferHeight, imageCallback](Image* image, const unsigned char* tempData){
+        image->initWithRawData(tempData, savedBufferWidth * savedBufferHeight * 4, savedBufferWidth, savedBufferHeight, 8, _texture2D->hasPremultipliedAlpha());
+        imageCallback(image);
+    };
+    auto callback = std::bind(initCallback, image, std::placeholders::_1);
+    
+    _texture2D->getBackendTexture()->getBytes(0, 0, savedBufferWidth, savedBufferHeight, flipImage, callback);
+    
+//    do
+//    {
+////        // TODO: move this to configuration, so we don't check it every time
+////        /*  Certain Qualcomm Adreno GPU's will retain data in memory after a frame buffer switch which corrupts the render to the texture. The solution is to clear the frame buffer before rendering to the texture. However, calling glClear has the unintended result of clearing the current texture. Create a temporary texture to overcome this. At the end of RenderTexture::begin(), switch the attached texture to the second one, call glClear, and then switch back to the original texture. This solution is unnecessary for other devices as they don't have the same issue with switching frame buffers.
+////         */
+////        if (Configuration::getInstance()->checkForGLExtension("GL_QCOM"))
+////        {
+////            // -- bind a temporary texture so we can clear the render buffer without losing our texture
+////            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _textureCopy->getName(), 0);
+////            CHECK_GL_ERROR_DEBUG();
+////            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+////            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _texture->getName(), 0);
+////        }
+//    } while (0);
+}
+
+void RenderTexture::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
+{
+    if (_autoDraw)
     {
-        CC_BREAK_IF(!(buffer = new (std::nothrow) GLubyte[savedBufferWidth * savedBufferHeight * 4]));
-
-        if (!(tempData = new (std::nothrow) GLubyte[savedBufferWidth * savedBufferHeight * 4]))
-        {
-            delete[] buffer;
-            buffer = nullptr;
-            break;
-        }
+        //Begin will create a render group using new render target
+        begin();
 
-        glGetIntegerv(GL_FRAMEBUFFER_BINDING, &_oldFBO);
-        glBindFramebuffer(GL_FRAMEBUFFER, _FBO);
+        //clear screen
+        Director::getInstance()->getRenderer()->clear(_clearFlags, _clearColor, _clearDepth, _clearStencil, _globalZOrder);
 
-        // TODO: move this to configuration, so we don't check it every time
-        /*  Certain Qualcomm Adreno GPU's will retain data in memory after a frame buffer switch which corrupts the render to the texture. The solution is to
-         * clear the frame buffer before rendering to the texture. However, calling glClear has the unintended result of clearing the current texture. Create a
-         * temporary texture to overcome this. At the end of RenderTexture::begin(), switch the attached texture to the second one, call glClear, and then
-         * switch back to the original texture. This solution is unnecessary for other devices as they don't have the same issue with switching frame buffers.
-         */
-        if (Configuration::getInstance()->checkForGLExtension("GL_QCOM"))
-        {
-            // -- bind a temporary texture so we can clear the render buffer without losing our texture
-            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _textureCopy->getName(), 0);
-            CHECK_GL_ERROR_DEBUG();
-            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _texture->getName(), 0);
-        }
-        glPixelStorei(GL_PACK_ALIGNMENT, 1);
-        glReadPixels(0, 0, savedBufferWidth, savedBufferHeight, GL_RGBA, GL_UNSIGNED_BYTE, tempData);
-        glBindFramebuffer(GL_FRAMEBUFFER, _oldFBO);
-
-        if (fliimage) // -- flip is only required when saving image to file
-        {
-            // to get the actual texture data
-            // #640 the image read from rendertexture is dirty
-            for (int i = 0; i < savedBufferHeight; ++i)
-            {
-                memcpy(&buffer[i * savedBufferWidth * 4], &tempData[(savedBufferHeight - i - 1) * savedBufferWidth * 4], savedBufferWidth * 4);
-            }
+        //! make sure all children are drawn
+        sortAllChildren();
 
-            image->initWithRawData(buffer, savedBufferWidth * savedBufferHeight * 4, savedBufferWidth, savedBufferHeight, 8);
-        }
-        else
+        for(const auto &child: _children)
         {
-            image->initWithRawData(tempData, savedBufferWidth * savedBufferHeight * 4, savedBufferWidth, savedBufferHeight, 8);
+            if (child != _sprite)
+                child->visit(renderer, transform, flags);
         }
 
-    } while (0);
-
-    CC_SAFE_DELETE_ARRAY(buffer);
-    CC_SAFE_DELETE_ARRAY(tempData);
-
-    return image;
+        //End will pop the current render group
+        end();
+    }
 }
 
 void RenderTexture::onBegin()
 {
-    //
-    Director* director = Director::getInstance();
+    Director *director = Director::getInstance();
 
     _oldProjMatrix = director->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
     director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, _projectionMatrix);
@@ -681,196 +514,101 @@ void RenderTexture::onBegin()
     _oldTransMatrix = director->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
     director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _transformMatrix);
 
-    if (!_keepMatrix)
+    if(!_keepMatrix)
     {
         director->setProjection(director->getProjection());
-        const Size& texSize = _texture->getContentSizeInPixels();
+        const Size& texSize = _texture2D->getContentSizeInPixels();
+
+        // Calculate the adjustment ratios based on the old and new projections
+        Size size = director->getWinSizeInPixels();
+        float widthRatio = size.width / texSize.width;
+        float heightRatio = size.height / texSize.height;
 
-        // Calculate the texture ortho matrix
         Mat4 orthoMatrix;
-        Mat4::createOrthographicOffCenter(0, texSize.width, 0, texSize.height, -1, 1, orthoMatrix);
-        director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, orthoMatrix);
+        Mat4::createOrthographicOffCenter((float)-1.0 / widthRatio, (float)1.0 / widthRatio, (float)-1.0 / heightRatio, (float)1.0 / heightRatio, -1, 1, &orthoMatrix);
+        director->multiplyMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, orthoMatrix);
     }
 
-    // calculate viewport
-    {
-        Rect viewport;
-        viewport.size.width = _fullviewPort.size.width;
-        viewport.size.height = _fullviewPort.size.height;
-        float viewPortRectWidthRatio = float(viewport.size.width) / _fullRect.size.width;
-        float viewPortRectHeightRatio = float(viewport.size.height) / _fullRect.size.height;
-        viewport.origin.x = (_fullRect.origin.x - _rtTextureRect.origin.x) * viewPortRectWidthRatio;
-        viewport.origin.y = (_fullRect.origin.y - _rtTextureRect.origin.y) * viewPortRectHeightRatio;
-        // glViewport(_fullviewPort.origin.x, _fullviewPort.origin.y, (GLsizei)_fullviewPort.size.width, (GLsizei)_fullviewPort.size.height);
-        glViewport(viewport.origin.x, viewport.origin.y, static_cast<GLsizei>(viewport.size.width), static_cast<GLsizei>(viewport.size.height));
-    }
+    Rect viewport;
+    viewport.size.width = _fullviewPort.size.width;
+    viewport.size.height = _fullviewPort.size.height;
+    float viewPortRectWidthRatio = float(viewport.size.width)/_fullRect.size.width;
+    float viewPortRectHeightRatio = float(viewport.size.height)/_fullRect.size.height;
+    viewport.origin.x = (_fullRect.origin.x - _rtTextureRect.origin.x) * viewPortRectWidthRatio;
+    viewport.origin.y = (_fullRect.origin.y - _rtTextureRect.origin.y) * viewPortRectHeightRatio;
 
-    // Adjust the orthographic projection and viewport
+    Renderer *renderer =  director->getRenderer();
+    
+    _oldViewport = renderer->getViewport();
+    renderer->setViewPort(viewport.origin.x, viewport.origin.y, viewport.size.width, viewport.size.height);
 
-    glGetIntegerv(GL_FRAMEBUFFER_BINDING, &_oldFBO);
-    glBindFramebuffer(GL_FRAMEBUFFER, _FBO);
+    _oldColorAttachment = renderer->getColorAttachment();
+    _oldDepthAttachment = renderer->getDepthAttachment();
+    _oldStencilAttachment = renderer->getStencilAttachment();
+    _oldRenderTargetFlag = renderer->getRenderTargetFlag();
 
-    // TODO: move this to configuration, so we don't check it every time
-    /*  Certain Qualcomm Adreno GPU's will retain data in memory after a frame buffer switch which corrupts the render to the texture. The solution is to clear
-     * the frame buffer before rendering to the texture. However, calling glClear has the unintended result of clearing the current texture. Create a temporary
-     * texture to overcome this. At the end of RenderTexture::begin(), switch the attached texture to the second one, call glClear, and then switch back to the
-     * original texture. This solution is unnecessary for other devices as they don't have the same issue with switching frame buffers.
-     */
-    if (Configuration::getInstance()->checkForGLExtension("GL_QCOM"))
-    {
-        // -- bind a temporary texture so we can clear the render buffer without losing our texture
-        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _textureCopy->getName(), 0);
-        CHECK_GL_ERROR_DEBUG();
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _texture->getName(), 0);
-    }
+    renderer->setRenderTarget(_renderTargetFlags, _texture2D, _depthStencilTexture, _depthStencilTexture);
 }
 
 void RenderTexture::onEnd()
 {
-    Director* director = Director::getInstance();
-
-    glBindFramebuffer(GL_FRAMEBUFFER, _oldFBO);
-
-    // restore viewport
-    director->setViewport();
-    const auto& vp = Camera::getDefaultViewport();
-    glViewport(vp._left, vp._bottom, vp._width, vp._height);
-    //
+    Director *director = Director::getInstance();
     director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, _oldProjMatrix);
     director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _oldTransMatrix);
-}
-
-void RenderTexture::onClear()
-{
-    // save clear color
-    GLfloat oldClearColor[4] = {0.0f};
-    GLfloat oldDepthClearValue = 0.0f;
-    GLint oldStencilClearValue = 0;
-
-    // backup and set
-    if (_clearFlags & GL_COLOR_BUFFER_BIT)
-    {
-        glGetFloatv(GL_COLOR_CLEAR_VALUE, oldClearColor);
-        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearColor.a);
-    }
-
-    if (_clearFlags & GL_DEPTH_BUFFER_BIT)
-    {
-        glGetFloatv(GL_DEPTH_CLEAR_VALUE, &oldDepthClearValue);
-        glClearDepth(_clearDepth);
-    }
-
-    if (_clearFlags & GL_STENCIL_BUFFER_BIT)
-    {
-        glGetIntegerv(GL_STENCIL_CLEAR_VALUE, &oldStencilClearValue);
-        glClearStencil(_clearStencil);
-    }
-
-    // clear
-    glClear(_clearFlags);
-
-    // restore
-    if (_clearFlags & GL_COLOR_BUFFER_BIT)
-    {
-        glClearColor(oldClearColor[0], oldClearColor[1], oldClearColor[2], oldClearColor[3]);
-    }
-    if (_clearFlags & GL_DEPTH_BUFFER_BIT)
-    {
-        glClearDepth(oldDepthClearValue);
-    }
-    if (_clearFlags & GL_STENCIL_BUFFER_BIT)
-    {
-        glClearStencil(oldStencilClearValue);
-    }
-}
-
-void RenderTexture::onClearDepth()
-{
-    //! save old depth value
-    GLfloat depthClearValue;
-    glGetFloatv(GL_DEPTH_CLEAR_VALUE, &depthClearValue);
-
-    glClearDepth(_clearDepth);
-    glClear(GL_DEPTH_BUFFER_BIT);
-
-    // restore clear color
-    glClearDepth(depthClearValue);
-}
-
-void RenderTexture::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
-{
-    if (_autoDraw)
-    {
-        // Begin will create a render group using new render target
-        begin();
-
-        // clear screen
-        if (getClearFlags() != 0x0)
-        {
-            _clearCommand.init(_globalZOrder);
-            _clearCommand.setFunc([this]() { onClear(); });
-            renderer->addCommand(&_clearCommand);
-        }
-
-        //! make sure all children are drawn
-        sortAllChildren();
-
-        for (const auto& child : _children)
-        {
-            if (child != _sprite)
-                child->visit(renderer, transform, flags);
-        }
-
-        // End will pop the current render group
-        end();
-    }
+    
+    Renderer *renderer =  Director::getInstance()->getRenderer();
+    renderer->setViewPort(_oldViewport.x, _oldViewport.y, _oldViewport.w, _oldViewport.h);
+    renderer->setRenderTarget(_oldRenderTargetFlag, _oldColorAttachment, _oldDepthAttachment, _oldStencilAttachment);
 }
 
 void RenderTexture::begin()
 {
     Director* director = Director::getInstance();
     CCASSERT(nullptr != director, "Director is null when setting matrix stack");
-
+    
     director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
     _projectionMatrix = director->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
-
+    
     director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
     _transformMatrix = director->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
-
-    if (!_keepMatrix)
+    
+    if(!_keepMatrix)
     {
         director->setProjection(director->getProjection());
-
-        const Size& texSize = _texture->getContentSizeInPixels();
-
+        
+        const Size& texSize = _texture2D->getContentSizeInPixels();
+        
         // Calculate the adjustment ratios based on the old and new projections
+        Size size = director->getWinSizeInPixels();
+        
+        float widthRatio = size.width / texSize.width;
+        float heightRatio = size.height / texSize.height;
+        
         Mat4 orthoMatrix;
-        Mat4::createOrthographicOffCenter(0, texSize.width, 0, texSize.height, -1, 1, orthoMatrix);
-        director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, orthoMatrix);
+        Mat4::createOrthographicOffCenter((float)-1.0 / widthRatio, (float)1.0 / widthRatio, (float)-1.0 / heightRatio, (float)1.0 / heightRatio, -1, 1, &orthoMatrix);
+        director->multiplyMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, orthoMatrix);
     }
 
     _groupCommand.init(_globalZOrder);
 
-    Renderer* renderer = Director::getInstance()->getRenderer();
+    Renderer *renderer =  Director::getInstance()->getRenderer();
     renderer->addCommand(&_groupCommand);
     renderer->pushGroup(_groupCommand.getRenderQueueID());
 
     _beginCommand.init(_globalZOrder);
-    _beginCommand.setFunc([this]() { onBegin(); });
-
-    Director::getInstance()->getRenderer()->addCommand(&_beginCommand);
+    _beginCommand.func = CC_CALLBACK_0(RenderTexture::onBegin, this);
+    renderer->addCommand(&_beginCommand);
 }
 
 void RenderTexture::end()
 {
     _endCommand.init(_globalZOrder);
-    _endCommand.setFunc([this]() { onEnd(); });
+    _endCommand.func = CC_CALLBACK_0(RenderTexture::onEnd, this);
 
     Director* director = Director::getInstance();
     CCASSERT(nullptr != director, "Director is null when setting matrix stack");
-
-    Renderer* renderer = director->getRenderer();
+    
+    Renderer *renderer = director->getRenderer();
     renderer->addCommand(&_endCommand);
     renderer->popGroup();
 
@@ -878,4 +616,32 @@ void RenderTexture::end()
     director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
 }
 
+void RenderTexture::setClearFlags(ClearFlag clearFlags)
+{
+    _clearFlags = clearFlags;
+    if (_clearFlags != ClearFlag::NONE
+        && !_depthStencilTexture)
+    {
+        _clearFlags = ClearFlag::COLOR;
+    }
+}
+
+void RenderTexture::clearColorAttachment()
+{
+    auto renderer = Director::getInstance()->getRenderer();
+    _beforeClearAttachmentCommand.func = [=]() -> void {
+        _oldColorAttachment = renderer->getColorAttachment();
+        renderer->setRenderTarget(RenderTargetFlag::COLOR, _texture2D, nullptr, nullptr);
+    };
+    renderer->addCommand(&_beforeClearAttachmentCommand);
+
+    Color4F color(0.f, 0.f, 0.f, 0.f);
+    renderer->clear(ClearFlag::COLOR, color, 1, 0, _globalZOrder);
+
+    _afterClearAttachmentCommand.func = [=]() -> void {
+        renderer->setRenderTarget(RenderTargetFlag::COLOR, _oldColorAttachment, nullptr, nullptr);
+    };
+    renderer->addCommand(&_afterClearAttachmentCommand);
+}
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCRenderTexture.h b/cocos2d/cocos/2d/CCRenderTexture.h
index bdc3626ac3..85979ef27b 100644
--- a/cocos2d/cocos/2d/CCRenderTexture.h
+++ b/cocos2d/cocos/2d/CCRenderTexture.h
@@ -2,6 +2,7 @@
 Copyright (c) 2009      Jason Booth
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -23,17 +24,23 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_RENDERTEXTURE_H
-#define CC_2D_RENDERTEXTURE_H
+#pragma once
 
 #include <cocos/2d/CCNode.h>
 #include <cocos/2d/CCSprite.h>
 #include <cocos/platform/CCImage.h>
-#include <cocos/renderer/CCCustomCommand.h>
 #include <cocos/renderer/CCGroupCommand.h>
+#include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/renderer/CCCallbackCommand.h>
+#include <cocos/renderer/backend/Types.h>
 
 NS_CC_BEGIN
 
+namespace backend
+{
+    class TextureBackend;
+}
+
 class EventCustom;
 
 /**
@@ -50,32 +57,37 @@ class EventCustom;
  * There are also functions for saving the render texture to disk in PNG or JPG format.
  * @since v0.8.1
  */
-class CC_DLL RenderTexture : public Node
+class CC_DLL RenderTexture : public Node 
 {
 public:
-    /** Initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format.
+    /** Initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format. 
      *
      * @param w The RenderTexture object width.
      * @param h The RenderTexture object height.
      * @param format In Points and a pixel format( only RGB and RGBA formats are valid ).
      * @param depthStencilFormat The depthStencil format.
      */
-    static RenderTexture* create(int w, int h, Texture2D::PixelFormat format, GLuint depthStencilFormat);
+    static RenderTexture * create(int w ,int h, backend::PixelFormat format, backend::PixelFormat depthStencilFormat);
 
-    /** Creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid.
+    /** Creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid. 
      *
      * @param w The RenderTexture object width.
      * @param h The RenderTexture object height.
      * @param format In Points and a pixel format( only RGB and RGBA formats are valid ).
      */
-    static RenderTexture* create(int w, int h, Texture2D::PixelFormat format);
+    static RenderTexture * create(int w, int h, backend::PixelFormat format);
 
-    /** Creates a RenderTexture object with width and height in Points, pixel format is RGBA8888.
+    /** Creates a RenderTexture object with width and height in Points, pixel format is RGBA8888. 
      *
      * @param w The RenderTexture object width.
      * @param h The RenderTexture object height.
      */
-    static RenderTexture* create(int w, int h);
+    static RenderTexture * create(int w, int h);
+
+    // Overrides
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
+    
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
     /** Starts grabbing. */
     virtual void begin();
@@ -102,7 +114,7 @@ public:
     virtual void beginWithClear(float r, float g, float b, float a, float depthValue);
 
     /** Starts rendering to the texture while clearing the texture first.
-     * This is more efficient then calling -clear first and then -begin.
+     * This is more efficient then calling -clear first and then -begin. 
      *
      * @param r Red.
      * @param g Green.
@@ -118,7 +130,7 @@ public:
      */
     virtual void end();
 
-    /** Clears the texture with a color.
+    /** Clears the texture with a color. 
      *
      * @param r Red.
      * @param g Green.
@@ -127,7 +139,7 @@ public:
      */
     void clear(float r, float g, float b, float a);
 
-    /** Clears the texture with a specified depth value.
+    /** Clears the texture with a specified depth value. 
      *
      * @param depthValue A specified depth value.
      */
@@ -138,7 +150,7 @@ public:
      * @param stencilValue A specified stencil value.
      */
     virtual void clearStencil(int stencilValue);
-
+    
     /* Creates a new Image from with the texture's data.
      * Caller is responsible for releasing it by calling delete.
      *
@@ -146,9 +158,17 @@ public:
      * @return An image.
      * @js NA
      */
-    Image* newImage(bool flipImage = true);
-
-    CC_DEPRECATED_ATTRIBUTE Image* newCCImage(bool flipImage = true) { return newImage(flipImage); }
+    void newImage(std::function<void(Image*)> imageCallback, bool flipImage = true);
+    
+    /** Saves the texture into a file using JPEG format. The file will be saved in the Documents folder.
+     * Returns true if the operation is successful.
+     *
+     * @param filename The file name.
+     * @param isRGBA The file is RGBA or not.
+     * @param callback When the file is save finished,it will callback this function.
+     * @return Returns true if the operation is successful.
+     */
+    bool saveToFileAsNonPMA(const std::string& filename, bool isRGBA = true, std::function<void(RenderTexture*, const std::string, bool)> callback = nullptr, bool flipImage = true);
 
     /** Saves the texture into a file using JPEG format. The file will be saved in the Documents folder.
      * Returns true if the operation is successful.
@@ -158,14 +178,26 @@ public:
      * @param callback When the file is save finished,it will callback this function.
      * @return Returns true if the operation is successful.
      */
-    bool saveToFile(const std::string& filename, bool isRGBA = true, std::function<void(RenderTexture*, const std::string&, bool)> callback = nullptr,
-                    bool flipImage = true);
+    bool saveToFile(const std::string& filename, bool isRGBA = true, std::function<void(RenderTexture*, const std::string&, bool)> callback = nullptr, bool flipImage = true);
+   
+   /** saves the texture into a file in non-PMA. The format could be JPG or PNG. The file will be saved in the Documents folder.
+        Returns true if the operation is successful.
+     * Notes: since v3.x, saveToFile will generate a custom command, which will be called in the following render->render().
+     * So if this function is called in a event handler, the actual save file will be called in the next frame. If we switch to a different scene, the game will crash.
+     * To solve this, add Director::getInstance()->getRenderer()->render(); after this function.
+     *
+     * @param filename The file name.
+     * @param format The image format.
+     * @param isRGBA The file is RGBA or not.
+     * @param callback When the file is save finished,it will callback this function.
+     * @return Returns true if the operation is successful.
+     */
+    bool saveToFileAsNonPMA(const std::string& fileName, Image::Format format, bool isRGBA, std::function<void(RenderTexture*, const std::string&, bool)> callback, bool flipImage);
 
     /** saves the texture into a file. The format could be JPG or PNG. The file will be saved in the Documents folder.
         Returns true if the operation is successful.
      * Notes: since v3.x, saveToFile will generate a custom command, which will be called in the following render->render().
-     * So if this function is called in a event handler, the actual save file will be called in the next frame. If we switch to a different scene, the game will
-     crash.
+     * So if this function is called in a event handler, the actual save file will be called in the next frame. If we switch to a different scene, the game will crash.
      * To solve this, add Director::getInstance()->getRenderer()->render(); after this function.
      *
      * @param filename The file name.
@@ -174,117 +206,102 @@ public:
      * @param callback When the file is save finished,it will callback this function.
      * @return Returns true if the operation is successful.
      */
-    bool saveToFile(const std::string& filename, Image::Format format, bool isRGBA = true,
-                    std::function<void(RenderTexture*, const std::string&, bool)> callback = nullptr, bool flipImage = true);
-
+    bool saveToFile(const std::string& filename, Image::Format format, bool isRGBA = true, std::function<void (RenderTexture*, const std::string&, bool)> callback = nullptr, bool flipImage = false);
+    
     /** Listen "come to background" message, and save render texture.
      * It only has effect on Android.
-     *
+     * 
      * @param event Event Custom.
      */
-    void listenToBackground(EventCustom* event);
-
+    void listenToBackground(EventCustom *event);
+    
     /** Listen "come to foreground" message and restore the frame buffer object.
      * It only has effect on Android.
      *
      * @param event Event Custom.
      */
-    void listenToForeground(EventCustom* event);
+    void listenToForeground(EventCustom *event);
 
-    /** Valid flags: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. They can be OR'ed. Valid when "autoDraw" is true.
+    /** Valid when "autoDraw" is true.
      *
      * @return Clear flags.
      */
-    unsigned int getClearFlags() const { return _clearFlags; }
+    inline ClearFlag getClearFlags() const { return _clearFlags; }
 
     /** Set flags.
      *
-     * @param clearFlags Valid flags: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT.
+     * @param clearFlags set clear flags.
      */
-    void setClearFlags(unsigned int clearFlags) { _clearFlags = clearFlags; }
-
-    /** Clear color value. Valid only when "autoDraw" is true.
+    void setClearFlags(ClearFlag clearFlags);
+    
+    /** Clear color value. Valid only when "autoDraw" is true. 
      *
      * @return Color value.
      */
-    const Color4F& getClearColor() const { return _clearColor; }
-
-    /** Set color value.
+    inline const Color4F& getClearColor() const { return _clearColor; }
+    
+    /** Set color value. 
      *
      * @param clearColor Color value.
      */
-    void setClearColor(const Color4F& clearColor) { _clearColor = clearColor; }
-
-    /** Value for clearDepth. Valid only when "autoDraw" is true.
+    inline void setClearColor(const Color4F &clearColor) { _clearColor = clearColor; }
+    
+    /** Value for clearDepth. Valid only when "autoDraw" is true. 
      *
      * @return Value for clearDepth.
      */
-    float getClearDepth() const { return _clearDepth; }
-
+    inline float getClearDepth() const { return _clearDepth; }
+    
     /** Set Value for clearDepth.
      *
      * @param clearDepth Value for clearDepth.
      */
-    void setClearDepth(float clearDepth) { _clearDepth = clearDepth; }
-
+    inline void setClearDepth(float clearDepth) { _clearDepth = clearDepth; }
+    
     /** Value for clear Stencil. Valid only when "autoDraw" is true.
      *
      * @return Value for clear Stencil.
      */
-    int getClearStencil() const { return _clearStencil; }
-
+    inline int getClearStencil() const { return _clearStencil; }
+    
     /** Set Value for clear Stencil.
      *
      * @param clearStencil Value for clear Stencil.
      */
-    void setClearStencil(int clearStencil) { _clearStencil = clearStencil; }
-
+    inline void setClearStencil(int clearStencil) { _clearStencil = clearStencil; }
+    
     /** When enabled, it will render its children into the texture automatically. Disabled by default for compatibility reasons.
      * Will be enabled in the future.
      *
      * @return Return the autoDraw value.
      */
-    bool isAutoDraw() const { return _autoDraw; }
-
-    /** Set a valve to control whether or not render its children into the texture automatically.
+    inline bool isAutoDraw() const { return _autoDraw; }
+    
+    /** Set a valve to control whether or not render its children into the texture automatically. 
      *
      * @param isAutoDraw Whether or not render its children into the texture automatically.
      */
-    void setAutoDraw(bool isAutoDraw) { _autoDraw = isAutoDraw; }
+    inline void setAutoDraw(bool isAutoDraw) { _autoDraw = isAutoDraw; }
 
-    /** Gets the Sprite being used.
+    /** Gets the Sprite being used. 
      *
      * @return A Sprite.
      */
-    Sprite* getSprite() const { return _sprite; }
-
-    /** Sets the Sprite being used.
+    inline Sprite* getSprite() const { return _sprite; }
+    
+    /** Sets the Sprite being used. 
      *
      * @param sprite A Sprite.
      */
     void setSprite(Sprite* sprite);
 
-    /**
-     * We need this method when destroying texture because in case of a context recovering on android or EMScripten,
-     * we don't want to destroy the associated openGL buffers, as they already have been destroyed
-     *
-     * @param p_contextRecovered Do we came from a context recovering
-     */
-#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID || CC_TARGET_PLATFORM == CC_PLATFORM_EMSCRIPTEN)
-    void setDestroyedFromContextRecovering(bool p_contextRecovered);
-#endif
-
-    // Overrides
-    virtual void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
-    virtual void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
-
     /** Flag: Use stack matrix computed from scene hierarchy or generate new modelView and projection matrix.
      *
      * @param keepMatrix Whether or not use stack matrix computed from scene hierarchy or generate new modelView and projection matrix.
      * @js NA
      */
-    void setKeepMatrix(bool keepMatrix);
-    /**Used for grab part of screen to a texture.
+    inline void setKeepMatrix(bool keepMatrix) { _keepMatrix = keepMatrix; }
+    /**Used for grab part of screen to a texture. 
      * @param rtBegin The position of renderTexture on the fullRect.
      * @param fullRect The total size of screen.
      * @param fullViewport The total viewportSize.
@@ -301,9 +318,9 @@ public:
 
     /**
      * @js NA
-     * @lua NA
+	 * @lua NA
      */
-    ~RenderTexture() override;
+    virtual ~RenderTexture();
     /** Initializes a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid.
      *
      * @param w The RenderTexture object width.
@@ -311,8 +328,8 @@ public:
      * @param format In Points and a pixel format( only RGB and RGBA formats are valid ).
      * @return If succeed, it will return true.
      */
-    bool initWithWidthAndHeight(int w, int h, Texture2D::PixelFormat format);
-    /** Initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format.
+    bool initWithWidthAndHeight(int w, int h, backend::PixelFormat format);
+    /** Initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format. 
      *
      * @param w The RenderTexture object width.
      * @param h The RenderTexture object height.
@@ -320,78 +337,69 @@ public:
      * @param depthStencilFormat The depthStencil format.
      * @return If succeed, it will return true.
      */
-    bool initWithWidthAndHeight(int w, int h, Texture2D::PixelFormat format, GLuint depthStencilFormat);
+    bool initWithWidthAndHeight(int w, int h, backend::PixelFormat format, backend::PixelFormat depthStencilFormat);
 
 protected:
-    virtual void beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue, GLbitfield flags);
-
-    // flags: whether generate new modelView and projection matrix or not
-    bool _keepMatrix;
-    Rect _rtTextureRect;
-    Rect _fullRect;
-    Rect _fullviewPort;
-
-    GLuint _FBO;
-    GLuint _depthRenderBufffer;
-    GLuint _stencilRenderBufffer;
-    GLint _oldFBO;
-    Texture2D* _texture;
-    Texture2D* _textureCopy; // a copy of _texture
-    Image* _UITextureImage;
-    Texture2D::PixelFormat _pixelFormat;
-#if CC_ENABLE_CACHE_TEXTURE_DATA
-    bool _destroyedFromContextRecovering;
-#endif
-
-    // code for "auto" update
-    GLbitfield _clearFlags;
+    virtual void beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue, ClearFlag flags);
+    //renderer caches and callbacks
+    void onBegin();
+    void onEnd();
+    void clearColorAttachment();
+
+    void onSaveToFile(const std::string& fileName, bool isRGBA = true, bool forceNonPMA = false, bool flipImage = true);
+
+    bool         _keepMatrix = false;
+    Rect         _rtTextureRect;
+    Rect         _fullRect;
+    Rect         _fullviewPort;
+
+    Viewport     _oldViewport;
+    
+    Texture2D* _texture2D = nullptr;
+    Texture2D* _depthStencilTexture = nullptr;
+    Texture2D* _texture2DCopy = nullptr;    // a copy of _texture
+    Texture2D* _oldColorAttachment = nullptr;
+    Texture2D* _oldDepthAttachment = nullptr;
+    Texture2D* _oldStencilAttachment = nullptr;
+    RenderTargetFlag _renderTargetFlags;
+    RenderTargetFlag _oldRenderTargetFlag;
+    Image*     _UITextureImage = nullptr;
+    backend::PixelFormat _pixelFormat = backend::PixelFormat::RGBA8888;
+    
     Color4F _clearColor;
-    GLclampf _clearDepth;
-    GLint _clearStencil;
-    bool _autoDraw;
+    float _clearDepth = 1.f;
+    int _clearStencil = 0;
+    bool _autoDraw = false;
+    ClearFlag _clearFlags = ClearFlag::NONE;
 
     /** The Sprite being used.
-     The sprite, by default, will use the following blending function: GL_ONE, GL_ONE_MINUS_SRC_ALPHA.
+     The sprite, by default, will use the following blending function: BlendFactor::ONE, BlendFactor::ONE_MINUS_SRC_ALPHA.
      The blending function can be changed in runtime by calling:
-     - renderTexture->getSprite()->setBlendFunc((BlendFunc){GL_ONE, GL_ONE_MINUS_SRC_ALPHA});
+     - renderTexture->getSprite()->setBlendFunc((BlendFunc){BlendFactor::ONE, BlendFactor::ONE_MINUS_SRC_ALPHA});
      */
-    Sprite* _sprite;
-
+    Sprite* _sprite = nullptr;
+    
     GroupCommand _groupCommand;
-    CustomCommand _beginWithClearCommand;
-    CustomCommand _clearDepthCommand;
-    CustomCommand _clearCommand;
-    CustomCommand _beginCommand;
-    CustomCommand _endCommand;
+    CallbackCommand _beginCommand;
+    CallbackCommand _endCommand;
+
+    CallbackCommand _beforeClearAttachmentCommand;
+    CallbackCommand _afterClearAttachmentCommand;
     /*this command is used to encapsulate saveToFile,
      call saveToFile twice will overwrite this command and callback
      and the command and callback will be executed twice.
     */
-    CustomCommand _saveToFileCommand;
-    std::function<void(RenderTexture*, const std::string&, bool)> _saveFileCallback;
-
-protected:
-    // renderer caches and callbacks
-    void onBegin();
-    void onEnd();
-
-    void onClear();
-    void onClearDepth();
-
-    void onSaveToFile(const std::string& fileName, bool isRGBA = true, bool flipImage = true);
-
-    void forcePMATrue();
-
+    CallbackCommand _saveToFileCommand;
+    std::function<void (RenderTexture*, const std::string&, bool)> _saveFileCallback = nullptr;
+    
     Mat4 _oldTransMatrix, _oldProjMatrix;
     Mat4 _transformMatrix, _projectionMatrix;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(RenderTexture)
+    CC_DISALLOW_COPY_AND_ASSIGN(RenderTexture);
 };
 
 // end of textures group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_RENDERTEXTURE_H
diff --git a/cocos2d/cocos/2d/CCScene.cpp b/cocos2d/cocos/2d/CCScene.cpp
index ad6d84769b..c11d587e17 100644
--- a/cocos2d/cocos/2d/CCScene.cpp
+++ b/cocos2d/cocos/2d/CCScene.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -26,56 +27,41 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCScene.h>
-
-#include <cocos/2d/CCCamera.h>
 #include <cocos/base/CCDirector.h>
+#include <cocos/2d/CCCamera.h>
 #include <cocos/base/CCEventDispatcher.h>
 #include <cocos/base/CCEventListenerCustom.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/renderer/CCFrameBuffer.h>
 #include <cocos/renderer/CCRenderer.h>
 
 #if CC_USE_PHYSICS
-#    include <cocos/physics/CCPhysicsWorld.h>
+#include "physics/CCPhysicsWorld.h"
 #endif
 
 #if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
-#    include "physics3d/CCPhysics3DComponent.h"
-#    include "physics3d/CCPhysics3DWorld.h"
+#include "physics3d/CCPhysics3DWorld.h"
+#include "physics3d/CCPhysics3DComponent.h"
 #endif
 
 #if CC_USE_NAVMESH
-#    include "navmesh/CCNavMesh.h"
+#include "navmesh/CCNavMesh.h"
 #endif
 
 NS_CC_BEGIN
 
 Scene::Scene()
+: _defaultCamera(Camera::create())
+, _event(Director::getInstance()->getEventDispatcher()->addCustomEventListener(Director::EVENT_PROJECTION_CHANGED, std::bind(&Scene::onProjectionChanged, this, std::placeholders::_1)))
 {
-#if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
-    _physics3DWorld = nullptr;
-    _physics3dDebugCamera = nullptr;
-#endif
-#if CC_USE_NAVMESH
-    _navMesh = nullptr;
-    _navMeshDebugCamera = nullptr;
-#endif
-#if CC_USE_PHYSICS
-    _physicsWorld = nullptr;
-#endif
     _ignoreAnchorPointForPosition = true;
     setAnchorPoint(Vec2(0.5f, 0.5f));
+    
+    //create default camera
 
-    _cameraOrderDirty = true;
-
-    // create default camera
-    _defaultCamera = Camera::create();
     addChild(_defaultCamera);
-
-    _event = Director::getInstance()->getEventDispatcher()->addCustomEventListener(Director::EVENT_PROJECTION_CHANGED,
-                                                                                   [this](EventCustom* evt) { onProjectionChanged(evt); });
+    
     _event->retain();
-
+    
     Camera::_visitingCamera = nullptr;
 }
 
@@ -90,11 +76,11 @@ Scene::~Scene()
 #endif
     Director::getInstance()->getEventDispatcher()->removeEventListener(_event);
     CC_SAFE_RELEASE(_event);
-
+    
 #if CC_USE_PHYSICS
     delete _physicsWorld;
 #endif
-
+    
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
     auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
     if (sEngine)
@@ -130,7 +116,7 @@ bool Scene::initWithSize(const Size& size)
 
 Scene* Scene::create()
 {
-    Scene* ret = new (std::nothrow) Scene();
+    Scene *ret = new (std::nothrow) Scene();
     if (ret && ret->init())
     {
         ret->autorelease();
@@ -145,7 +131,7 @@ Scene* Scene::create()
 
 Scene* Scene::createWithSize(const Size& size)
 {
-    Scene* ret = new (std::nothrow) Scene();
+    Scene *ret = new (std::nothrow) Scene();
     if (ret && ret->initWithSize(size))
     {
         ret->autorelease();
@@ -163,7 +149,7 @@ std::string Scene::getDescription() const
     return StringUtils::format("<Scene | tag = %d>", _tag);
 }
 
-void Scene::onProjectionChanged(EventCustom* event)
+void Scene::onProjectionChanged(EventCustom* /*event*/)
 {
     if (_defaultCamera)
     {
@@ -212,14 +198,15 @@ void Scene::render(Renderer* renderer, const Mat4& eyeTransform, const Mat4* eye
         // culling and other stuff.
         if (eyeProjection)
             camera->setAdditionalProjection(*eyeProjection * camera->getProjectionMatrix().getInversed());
-        camera->setAdditionalTransform(eyeTransform.getInversed());
 
+        camera->setAdditionalTransform(eyeTransform.getInversed());
         director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
         director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, Camera::_visitingCamera->getViewProjectionMatrix());
+
         camera->apply();
-        // clear background with max depth
+        //clear background with max depth
         camera->clearBackground();
-        // visit the scene
+        //visit the scene
         visit(renderer, transform, 0);
 #if CC_USE_NAVMESH
         if (_navMesh && _navMeshDebugCamera == camera)
@@ -229,7 +216,6 @@ void Scene::render(Renderer* renderer, const Mat4& eyeTransform, const Mat4* eye
 #endif
 
         renderer->render();
-        camera->restore();
 
         director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
 
@@ -241,17 +227,26 @@ void Scene::render(Renderer* renderer, const Mat4& eyeTransform, const Mat4* eye
 #if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
     if (_physics3DWorld && _physics3DWorld->isDebugDrawEnabled())
     {
+        Camera *physics3dDebugCamera = _physics3dDebugCamera != nullptr ? _physics3dDebugCamera: defaultCamera;
+
+        if (eyeProjection)
+            physics3dDebugCamera->setAdditionalProjection(*eyeProjection * physics3dDebugCamera->getProjectionMatrix().getInversed());
+
+        physics3dDebugCamera->setAdditionalTransform(eyeTransform.getInversed());
         director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
-        director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION,
-                             _physics3dDebugCamera != nullptr ? _physics3dDebugCamera->getViewProjectionMatrix() : defaultCamera->getViewProjectionMatrix());
+        director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, physics3dDebugCamera->getViewProjectionMatrix());
+
+        physics3dDebugCamera->apply();
+        physics3dDebugCamera->clearBackground();
+
         _physics3DWorld->debugDraw(renderer);
         renderer->render();
+
         director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
     }
 #endif
 
     Camera::_visitingCamera = nullptr;
-    //    experimental::FrameBuffer::applyDefaultFBO();
 }
 
 void Scene::removeAllChildren()
@@ -278,7 +273,7 @@ void Scene::setPhysics3DDebugCamera(Camera* camera)
 #endif
 
 #if CC_USE_NAVMESH
-void Scene::setNavMeshDebugCamera(Camera* camera)
+void Scene::setNavMeshDebugCamera(Camera *camera)
 {
     CC_SAFE_RETAIN(camera);
     CC_SAFE_RELEASE(_navMeshDebugCamera);
@@ -291,7 +286,7 @@ void Scene::setNavMeshDebugCamera(Camera* camera)
 
 Scene* Scene::createWithPhysics()
 {
-    Scene* ret = new (std::nothrow) Scene();
+    Scene *ret = new (std::nothrow) Scene();
     if (ret && ret->initWithPhysics())
     {
         ret->autorelease();
@@ -306,23 +301,23 @@ Scene* Scene::createWithPhysics()
 
 bool Scene::initWithPhysics()
 {
-#    if CC_USE_PHYSICS
+#if CC_USE_PHYSICS
     _physicsWorld = PhysicsWorld::construct(this);
-#    endif
+#endif
 
     bool ret = false;
     do
     {
-        Director* director;
-        CC_BREAK_IF(!(director = Director::getInstance()));
+        Director * director;
+        CC_SAFE_DELETE_ARRAY( ! (director = Director::getInstance();) );
 
         this->setContentSize(director->getWinSize());
 
-#    if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
+#if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
         Physics3DWorldDes info;
-        CC_BREAK_IF(!(_physics3DWorld = Physics3DWorld::create(&info)));
+        CC_SAFE_DELETE_ARRAY(! (_physics3DWorld = Physics3DWorld::create(&info);));
         _physics3DWorld->retain();
-#    endif
+#endif
 
         // success
         ret = true;
@@ -335,23 +330,23 @@ bool Scene::initWithPhysics()
 #if (CC_USE_PHYSICS || (CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION) || CC_USE_NAVMESH)
 void Scene::stepPhysicsAndNavigation(float deltaTime)
 {
-#    if CC_USE_PHYSICS
+#if CC_USE_PHYSICS
     if (_physicsWorld && _physicsWorld->isAutoStep())
         _physicsWorld->update(deltaTime);
-#    endif
+#endif
 
-#    if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
+#if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
     if (_physics3DWorld)
     {
         _physics3DWorld->stepSimulate(deltaTime);
     }
-#    endif
-#    if CC_USE_NAVMESH
+#endif
+#if CC_USE_NAVMESH
     if (_navMesh)
     {
         _navMesh->update(deltaTime);
     }
-#    endif
+#endif
 }
 #endif
 
diff --git a/cocos2d/cocos/2d/CCScene.h b/cocos2d/cocos/2d/CCScene.h
index 454b29a7f9..e3a5c9176d 100644
--- a/cocos2d/cocos/2d/CCScene.h
+++ b/cocos2d/cocos/2d/CCScene.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,12 +26,11 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_SCENE_H
-#define CC_2D_SCENE_H
-
-#include <cocos/2d/CCNode.h>
+#ifndef __CCSCENE_H__
+#define __CCSCENE_H__
 
 #include <string>
+#include <cocos/2d/CCNode.h>
 
 NS_CC_BEGIN
 
@@ -64,31 +64,31 @@ For the moment Scene has no other logic than that, but in future releases it mig
 additional logic.
 
 It is a good practice to use a Scene as the parent of all your nodes.
-
+ 
 Scene will create a default camera for you.
 */
 class CC_DLL Scene : public Node
 {
 public:
-    /** Creates a new Scene object.
+    /** Creates a new Scene object. 
      *
      * @return An autoreleased Scene object.
      */
-    static Scene* create();
+    static Scene *create();
 
-    /** Creates a new Scene object with a predefined Size.
+    /** Creates a new Scene object with a predefined Size. 
      *
      * @param size The predefined size of scene.
      * @return An autoreleased Scene object.
      * @js NA
      */
-    static Scene* createWithSize(const Size& size);
+    static Scene *createWithSize(const Size& size);
 
     using Node::addChild;
     virtual std::string getDescription() const override;
-
+    
     /** Get all cameras.
-     *
+     * 
      * @return The vector of all cameras, ordered by camera depth.
      * @js NA
      */
@@ -108,21 +108,24 @@ public:
 
     /** Render the scene.
      * @param renderer The renderer use to render the scene.
+     * @param eyeTransform The AdditionalTransform of camera.
+     * @param eyeProjection The projection matrix of camera.
      * @js NA
      */
     virtual void render(Renderer* renderer, const Mat4& eyeTransform, const Mat4* eyeProjection = nullptr);
-
+  
     /** override function */
     virtual void removeAllChildren() override;
-
-    CC_CONSTRUCTOR_ACCESS : Scene();
-    ~Scene() override;
-
+    
+CC_CONSTRUCTOR_ACCESS:
+    Scene();
+    virtual ~Scene();
+    
     bool init() override;
     bool initWithSize(const Size& size);
-
+    
     void setCameraOrderDirty() { _cameraOrderDirty = true; }
-
+    
     void onProjectionChanged(EventCustom* event);
 
 protected:
@@ -132,62 +135,63 @@ protected:
     friend class Camera;
     friend class BaseLight;
     friend class Renderer;
-
-    std::vector<Camera*> _cameras; // weak ref to Camera
-    Camera* _defaultCamera; // weak ref, default camera created by scene, _cameras[0], Caution that the default camera can not be added to _cameras before
-                            // onEnter is called
-    bool _cameraOrderDirty; // order is dirty, need sort
-    EventListenerCustom* _event;
-
-    std::vector<BaseLight*> _lights;
-
+    
+    std::vector<Camera*> _cameras; //weak ref to Camera
+    Camera*              _defaultCamera = nullptr; //weak ref, default camera created by scene, _cameras[0], Caution that the default camera can not be added to _cameras before onEnter is called
+    bool                 _cameraOrderDirty = true; // order is dirty, need sort
+    EventListenerCustom*       _event = nullptr;
+
+    std::vector<BaseLight *> _lights;
+    
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(Scene)
-
+    CC_DISALLOW_COPY_AND_ASSIGN(Scene);
+    
 #if (CC_USE_PHYSICS || (CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION))
 public:
-#    if CC_USE_PHYSICS
+    
+#if CC_USE_PHYSICS
     /** Get the physics world of the scene.
      * @return The physics world of the scene.
      * @js NA
      */
     PhysicsWorld* getPhysicsWorld() const { return _physicsWorld; }
-#    endif
-
-#    if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
+#endif
+    
+#if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
     /** Get the 3d physics world of the scene.
      * @return The 3d physics world of the scene.
      * @js NA
      */
     Physics3DWorld* getPhysics3DWorld() { return _physics3DWorld; }
-
-    /**
+    
+    /** 
      * Set Physics3D debug draw camera.
      */
     void setPhysics3DDebugCamera(Camera* camera);
-#    endif
-
+#endif
+    
     /** Create a scene with physics.
      * @return An autoreleased Scene object with physics.
      * @js NA
      */
-    static Scene* createWithPhysics();
-
-    CC_CONSTRUCTOR_ACCESS : bool initWithPhysics();
-
+    static Scene *createWithPhysics();
+    
+CC_CONSTRUCTOR_ACCESS:
+    bool initWithPhysics();
+    
 protected:
     void addChildToPhysicsWorld(Node* child);
 
-#    if CC_USE_PHYSICS
-    PhysicsWorld* _physicsWorld;
-#    endif
-
-#    if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
-    Physics3DWorld* _physics3DWorld;
-    Camera* _physics3dDebugCamera; //
-#    endif
+#if CC_USE_PHYSICS
+    PhysicsWorld* _physicsWorld = nullptr;
+#endif
+    
+#if CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION
+    Physics3DWorld*            _physics3DWorld = nullptr;
+    Camera*                    _physics3dDebugCamera = nullptr;
+#endif
 #endif // (CC_USE_PHYSICS || CC_USE_3D_PHYSICS)
-
+    
 #if CC_USE_NAVMESH
 public:
     /** set navigation mesh */
@@ -195,15 +199,15 @@ public:
     /** get navigation mesh */
     NavMesh* getNavMesh() const { return _navMesh; }
     /**
-     * Set NavMesh debug draw camera.
-     */
-    void setNavMeshDebugCamera(Camera* camera);
+    * Set NavMesh debug draw camera.
+    */
+    void setNavMeshDebugCamera(Camera *camera);
 
 protected:
-    NavMesh* _navMesh;
-    Camera* _navMeshDebugCamera;
+    NavMesh*        _navMesh = nullptr;
+    Camera *        _navMeshDebugCamera = nullptr;
 #endif
-
+    
 #if (CC_USE_PHYSICS || (CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION) || CC_USE_NAVMESH)
 public:
     void stepPhysicsAndNavigation(float deltaTime);
@@ -215,4 +219,4 @@ public:
 
 NS_CC_END
 
-#endif // CC_2D_SCENE_H
+#endif // __CCSCENE_H__
diff --git a/cocos2d/cocos/2d/CCSprite.cpp b/cocos2d/cocos/2d/CCSprite.cpp
index 1e37011cf1..6f8edf412a 100644
--- a/cocos2d/cocos/2d/CCSprite.cpp
+++ b/cocos2d/cocos/2d/CCSprite.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,48 +25,32 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-
 #include <cocos/2d/CCSprite.h>
 
-#include <cocos/2d/CCAnimation.h>
-#include <cocos/2d/CCAnimationCache.h>
-#include <cocos/2d/CCAutoPolygon.h>
-#include <cocos/2d/CCCamera.h>
-#include <cocos/2d/CCNode.h>
+#include <algorithm>
+
 #include <cocos/2d/CCSpriteBatchNode.h>
+#include <cocos/2d/CCAnimationCache.h>
 #include <cocos/2d/CCSpriteFrame.h>
 #include <cocos/2d/CCSpriteFrameCache.h>
+#include <cocos/renderer/CCTextureCache.h>
+#include <cocos/renderer/CCTexture2D.h>
+#include <cocos/renderer/CCRenderer.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCImage.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTexture2D.h>
-#include <cocos/renderer/CCTextureAtlas.h>
-#include <cocos/renderer/CCTextureCache.h>
-#include <cocos/renderer/CCTrianglesCommand.h>
+#include <cocos/2d/CCCamera.h>
+#include <cocos/platform/CCFileUtils.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
+#include <cocos/2d/CCAnimation.h>
 
-#include <cstdio>
-#include <cstring>
-#include <new>
-#include <type_traits>
 
 NS_CC_BEGIN
 
 // MARK: create, init, dealloc
-Sprite* Sprite::createWithTexture(Texture2D* texture)
+Sprite* Sprite::createWithTexture(Texture2D *texture)
 {
-    Sprite* sprite = new (std::nothrow) Sprite();
+    Sprite *sprite = new (std::nothrow) Sprite();
     if (sprite && sprite->initWithTexture(texture))
     {
         sprite->autorelease();
@@ -75,9 +60,9 @@ Sprite* Sprite::createWithTexture(Texture2D* texture)
     return nullptr;
 }
 
-Sprite* Sprite::createWithTexture(Texture2D* texture, const Rect& rect, bool rotated)
+Sprite* Sprite::createWithTexture(Texture2D *texture, const Rect& rect, bool rotated)
 {
-    Sprite* sprite = new (std::nothrow) Sprite();
+    Sprite *sprite = new (std::nothrow) Sprite();
     if (sprite && sprite->initWithTexture(texture, rect, rotated))
     {
         sprite->autorelease();
@@ -89,7 +74,7 @@ Sprite* Sprite::createWithTexture(Texture2D* texture, const Rect& rect, bool rot
 
 Sprite* Sprite::create(const std::string& filename)
 {
-    Sprite* sprite = new (std::nothrow) Sprite();
+    Sprite *sprite = new (std::nothrow) Sprite();
     if (sprite && sprite->initWithFile(filename))
     {
         sprite->autorelease();
@@ -101,8 +86,8 @@ Sprite* Sprite::create(const std::string& filename)
 
 Sprite* Sprite::create(const PolygonInfo& info)
 {
-    Sprite* sprite = new (std::nothrow) Sprite();
-    if (sprite && sprite->initWithPolygon(info))
+    Sprite *sprite = new (std::nothrow) Sprite();
+    if(sprite && sprite->initWithPolygon(info))
     {
         sprite->autorelease();
         return sprite;
@@ -113,7 +98,7 @@ Sprite* Sprite::create(const PolygonInfo& info)
 
 Sprite* Sprite::create(const std::string& filename, const Rect& rect)
 {
-    Sprite* sprite = new (std::nothrow) Sprite();
+    Sprite *sprite = new (std::nothrow) Sprite();
     if (sprite && sprite->initWithFile(filename, rect))
     {
         sprite->autorelease();
@@ -123,9 +108,9 @@ Sprite* Sprite::create(const std::string& filename, const Rect& rect)
     return nullptr;
 }
 
-Sprite* Sprite::createWithSpriteFrame(SpriteFrame* spriteFrame)
+Sprite* Sprite::createWithSpriteFrame(SpriteFrame *spriteFrame)
 {
-    Sprite* sprite = new (std::nothrow) Sprite();
+    Sprite *sprite = new (std::nothrow) Sprite();
     if (sprite && spriteFrame && sprite->initWithSpriteFrame(spriteFrame))
     {
         sprite->autorelease();
@@ -137,7 +122,7 @@ Sprite* Sprite::createWithSpriteFrame(SpriteFrame* spriteFrame)
 
 Sprite* Sprite::createWithSpriteFrameName(const std::string& spriteFrameName)
 {
-    SpriteFrame* frame = SpriteFrameCache::getInstance()->getSpriteFrameByName(spriteFrameName);
+    SpriteFrame *frame = SpriteFrameCache::getInstance()->getSpriteFrameByName(spriteFrameName);
 
 #if COCOS2D_DEBUG > 0
     char msg[256] = {0};
@@ -150,7 +135,7 @@ Sprite* Sprite::createWithSpriteFrameName(const std::string& spriteFrameName)
 
 Sprite* Sprite::create()
 {
-    Sprite* sprite = new (std::nothrow) Sprite();
+    Sprite *sprite = new (std::nothrow) Sprite();
     if (sprite && sprite->init())
     {
         sprite->autorelease();
@@ -163,24 +148,21 @@ Sprite* Sprite::create()
 bool Sprite::init()
 {
     initWithTexture(nullptr, Rect::ZERO);
-
     return true;
 }
 
-bool Sprite::initWithTexture(Texture2D* texture)
+bool Sprite::initWithTexture(Texture2D *texture)
 {
     CCASSERT(texture != nullptr, "Invalid texture for sprite");
 
     Rect rect = Rect::ZERO;
     if (texture)
-    {
         rect.size = texture->getContentSize();
-    }
 
     return initWithTexture(texture, rect, false);
 }
 
-bool Sprite::initWithTexture(Texture2D* texture, const Rect& rect)
+bool Sprite::initWithTexture(Texture2D *texture, const Rect& rect)
 {
     return initWithTexture(texture, rect, false);
 }
@@ -194,9 +176,8 @@ bool Sprite::initWithFile(const std::string& filename)
     }
 
     _fileName = filename;
-    _fileType = 0;
 
-    Texture2D* texture = _director->getTextureCache()->addImage(filename);
+    Texture2D *texture = _director->getTextureCache()->addImage(filename);
     if (texture)
     {
         Rect rect = Rect::ZERO;
@@ -210,22 +191,17 @@ bool Sprite::initWithFile(const std::string& filename)
     return false;
 }
 
-bool Sprite::initWithFile(const std::string& filename, const Rect& rect)
+bool Sprite::initWithFile(const std::string &filename, const Rect& rect)
 {
     CCASSERT(!filename.empty(), "Invalid filename");
     if (filename.empty())
-    {
         return false;
-    }
 
     _fileName = filename;
-    _fileType = 0;
 
-    Texture2D* texture = _director->getTextureCache()->addImage(filename);
+    Texture2D *texture = _director->getTextureCache()->addImage(filename);
     if (texture)
-    {
         return initWithTexture(texture, rect);
-    }
 
     // don't release here.
     // when load texture failed, it's better to get a "transparent" sprite then a crashed program
@@ -237,40 +213,37 @@ bool Sprite::initWithSpriteFrameName(const std::string& spriteFrameName)
 {
     CCASSERT(!spriteFrameName.empty(), "Invalid spriteFrameName");
     if (spriteFrameName.empty())
-    {
         return false;
-    }
 
     _fileName = spriteFrameName;
     _fileType = 1;
 
-    SpriteFrame* frame = SpriteFrameCache::getInstance()->getSpriteFrameByName(spriteFrameName);
+    SpriteFrame *frame = SpriteFrameCache::getInstance()->getSpriteFrameByName(spriteFrameName);
     return initWithSpriteFrame(frame);
 }
 
-bool Sprite::initWithSpriteFrame(SpriteFrame* spriteFrame)
+bool Sprite::initWithSpriteFrame(SpriteFrame *spriteFrame)
 {
     CCASSERT(spriteFrame != nullptr, "spriteFrame can't be nullptr!");
     if (spriteFrame == nullptr)
-    {
         return false;
-    }
 
-    bool bRet = initWithTexture(spriteFrame->getTexture(), spriteFrame->getRect());
+    bool ret = initWithTexture(spriteFrame->getTexture(), spriteFrame->getRect(), spriteFrame->isRotated());
     setSpriteFrame(spriteFrame);
 
-    return bRet;
+    return ret;
 }
 
-bool Sprite::initWithPolygon(const cocos2d::PolygonInfo& info)
+bool Sprite::initWithPolygon(const cocos2d::PolygonInfo &info)
 {
     bool ret = false;
 
-    Texture2D* texture = _director->getTextureCache()->addImage(info.filename);
-    if (texture && initWithTexture(texture))
+    Texture2D *texture = _director->getTextureCache()->addImage(info.getFilename());
+    if(texture && initWithTexture(texture))
     {
         _polyInfo = info;
-        setContentSize(_polyInfo.rect.size / _director->getContentScaleFactor());
+        _renderMode = RenderMode::POLYGON;
+        Node::setContentSize(_polyInfo.getRect().size / _director->getContentScaleFactor());
         ret = true;
     }
 
@@ -278,7 +251,7 @@ bool Sprite::initWithPolygon(const cocos2d::PolygonInfo& info)
 }
 
 // designated initializer
-bool Sprite::initWithTexture(Texture2D* texture, const Rect& rect, bool rotated)
+bool Sprite::initWithTexture(Texture2D *texture, const Rect& rect, bool rotated)
 {
     bool result = false;
     if (Node::init())
@@ -288,14 +261,10 @@ bool Sprite::initWithTexture(Texture2D* texture, const Rect& rect, bool rotated)
         _recursiveDirty = false;
         setDirty(false);
 
-        _opacityModifyRGB = true;
-
-        _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
-
         _flippedX = _flippedY = false;
 
         // default transform anchor: center
-        setAnchorPoint(Vec2(0.5f, 0.5f));
+        setAnchorPoint(Vec2::ANCHOR_MIDDLE);
 
         // zwoptex default values
         _offsetPosition.setZero();
@@ -309,9 +278,6 @@ bool Sprite::initWithTexture(Texture2D* texture, const Rect& rect, bool rotated)
         _quad.tl.colors = Color4B::WHITE;
         _quad.tr.colors = Color4B::WHITE;
 
-        // shader state
-        // setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP));
-
         // update texture (calls updateBlendFunc)
         setTexture(texture);
         setTextureRect(rect, rotated, rect.size);
@@ -333,11 +299,13 @@ Sprite::Sprite()
 #if CC_SPRITE_DEBUG_DRAW
     _debugDrawNode = DrawNode::create();
     addChild(_debugDrawNode);
-#endif // CC_SPRITE_DEBUG_DRAW
+#endif //CC_SPRITE_DEBUG_DRAW
 }
 
 Sprite::~Sprite()
 {
+    CC_SAFE_DELETE_ARRAY(_trianglesVertex);;
+    CC_SAFE_DELETE_ARRAY(_trianglesIndex);;
     CC_SAFE_RELEASE(_spriteFrame);
     CC_SAFE_RELEASE(_texture);
 }
@@ -358,32 +326,102 @@ Sprite::~Sprite()
  */
 static unsigned char cc_2x2_white_image[] = {
     // RGBA8888
-    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+    0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF
+};
 
-#define CC_2x2_WHITE_IMAGE_KEY "/cc_2x2_white_image"
+#define CC_2x2_WHITE_IMAGE_KEY  "/cc_2x2_white_image"
 
 // MARK: texture
-void Sprite::setTexture(const std::string& filename)
+void Sprite::setTexture(const std::string &filename)
 {
-    Texture2D* texture = Director::getInstance()->getTextureCache()->addImage(filename);
+    Texture2D *texture = Director::getInstance()->getTextureCache()->addImage(filename);
     setTexture(texture);
     _unflippedOffsetPositionFromCenter = Vec2::ZERO;
     Rect rect = Rect::ZERO;
     if (texture)
         rect.size = texture->getContentSize();
+
     setTextureRect(rect);
 }
 
-void Sprite::setTexture(Texture2D* texture)
+void Sprite::setVertexLayout()
+{
+    //set vertexLayout according to V3F_C4B_T2F structure
+    //auto& vertexLayout = _trianglesCommand.getPipelineDescriptor().vertexLayout;
+    auto vertexLayout = _programState->getVertexLayout();
+    ///a_position
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_POSITION,
+                              _programState->getAttributeLocation(backend::Attribute::POSITION),
+                              backend::VertexFormat::FLOAT3,
+                              0,
+                              false);
+    ///a_texCoord
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_TEXCOORD,
+                              _programState->getAttributeLocation(backend::Attribute::TEXCOORD),
+                              backend::VertexFormat::FLOAT2,
+                              offsetof(V3F_C4B_T2F, texCoords),
+                              false);
+    
+    ///a_color
+    vertexLayout->setAttribute(backend::ATTRIBUTE_NAME_COLOR,
+                              _programState->getAttributeLocation(backend::Attribute::COLOR),
+                              backend::VertexFormat::UBYTE4,
+                              offsetof(V3F_C4B_T2F, colors),
+                              true);
+    vertexLayout->setLayout(sizeof(V3F_C4B_T2F));
+}
+
+void Sprite::updateShaders(const char* vert, const char* frag)
+{
+    auto programState = new (std::nothrow) backend::ProgramState(vert, frag);
+    setProgramState(programState);
+    CC_SAFE_RELEASE_NULL(programState);
+}
+
+void Sprite::setProgramState(backend::ProgramType type)
+{
+    if(_programState != nullptr &&
+       _programState->getProgram()->getProgramType() == type)
+        return;
+    
+    auto programState = new (std::nothrow) backend::ProgramState(type);
+    setProgramState(programState);
+    CC_SAFE_RELEASE_NULL(programState);
+}
+
+void Sprite::setProgramState(backend::ProgramState *programState)
 {
-    setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR_NO_MVP, texture));
+    CCASSERT(programState, "argument should not be nullptr");
+    auto& pipelineDescriptor = _trianglesCommand.getPipelineDescriptor();
+    if (_programState != programState)
+    {
+        CC_SAFE_RELEASE(_programState);
+        _programState = programState;
+        CC_SAFE_RETAIN(programState);
+    }
+    pipelineDescriptor.programState = _programState;
 
-    // If batchnode, then texture id should be the same
-    CCASSERT(!_batchNode || (texture && texture->getName() == _batchNode->getTexture()->getName()),
-             "CCSprite: Batched sprites should use the same texture as the batchnode");
-    // accept texture==nil as argument
-    CCASSERT(!texture || dynamic_cast<Texture2D*>(texture), "setTexture expects a Texture2D. Invalid argument");
+    _mvpMatrixLocation = pipelineDescriptor.programState->getUniformLocation(backend::Uniform::MVP_MATRIX);
+    _textureLocation = pipelineDescriptor.programState->getUniformLocation(backend::Uniform::TEXTURE);
+    _alphaTextureLocation = pipelineDescriptor.programState->getUniformLocation(backend::Uniform::TEXTURE1);
 
+    setVertexLayout();
+    updateProgramState();
+    setMVPMatrixUniform();
+}
+
+void Sprite::setTexture(Texture2D *texture)
+{
+    auto isETC1 = texture && texture->getAlphaTextureName();
+    setProgramState((isETC1) ? backend::ProgramType::ETC1 : backend::ProgramType::POSITION_TEXTURE_COLOR);
+
+    CCASSERT(! _batchNode || (texture &&  texture == _batchNode->getTexture()), "CCSprite: Batched sprites should use the same texture as the batchnode");
+    // accept texture==nil as argument
+    CCASSERT( !texture || dynamic_cast<Texture2D*>(texture), "setTexture expects a Texture2D. Invalid argument");
+    
     if (texture == nullptr)
     {
         // Gets the texture by key firstly.
@@ -393,8 +431,7 @@ void Sprite::setTexture(Texture2D* texture)
         if (texture == nullptr)
         {
             Image* image = new (std::nothrow) Image();
-            bool isOK = image->initWithRawData(cc_2x2_white_image, sizeof(cc_2x2_white_image), 2, 2, 8);
-            CC_UNUSED_PARAM(isOK);
+            bool CC_UNUSED isOK = image->initWithRawData(cc_2x2_white_image, sizeof(cc_2x2_white_image), 2, 2, 8);
             CCASSERT(isOK, "The 2x2 empty texture was created unsuccessfully.");
 
             texture = _director->getTextureCache()->addImage(image, CC_2x2_WHITE_IMAGE_KEY);
@@ -402,13 +439,32 @@ void Sprite::setTexture(Texture2D* texture)
         }
     }
 
-    if (!_batchNode && _texture != texture)
+    if (_renderMode != RenderMode::QUAD_BATCHNODE)
     {
-        CC_SAFE_RETAIN(texture);
-        CC_SAFE_RELEASE(_texture);
-        _texture = texture;
+        if (_texture != texture)
+        {
+            CC_SAFE_RETAIN(texture);
+            CC_SAFE_RELEASE(_texture);
+            _texture = texture;
+        }
         updateBlendFunc();
     }
+
+    updateProgramState();
+}
+
+void Sprite::updateProgramState()
+{
+    if (_texture == nullptr || _texture->getBackendTexture() == nullptr)
+        return;
+
+    auto programState = _trianglesCommand.getPipelineDescriptor().programState;
+    programState->setTexture(_textureLocation, 0, _texture->getBackendTexture());
+    auto alphaTexture = _texture->getAlphaTexture();
+    if(alphaTexture && alphaTexture->getBackendTexture())
+    {
+        programState->setTexture(_alphaTextureLocation, 1, alphaTexture->getBackendTexture());
+    }
 }
 
 Texture2D* Sprite::getTexture() const
@@ -425,50 +481,351 @@ void Sprite::setTextureRect(const Rect& rect, bool rotated, const Size& untrimme
 {
     _rectRotated = rotated;
 
-    setContentSize(untrimmedSize);
+    Node::setContentSize(untrimmedSize);
+    _originalContentSize = untrimmedSize;
+
     setVertexRect(rect);
-    setTextureCoords(rect);
+    updateStretchFactor();
+    updatePoly();
+}
+
+void Sprite::updatePoly()
+{
+    // There are 3 cases:
+    //
+    // A) a non 9-sliced, non stretched
+    //    contentsize doesn't not affect the stretching, since there is no stretching
+    //    this was the original behavior, and we keep it for backwards compatibility reasons
+    //    When non-stretching is enabled, we have to change the offset in order to "fill the empty" space at the
+    //    left-top of the texture
+    // B) non 9-sliced, stretched
+    //    the texture is stretched to the content size
+    // C) 9-sliced, stretched
+    //    the sprite is 9-sliced and stretched.
+    if (_renderMode == RenderMode::QUAD || _renderMode == RenderMode::QUAD_BATCHNODE)
+    {
+        Rect copyRect;
+        if (_stretchEnabled)
+            // case B)
+            copyRect = Rect(0, 0, _rect.size.width * _stretchFactor.x, _rect.size.height * _stretchFactor.y);
+        else
+            // case A)
+            // modify origin to put the sprite in the correct offset
+            copyRect = Rect((_contentSize.width - _originalContentSize.width) / 2.0f,
+                            (_contentSize.height - _originalContentSize.height) / 2.0f,
+                            _rect.size.width,
+                            _rect.size.height);
 
-    float relativeOffsetX = _unflippedOffsetPositionFromCenter.x;
-    float relativeOffsetY = _unflippedOffsetPositionFromCenter.y;
+        setTextureCoords(_rect, &_quad);
+        setVertexCoords(copyRect, &_quad);
+        _polyInfo.setQuad(&_quad);
 
-    // issue #732
-    if (_flippedX)
-    {
-        relativeOffsetX = -relativeOffsetX;
     }
-    if (_flippedY)
+    else if (_renderMode == RenderMode::SLICE9)
     {
-        relativeOffsetY = -relativeOffsetY;
+        // case C)
+
+        // How the texture is split
+        //
+        //  u,v: are the texture coordinates
+        //  w,h: are the width and heights
+        //
+        //      w0    w1   w2
+        // v2 +----+------+--+
+        //    |    |      |  |
+        //    |    |      |  |
+        //    | 6  |   7  | 8|  h2
+        //    |    |      |  |
+        // v1 +----+------+--|
+        //    |    |      |  |
+        //    | 3  |   4  | 5|  h1
+        // v0 +----+------+--|
+        //    |    |      |  |
+        //    | 0  |   1  | 2|  h0
+        //    |    |      |  |
+        //    +----+------+--+
+        //    u0   u1    u2
+        //
+        //
+        //  and when the texture is rotated, it will get transformed.
+        //  not only the rects have a different position, but also u,v
+        //  points to the bottom-left and not top-right of the texture
+        //  so some swaping/origin/reordering needs to be done in order
+        //  to support rotated slice-9 correctly
+        //
+        //       w0    w1     w2
+        // v2 +------+----+--------+
+        //    |      |    |        |
+        //    |   0  |  3 |    6   | h2
+        // v1 +------+----+--------+
+        //    |      |    |        |
+        //    |   1  |  4 |    7   | h1
+        //    |      |    |        |
+        // v0 +------+----+--------+
+        //    |   2  |  5 |    8   | h0
+        //    +------+----+--------+
+        //    u0      u1     u2
+
+
+        // center rect
+        float cx1 = _centerRectNormalized.origin.x;
+        float cy1 = _centerRectNormalized.origin.y;
+        float cx2 = _centerRectNormalized.origin.x + _centerRectNormalized.size.width;
+        float cy2 = _centerRectNormalized.origin.y + _centerRectNormalized.size.height;
+
+        // "O"riginal rect
+        const float oox = _rect.origin.x;
+        const float ooy = _rect.origin.y;
+        float osw = _rect.size.width;
+        float osh = _rect.size.height;
+
+        if (_rectRotated)
+        {
+            std::swap(cx1, cy1);
+            std::swap(cx2, cy2);
+
+            // when the texture is rotated, then the centerRect starts from the "bottom" (left)
+            // but when it is not rotated, it starts from the top, so invert it
+            cy2 = 1 - cy2;
+            cy1 = 1 - cy1;
+            std::swap(cy1, cy2);
+            std::swap(osw, osh);
+        }
+
+        //
+        // textCoords Data: Y must be inverted.
+        //
+        const float w0 = osw * cx1;
+        const float w1 = osw * (cx2-cx1);
+        const float w2 = osw * (1-cx2);
+        const float h0 = osh * cy1;
+        const float h1 = osh * (cy2-cy1);
+        const float h2 = osh * (1-cy2);
+
+        const float u0 = oox;
+        const float u1 = u0 + w0;
+        const float u2 = u1 + w1;
+        const float v2 = ooy;
+        const float v1 = v2 + h2;
+        const float v0 = v1 + h1;
+
+
+        const Rect texRects_normal[9] = {
+            Rect(u0, v0,    w0, h0),   // bottom-left
+            Rect(u1, v0,    w1, h0),   // bottom
+            Rect(u2, v0,    w2, h0),   // bottom-right
+
+            Rect(u0, v1,    w0, h1),   // left
+            Rect(u1, v1,    w1, h1),   // center
+            Rect(u2, v1,    w2, h1),   // right
+
+            Rect(u0, v2,    w0, h2),   // top-left
+            Rect(u1, v2,    w1, h2),   // top
+            Rect(u2, v2,    w2, h2),   // top-right
+        };
+
+        // swap width and height because setTextureCoords()
+        // will expects the hight and width to be swapped
+        const Rect texRects_rotated[9] = {
+            Rect(u0, v2,    h2, w0),        // top-left
+            Rect(u0, v1,    h1, w0),        // left
+            Rect(u0, v0,    h0, w0),        // bottom-left
+
+            Rect(u1, v2,    h2, w1),        // top
+            Rect(u1, v1,    h1, w1),        // center
+            Rect(u1, v0,    h0, w1),        // bottom
+
+            Rect(u2, v2,    h2, w2),        // top-right
+            Rect(u2, v1,    h1, w2),        // right
+            Rect(u2, v0,    h0, w2),        // bottom-right
+        };
+
+        const Rect* texRects = _rectRotated ? texRects_rotated : texRects_normal;
+
+        //
+        // vertex Data.
+        //
+
+        // reset center rect since it is altered when when the texture
+        // is rotated
+        cx1 = _centerRectNormalized.origin.x;
+        cy1 = _centerRectNormalized.origin.y;
+        cx2 = _centerRectNormalized.origin.x + _centerRectNormalized.size.width;
+        cy2 = _centerRectNormalized.origin.y + _centerRectNormalized.size.height;
+        if (_rectRotated)
+            std::swap(osw, osh);
+
+        // sizes
+        float x0_s = osw * cx1;
+        float x1_s = osw * (cx2-cx1) * _stretchFactor.x;
+        float x2_s = osw * (1-cx2);
+        float y0_s = osh * cy1;
+        float y1_s = osh * (cy2-cy1) * _stretchFactor.y;
+        float y2_s = osh * (1-cy2);
+
+
+        // avoid negative size:
+        if (_contentSize.width < x0_s + x2_s)
+            x2_s = x0_s = _contentSize.width / 2;
+
+        if  (_contentSize.height < y0_s + y2_s)
+            y2_s = y0_s = _contentSize.height / 2;
+
+
+        // is it flipped?
+        // swap sizes to calculate offset correctly
+        if (_flippedX)
+            std::swap(x0_s, x2_s);
+        if (_flippedY)
+            std::swap(y0_s, y2_s);
+
+        // origins
+        float x0 = 0;
+        float x1 = x0 + x0_s;
+        float x2 = x1 + x1_s;
+        float y0 = 0;
+        float y1 = y0 + y0_s;
+        float y2 = y1 + y1_s;
+
+        // swap origin, but restore size to its original value
+        if (_flippedX)
+        {
+            std::swap(x0, x2);
+            std::swap(x0_s, x2_s);
+        }
+        if (_flippedY)
+        {
+            std::swap(y0, y2);
+            std::swap(y0_s, y2_s);
+        }
+
+        const Rect verticesRects[9] = {
+            Rect(x0, y0,  x0_s, y0_s),      // bottom-left
+            Rect(x1, y0,  x1_s, y0_s),      // bottom
+            Rect(x2, y0,  x2_s, y0_s),      // bottom-right
+
+            Rect(x0, y1,  x0_s, y1_s),      // left
+            Rect(x1, y1,  x1_s, y1_s),      // center
+            Rect(x2, y1,  x2_s, y1_s),      // right
+
+            Rect(x0, y2,  x0_s, y2_s),      // top-left
+            Rect(x1, y2,  x1_s, y2_s),      // top
+            Rect(x2, y2,  x2_s, y2_s),      // top-right
+        };
+
+        // needed in order to get color from "_quad"
+        V3F_C4B_T2F_Quad tmpQuad = _quad;
+
+        for (int i=0; i<9; ++i)
+        {
+            setTextureCoords(texRects[i], &tmpQuad);
+            setVertexCoords(verticesRects[i], &tmpQuad);
+            populateTriangle(i, tmpQuad);
+        }
+        TrianglesCommand::Triangles triangles;
+        triangles.verts = _trianglesVertex;
+        triangles.vertCount = 16;
+        triangles.indices = _trianglesIndex;
+        triangles.indexCount = 6 * 9;   // 9 quads, each needs 6 vertices
+
+        // probably we can update the _trianglesCommand directly
+        // to avoid memcpy'ing stuff
+        _polyInfo.setTriangles(triangles);
     }
+}
 
-    _offsetPosition.x = relativeOffsetX + (_contentSize.width - _rect.size.width) / 2;
-    _offsetPosition.y = relativeOffsetY + (_contentSize.height - _rect.size.height) / 2;
+void Sprite::setCenterRectNormalized(const cocos2d::Rect &rectTopLeft)
+{
+    if (_renderMode != RenderMode::QUAD && _renderMode != RenderMode::SLICE9) {
+        CCLOGWARN("Warning: Sprite::setCenterRectNormalized() only works with QUAD and SLICE9 render modes");
+        return;
+    }
 
-    // rendering using batch node
-    if (_batchNode)
+    // FIMXE: Rect is has origin on top-left (like text coordinate).
+    // but all the logic has been done using bottom-left as origin. So it is easier to invert Y
+    // here, than in the rest of the places... but it is not as clean.
+    Rect rect(rectTopLeft.origin.x, 1 - rectTopLeft.origin.y - rectTopLeft.size.height, rectTopLeft.size.width, rectTopLeft.size.height);
+    if (!_centerRectNormalized.equals(rect))
     {
-        // update dirty_, don't update recursiveDirty_
-        setDirty(true);
+        _centerRectNormalized = rect;
+
+        // convert it to 1-slice when the centerRect is not present.
+        if (rect.equals(Rect(0,0,1,1)))
+        {
+            _renderMode = RenderMode::QUAD;
+            free(_trianglesVertex);
+            free(_trianglesIndex);
+            _trianglesVertex = nullptr;
+            _trianglesIndex = nullptr;
+        }
+        else
+        {
+            // convert it to 9-slice if it isn't already
+            if (_renderMode != RenderMode::SLICE9)
+            {
+                _renderMode = RenderMode::SLICE9;
+                // 9 quads + 7 exterior points = 16
+                _trianglesVertex = (V3F_C4B_T2F*) malloc(sizeof(*_trianglesVertex) * (9 + 3 + 4));
+                // 9 quads, each needs 6 vertices = 54
+                _trianglesIndex = (unsigned short*) malloc(sizeof(*_trianglesIndex) * 6 * 9);
+
+                // populate indices in CCW direction
+                for (int i=0; i<9; ++i)
+                {
+                    _trianglesIndex[i * 6 + 0] = (i * 4 / 3) + 4;
+                    _trianglesIndex[i * 6 + 1] = (i * 4 / 3) + 0;
+                    _trianglesIndex[i * 6 + 2] = (i * 4 / 3) + 5;
+                    _trianglesIndex[i * 6 + 3] = (i * 4 / 3) + 1;
+                    _trianglesIndex[i * 6 + 4] = (i * 4 / 3) + 5;
+                    _trianglesIndex[i * 6 + 5] = (i * 4 / 3) + 0;
+                }
+            }
+        }
+
+        updateStretchFactor();
+        updatePoly();
+        updateColor();
     }
-    else
+}
+
+void Sprite::setCenterRect(const cocos2d::Rect &rectInPoints)
+{
+    if (_renderMode != RenderMode::QUAD && _renderMode != RenderMode::SLICE9)
     {
-        // self rendering
+        CCLOGWARN("Warning: Sprite::setCenterRect() only works with QUAD and SLICE9 render modes");
+        return;
+    }
 
-        // Atlas: Vertex
-        float x1 = 0.0f + _offsetPosition.x;
-        float y1 = 0.0f + _offsetPosition.y;
-        float x2 = x1 + _rect.size.width;
-        float y2 = y1 + _rect.size.height;
+    if (!_originalContentSize.equals(Size::ZERO))
+    {
+        Rect rect = rectInPoints;
 
-        // Don't update Z.
-        _quad.bl.vertices.set(x1, y1, 0.0f);
-        _quad.br.vertices.set(x2, y1, 0.0f);
-        _quad.tl.vertices.set(x1, y2, 0.0f);
-        _quad.tr.vertices.set(x2, y2, 0.0f);
+        const float x = rect.origin.x / _rect.size.width;
+        const float y = rect.origin.y / _rect.size.height;
+        const float w = rect.size.width / _rect.size.width;
+        const float h = rect.size.height / _rect.size.height;
+        setCenterRectNormalized(Rect(x,y,w,h));
     }
+}
+
+Rect Sprite::getCenterRectNormalized() const
+{
+    // FIXME: _centerRectNormalized is in bottom-left coords, but should converted to top-left
+    Rect ret(_centerRectNormalized.origin.x,
+             1 - _centerRectNormalized.origin.y - _centerRectNormalized.size.height,
+             _centerRectNormalized.size.width,
+             _centerRectNormalized.size.height);
+    return ret;
+}
 
-    _polyInfo.setQuad(&_quad);
+Rect Sprite::getCenterRect() const
+{
+    Rect rect = getCenterRectNormalized();
+    rect.origin.x *= _rect.size.width;
+    rect.origin.y *= _rect.size.height;
+    rect.size.width *= _rect.size.width;
+    rect.size.height *= _rect.size.height;
+    return rect;
 }
 
 // override this method to generate "double scale" sprites
@@ -477,100 +834,196 @@ void Sprite::setVertexRect(const Rect& rect)
     _rect = rect;
 }
 
-void Sprite::setTextureCoords(const Rect& rectInPoint)
+void Sprite::setTextureCoords(const Rect& rectInPoints)
+{
+    setTextureCoords(rectInPoints, &_quad);
+}
+
+void Sprite::setTextureCoords(const Rect& rectInPoints, V3F_C4B_T2F_Quad* outQuad)
 {
-    Texture2D* tex = _batchNode ? _textureAtlas->getTexture() : _texture;
+    Texture2D *tex = (_renderMode == RenderMode::QUAD_BATCHNODE) ? _textureAtlas->getTexture() : _texture;
+    
     if (tex == nullptr)
-    {
         return;
-    }
 
-    auto rectInPixels = CC_RECT_POINTS_TO_PIXELS(rectInPoint);
+    const auto rectInPixels = CC_RECT_POINTS_TO_PIXELS(rectInPoints);
 
-    float atlasWidth = static_cast<float>(tex->getPixelsWide());
-    float atlasHeight = static_cast<float>(tex->getPixelsHigh());
+    const float atlasWidth = (float)tex->getPixelsWide();
+    const float atlasHeight = (float)tex->getPixelsHigh();
+   
+    float rw = rectInPixels.size.width;
+    float rh = rectInPixels.size.height;
 
-    float left, right, top, bottom;
+    // if the rect is rotated, it means that the frame is rotated 90 degrees (clockwise) and:
+    //  - rectInpoints: origin will be the bottom-left of the frame (and not the top-right)
+    //  - size: represents the unrotated texture size
+    //
+    // so what we have to do is:
+    //  - swap texture width and height
+    //  - take into account the origin
+    //  - flip X instead of Y when flipY is enabled
+    //  - flip Y instead of X when flipX is enabled
 
     if (_rectRotated)
-    {
+        std::swap(rw, rh);
+
 #if CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
-        left = (2 * rectInPixels.origin.x + 1) / (2 * atlasWidth);
-        right = left + (rectInPixels.size.height * 2 - 2) / (2 * atlasWidth);
-        top = (2 * rectInPixels.origin.y + 1) / (2 * atlasHeight);
-        bottom = top + (rectInPixels.size.width * 2 - 2) / (2 * atlasHeight);
+    float left    = (2*rectInPixels.origin.x+1) / (2*atlasWidth);
+    float right   = left+(rw*2-2) / (2*atlasWidth);
+    float top     = (2*rectInPixels.origin.y+1) / (2*atlasHeight);
+    float bottom  = top+(rh*2-2) / (2*atlasHeight);
 #else
-        left = rectInPixels.origin.x / atlasWidth;
-        right = (rectInPixels.origin.x + rectInPixels.size.height) / atlasWidth;
-        top = rectInPixels.origin.y / atlasHeight;
-        bottom = (rectInPixels.origin.y + rectInPixels.size.width) / atlasHeight;
+    float left    = rectInPixels.origin.x / atlasWidth;
+    float right   = (rectInPixels.origin.x + rw) / atlasWidth;
+    float top     = rectInPixels.origin.y / atlasHeight;
+    float bottom  = (rectInPixels.origin.y + rh) / atlasHeight;
 #endif // CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
 
-        if (_flippedX)
-        {
-            std::swap(top, bottom);
-        }
 
-        if (_flippedY)
-        {
-            std::swap(left, right);
-        }
+    if ((!_rectRotated && _flippedX) || (_rectRotated && _flippedY))
+        std::swap(left, right);
+
+    if ((!_rectRotated && _flippedY) || (_rectRotated && _flippedX))
+        std::swap(top, bottom);
 
-        _quad.bl.texCoords.u = left;
-        _quad.bl.texCoords.v = top;
-        _quad.br.texCoords.u = left;
-        _quad.br.texCoords.v = bottom;
-        _quad.tl.texCoords.u = right;
-        _quad.tl.texCoords.v = top;
-        _quad.tr.texCoords.u = right;
-        _quad.tr.texCoords.v = bottom;
+    if (_rectRotated)
+    {
+        outQuad->bl.texCoords.u = left;
+        outQuad->bl.texCoords.v = top;
+        outQuad->br.texCoords.u = left;
+        outQuad->br.texCoords.v = bottom;
+        outQuad->tl.texCoords.u = right;
+        outQuad->tl.texCoords.v = top;
+        outQuad->tr.texCoords.u = right;
+        outQuad->tr.texCoords.v = bottom;
     }
     else
     {
-#if CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
-        left = (2 * rectInPixels.origin.x + 1) / (2 * atlasWidth);
-        right = left + (rectInPixels.size.width * 2 - 2) / (2 * atlasWidth);
-        top = (2 * rectInPixels.origin.y + 1) / (2 * atlasHeight);
-        bottom = top + (rectInPixels.size.height * 2 - 2) / (2 * atlasHeight);
-#else
-        left = rectInPixels.origin.x / atlasWidth;
-        right = (rectInPixels.origin.x + rectInPixels.size.width) / atlasWidth;
-        top = rectInPixels.origin.y / atlasHeight;
-        bottom = (rectInPixels.origin.y + rectInPixels.size.height) / atlasHeight;
-#endif // ! CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
+        outQuad->bl.texCoords.u = left;
+        outQuad->bl.texCoords.v = bottom;
+        outQuad->br.texCoords.u = right;
+        outQuad->br.texCoords.v = bottom;
+        outQuad->tl.texCoords.u = left;
+        outQuad->tl.texCoords.v = top;
+        outQuad->tr.texCoords.u = right;
+        outQuad->tr.texCoords.v = top;
+    }
+}
+
+void Sprite::setVertexCoords(const Rect& rect, V3F_C4B_T2F_Quad* outQuad)
+{
+    float relativeOffsetX = _unflippedOffsetPositionFromCenter.x;
+    float relativeOffsetY = _unflippedOffsetPositionFromCenter.y;
+
+    // issue #732
+    if (_flippedX)
+        relativeOffsetX = -relativeOffsetX;
+    if (_flippedY)
+        relativeOffsetY = -relativeOffsetY;
 
+    _offsetPosition.x = relativeOffsetX + (_originalContentSize.width - _rect.size.width) / 2;
+    _offsetPosition.y = relativeOffsetY + (_originalContentSize.height - _rect.size.height) / 2;
+
+    // FIXME: Stretching should be applied to the "offset" as well
+    // but probably it should be calculated in the caller function. It will be tidier
+    if (_renderMode == RenderMode::QUAD)
+    {
+        _offsetPosition.x *= _stretchFactor.x;
+        _offsetPosition.y *= _stretchFactor.y;
+    }
+
+    // rendering using batch node
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
+    {
+        // update dirty_, don't update recursiveDirty_
+        setDirty(true);
+    }
+    else
+    {
+        // self rendering
+
+        // Atlas: Vertex
+        const float x1 = 0.0f + _offsetPosition.x + rect.origin.x;
+        const float y1 = 0.0f + _offsetPosition.y + rect.origin.y;
+        const float x2 = x1 + rect.size.width;
+        const float y2 = y1 + rect.size.height;
+
+        // Don't update Z.
+        outQuad->bl.vertices.set(x1, y1, 0.0f);
+        outQuad->br.vertices.set(x2, y1, 0.0f);
+        outQuad->tl.vertices.set(x1, y2, 0.0f);
+        outQuad->tr.vertices.set(x2, y2, 0.0f);
+    }
+}
+
+void Sprite::populateTriangle(int quadIndex, const V3F_C4B_T2F_Quad& quad)
+{
+    CCASSERT(quadIndex < 9, "Invalid quadIndex");
+    // convert Quad intro Triangle since it takes less memory
+
+    // Triangles are ordered like the following:
+    //   Numbers: Quad Index
+    //   Letters: triangles' vertices
+    //
+    //  M-----N-----O-----P
+    //  |     |     |     |
+    //  |  6  |  7  |  8  |
+    //  |     |     |     |
+    //  I-----J-----K-----L
+    //  |     |     |     |
+    //  |  3  |  4  |  5  |
+    //  |     |     |     |
+    //  E-----F-----G-----H
+    //  |     |     |     |
+    //  |  0  |  1  |  2  |
+    //  |     |     |     |
+    //  A-----B-----C-----D
+    //
+    // So, if QuadIndex == 4, then it should update vertices J,K,F,G
+
+    // Optimization: I don't need to copy all the vertices all the time. just the 4 "quads" from the corners.
+    if (quadIndex == 0 || quadIndex == 2 || quadIndex == 6 || quadIndex == 8)
+    {
         if (_flippedX)
         {
-            std::swap(left, right);
+            if (quadIndex % 3 == 0)
+                quadIndex += 2;
+            else
+                quadIndex -= 2;
         }
 
         if (_flippedY)
         {
-            std::swap(top, bottom);
+            if (quadIndex <= 2)
+                quadIndex += 6;
+            else
+                quadIndex -= 6;
         }
 
-        _quad.bl.texCoords.u = left;
-        _quad.bl.texCoords.v = bottom;
-        _quad.br.texCoords.u = right;
-        _quad.br.texCoords.v = bottom;
-        _quad.tl.texCoords.u = left;
-        _quad.tl.texCoords.v = top;
-        _quad.tr.texCoords.u = right;
-        _quad.tr.texCoords.v = top;
+        const int index_bl = quadIndex * 4 / 3;
+        const int index_br = index_bl + 1;
+        const int index_tl = index_bl + 4;
+        const int index_tr = index_bl + 5;
+
+        _trianglesVertex[index_tr] = quad.tr;
+        _trianglesVertex[index_br] = quad.br;
+        _trianglesVertex[index_tl] = quad.tl;
+        _trianglesVertex[index_bl] = quad.bl;
     }
 }
 
+
 // MARK: visit, draw, transform
 
-void Sprite::updateTransform(void)
+void Sprite::updateTransform()
 {
-    CCASSERT(_batchNode, "updateTransform is only valid when Sprite is being rendered using an SpriteBatchNode");
+    CCASSERT(_renderMode == RenderMode::QUAD_BATCHNODE, "updateTransform is only valid when Sprite is being rendered using an SpriteBatchNode");
 
     // recalculate matrix only if it is dirty
-    if (isDirty())
+    if(isDirty() )
     {
         // If it is not visible, or one of its ancestors is not visible, then do nothing:
-        if (!_visible || (_parent && _parent != _batchNode && static_cast<Sprite*>(_parent)->_shouldBeHidden))
+        if( !_visible || ( _parent && _parent != _batchNode && static_cast<Sprite*>(_parent)->_shouldBeHidden) )
         {
             _quad.br.vertices.setZero();
             _quad.tl.vertices.setZero();
@@ -582,15 +1035,13 @@ void Sprite::updateTransform(void)
         {
             _shouldBeHidden = false;
 
-            if (!_parent || _parent == _batchNode)
-            {
+            if( ! _parent || _parent == _batchNode )
                 _transformToBatch = getNodeToParentTransform();
-            }
             else
             {
-                CCASSERT(dynamic_cast<Sprite*>(_parent), "Logic error in Sprite. Parent must be a Sprite");
-                const Mat4& nodeToParent = getNodeToParentTransform();
-                Mat4& parentTransform = static_cast<Sprite*>(_parent)->_transformToBatch;
+                CCASSERT( dynamic_cast<Sprite*>(_parent), "Logic error in Sprite. Parent must be a Sprite");
+                const Mat4 &nodeToParent = getNodeToParentTransform();
+                Mat4 &parentTransform = static_cast<Sprite*>(_parent)->_transformToBatch;
                 _transformToBatch = parentTransform * nodeToParent;
             }
 
@@ -598,7 +1049,7 @@ void Sprite::updateTransform(void)
             // calculate the Quad based on the Affine Matrix
             //
 
-            Size& size = _rect.size;
+            Size &size = _rect.size;
 
             float x1 = _offsetPosition.x;
             float y1 = _offsetPosition.y;
@@ -634,97 +1085,85 @@ void Sprite::updateTransform(void)
 
         // MARMALADE CHANGE: ADDED CHECK FOR nullptr, TO PERMIT SPRITES WITH NO BATCH NODE / TEXTURE ATLAS
         if (_textureAtlas)
-        {
             _textureAtlas->updateQuad(&_quad, _atlasIndex);
-        }
 
         _recursiveDirty = false;
         setDirty(false);
     }
 
-    // MARMALADE CHANGED
-    // recursively iterate over children
-    /*    if( _hasChildren )
-     {
-     // MARMALADE: CHANGED TO USE Node*
-     // NOTE THAT WE HAVE ALSO DEFINED virtual Node::updateTransform()
-     arrayMakeObjectsPerformSelector(_children, updateTransform, Sprite*);
-     }*/
     Node::updateTransform();
 }
 
 // draw
-
-void Sprite::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void Sprite::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
-    if (_texture == nullptr)
-    {
+    if (_texture == nullptr || _texture->getBackendTexture() == nullptr)
         return;
-    }
+    
+    //TODO: arnold: current camera can be a non-default one.
+    setMVPMatrixUniform();
 
 #if CC_USE_CULLING
     // Don't calculate the culling if the transform was not updated
     auto visitingCamera = Camera::getVisitingCamera();
     auto defaultCamera = Camera::getDefaultCamera();
-    if (visitingCamera == defaultCamera)
-    {
-        _insideBounds = ((flags & FLAGS_TRANSFORM_DIRTY) || visitingCamera->isViewProjectionUpdated()) ? renderer->checkVisibility(transform, _contentSize) :
-                                                                                                         _insideBounds;
-    }
+    if (visitingCamera == nullptr)
+        _insideBounds = true;
+    else if (visitingCamera == defaultCamera)
+        _insideBounds = ((flags & FLAGS_TRANSFORM_DIRTY) || visitingCamera->isViewProjectionUpdated()) ? renderer->checkVisibility(transform, _contentSize) : _insideBounds;
     else
-    {
         // XXX: this always return true since
         _insideBounds = renderer->checkVisibility(transform, _contentSize);
-    }
 
-    if (_insideBounds)
+    if(_insideBounds)
 #endif
     {
-        _trianglesCommand.init(_globalZOrder, _texture, getGLProgramState(), _blendFunc, _polyInfo.triangles, transform, flags);
-
+        _trianglesCommand.init(_globalZOrder,
+                               _texture,
+                               _blendFunc,
+                               _polyInfo.triangles,
+                               transform,
+                               flags);
         renderer->addCommand(&_trianglesCommand);
-
+        
 #if CC_SPRITE_DEBUG_DRAW
-        _debugDrawNode->clear();
-        auto count = _polyInfo.triangles.indexCount / 3;
-        auto indices = _polyInfo.triangles.indices;
-        auto verts = _polyInfo.triangles.verts;
-        for (std::size_t i = 0; i < count; i++)
-        {
-            // draw 3 lines
-            Vec3 from = verts[indices[i * 3]].vertices;
-            Vec3 to = verts[indices[i * 3 + 1]].vertices;
-            _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x, to.y), Color4F::WHITE);
-
-            from = verts[indices[i * 3 + 1]].vertices;
-            to = verts[indices[i * 3 + 2]].vertices;
-            _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x, to.y), Color4F::WHITE);
-
-            from = verts[indices[i * 3 + 2]].vertices;
-            to = verts[indices[i * 3]].vertices;
-            _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x, to.y), Color4F::WHITE);
-        }
-#endif // CC_SPRITE_DEBUG_DRAW
+            _debugDrawNode->clear();
+            auto count = _polyInfo.triangles.indexCount / 3;
+            auto indices = _polyInfo.triangles.indices;
+            auto verts = _polyInfo.triangles.verts;
+            for(unsigned int i = 0; i < count; i++)
+            {
+                //draw 3 lines
+                Vec3 from =verts[indices[i*3]].vertices;
+                Vec3 to = verts[indices[i*3+1]].vertices;
+                _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x,to.y), Color4F::WHITE);
+                
+                from =verts[indices[i*3+1]].vertices;
+                to = verts[indices[i*3+2]].vertices;
+                _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x,to.y), Color4F::WHITE);
+                
+                from =verts[indices[i*3+2]].vertices;
+                to = verts[indices[i*3]].vertices;
+                _debugDrawNode->drawLine(Vec2(from.x, from.y), Vec2(to.x,to.y), Color4F::WHITE);
+            }
+#endif //CC_SPRITE_DEBUG_DRAW
     }
 }
 
 // MARK: visit, draw, transform
 
-void Sprite::addChild(Node* child, int zOrder, int tag)
+void Sprite::addChild(Node *child, int zOrder, int tag)
 {
     CCASSERT(child != nullptr, "Argument must be non-nullptr");
     if (child == nullptr)
-    {
         return;
-    }
 
-    if (_batchNode)
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
     {
         Sprite* childSprite = dynamic_cast<Sprite*>(child);
-        CCASSERT(childSprite, "CCSprite only supports Sprites as children when using SpriteBatchNode");
-        CCASSERT(childSprite->getTexture()->getName() == _textureAtlas->getTexture()->getName(),
-                 "childSprite's texture name should be equal to _textureAtlas's texture name!");
-        // put it in descendants array of batch node
+        CCASSERT( childSprite, "CCSprite only supports Sprites as children when using SpriteBatchNode");
+        CCASSERT(childSprite->getTexture() == _textureAtlas->getTexture(), "childSprite's texture name should be equal to _textureAtlas's texture name!");
+        //put it in descendants array of batch node
         _batchNode->appendChild(childSprite);
 
         if (!_reorderChildDirty)
@@ -732,25 +1171,23 @@ void Sprite::addChild(Node* child, int zOrder, int tag)
             setReorderChildDirtyRecursively();
         }
     }
-    // CCNode already sets isReorderChildDirty_ so this needs to be after batchNode check
+    //CCNode already sets isReorderChildDirty_ so this needs to be after batchNode check
     Node::addChild(child, zOrder, tag);
 }
 
-void Sprite::addChild(Node* child, int zOrder, const std::string& name)
+void Sprite::addChild(Node *child, int zOrder, const std::string &name)
 {
     CCASSERT(child != nullptr, "Argument must be non-nullptr");
     if (child == nullptr)
-    {
         return;
-    }
 
-    if (_batchNode)
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
     {
         Sprite* childSprite = dynamic_cast<Sprite*>(child);
-        CCASSERT(childSprite, "CCSprite only supports Sprites as children when using SpriteBatchNode");
-        CCASSERT(childSprite->getTexture()->getName() == _textureAtlas->getTexture()->getName(),
+        CCASSERT( childSprite, "CCSprite only supports Sprites as children when using SpriteBatchNode");
+        CCASSERT(childSprite->getTexture() == _textureAtlas->getTexture(),
                  "childSprite's texture name should be equal to _textureAtlas's texture name.");
-        // put it in descendants array of batch node
+        //put it in descendants array of batch node
         _batchNode->appendChild(childSprite);
 
         if (!_reorderChildDirty)
@@ -758,16 +1195,16 @@ void Sprite::addChild(Node* child, int zOrder, const std::string& name)
             setReorderChildDirtyRecursively();
         }
     }
-    // CCNode already sets isReorderChildDirty_ so this needs to be after batchNode check
+    //CCNode already sets isReorderChildDirty_ so this needs to be after batchNode check
     Node::addChild(child, zOrder, name);
 }
 
-void Sprite::reorderChild(Node* child, int zOrder)
+void Sprite::reorderChild(Node *child, int zOrder)
 {
     CCASSERT(child != nullptr, "child must be non null");
     CCASSERT(_children.contains(child), "child does not belong to this");
 
-    if (_batchNode && !_reorderChildDirty)
+    if ((_renderMode == RenderMode::QUAD_BATCHNODE) && ! _reorderChildDirty)
     {
         setReorderChildDirtyRecursively();
         _batchNode->reorderBatch(true);
@@ -776,27 +1213,23 @@ void Sprite::reorderChild(Node* child, int zOrder)
     Node::reorderChild(child, zOrder);
 }
 
-void Sprite::removeChild(Node* child, bool cleanup)
+void Sprite::removeChild(Node *child, bool cleanup)
 {
-    if (_batchNode)
-    {
-        _batchNode->removeSpriteFromAtlas(static_cast<Sprite*>(child));
-    }
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
+        _batchNode->removeSpriteFromAtlas((Sprite*)(child));
 
     Node::removeChild(child, cleanup);
 }
 
 void Sprite::removeAllChildrenWithCleanup(bool cleanup)
 {
-    if (_batchNode)
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
     {
-        for (const auto& child : _children)
+        for(const auto &child : _children)
         {
             Sprite* sprite = dynamic_cast<Sprite*>(child);
             if (sprite)
-            {
                 _batchNode->removeSpriteFromAtlas(sprite);
-            }
         }
     }
 
@@ -809,9 +1242,9 @@ void Sprite::sortAllChildren()
     {
         sortNodes(_children);
 
-        if (_batchNode)
+        if (_renderMode == RenderMode::QUAD_BATCHNODE)
         {
-            for (const auto& child : _children)
+            for(const auto &child : _children)
                 child->sortAllChildren();
         }
 
@@ -824,17 +1257,17 @@ void Sprite::sortAllChildren()
 // used only when parent is SpriteBatchNode
 //
 
-void Sprite::setReorderChildDirtyRecursively(void)
+void Sprite::setReorderChildDirtyRecursively()
 {
-    // only set parents flag the first time
-    if (!_reorderChildDirty)
+    //only set parents flag the first time
+    if ( ! _reorderChildDirty )
     {
         _reorderChildDirty = true;
         Node* node = static_cast<Node*>(_parent);
         while (node && node != _batchNode)
         {
             static_cast<Sprite*>(node)->setReorderChildDirtyRecursively();
-            node = node->getParent();
+            node=node->getParent();
         }
     }
 }
@@ -844,27 +1277,23 @@ void Sprite::setDirtyRecursively(bool bValue)
     _recursiveDirty = bValue;
     setDirty(bValue);
 
-    for (const auto& child : _children)
+    for(const auto &child: _children)
     {
         Sprite* sp = dynamic_cast<Sprite*>(child);
         if (sp)
-        {
             sp->setDirtyRecursively(true);
-        }
     }
 }
 
 // FIXME: HACK: optimization
-#define SET_DIRTY_RECURSIVELY()            \
-    {                                      \
-        if (!_recursiveDirty)              \
-        {                                  \
-            _recursiveDirty = true;        \
-            setDirty(true);                \
-            if (!_children.empty())        \
-                setDirtyRecursively(true); \
-        }                                  \
-    }
+#define SET_DIRTY_RECURSIVELY() {                       \
+                    if (! _recursiveDirty) {            \
+                        _recursiveDirty = true;         \
+                        setDirty(true);                 \
+                        if (!_children.empty())         \
+                            setDirtyRecursively(true);  \
+                        }                               \
+                    }
 
 void Sprite::setPosition(const Vec2& pos)
 {
@@ -917,6 +1346,10 @@ void Sprite::setScaleX(float scaleX)
 
 void Sprite::setScaleY(float scaleY)
 {
+#ifdef CC_USE_METAL
+    if(_texture->isRenderTarget())
+       scaleY = std::abs(scaleY);
+#endif
     Node::setScaleY(scaleY);
     SET_DIRTY_RECURSIVELY();
 }
@@ -947,7 +1380,7 @@ void Sprite::setAnchorPoint(const Vec2& anchor)
 
 void Sprite::setIgnoreAnchorPointForPosition(bool value)
 {
-    CCASSERT(!_batchNode, "setIgnoreAnchorPointForPosition is invalid in Sprite");
+    CCASSERT(_renderMode != RenderMode::QUAD_BATCHNODE, "setIgnoreAnchorPointForPosition is invalid in Sprite");
     Node::setIgnoreAnchorPointForPosition(value);
 }
 
@@ -957,41 +1390,147 @@ void Sprite::setVisible(bool bVisible)
     SET_DIRTY_RECURSIVELY();
 }
 
+void Sprite::setContentSize(const Size& size)
+{
+    if (_renderMode == RenderMode::QUAD_BATCHNODE || _renderMode == RenderMode::POLYGON)
+        CCLOGWARN("Sprite::setContentSize() doesn't stretch the sprite when using QUAD_BATCHNODE or POLYGON render modes");
+
+    Node::setContentSize(size);
+
+    updateStretchFactor();
+    updatePoly();
+}
+
+void Sprite::setStretchEnabled(bool enabled)
+{
+    if (_stretchEnabled != enabled)
+    {
+        _stretchEnabled = enabled;
+
+        // disabled centerrect / number of slices if disabled
+        if (!enabled)
+            setCenterRectNormalized(Rect(0,0,1,1));
+
+        updateStretchFactor();
+        updatePoly();
+    }
+}
+
+bool Sprite::isStretchEnabled() const
+{
+    return _stretchEnabled;
+}
+
+void Sprite::updateStretchFactor()
+{
+    const Size size = getContentSize();
+
+    if (_renderMode == RenderMode::QUAD)
+    {
+        // If stretch is disabled, calculate the stretch anyway
+        // since it is needed to calculate the offset
+        const float x_factor = size.width / _originalContentSize.width;
+        const float y_factor = size.height / _originalContentSize.height;
+
+        _stretchFactor = Vec2(std::max(0.0f, x_factor),
+                              std::max(0.0f, y_factor));
+    }
+    else if (_renderMode == RenderMode::SLICE9)
+    {
+        const float x1 = _rect.size.width * _centerRectNormalized.origin.x;
+        const float x2 = _rect.size.width * _centerRectNormalized.size.width;
+        const float x3 = _rect.size.width * (1 - _centerRectNormalized.origin.x - _centerRectNormalized.size.width);
+
+        const float y1 = _rect.size.height * _centerRectNormalized.origin.y;
+        const float y2 = _rect.size.height * _centerRectNormalized.size.height;
+        const float y3 = _rect.size.height * (1 - _centerRectNormalized.origin.y - _centerRectNormalized.size.height);
+
+        // adjustedSize = the new _rect size
+        const float adjustedWidth = size.width - (_originalContentSize.width - _rect.size.width);
+        const float adjustedHeight = size.height - (_originalContentSize.height - _rect.size.height);
+
+        const float x_factor = (adjustedWidth - x1 - x3) / x2;
+        const float y_factor = (adjustedHeight - y1 - y3) / y2;
+
+        _stretchFactor = Vec2(std::max(0.0f, x_factor),
+                              std::max(0.0f, y_factor));
+    }
+
+    // else:
+    // Do nothing if renderMode is Polygon
+}
+
 void Sprite::setFlippedX(bool flippedX)
 {
     if (_flippedX != flippedX)
     {
         _flippedX = flippedX;
-        updateFlipX();
+        flipX();
     }
 }
 
-bool Sprite::isFlippedX(void) const
+bool Sprite::isFlippedX() const
 {
     return _flippedX;
 }
 
 void Sprite::setFlippedY(bool flippedY)
 {
+#ifdef CC_USE_METAL
+    if(_texture->isRenderTarget())
+        flippedY = !flippedY;
+#endif
     if (_flippedY != flippedY)
     {
         _flippedY = flippedY;
-        updateFlipY();
+        flipY();
     }
 }
 
-bool Sprite::isFlippedY(void) const
+bool Sprite::isFlippedY() const
 {
     return _flippedY;
 }
 
+void Sprite::flipX()
+{
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
+        setDirty(true);
+    else if (_renderMode == RenderMode::POLYGON)
+    {
+        for (unsigned int i = 0; i < _polyInfo.triangles.vertCount; i++) {
+            auto& v = _polyInfo.triangles.verts[i].vertices;
+            v.x = _contentSize.width -v.x;
+        }
+    }
+    else
+        // RenderMode:: Quad or Slice9
+        updatePoly();
+}
+
+void Sprite::flipY()
+{
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
+        setDirty(true);
+    else if (_renderMode == RenderMode::POLYGON)
+    {
+        for (unsigned int i = 0; i < _polyInfo.triangles.vertCount; i++) {
+            auto& v = _polyInfo.triangles.verts[i].vertices;
+            v.y = _contentSize.height -v.y;
+        }
+    }
+    else
+        // RenderMode:: Quad or Slice9
+        updatePoly();
+}
+
 //
 // MARK: RGBA protocol
 //
 
-void Sprite::updateColor(void)
+void Sprite::updateColor()
 {
-    Color4B color4(_displayedColor.r, _displayedColor.g, _displayedColor.b, _displayedOpacity);
+    Color4B color4( _displayedColor.r, _displayedColor.g, _displayedColor.b, _displayedOpacity );
 
     // special opacity for premultiplied textures
     if (_opacityModifyRGB)
@@ -1001,56 +1540,29 @@ void Sprite::updateColor(void)
         color4.b *= _displayedOpacity / 255.0f;
     }
 
-    for (std::size_t i = 0; i < _polyInfo.triangles.vertCount; i++)
-    {
+    for (unsigned int i = 0; i < _polyInfo.triangles.vertCount; i++)
         _polyInfo.triangles.verts[i].colors = color4;
-    }
+
+    // related to issue #17116
+    // when switching from Quad to Slice9, the color will be obtained from _quad
+    // so it is important to update _quad colors as well.
+    _quad.bl.colors = _quad.tl.colors = _quad.br.colors = _quad.tr.colors = color4;
 
     // renders using batch node
-    if (_batchNode)
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
     {
         if (_atlasIndex != INDEX_NOT_INITIALIZED)
-        {
             _textureAtlas->updateQuad(&_quad, _atlasIndex);
-        }
         else
-        {
             // no need to set it recursively
             // update dirty_, don't update recursiveDirty_
             setDirty(true);
-        }
     }
 
     // self render
     // do nothing
 }
 
-void Sprite::updateFlipX(void)
-{
-    for (std::size_t i = 0; i < _polyInfo.triangles.vertCount; i++)
-    {
-        auto& v = _polyInfo.triangles.verts[i].vertices;
-        v.x = _contentSize.width - v.x;
-    }
-    if (_textureAtlas)
-    {
-        setDirty(true);
-    }
-}
-
-void Sprite::updateFlipY(void)
-{
-    for (std::size_t i = 0; i < _polyInfo.triangles.vertCount; i++)
-    {
-        auto& v = _polyInfo.triangles.verts[i].vertices;
-        v.y = _contentSize.height - v.y;
-    }
-    if (_textureAtlas)
-    {
-        setDirty(true);
-    }
-}
-
 void Sprite::setOpacityModifyRGB(bool modify)
 {
     if (_opacityModifyRGB != modify)
@@ -1060,30 +1572,28 @@ void Sprite::setOpacityModifyRGB(bool modify)
     }
 }
 
-bool Sprite::isOpacityModifyRGB(void) const
+bool Sprite::isOpacityModifyRGB() const
 {
     return _opacityModifyRGB;
 }
 
 // MARK: Frames
 
-void Sprite::setSpriteFrame(const std::string& spriteFrameName)
+void Sprite::setSpriteFrame(const std::string &spriteFrameName)
 {
     CCASSERT(!spriteFrameName.empty(), "spriteFrameName must not be empty");
     if (spriteFrameName.empty())
-    {
         return;
-    }
 
-    SpriteFrameCache* cache = SpriteFrameCache::getInstance();
-    SpriteFrame* spriteFrame = cache->getSpriteFrameByName(spriteFrameName);
+    SpriteFrameCache *cache = SpriteFrameCache::getInstance();
+    SpriteFrame *spriteFrame = cache->getSpriteFrameByName(spriteFrameName);
 
     CCASSERT(spriteFrame, std::string("Invalid spriteFrameName :").append(spriteFrameName).c_str());
 
     setSpriteFrame(spriteFrame);
 }
 
-void Sprite::setSpriteFrame(SpriteFrame* spriteFrame)
+void Sprite::setSpriteFrame(SpriteFrame *spriteFrame)
 {
     // retain the sprite frame
     // do not removed by SpriteFrameCache::removeUnusedSpriteFrames
@@ -1095,12 +1605,10 @@ void Sprite::setSpriteFrame(SpriteFrame* spriteFrame)
     }
     _unflippedOffsetPositionFromCenter = spriteFrame->getOffset();
 
-    Texture2D* texture = spriteFrame->getTexture();
+    Texture2D *texture = spriteFrame->getTexture();
     // update texture before updating texture rect
     if (texture != _texture)
-    {
         setTexture(texture);
-    }
 
     // update rect
     _rectRotated = spriteFrame->isRotated();
@@ -1109,35 +1617,24 @@ void Sprite::setSpriteFrame(SpriteFrame* spriteFrame)
     if (spriteFrame->hasPolygonInfo())
     {
         _polyInfo = spriteFrame->getPolygonInfo();
+        _renderMode = RenderMode::POLYGON;
+        if (_flippedX) flipX();
+        if (_flippedY) flipY();
+        updateColor();
     }
     if (spriteFrame->hasAnchorPoint())
-    {
         setAnchorPoint(spriteFrame->getAnchorPoint());
-    }
-
-    // reapply color and opacity values to the updated _polygon's vertices
-    updateColor();
-
-    // reapply flip values to the polygon's vertices
-    if (_flippedX)
-    {
-        updateFlipX();
-    }
-    if (_flippedY)
-    {
-        updateFlipY();
-    }
+    if (spriteFrame->hasCenterRect())
+        setCenterRect(spriteFrame->getCenterRect());
 }
 
-void Sprite::setDisplayFrameWithAnimationName(const std::string& animationName, std::size_t frameIndex)
+void Sprite::setDisplayFrameWithAnimationName(const std::string& animationName, unsigned int frameIndex)
 {
     CCASSERT(!animationName.empty(), "CCSprite#setDisplayFrameWithAnimationName. animationName must not be nullptr");
     if (animationName.empty())
-    {
         return;
-    }
 
-    Animation* a = AnimationCache::getInstance()->getAnimation(animationName);
+    Animation *a = AnimationCache::getInstance()->getAnimation(animationName);
 
     CCASSERT(a, "CCSprite#setDisplayFrameWithAnimationName: Frame not found");
 
@@ -1148,21 +1645,25 @@ void Sprite::setDisplayFrameWithAnimationName(const std::string& animationName,
     setSpriteFrame(frame->getSpriteFrame());
 }
 
-bool Sprite::isFrameDisplayed(SpriteFrame* frame) const
+bool Sprite::isFrameDisplayed(SpriteFrame *frame) const
 {
     Rect r = frame->getRect();
 
-    return (r.equals(_rect) && frame->getTexture()->getName() == _texture->getName() && frame->getOffset().equals(_unflippedOffsetPositionFromCenter));
+    return (r.equals(_rect) &&
+            frame->getTexture() == _texture &&
+            frame->getOffset().equals(_unflippedOffsetPositionFromCenter));
 }
 
 SpriteFrame* Sprite::getSpriteFrame() const
 {
     if (nullptr != this->_spriteFrame)
-    {
         return this->_spriteFrame;
-    }
-    return SpriteFrame::createWithTexture(_texture, CC_RECT_POINTS_TO_PIXELS(_rect), _rectRotated,
-                                          CC_POINT_POINTS_TO_PIXELS(_unflippedOffsetPositionFromCenter), CC_SIZE_POINTS_TO_PIXELS(_contentSize));
+
+    return SpriteFrame::createWithTexture(_texture,
+                                          CC_RECT_POINTS_TO_PIXELS(_rect),
+                                          _rectRotated,
+                                          CC_POINT_POINTS_TO_PIXELS(_unflippedOffsetPositionFromCenter),
+                                          CC_SIZE_POINTS_TO_PIXELS(_originalContentSize));
 }
 
 SpriteBatchNode* Sprite::getBatchNode() const
@@ -1170,13 +1671,16 @@ SpriteBatchNode* Sprite::getBatchNode() const
     return _batchNode;
 }
 
-void Sprite::setBatchNode(SpriteBatchNode* spriteBatchNode)
+void Sprite::setBatchNode(SpriteBatchNode *spriteBatchNode)
 {
     _batchNode = spriteBatchNode; // weak reference
 
     // self render
-    if (!_batchNode)
+    if (! _batchNode)
     {
+        if (_renderMode != RenderMode::SLICE9)
+            _renderMode = RenderMode::QUAD;
+
         _atlasIndex = INDEX_NOT_INITIALIZED;
         setTextureAtlas(nullptr);
         _recursiveDirty = false;
@@ -1186,27 +1690,31 @@ void Sprite::setBatchNode(SpriteBatchNode* spriteBatchNode)
         float y1 = _offsetPosition.y;
         float x2 = x1 + _rect.size.width;
         float y2 = y1 + _rect.size.height;
-        _quad.bl.vertices.set(x1, y1, 0);
+        _quad.bl.vertices.set( x1, y1, 0 );
         _quad.br.vertices.set(x2, y1, 0);
         _quad.tl.vertices.set(x1, y2, 0);
         _quad.tr.vertices.set(x2, y2, 0);
+
     }
     else
     {
         // using batch
+        _renderMode = RenderMode::QUAD_BATCHNODE;
         _transformToBatch = Mat4::IDENTITY;
         setTextureAtlas(_batchNode->getTextureAtlas()); // weak ref
     }
 }
 
 // MARK: Texture protocol
-
-void Sprite::updateBlendFunc(void)
+void Sprite::updateBlendFunc()
 {
-    CCASSERT(!_batchNode, "CCSprite: updateBlendFunc doesn't work when the sprite is rendered using a SpriteBatchNode");
-
+    CCASSERT(_renderMode != RenderMode::QUAD_BATCHNODE, "CCSprite: updateBlendFunc doesn't work when the sprite is rendered using a SpriteBatchNode");
+    
     // it is possible to have an untextured sprite
-    if (!_texture || !_texture->hasPremultipliedAlpha())
+    backend::BlendDescriptor& blendDescriptor = _trianglesCommand.getPipelineDescriptor().blendDescriptor;
+    blendDescriptor.blendEnabled = true;
+    
+    if (! _texture || ! _texture->hasPremultipliedAlpha())
     {
         _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
         setOpacityModifyRGB(false);
@@ -1220,12 +1728,13 @@ void Sprite::updateBlendFunc(void)
 
 std::string Sprite::getDescription() const
 {
-    int texture_id = -1;
-    if (_batchNode)
-        texture_id = _batchNode->getTextureAtlas()->getTexture()->getName();
+    char textureDescriptor[100];
+    if (_renderMode == RenderMode::QUAD_BATCHNODE)
+        sprintf(textureDescriptor, "<Sprite | Tag = %d, TextureID = %p>", _tag, _batchNode->getTextureAtlas()->getTexture()->getBackendTexture());
     else
-        texture_id = _texture->getName();
-    return StringUtils::format("<Sprite | Tag = %d, TextureID = %d>", _tag, texture_id);
+        sprintf(textureDescriptor, "<Sprite | Tag = %d, TextureID = %p>", _tag, _texture->getBackendTexture());
+    
+    return textureDescriptor;
 }
 
 const PolygonInfo& Sprite::getPolygonInfo() const
@@ -1236,6 +1745,20 @@ const PolygonInfo& Sprite::getPolygonInfo() const
 void Sprite::setPolygonInfo(const PolygonInfo& info)
 {
     _polyInfo = info;
+    _renderMode = RenderMode::POLYGON;
+}
+
+void Sprite::setMVPMatrixUniform()
+{
+    const auto& projectionMat = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    auto programState = _trianglesCommand.getPipelineDescriptor().programState;
+    if (programState && _mvpMatrixLocation)
+        programState->setUniform(_mvpMatrixLocation, projectionMat.m, sizeof(projectionMat.m));
+}
+
+backend::ProgramState* Sprite::getProgramState() const
+{
+    return _programState;
 }
 
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCSprite.h b/cocos2d/cocos/2d/CCSprite.h
index 48da5ffc33..b6c385095a 100644
--- a/cocos2d/cocos/2d/CCSprite.h
+++ b/cocos2d/cocos/2d/CCSprite.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,43 +25,35 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
+#pragma once
 
-#ifndef CC_2D_SPRITE_H
-#define CC_2D_SPRITE_H
-
-#include <cocos/2d/CCAutoPolygon.h>
+#include <string>
 #include <cocos/2d/CCNode.h>
+#include <cocos/2d/CCDrawNode.h>
 #include <cocos/base/CCProtocols.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
+#include <cocos/renderer/CCTextureAtlas.h>
 #include <cocos/renderer/CCTrianglesCommand.h>
-
-#include <cstddef>
-#include <cstdint>
-#include <iosfwd>
-#include <limits>
+#include <cocos/renderer/CCCustomCommand.h>
+#include <cocos/2d/CCAutoPolygon.h>
 
 NS_CC_BEGIN
 
-class Renderer;
 class SpriteBatchNode;
 class SpriteFrame;
+class Animation;
+class Rect;
+class Size;
 class Texture2D;
-class TextureAtlas;
+struct transformValues_;
 
 #ifdef SPRITE_RENDER_IN_SUBPIXEL
-#    undef SPRITE_RENDER_IN_SUBPIXEL
+#undef SPRITE_RENDER_IN_SUBPIXEL
 #endif
 
 #if CC_SPRITEBATCHNODE_RENDER_SUBPIXEL
-#    define SPRITE_RENDER_IN_SUBPIXEL
+#define SPRITE_RENDER_IN_SUBPIXEL
 #else
-#    define SPRITE_RENDER_IN_SUBPIXEL(__ARGS__) (ceil(__ARGS__))
+#define SPRITE_RENDER_IN_SUBPIXEL(__ARGS__) (ceil(__ARGS__))
 #endif
 
 /**
@@ -78,8 +71,18 @@ class TextureAtlas;
  *  - Use the same blending function for all your sprites.
  *  - ...and the Renderer will automatically "batch" your sprites (will draw all of them in one OpenGL call).
  *
- *  To gain an additional 5% ~ 10% more in the rendering, you can parent your sprites into a `SpriteBatchNode`.
- *  But doing so carries the following limitations:
+ *  Sprite has 4 types or rendering modes:
+ *
+ *  - `QUAD`: Renders the sprite using 2 triangles (1 rectangle): uses small memory, but renders empty pixels (slow)
+ *  - `POLYGON`: Renders the sprite using many triangles (depending on the setting): Uses more memory, but doesn't render so much empty pixels (faster)
+ *  - `SLICE9`: Renders the sprite using 18 triangles (9 rectangles). Useful to to scale buttons an other rectangular sprites
+ *  - `QUAD_BATCHNODE`: Renders the sprite using 2 triangles (1 rectangle) with a static batch, which has some limitations (see below)
+ *
+ * By default, the sprite uses `QUAD` mode. But can be changed to `POLYGON` when calling `setPolygonInfo()`. To use `SLICE9` call `setCenterRect()` or
+ * `serCenterRectNormalized()`. To use `QUAD_BATCHNODE` parent the sprite to a `SpriteBatchNode` object.
+ *
+ *
+ *  `QUAD_BATCHNODE` is deprecated and should be avoid. It has the following limitations:
  *
  *  - The Alias/Antialias property belongs to `SpriteBatchNode`, so you can't individually set the aliased property.
  *  - The Blending function property belongs to `SpriteBatchNode`, so you can't individually set the blending function property.
@@ -91,8 +94,14 @@ class TextureAtlas;
 class CC_DLL Sprite : public Node, public TextureProtocol
 {
 public:
-    /** Sprite invalid index on the SpriteBatchNode. */
-    static const std::size_t INDEX_NOT_INITIALIZED = std::numeric_limits<std::size_t>::max();
+    enum class RenderMode {
+        QUAD,
+        POLYGON,
+        SLICE9,
+        QUAD_BATCHNODE
+    };
+     /** Sprite invalid index on the SpriteBatchNode. */
+    static const int INDEX_NOT_INITIALIZED = -1;
 
     /// @name Creators
     /// @{
@@ -115,7 +124,7 @@ public:
      * @return  An autoreleased sprite object.
      */
     static Sprite* create(const std::string& filename);
-
+    
     /**
      * Creates a polygon sprite with a polygon info.
      *
@@ -144,7 +153,7 @@ public:
      * @param   texture    A pointer to a Texture2D object.
      * @return  An autoreleased sprite object.
      */
-    static Sprite* createWithTexture(Texture2D* texture);
+    static Sprite* createWithTexture(Texture2D *texture);
 
     /**
      * Creates a sprite with a texture and a rect.
@@ -157,7 +166,7 @@ public:
      * @param   rotated     Whether or not the rect is rotated.
      * @return  An autoreleased sprite object.
      */
-    static Sprite* createWithTexture(Texture2D* texture, const Rect& rect, bool rotated = false);
+    static Sprite* createWithTexture(Texture2D *texture, const Rect& rect, bool rotated=false);
 
     /**
      * Creates a sprite with an sprite frame.
@@ -165,7 +174,7 @@ public:
      * @param   spriteFrame    A sprite frame which involves a texture and a rect.
      * @return  An autoreleased sprite object.
      */
-    static Sprite* createWithSpriteFrame(SpriteFrame* spriteFrame);
+    static Sprite* createWithSpriteFrame(SpriteFrame *spriteFrame);
 
     /**
      * Creates a sprite with an sprite frame name.
@@ -173,7 +182,7 @@ public:
      * A SpriteFrame will be fetched from the SpriteFrameCache by spriteFrameName param.
      * If the SpriteFrame doesn't exist it will raise an exception.
      *
-     * @param   spriteFrameName A null terminated string which indicates the sprite frame name.
+     * @param   spriteFrameName The name of sprite frame.
      * @return  An autoreleased sprite object.
      */
     static Sprite* createWithSpriteFrameName(const std::string& spriteFrameName);
@@ -181,6 +190,7 @@ public:
     //  end of creators group
     /// @}
 
+
     /// @{
     /// @name BatchNode methods
 
@@ -206,10 +216,11 @@ public:
      * layer->addChild(batch);
      * @endcode
      */
-    virtual void setBatchNode(SpriteBatchNode* spriteBatchNode);
+    virtual void setBatchNode(SpriteBatchNode *spriteBatchNode);
 
     /// @} end of BatchNode methods
 
+
     /// @{
     /// @name Texture / Frame methods
 
@@ -218,13 +229,13 @@ public:
      *  @memberof Sprite
      *  It will call `setTextureRect()` with the texture's content size.
      */
-    virtual void setTexture(const std::string& filename);
+    virtual void setTexture(const std::string &filename );
 
     /** @overload
      *
      *  The Texture's rect is not changed.
      */
-    virtual void setTexture(Texture2D* texture) override;
+    virtual void setTexture(Texture2D *texture) override;
 
     /** Returns the Texture2D object used by the sprite. */
     virtual Texture2D* getTexture() const override;
@@ -251,43 +262,71 @@ public:
      */
     virtual void setVertexRect(const Rect& rect);
 
+    /**
+     * setCenterRectNormalized
+     *
+     * Useful to implement "9 sliced" sprites.
+     * The default value is (0,0) - (1,1), which means that only one "slice" will be used: From top-left (0,0) to bottom-right (1,1).
+     * If the value is different than (0,0), (1,1), then the sprite will be sliced into a 3 x 3 grid. The four corners of this grid are applied without
+     * performing any scaling. The upper- and lower-middle parts are scaled horizontally, and the left- and right-middle parts are scaled vertically.
+     * The center is scaled in both directions.
+     * Important: The scaling is based the Sprite's trimmed size.
+     *
+     * Limitations: Does not work when the sprite is part of `SpriteBatchNode`.
+     */
+    virtual void setCenterRectNormalized(const Rect& rect);
+
+    /**
+     * getCenterRectNormalized
+     *
+     * Returns the CenterRect in normalized coordinates
+     */
+    virtual Rect getCenterRectNormalized() const;
+
+    /* setCenterRect
+     *
+     * Like `setCenterRectNormalized`, but instead of being in normalized coordinates, it is in points coordinates
+     */
+    virtual void setCenterRect(const Rect& rect);
+
+    /**
+     * @brief Returns the Cap Insets rect
+     *
+     * @return Scale9Sprite's cap inset.
+     */
+    virtual Rect getCenterRect() const;
+
+
     /** @{
      * Sets a new SpriteFrame to the Sprite.
      */
-    virtual void setSpriteFrame(const std::string& spriteFrameName);
+    virtual void setSpriteFrame(const std::string &spriteFrameName);
     virtual void setSpriteFrame(SpriteFrame* newFrame);
     /** @} */
 
-    /** @deprecated Use `setSpriteFrame()` instead. */
-    CC_DEPRECATED_ATTRIBUTE virtual void setDisplayFrame(SpriteFrame* newFrame) { setSpriteFrame(newFrame); }
-
     /**
      * Returns whether or not a SpriteFrame is being displayed.
      */
-    virtual bool isFrameDisplayed(SpriteFrame* frame) const;
+    virtual bool isFrameDisplayed(SpriteFrame *frame) const;
 
     /**
      * Returns the current displayed frame.
      */
     virtual SpriteFrame* getSpriteFrame() const;
-    /** @deprecated Use `getSpriteFrame()` instead.
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE virtual SpriteFrame* getDisplayFrame() const { return getSpriteFrame(); }
-    /** @deprecated Use `getSpriteFrame()` instead. */
-    CC_DEPRECATED_ATTRIBUTE virtual SpriteFrame* displayFrame() const { return getSpriteFrame(); }
 
     /// @} End of frames methods
 
+
     /// @{
     /// @name Animation methods
     /**
      * Changes the display frame with animation name and index.
      * The animation name will be get from the AnimationCache.
      */
-    virtual void setDisplayFrameWithAnimationName(const std::string& animationName, std::size_t frameIndex);
+    virtual void setDisplayFrameWithAnimationName(const std::string& animationName, unsigned int frameIndex);
     /// @}
 
+
     /// @{
     /// @name Sprite Properties' setter/getters.
 
@@ -303,6 +342,47 @@ public:
      */
     virtual void setDirty(bool dirty) { _dirty = dirty; }
 
+    /**
+     * @js NA
+     */
+    virtual std::string getDescription() const override;
+
+    /// @{
+    /// @name Functions inherited from Node.
+    virtual void setScaleX(float scaleX) override;
+    virtual void setScaleY(float scaleY) override;
+    virtual void setScale(float scaleX, float scaleY) override;
+    /**
+    * @js  NA
+    * @lua NA
+    */
+    virtual void setPosition(const Vec2& pos) override;
+    virtual void setPosition(float x, float y) override;
+    virtual void setRotation(float rotation) override;
+    virtual void setRotationSkewX(float rotationX) override;
+    virtual void setRotationSkewY(float rotationY) override;
+    virtual void setSkewX(float sx) override;
+    virtual void setSkewY(float sy) override;
+    virtual void removeChild(Node* child, bool cleanup) override;
+    virtual void removeAllChildrenWithCleanup(bool cleanup) override;
+    virtual void reorderChild(Node *child, int zOrder) override;
+    using Node::addChild;
+    virtual void addChild(Node *child, int zOrder, int tag) override;
+    virtual void addChild(Node *child, int zOrder, const std::string &name) override;
+    virtual void sortAllChildren() override;
+    virtual void setScale(float scale) override;
+    virtual void setPositionZ(float positionZ) override;
+    virtual void setAnchorPoint(const Vec2& anchor) override;
+    virtual void setContentSize(const Size& size) override;
+
+    virtual void setIgnoreAnchorPointForPosition(bool value) override;
+
+    virtual void setVisible(bool bVisible) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
+    virtual void setOpacityModifyRGB(bool modify) override;
+    virtual bool isOpacityModifyRGB() const override;
+    /// @}
+
     /**
      * Returns the quad (tex coords, vertex coords and color) information.
      * @js  NA
@@ -318,14 +398,14 @@ public:
     /**
      * Returns the index used on the TextureAtlas.
      */
-    std::size_t getAtlasIndex() const { return _atlasIndex; }
+    unsigned int getAtlasIndex() const { return _atlasIndex; }
 
     /**
      * Sets the index used on the TextureAtlas.
      *
      * @warning Don't modify this value unless you know what you are doing.
      */
-    void setAtlasIndex(std::size_t atlasIndex) { _atlasIndex = atlasIndex; }
+    void setAtlasIndex(unsigned int atlasIndex) { _atlasIndex = atlasIndex; }
 
     /**
      * Returns the rect of the Sprite in points.
@@ -337,16 +417,27 @@ public:
      */
     TextureAtlas* getTextureAtlas() const { return _textureAtlas; }
 
+    /**
+    * Set ProgramState
+    */
+    virtual void setProgramState(backend::ProgramState *programState) override;
+
+    /**
+    * Get current ProgramState
+    */
+    virtual backend::ProgramState *getProgramState() const override;
+
     /**
      * Sets the weak reference of the TextureAtlas when the sprite is rendered using via SpriteBatchNode.
      */
-    void setTextureAtlas(TextureAtlas* textureAtlas) { _textureAtlas = textureAtlas; }
+    void setTextureAtlas(TextureAtlas *textureAtlas) { _textureAtlas = textureAtlas; }
 
     /**
      * Gets the offset position of the sprite. Calculated automatically by editors like Zwoptex.
      */
     const Vec2& getOffsetPosition() const { return _offsetPosition; }
 
+
     /**
      * Returns the flag which indicates whether the sprite is flipped horizontally or not.
      *
@@ -365,16 +456,6 @@ public:
      */
     void setFlippedX(bool flippedX);
 
-    /** @deprecated Use isFlippedX() instead.
-     * @js NA
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE bool isFlipX() { return isFlippedX(); }
-    /** @deprecated Use setFlippedX() instead
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE void setFlipX(bool flippedX) { setFlippedX(flippedX); }
-
     /**
      * Return the flag which indicates whether the sprite is flipped vertically or not.
      *
@@ -395,15 +476,6 @@ public:
 
     /// @} End of Sprite properties getter/setters
 
-    /** @deprecated Use isFlippedY() instead.
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE bool isFlipY() { return isFlippedY(); }
-    /** @deprecated Use setFlippedY() instead.
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE void setFlipY(bool flippedY) { setFlippedY(flippedY); }
-
     /**
      * returns a reference of the polygon information associated with this sprite
      *
@@ -417,75 +489,42 @@ public:
      * @param PolygonInfo the polygon information object
      */
     void setPolygonInfo(const PolygonInfo& info);
+
+    /** whether or not contentSize stretches the sprite's texture */
+    void setStretchEnabled(bool enabled);
+
+    /** returns whether or not contentSize stretches the sprite's texture */
+    bool isStretchEnabled() const;
+
     //
     // Overrides
     //
     /// @{
     /// @name Functions inherited from TextureProtocol.
     /**
-     *@code
-     *When this function bound into js or lua,the parameter will be changed.
-     *In js: var setBlendFunc(var src, var dst).
-     *In lua: local setBlendFunc(local src, local dst).
-     *@endcode
-     */
-    void setBlendFunc(const BlendFunc& blendFunc) override { _blendFunc = blendFunc; }
-    /**
-     * @js  NA
-     * @lua NA
-     */
+    *@code
+    *When this function bound into js or lua,the parameter will be changed.
+    *In js: var setBlendFunc(var src, var dst).
+    *In lua: local setBlendFunc(local src, local dst).
+    *@endcode
+    */
+    void setBlendFunc(const BlendFunc &blendFunc) override { _blendFunc = blendFunc; }
+    /**
+    * @js  NA
+    * @lua NA
+    */
     const BlendFunc& getBlendFunc() const override { return _blendFunc; }
     /// @}
 
-    /**
-     * @js NA
-     */
-    virtual std::string getDescription() const override;
-
-    /// @{
-    /// @name Functions inherited from Node.
-    virtual void setScaleX(float scaleX) override;
-    virtual void setScaleY(float scaleY) override;
-    virtual void setScale(float scaleX, float scaleY) override;
-    /**
-     * @js  NA
-     * @lua NA
-     */
-    virtual void setPosition(const Vec2& pos) override;
-    virtual void setPosition(float x, float y) override;
-    virtual void setRotation(float rotation) override;
-    virtual void setRotationSkewX(float rotationX) override;
-    virtual void setRotationSkewY(float rotationY) override;
-    virtual void setSkewX(float sx) override;
-    virtual void setSkewY(float sy) override;
-    virtual void removeChild(Node* child, bool cleanup) override;
-    virtual void removeAllChildrenWithCleanup(bool cleanup) override;
-    virtual void reorderChild(Node* child, int zOrder) override;
-    using Node::addChild;
-    virtual void addChild(Node* child, int zOrder, int tag) override;
-    virtual void addChild(Node* child, int zOrder, const std::string& name) override;
-    virtual void sortAllChildren() override;
-    virtual void setScale(float scale) override;
-    virtual void setPositionZ(float positionZ) override;
-    virtual void setAnchorPoint(const Vec2& anchor) override;
-
-    virtual void setIgnoreAnchorPointForPosition(bool value) override;
-
-    virtual void setVisible(bool bVisible) override;
-    virtual void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
-    virtual void setOpacityModifyRGB(bool modify) override;
-    virtual bool isOpacityModifyRGB() const override;
-    /// @}
-
     int getResourceType() const { return _fileType; }
     const std::string& getResourceName() const { return _fileName; }
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        Sprite();
-    ~Sprite() override;
+CC_CONSTRUCTOR_ACCESS :
+	/**
+     * @js ctor
+     */
+    Sprite();
+    virtual ~Sprite();
 
     /* Initializes an empty sprite with no parameters. */
     virtual bool init() override;
@@ -499,8 +538,9 @@ public:
      *                      You can use a Texture2D object for many sprites.
      * @return  True if the sprite is initialized properly, false otherwise.
      */
-    virtual bool initWithTexture(Texture2D* texture);
-
+    virtual bool initWithTexture(Texture2D *texture);
+    
+    
     /**
      * Initializes a sprite with a PolygonInfo.
      *
@@ -521,7 +561,7 @@ public:
      * @param   rect        Only the contents inside rect of this texture will be applied for this sprite.
      * @return  True if the sprite is initialized properly, false otherwise.
      */
-    virtual bool initWithTexture(Texture2D* texture, const Rect& rect);
+    virtual bool initWithTexture(Texture2D *texture, const Rect& rect);
 
     /**
      * Initializes a sprite with a texture and a rect in points, optionally rotated.
@@ -534,7 +574,7 @@ public:
      * @param   rotated     Whether or not the texture rectangle is rotated.
      * @return  True if the sprite is initialized properly, false otherwise.
      */
-    virtual bool initWithTexture(Texture2D* texture, const Rect& rect, bool rotated);
+    virtual bool initWithTexture(Texture2D *texture, const Rect& rect, bool rotated);
 
     /**
      * Initializes a sprite with an SpriteFrame. The texture and rect in SpriteFrame will be applied on this sprite.
@@ -542,7 +582,7 @@ public:
      * @param   spriteFrame  A SpriteFrame object. It should includes a valid texture and a rect.
      * @return  True if the sprite is initialized properly, false otherwise.
      */
-    virtual bool initWithSpriteFrame(SpriteFrame* spriteFrame);
+    virtual bool initWithSpriteFrame(SpriteFrame *spriteFrame);
 
     /**
      * Initializes a sprite with an sprite frame name.
@@ -582,44 +622,66 @@ public:
      */
     virtual bool initWithFile(const std::string& filename, const Rect& rect);
 
+    virtual void setVertexLayout();
+    virtual void updateShaders(const char* vert, const char* frag);
+    
 protected:
-    void updateColor() override;
-    virtual void updateFlipX();
-    virtual void updateFlipY();
+    virtual void updateColor() override;
     virtual void setTextureCoords(const Rect& rect);
+    virtual void setTextureCoords(const Rect& rect, V3F_C4B_T2F_Quad* outQuad);
+    virtual void setVertexCoords(const Rect& rect, V3F_C4B_T2F_Quad* outQuad);
     virtual void updateBlendFunc();
     virtual void setReorderChildDirtyRecursively();
     virtual void setDirtyRecursively(bool value);
-
+    virtual void flipX();
+    virtual void flipY();
+    virtual void updateProgramState();
+
+    void updatePoly();
+    void updateStretchFactor();
+    void populateTriangle(int quadIndex, const V3F_C4B_T2F_Quad& quad);
+    void setMVPMatrixUniform();
+    void setProgramState(backend::ProgramType type);
     //
     // Data used when the sprite is rendered using a SpriteSheet
     //
-    TextureAtlas* _textureAtlas = nullptr; /// SpriteBatchNode texture atlas (weak reference)
-    std::size_t _atlasIndex = INDEX_NOT_INITIALIZED; /// Absolute (real) Index on the SpriteSheet
-    SpriteBatchNode* _batchNode = nullptr; /// Used batch node (weak reference)
+    TextureAtlas* _textureAtlas = nullptr;          /// SpriteBatchNode texture atlas (weak reference)
+    unsigned int _atlasIndex = 0;                   /// Absolute (real) Index on the SpriteSheet
+    SpriteBatchNode* _batchNode = nullptr;          /// Used batch node (weak reference)
 
-    bool _dirty = false; /// Whether the sprite needs to be updated
-    bool _recursiveDirty = false; /// Whether all of the sprite's children needs to be updated
-    bool _shouldBeHidden = false; /// should not be drawn because one of the ancestors is not visible
+    bool _dirty = false;             /// Whether the sprite needs to be updated
+    bool _recursiveDirty = false;    /// Whether all of the sprite's children needs to be updated
+    bool _shouldBeHidden = false;    /// should not be drawn because one of the ancestors is not visible
     Mat4 _transformToBatch;
 
     //
     // Data used when the sprite is self-rendered
     //
-    BlendFunc _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED; /// It's required for TextureProtocol inheritance
-    Texture2D* _texture = nullptr; /// Texture2D object that is used to render the sprite
+    BlendFunc _blendFunc;            /// It's required for TextureProtocol inheritance
+    Texture2D* _texture = nullptr;   /// Texture2D object that is used to render the sprite
     SpriteFrame* _spriteFrame = nullptr;
-    TrianglesCommand _trianglesCommand; ///
+    TrianglesCommand _trianglesCommand;
+    
+    backend::UniformLocation _mvpMatrixLocation;
+    backend::UniformLocation _textureLocation;
+    backend::UniformLocation _alphaTextureLocation;
+        
 #if CC_SPRITE_DEBUG_DRAW
-    DrawNode* _debugDrawNode = nullptr;
-#endif // CC_SPRITE_DEBUG_DRAW
+    DrawNode *_debugDrawNode = nullptr;
+#endif //CC_SPRITE_DEBUG_DRAW
     //
     // Shared data
     //
 
     // texture
-    Rect _rect; /// Rectangle of Texture2D
-    bool _rectRotated = false; /// Whether the texture is rotated
+    Rect _rect;                             /// Rectangle of Texture2D
+    bool _rectRotated = false;              /// Whether the texture is rotated
+
+    Rect _centerRectNormalized = {0,0,1,1}; /// Rectangle to implement "slice 9"
+    RenderMode _renderMode = Sprite::RenderMode::QUAD;   /// render mode used by the Sprite: Quad, Slice9, Polygon or Quad_Batchnode
+    Vec2 _stretchFactor = Vec2::ONE;                     /// stretch factor to match the contentSize. for 1- and 9- slice sprites
+    Size _originalContentSize = Size::ZERO;              /// original content size
+
 
     // Offset Position (used by Zwoptex)
     Vec2 _offsetPosition;
@@ -627,27 +689,30 @@ protected:
 
     // vertex coords, texture coords and color info
     V3F_C4B_T2F_Quad _quad;
-    PolygonInfo _polyInfo;
+    V3F_C4B_T2F* _trianglesVertex = nullptr;
+    unsigned short* _trianglesIndex = nullptr;
+    PolygonInfo  _polyInfo;
 
     // opacity and RGB protocol
-    bool _opacityModifyRGB = false;
+    bool _opacityModifyRGB;
 
     // image is flipped
-    bool _flippedX = false; /// Whether the sprite is flipped horizontally or not
-    bool _flippedY = false; /// Whether the sprite is flipped vertically or not
+    bool _flippedX = false;                 /// Whether the sprite is flipped horizontally or not
+    bool _flippedY = false;                 /// Whether the sprite is flipped vertically or not
 
-    bool _insideBounds = true; /// whether or not the sprite was inside bounds the previous frame
+    bool _insideBounds = true;              /// whether or not the sprite was inside bounds the previous frame
 
     std::string _fileName;
-    int _fileType = -1;
+    int _fileType = 0;
 
+    bool _stretchEnabled = true;
+    
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(Sprite)
+    CC_DISALLOW_COPY_AND_ASSIGN(Sprite);
 };
 
+
 // end of sprite_nodes group
 /// @}
 
 NS_CC_END
-
-#endif // CC_2D_SPRITE_H
diff --git a/cocos2d/cocos/2d/CCSpriteBatchNode.cpp b/cocos2d/cocos/2d/CCSpriteBatchNode.cpp
index c2ea06adf6..5dc0c856a6 100644
--- a/cocos2d/cocos/2d/CCSpriteBatchNode.cpp
+++ b/cocos2d/cocos/2d/CCSpriteBatchNode.cpp
@@ -4,6 +4,7 @@ Copyright (c) 2009      Matt Oswald
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -27,82 +28,67 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCSpriteBatchNode.h>
-
-#include <cocos/2d/CCNode.h>
 #include <cocos/2d/CCSprite.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
+#include <cocos/base/CCProfiling.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCBatchCommand.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCRenderer.h>
-#include <cocos/renderer/CCTexture2D.h>
-#include <cocos/renderer/CCTextureAtlas.h>
 #include <cocos/renderer/CCTextureCache.h>
+#include <cocos/renderer/CCRenderer.h>
+#include <cocos/renderer/CCQuadCommand.h>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
-#include <algorithm>
-#include <iterator>
-#include <new>
-#include <type_traits>
 
 NS_CC_BEGIN
 
-class Ref;
-
 /*
- * creation with Texture2D
- */
+* creation with Texture2D
+*/
 
-SpriteBatchNode* SpriteBatchNode::createWithTexture(Texture2D* tex, std::size_t capacity /* = DEFAULT_CAPACITY*/)
+SpriteBatchNode* SpriteBatchNode::createWithTexture(Texture2D* tex, ssize_t capacity/* = DEFAULT_CAPACITY*/)
 {
-    SpriteBatchNode* batchNode = new (std::nothrow) SpriteBatchNode();
-    if (batchNode && batchNode->initWithTexture(tex, capacity))
+    SpriteBatchNode *batchNode = new (std::nothrow) SpriteBatchNode();
+    if(batchNode && batchNode->initWithTexture(tex, capacity))
     {
         batchNode->autorelease();
         return batchNode;
     }
-
+    
     delete batchNode;
     return nullptr;
 }
 
 /*
- * creation with File Image
- */
+* creation with File Image
+*/
 
-SpriteBatchNode* SpriteBatchNode::create(const std::string& fileImage, std::size_t capacity /* = DEFAULT_CAPACITY*/)
+SpriteBatchNode* SpriteBatchNode::create(const std::string& fileImage, ssize_t capacity/* = DEFAULT_CAPACITY*/)
 {
-    SpriteBatchNode* batchNode = new (std::nothrow) SpriteBatchNode();
-    if (batchNode && batchNode->initWithFile(fileImage, capacity))
+    SpriteBatchNode *batchNode = new (std::nothrow) SpriteBatchNode();
+    if(batchNode && batchNode->initWithFile(fileImage, capacity))
     {
         batchNode->autorelease();
         return batchNode;
     }
-
+    
     delete batchNode;
     return nullptr;
 }
 
 /*
- * init with Texture2D
- */
-bool SpriteBatchNode::initWithTexture(Texture2D* tex, std::size_t capacity /* = DEFAULT_CAPACITY*/)
+* init with Texture2D
+*/
+bool SpriteBatchNode::initWithTexture(Texture2D *tex, ssize_t capacity/* = DEFAULT_CAPACITY*/)
 {
-    if (tex == nullptr)
+    if(tex == nullptr)
     {
         return false;
     }
-
-    CCASSERT(capacity >= 0, "Capacity must be >= 0");
-
+    
+    CCASSERT(capacity>=0, "Capacity must be >= 0");
+    
     _blendFunc = BlendFunc::ALPHA_PREMULTIPLIED;
-    if (!tex->hasPremultipliedAlpha())
+    if(!tex->hasPremultipliedAlpha())
     {
         _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
     }
@@ -112,7 +98,7 @@ bool SpriteBatchNode::initWithTexture(Texture2D* tex, std::size_t capacity /* =
     {
         capacity = DEFAULT_CAPACITY;
     }
-
+    
     _textureAtlas->initWithTexture(tex, capacity);
 
     updateBlendFunc();
@@ -120,40 +106,70 @@ bool SpriteBatchNode::initWithTexture(Texture2D* tex, std::size_t capacity /* =
     _children.reserve(capacity);
 
     _descendants.reserve(capacity);
-
-    setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR, tex));
+    
+    updateShaders(positionTextureColor_vert, positionTextureColor_frag);
+    
     return true;
 }
 
+void SpriteBatchNode::updateShaders(const std::string &vertexShader, const std::string &fragmentShader)
+{
+    auto& pipelineDescriptor = _quadCommand.getPipelineDescriptor();
+    CC_SAFE_RELEASE(_programState);
+    _programState = new (std::nothrow) backend::ProgramState(vertexShader, fragmentShader);
+    pipelineDescriptor.programState = _programState;
+    _mvpMatrixLocaiton = pipelineDescriptor.programState->getUniformLocation("u_MVPMatrix");
+    _textureLocation = pipelineDescriptor.programState->getUniformLocation("u_texture");
+
+    auto vertexLayout = _programState->getVertexLayout();
+    const auto& attributeInfo = _programState->getProgram()->getActiveAttributes();
+    auto iter = attributeInfo.find("a_position");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_position", iter->second.location, backend::VertexFormat::FLOAT3, 0, false);
+    }
+    iter = attributeInfo.find("a_texCoord");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_texCoord", iter->second.location, backend::VertexFormat::FLOAT2, offsetof(V3F_C4B_T2F, texCoords), false);
+    }
+    iter = attributeInfo.find("a_color");
+    if(iter != attributeInfo.end())
+    {
+        vertexLayout->setAttribute("a_color", iter->second.location, backend::VertexFormat::UBYTE4, offsetof(V3F_C4B_T2F, colors), true);
+    }
+    vertexLayout->setLayout(sizeof(V3F_C4B_T2F));
+}
+
 bool SpriteBatchNode::init()
 {
-    Texture2D* texture = new (std::nothrow) Texture2D();
+    Texture2D * texture = new (std::nothrow) Texture2D();
     texture->autorelease();
     return this->initWithTexture(texture, 0);
 }
 
 /*
- * init with FileImage
- */
-bool SpriteBatchNode::initWithFile(const std::string& fileImage, std::size_t capacity /* = DEFAULT_CAPACITY*/)
+* init with FileImage
+*/
+bool SpriteBatchNode::initWithFile(const std::string& fileImage, ssize_t capacity/* = DEFAULT_CAPACITY*/)
 {
-    Texture2D* texture2D = Director::getInstance()->getTextureCache()->addImage(fileImage);
+    Texture2D *texture2D = Director::getInstance()->getTextureCache()->addImage(fileImage);
     return initWithTexture(texture2D, capacity);
 }
 
 SpriteBatchNode::SpriteBatchNode()
-: _textureAtlas(nullptr)
 {
 }
 
 SpriteBatchNode::~SpriteBatchNode()
 {
     CC_SAFE_RELEASE(_textureAtlas);
+    CC_SAFE_RELEASE(_programState);
 }
 
 // override visit
 // don't call visit on it's children
-void SpriteBatchNode::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void SpriteBatchNode::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
     CC_PROFILER_START_CATEGORY(kProfilerCategoryBatchSprite, "CCSpriteBatchNode - visit");
 
@@ -164,7 +180,7 @@ void SpriteBatchNode::visit(Renderer* renderer, const Mat4& parentTransform, uin
     // The alternative is to have a void Sprite#visit, but
     // although this is less maintainable, is faster
     //
-    if (!_visible)
+    if (! _visible)
     {
         return;
     }
@@ -180,46 +196,46 @@ void SpriteBatchNode::visit(Renderer* renderer, const Mat4& parentTransform, uin
         // but it is deprecated and your code should not rely on it
         _director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
         _director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform);
-
+        
         draw(renderer, _modelViewTransform, flags);
-
+        
         _director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
         // FIX ME: Why need to set _orderOfArrival to 0??
         // Please refer to https://github.com/cocos2d/cocos2d-x/pull/6920
         //    setOrderOfArrival(0);
-
+        
         CC_PROFILER_STOP_CATEGORY(kProfilerCategoryBatchSprite, "CCSpriteBatchNode - visit");
     }
 }
 
-void SpriteBatchNode::addChild(Node* child, int zOrder, int tag)
+void SpriteBatchNode::addChild(Node *child, int zOrder, int tag)
 {
     CCASSERT(child != nullptr, "child should not be null");
     CCASSERT(dynamic_cast<Sprite*>(child) != nullptr, "CCSpriteBatchNode only supports Sprites as children");
-    Sprite* sprite = static_cast<Sprite*>(child);
+    Sprite *sprite = static_cast<Sprite*>(child);
     // check Sprite is using the same texture id
-    CCASSERT(sprite->getTexture()->getName() == _textureAtlas->getTexture()->getName(), "CCSprite is not using the same texture id");
+    CCASSERT(sprite->getTexture()->getBackendTexture() == _textureAtlas->getTexture()->getBackendTexture(), "CCSprite is not using the same texture id");
 
     Node::addChild(child, zOrder, tag);
 
     appendChild(sprite);
 }
 
-void SpriteBatchNode::addChild(Node* child, int zOrder, const std::string& name)
+void SpriteBatchNode::addChild(Node * child, int zOrder, const std::string &name)
 {
     CCASSERT(child != nullptr, "child should not be null");
     CCASSERT(dynamic_cast<Sprite*>(child) != nullptr, "CCSpriteBatchNode only supports Sprites as children");
-    Sprite* sprite = static_cast<Sprite*>(child);
+    Sprite *sprite = static_cast<Sprite*>(child);
     // check Sprite is using the same texture id
-    CCASSERT(sprite->getTexture()->getName() == _textureAtlas->getTexture()->getName(), "CCSprite is not using the same texture id");
-
+    CCASSERT(sprite->getTexture() == _textureAtlas->getTexture(), "CCSprite is not using the same texture id");
+    
     Node::addChild(child, zOrder, name);
-
+    
     appendChild(sprite);
 }
 
 // override reorderChild
-void SpriteBatchNode::reorderChild(Node* child, int zOrder)
+void SpriteBatchNode::reorderChild(Node *child, int zOrder)
 {
     CCASSERT(child != nullptr, "the child should not be null");
     CCASSERT(_children.contains(child), "Child doesn't belong to Sprite");
@@ -229,14 +245,14 @@ void SpriteBatchNode::reorderChild(Node* child, int zOrder)
         return;
     }
 
-    // set the z-order and sort later
+    //set the z-order and sort later
     Node::reorderChild(child, zOrder);
 }
 
 // override remove child
-void SpriteBatchNode::removeChild(Node* child, bool cleanup)
+void SpriteBatchNode::removeChild(Node *child, bool cleanup)
 {
-    Sprite* sprite = static_cast<Sprite*>(child);
+    Sprite *sprite = static_cast<Sprite*>(child);
 
     // explicit null handling
     if (sprite == nullptr)
@@ -252,9 +268,9 @@ void SpriteBatchNode::removeChild(Node* child, bool cleanup)
     Node::removeChild(sprite, cleanup);
 }
 
-void SpriteBatchNode::removeChildAtIndex(std::size_t index, bool doCleanup)
+void SpriteBatchNode::removeChildAtIndex(ssize_t index, bool doCleanup)
 {
-    CCASSERT(index >= 0 && index < _children.size(), "Invalid index");
+    CCASSERT(index>=0 && index < _children.size(), "Invalid index");
     removeChild(_children.at(index), doCleanup);
 }
 
@@ -262,75 +278,68 @@ void SpriteBatchNode::removeAllChildrenWithCleanup(bool doCleanup)
 {
     // Invalidate atlas index. issue #569
     // useSelfRender should be performed on all descendants. issue #1216
-    for (const auto& sprite : _descendants)
-    {
+    for(const auto &sprite: _descendants) {
         sprite->setBatchNode(nullptr);
     }
 
     Node::removeAllChildrenWithCleanup(doCleanup);
 
     _descendants.clear();
-    if (_textureAtlas)
-    {
-        _textureAtlas->removeAllQuads();
-    }
+    if (_textureAtlas) {_textureAtlas->removeAllQuads();}
 }
 
-// override sortAllChildren
+//override sortAllChildren
 void SpriteBatchNode::sortAllChildren()
 {
     if (_reorderChildDirty)
     {
         sortNodes(_children);
 
-        // sorted now check all children
+        //sorted now check all children
         if (!_children.empty())
         {
-            // first sort all children recursively based on zOrder
-            for (const auto& child : _children)
-            {
+            //first sort all children recursively based on zOrder
+            for(const auto &child: _children) {
                 child->sortAllChildren();
             }
 
-            std::size_t index = 0;
+            ssize_t index=0;
 
-            // fast dispatch, give every child a new atlasIndex based on their relative zOrder (keep parent -> child relations intact)
+            //fast dispatch, give every child a new atlasIndex based on their relative zOrder (keep parent -> child relations intact)
             // and at the same time reorder descendants and the quads to the right index
-            for (const auto& child : _children)
-            {
+            for(const auto &child: _children) {
                 Sprite* sp = static_cast<Sprite*>(child);
                 updateAtlasIndex(sp, &index);
             }
         }
 
-        _reorderChildDirty = false;
+        _reorderChildDirty=false;
     }
 }
 
-void SpriteBatchNode::updateAtlasIndex(Sprite* sprite, std::size_t* curIndex)
+void SpriteBatchNode::updateAtlasIndex(Sprite* sprite, ssize_t* curIndex)
 {
     auto& array = sprite->getChildren();
     auto count = array.size();
+    
+    ssize_t oldIndex = 0;
 
-    std::size_t oldIndex = 0;
-
-    if (count == 0)
+    if( count == 0 )
     {
         oldIndex = sprite->getAtlasIndex();
         sprite->setAtlasIndex(*curIndex);
-        if (oldIndex != *curIndex)
-        {
+        if (oldIndex != *curIndex){
             swap(oldIndex, *curIndex);
         }
         (*curIndex)++;
     }
     else
     {
-        bool needNewIndex = true;
+        bool needNewIndex=true;
 
         if (array.at(0)->getLocalZOrder() >= 0)
         {
-            // all children are in front of the parent
+            //all children are in front of the parent
             oldIndex = sprite->getAtlasIndex();
             sprite->setAtlasIndex(*curIndex);
             if (oldIndex != *curIndex)
@@ -342,30 +351,27 @@ void SpriteBatchNode::updateAtlasIndex(Sprite* sprite, std::size_t* curIndex)
             needNewIndex = false;
         }
 
-        for (const auto& child : array)
-        {
+        for(const auto &child: array) {
             Sprite* sp = static_cast<Sprite*>(child);
             if (needNewIndex && sp->getLocalZOrder() >= 0)
             {
                 oldIndex = sprite->getAtlasIndex();
                 sprite->setAtlasIndex(*curIndex);
-                if (oldIndex != *curIndex)
-                {
+                if (oldIndex != *curIndex) {
                     this->swap(oldIndex, *curIndex);
                 }
                 (*curIndex)++;
                 needNewIndex = false;
             }
-
+            
             updateAtlasIndex(sp, curIndex);
         }
 
         if (needNewIndex)
-        { // all children have a zOrder < 0)
+        {//all children have a zOrder < 0)
             oldIndex = sprite->getAtlasIndex();
             sprite->setAtlasIndex(*curIndex);
-            if (oldIndex != *curIndex)
-            {
+            if (oldIndex != *curIndex) {
                 swap(oldIndex, *curIndex);
             }
             (*curIndex)++;
@@ -373,54 +379,49 @@ void SpriteBatchNode::updateAtlasIndex(Sprite* sprite, std::size_t* curIndex)
     }
 }
 
-void SpriteBatchNode::swap(std::size_t oldIndex, std::size_t newIndex)
+void SpriteBatchNode::swap(ssize_t oldIndex, ssize_t newIndex)
 {
-    CCASSERT(oldIndex >= 0 && oldIndex < (int)_descendants.size() && newIndex >= 0 && newIndex < (int)_descendants.size(), "Invalid index");
+    CCASSERT(oldIndex>=0 && oldIndex < (int)_descendants.size() && newIndex >=0 && newIndex < (int)_descendants.size(), "Invalid index");
 
     V3F_C4B_T2F_Quad* quads = _textureAtlas->getQuads();
-    std::swap(quads[oldIndex], quads[newIndex]);
+    std::swap( quads[oldIndex], quads[newIndex] );
 
-    // update the index of other swapped item
+    //update the index of other swapped item
 
-    auto oldIt = std::next(_descendants.begin(), oldIndex);
-    auto newIt = std::next(_descendants.begin(), newIndex);
+    auto oldIt = std::next( _descendants.begin(), oldIndex );
+    auto newIt = std::next( _descendants.begin(), newIndex );
 
     (*newIt)->setAtlasIndex(oldIndex);
-    //    (*oldIt)->setAtlasIndex(newIndex);
+//    (*oldIt)->setAtlasIndex(newIndex);
 
-    std::swap(*oldIt, *newIt);
+    std::swap( *oldIt, *newIt );
 }
 
 void SpriteBatchNode::reorderBatch(bool reorder)
 {
-    _reorderChildDirty = reorder;
+    _reorderChildDirty=reorder;
 }
 
-void SpriteBatchNode::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void SpriteBatchNode::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
     // Optimization: Fast Dispatch
-    if (_textureAtlas->getTotalQuads() == 0)
+    if( _textureAtlas->getTotalQuads() == 0 )
     {
         return;
     }
 
-    for (const auto& child : _children)
+    for (const auto &child : _children)
     {
         child->updateTransform();
     }
+    
+    const auto& matrixProjection = Director::getInstance()->getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);
+    auto programState = _quadCommand.getPipelineDescriptor().programState;
+    programState->setUniform(_mvpMatrixLocaiton, matrixProjection.m, sizeof(matrixProjection.m));
+    programState->setTexture(_textureLocation, 0, _textureAtlas->getTexture()->getBackendTexture());
 
-    _batchCommand.init(_globalZOrder, getGLProgram(), _blendFunc, _textureAtlas, transform, flags);
-    renderer->addCommand(&_batchCommand);
-}
-
-void SpriteBatchNode::setTextureAtlas(TextureAtlas* textureAtlas)
-{
-    if (textureAtlas != _textureAtlas)
-    {
-        CC_SAFE_RETAIN(textureAtlas);
-        CC_SAFE_RELEASE(_textureAtlas);
-        _textureAtlas = textureAtlas;
-    }
+    _quadCommand.init(_globalZOrder, _textureAtlas->getTexture(), _blendFunc, _textureAtlas->getQuads(), _textureAtlas->getTotalQuads(), transform, flags);
+    renderer->addCommand(&_quadCommand);
 }
 
 void SpriteBatchNode::increaseAtlasCapacity()
@@ -428,12 +429,13 @@ void SpriteBatchNode::increaseAtlasCapacity()
     // if we're going beyond the current TextureAtlas's capacity,
     // all the previously initialized sprites will need to redo their texture coords
     // this is likely computationally expensive
-    std::size_t quantity = (_textureAtlas->getCapacity() + 1) * 4 / 3;
+    ssize_t quantity = (_textureAtlas->getCapacity() + 1) * 4 / 3;
 
-    CCLOG("cocos2d: SpriteBatchNode: resizing TextureAtlas capacity from [%d] to [%d].", static_cast<int>(_textureAtlas->getCapacity()),
-          static_cast<int>(quantity));
+    CCLOG("cocos2d: SpriteBatchNode: resizing TextureAtlas capacity from [%d] to [%d].",
+        static_cast<int>(_textureAtlas->getCapacity()),
+        static_cast<int>(quantity));
 
-    if (!_textureAtlas->resizeCapacity(quantity))
+    if (! _textureAtlas->resizeCapacity(quantity))
     {
         // serious problems
         CCLOGWARN("cocos2d: WARNING: Not enough memory to resize the atlas");
@@ -441,12 +443,12 @@ void SpriteBatchNode::increaseAtlasCapacity()
     }
 }
 
-void SpriteBatchNode::reserveCapacity(std::size_t newCapacity)
+void SpriteBatchNode::reserveCapacity(ssize_t newCapacity)
 {
     if (newCapacity <= _textureAtlas->getCapacity())
         return;
 
-    if (!_textureAtlas->resizeCapacity(newCapacity))
+    if (! _textureAtlas->resizeCapacity(newCapacity))
     {
         // serious problems
         CCLOGWARN("cocos2d: WARNING: Not enough memory to resize the atlas");
@@ -454,13 +456,12 @@ void SpriteBatchNode::reserveCapacity(std::size_t newCapacity)
     }
 }
 
-std::size_t SpriteBatchNode::rebuildIndexInOrder(Sprite* parent, std::size_t index)
+ssize_t SpriteBatchNode::rebuildIndexInOrder(Sprite *parent, ssize_t index)
 {
-    CCASSERT(index >= 0 && index < _children.size(), "Invalid index");
+    CCASSERT(index>=0 && index < _children.size(), "Invalid index");
 
     auto& children = parent->getChildren();
-    for (const auto& child : children)
-    {
+    for(const auto &child: children) {
         Sprite* sp = static_cast<Sprite*>(child);
         if (sp && (sp->getLocalZOrder() < 0))
         {
@@ -475,8 +476,7 @@ std::size_t SpriteBatchNode::rebuildIndexInOrder(Sprite* parent, std::size_t ind
         index++;
     }
 
-    for (const auto& child : children)
-    {
+    for(const auto &child: children) {
         Sprite* sp = static_cast<Sprite*>(child);
         if (sp && (sp->getLocalZOrder() >= 0))
         {
@@ -487,21 +487,21 @@ std::size_t SpriteBatchNode::rebuildIndexInOrder(Sprite* parent, std::size_t ind
     return index;
 }
 
-std::size_t SpriteBatchNode::highestAtlasIndexInChild(Sprite* sprite)
+ssize_t SpriteBatchNode::highestAtlasIndexInChild(Sprite *sprite)
 {
     auto& children = sprite->getChildren();
 
-    if (children.size() == 0)
+    if (children.empty())
     {
         return sprite->getAtlasIndex();
     }
     else
     {
-        return highestAtlasIndexInChild(static_cast<Sprite*>(children.back()));
+        return highestAtlasIndexInChild( static_cast<Sprite*>(children.back()));
     }
 }
 
-std::size_t SpriteBatchNode::lowestAtlasIndexInChild(Sprite* sprite)
+ssize_t SpriteBatchNode::lowestAtlasIndexInChild(Sprite *sprite)
 {
     auto& children = sprite->getChildren();
 
@@ -515,14 +515,14 @@ std::size_t SpriteBatchNode::lowestAtlasIndexInChild(Sprite* sprite)
     }
 }
 
-std::size_t SpriteBatchNode::atlasIndexForChild(Sprite* sprite, int nZ)
+ssize_t SpriteBatchNode::atlasIndexForChild(Sprite *sprite, int nZ)
 {
     auto& siblings = sprite->getParent()->getChildren();
     auto childIndex = siblings.getIndex(sprite);
 
     // ignore parent Z if parent is spriteSheet
     bool ignoreParent = (SpriteBatchNode*)(sprite->getParent()) == this;
-    Sprite* prev = nullptr;
+    Sprite *prev = nullptr;
     if (childIndex > 0 && childIndex != -1)
     {
         prev = static_cast<Sprite*>(siblings.at(childIndex - 1));
@@ -544,7 +544,7 @@ std::size_t SpriteBatchNode::atlasIndexForChild(Sprite* sprite, int nZ)
     // first child of an Sprite ?
     if (childIndex == 0)
     {
-        Sprite* p = static_cast<Sprite*>(sprite->getParent());
+        Sprite *p = static_cast<Sprite*>(sprite->getParent());
 
         // less than parent and brothers
         if (nZ < 0)
@@ -565,7 +565,7 @@ std::size_t SpriteBatchNode::atlasIndexForChild(Sprite* sprite, int nZ)
         }
 
         // else (previous < 0 and sprite >= 0 )
-        Sprite* p = static_cast<Sprite*>(sprite->getParent());
+        Sprite *p = static_cast<Sprite*>(sprite->getParent());
         return p->getAtlasIndex() + 1;
     }
 
@@ -577,17 +577,16 @@ std::size_t SpriteBatchNode::atlasIndexForChild(Sprite* sprite, int nZ)
 // addChild helper, faster than insertChild
 void SpriteBatchNode::appendChild(Sprite* sprite)
 {
-    _reorderChildDirty = true;
+    _reorderChildDirty=true;
     sprite->setBatchNode(this);
     sprite->setDirty(true);
 
-    if (_textureAtlas->getTotalQuads() == _textureAtlas->getCapacity())
-    {
+    if(_textureAtlas->getTotalQuads() == _textureAtlas->getCapacity()) {
         increaseAtlasCapacity();
     }
 
     _descendants.push_back(sprite);
-    int index = static_cast<int>(_descendants.size() - 1);
+    int index = static_cast<int>(_descendants.size()-1);
 
     sprite->setAtlasIndex(index);
 
@@ -596,14 +595,12 @@ void SpriteBatchNode::appendChild(Sprite* sprite)
 
     // add children recursively
     auto& children = sprite->getChildren();
-    for (const auto& child : children)
-    {
+    for(const auto &child: children) {
 #if CC_SPRITE_DEBUG_DRAW
         // when using CC_SPRITE_DEBUG_DRAW, a DrawNode is appended to sprites. remove it since only Sprites can be used
         // as children in SpriteBatchNode
         // Github issue #14730
-        if (dynamic_cast<DrawNode*>(child))
-        {
+        if (dynamic_cast<DrawNode*>(child)) {
             // to avoid calling Sprite::removeChild()
             sprite->Node::removeChild(child, true);
         }
@@ -611,11 +608,11 @@ void SpriteBatchNode::appendChild(Sprite* sprite)
 #else
         CCASSERT(dynamic_cast<Sprite*>(child) != nullptr, "You can only add Sprites (or subclass of Sprite) to SpriteBatchNode");
 #endif
-            appendChild(static_cast<Sprite*>(child));
+        appendChild(static_cast<Sprite*>(child));
     }
 }
 
-void SpriteBatchNode::removeSpriteFromAtlas(Sprite* sprite)
+void SpriteBatchNode::removeSpriteFromAtlas(Sprite *sprite)
 {
     // remove from TextureAtlas
     _textureAtlas->removeQuadAtIndex(sprite->getAtlasIndex());
@@ -623,16 +620,15 @@ void SpriteBatchNode::removeSpriteFromAtlas(Sprite* sprite)
     // Cleanup sprite. It might be reused (issue #569)
     sprite->setBatchNode(nullptr);
 
-    auto it = std::find(_descendants.begin(), _descendants.end(), sprite);
-    if (it != _descendants.end())
+    auto it = std::find(_descendants.begin(), _descendants.end(), sprite );
+    if( it != _descendants.end() )
     {
         auto next = std::next(it);
 
-        Sprite* spr = nullptr;
-        for (; next != _descendants.end(); ++next)
-        {
+        Sprite *spr = nullptr;
+        for(auto nextEnd = _descendants.end(); next != nextEnd; ++next) {
             spr = *next;
-            spr->setAtlasIndex(spr->getAtlasIndex() - 1);
+            spr->setAtlasIndex( spr->getAtlasIndex() - 1 );
         }
 
         _descendants.erase(it);
@@ -640,8 +636,7 @@ void SpriteBatchNode::removeSpriteFromAtlas(Sprite* sprite)
 
     // remove children recursively
     auto& children = sprite->getChildren();
-    for (const auto& obj : children)
-    {
+    for(const auto &obj: children) {
         Sprite* child = static_cast<Sprite*>(obj);
         if (child)
         {
@@ -652,7 +647,7 @@ void SpriteBatchNode::removeSpriteFromAtlas(Sprite* sprite)
 
 void SpriteBatchNode::updateBlendFunc()
 {
-    if (!_textureAtlas->getTexture()->hasPremultipliedAlpha())
+    if (! _textureAtlas->getTexture()->hasPremultipliedAlpha())
     {
         _blendFunc = BlendFunc::ALPHA_NON_PREMULTIPLIED;
         setOpacityModifyRGB(false);
@@ -665,7 +660,7 @@ void SpriteBatchNode::updateBlendFunc()
 }
 
 // CocosNodeTexture protocol
-void SpriteBatchNode::setBlendFunc(const BlendFunc& blendFunc)
+void SpriteBatchNode::setBlendFunc(const BlendFunc &blendFunc)
 {
     _blendFunc = blendFunc;
 }
@@ -680,22 +675,23 @@ Texture2D* SpriteBatchNode::getTexture() const
     return _textureAtlas->getTexture();
 }
 
-void SpriteBatchNode::setTexture(Texture2D* texture)
+void SpriteBatchNode::setTexture(Texture2D *texture)
 {
     _textureAtlas->setTexture(texture);
     updateBlendFunc();
 }
 
+
 // SpriteSheet Extension
-// implementation SpriteSheet (TMXTiledMapExtension)
+//implementation SpriteSheet (TMXTiledMapExtension)
 
-void SpriteBatchNode::insertQuadFromSprite(Sprite* sprite, std::size_t index)
+void SpriteBatchNode::insertQuadFromSprite(Sprite *sprite, ssize_t index)
 {
-    CCASSERT(sprite != nullptr, "Argument must be non-nullptr");
-    CCASSERT(dynamic_cast<Sprite*>(sprite), "CCSpriteBatchNode only supports Sprites as children");
+    CCASSERT( sprite != nullptr, "Argument must be non-nullptr");
+    CCASSERT( dynamic_cast<Sprite*>(sprite), "CCSpriteBatchNode only supports Sprites as children");
 
     // make needed room
-    while (index >= _textureAtlas->getCapacity() || _textureAtlas->getCapacity() == _textureAtlas->getTotalQuads())
+    while(index >= _textureAtlas->getCapacity() || _textureAtlas->getCapacity() == _textureAtlas->getTotalQuads())
     {
         this->increaseAtlasCapacity();
     }
@@ -714,42 +710,42 @@ void SpriteBatchNode::insertQuadFromSprite(Sprite* sprite, std::size_t index)
     sprite->updateTransform();
 }
 
-void SpriteBatchNode::updateQuadFromSprite(Sprite* sprite, std::size_t index)
+void SpriteBatchNode::updateQuadFromSprite(Sprite *sprite, ssize_t index)
 {
     CCASSERT(sprite != nullptr, "Argument must be non-nil");
     CCASSERT(dynamic_cast<Sprite*>(sprite) != nullptr, "CCSpriteBatchNode only supports Sprites as children");
-
+    
     // make needed room
     while (index >= _textureAtlas->getCapacity() || _textureAtlas->getCapacity() == _textureAtlas->getTotalQuads())
     {
         this->increaseAtlasCapacity();
     }
-
+    
     //
     // update the quad directly. Don't add the sprite to the scene graph
     //
     sprite->setBatchNode(this);
     sprite->setAtlasIndex(index);
-
+    
     sprite->setDirty(true);
-
+    
     // UpdateTransform updates the textureAtlas quad
     sprite->updateTransform();
 }
 
-SpriteBatchNode* SpriteBatchNode::addSpriteWithoutQuad(Sprite* child, int z, int aTag)
+SpriteBatchNode * SpriteBatchNode::addSpriteWithoutQuad(Sprite*child, int z, int aTag)
 {
-    CCASSERT(child != nullptr, "Argument must be non-nullptr");
-    CCASSERT(dynamic_cast<Sprite*>(child), "CCSpriteBatchNode only supports Sprites as children");
+    CCASSERT( child != nullptr, "Argument must be non-nullptr");
+    CCASSERT( dynamic_cast<Sprite*>(child), "CCSpriteBatchNode only supports Sprites as children");
 
     // quad index is Z
     child->setAtlasIndex(z);
 
     // FIXME:: optimize with a binary search
     auto it = _descendants.begin();
-    for (; it != _descendants.end(); ++it)
+    for (auto itEnd = _descendants.end(); it != itEnd; ++it)
     {
-        if ((*it)->getAtlasIndex() >= z)
+        if((*it)->getAtlasIndex() >= z)
             break;
     }
 
diff --git a/cocos2d/cocos/2d/CCSpriteBatchNode.h b/cocos2d/cocos/2d/CCSpriteBatchNode.h
index 440c0b621e..550bfcb525 100644
--- a/cocos2d/cocos/2d/CCSpriteBatchNode.h
+++ b/cocos2d/cocos/2d/CCSpriteBatchNode.h
@@ -4,6 +4,7 @@ Copyright (c) 2009      Matt Oswald
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,23 +26,14 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
+#pragma once
 
-#ifndef CC_2D_SPRITEBATCHNODE_H
-#define CC_2D_SPRITEBATCHNODE_H
+#include <vector>
 
 #include <cocos/2d/CCNode.h>
 #include <cocos/base/CCProtocols.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCBatchCommand.h>
-
-#include <cstddef>
-#include <cstdint>
-#include <iosfwd>
-#include <vector>
+#include <cocos/renderer/CCTextureAtlas.h>
+#include <cocos/renderer/CCQuadCommand.h>
 
 NS_CC_BEGIN
 
@@ -50,10 +42,8 @@ NS_CC_BEGIN
  * @{
  */
 
-class Renderer;
+
 class Sprite;
-class Texture2D;
-class TextureAtlas;
 
 /** SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call
  * (often known as "batch draw").
@@ -65,10 +55,8 @@ class TextureAtlas;
  *
  *
  * Limitations:
- *  - The only object that is accepted as child (or grandchild, grand-grandchild, etc...) is Sprite or any subclass of Sprite. eg: particles, labels and layer
- * can't be added to a SpriteBatchNode.
- *  - Either all its children are Aliased or Antialiased. It can't be a mix. This is because "alias" is a property of the texture, and all the sprites share the
- * same texture.
+ *  - The only object that is accepted as child (or grandchild, grand-grandchild, etc...) is Sprite or any subclass of Sprite. eg: particles, labels and layer can't be added to a SpriteBatchNode.
+ *  - Either all its children are Aliased or Antialiased. It can't be a mix. This is because "alias" is a property of the texture, and all the sprites share the same texture.
  *
  * @since v0.7.1
  */
@@ -84,7 +72,7 @@ public:
      * @param capacity The capacity of children.
      * @return Return an autorelease object.
      */
-    static SpriteBatchNode* createWithTexture(Texture2D* tex, std::size_t capacity = DEFAULT_CAPACITY);
+    static SpriteBatchNode* createWithTexture(Texture2D* tex, ssize_t capacity = DEFAULT_CAPACITY);
 
     /** Creates a SpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and capacity of children.
      * The capacity will be increased in 33% in runtime if it runs out of space.
@@ -94,23 +82,32 @@ public:
      * @param capacity The capacity of children.
      * @return Return an autorelease object.
      */
-    static SpriteBatchNode* create(const std::string& fileImage, std::size_t capacity = DEFAULT_CAPACITY);
+    static SpriteBatchNode* create(const std::string& fileImage, ssize_t capacity = DEFAULT_CAPACITY);
 
-    /** Returns the TextureAtlas object.
+
+    /** Returns the TextureAtlas object. 
      *
      * @return The TextureAtlas object.
      */
     TextureAtlas* getTextureAtlas() { return _textureAtlas; }
 
-    /** Sets the TextureAtlas object.
+    /** Sets the TextureAtlas object. 
      *
      * @param textureAtlas The TextureAtlas object.
      */
-    void setTextureAtlas(TextureAtlas* textureAtlas);
+    void setTextureAtlas(TextureAtlas* textureAtlas)
+    { 
+        if (textureAtlas != _textureAtlas)
+        {
+            CC_SAFE_RETAIN(textureAtlas);
+            CC_SAFE_RELEASE(_textureAtlas);
+            _textureAtlas = textureAtlas;
+        }
+    }
 
     /** Returns an array with the descendants (children, gran children, etc.).
      * This is specific to BatchNode. In order to use the children, use getChildren() instead.
-     *
+     * 
      * @return An array with the descendants (children, gran children, etc.).
      */
     const std::vector<Sprite*>& getDescendants() const { return _descendants; }
@@ -124,49 +121,49 @@ public:
      * @param doCleanup Whether or not to cleanup the running actions.
      * @warning Removing a child from a SpriteBatchNode is very slow.
      */
-    void removeChildAtIndex(std::size_t index, bool doCleanup);
-
-    /** Append the child.
+    void removeChildAtIndex(ssize_t index, bool doCleanup);
+    
+    /** Append the child. 
      *
      * @param sprite A Sprite.
      */
     void appendChild(Sprite* sprite);
-
-    /** Remove a sprite from Atlas.
+    
+    /** Remove a sprite from Atlas. 
      *
      * @param sprite A Sprite.
      */
-    void removeSpriteFromAtlas(Sprite* sprite);
-
-    /** Rebuild index with a sprite all child.
+    void removeSpriteFromAtlas(Sprite *sprite);
+    
+    /** Rebuild index with a sprite all child. 
      *
      * @param parent The parent sprite.
      * @param index The child index.
      * @return Index.
      */
-    std::size_t rebuildIndexInOrder(Sprite* parent, std::size_t index);
-
+    ssize_t rebuildIndexInOrder(Sprite *parent, ssize_t index);
+    
     /** Get the Max image block index,in all child.
      *
      * @param sprite The parent sprite.
      * @return Index.
      */
-    std::size_t highestAtlasIndexInChild(Sprite* sprite);
-
-    /** Get the Min image block index,in all child.
+    ssize_t highestAtlasIndexInChild(Sprite *sprite);
+    
+    /** Get the Min image block index,in all child. 
      *
      * @param sprite The parent sprite.
      * @return Index.
      */
-    std::size_t lowestAtlasIndexInChild(Sprite* sprite);
-
+    ssize_t lowestAtlasIndexInChild(Sprite *sprite);
+    
     /** Get the nearest index from the sprite in z.
      *
      * @param sprite The parent sprite.
      * @param z Z order for drawing priority.
      * @return Index.
      */
-    std::size_t atlasIndexForChild(Sprite* sprite, int z);
+    ssize_t atlasIndexForChild(Sprite *sprite, int z);
     /* Sprites use this to start sortChildren, don't call this manually. */
     void reorderBatch(bool reorder);
 
@@ -175,97 +172,103 @@ public:
     //
     // TextureProtocol
     virtual Texture2D* getTexture() const override;
-    virtual void setTexture(Texture2D* texture) override;
+    virtual void setTexture(Texture2D *texture) override;
     /**
-     *@code
-     * When this function bound into js or lua,the parameter will be changed.
-     * In js: var setBlendFunc(var src, var dst).
-     * @endcode
-     * @lua NA
-     */
-    virtual void setBlendFunc(const BlendFunc& blendFunc) override;
+    *@code
+    * When this function bound into js or lua,the parameter will be changed.
+    * In js: var setBlendFunc(var src, var dst).
+    * @endcode
+    * @lua NA 
+    */
+    virtual void setBlendFunc(const BlendFunc &blendFunc) override;
     /**
-     * @lua NA
-     */
+    * @lua NA
+    */
     virtual const BlendFunc& getBlendFunc() const override;
 
     /**
      * @js NA
      */
-    virtual void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
-
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
+    
     using Node::addChild;
-    virtual void addChild(Node* child, int zOrder, int tag) override;
-    virtual void addChild(Node* child, int zOrder, const std::string& name) override;
-    virtual void reorderChild(Node* child, int zOrder) override;
-
-    virtual void removeChild(Node* child, bool cleanup) override;
+    virtual void addChild(Node * child, int zOrder, int tag) override;
+    virtual void addChild(Node * child, int zOrder, const std::string &name) override;
+    virtual void reorderChild(Node *child, int zOrder) override;
+        
+	virtual void removeChild(Node *child, bool cleanup) override;
     /**
      * @js NA
      */
     virtual void removeAllChildrenWithCleanup(bool cleanup) override;
-    virtual void sortAllChildren() override;
-    /**
-     * @js NA
-     */
-    virtual void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
-    /**
-     * @js NA
-     */
+	virtual void sortAllChildren() override;
+	/**
+	* @js NA
+	*/
+	virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
+	/**
+	* @js NA
+	*/
     virtual std::string getDescription() const override;
 
     /** Inserts a quad at a certain index into the texture atlas. The Sprite won't be added into the children array.
      * This method should be called only when you are dealing with very big AtlasSprite and when most of the Sprite won't be updated.
      * For example: a tile map (TMXMap) or a label with lots of characters (LabelBMFont).
      */
-    void insertQuadFromSprite(Sprite* sprite, std::size_t index);
+    void insertQuadFromSprite(Sprite *sprite, ssize_t index);
     /* This is the opposite of "addQuadFromSprite.
      * It add the sprite to the children and descendants array, but it doesn't update add it to the texture atlas
      */
-    SpriteBatchNode* addSpriteWithoutQuad(Sprite* child, int z, int aTag);
+    SpriteBatchNode * addSpriteWithoutQuad(Sprite *child, int z, int aTag);
 
     /** reserves capacity for the batch node.
      If the current capacity is bigger, nothing happens.
      otherwise, a new capacity is allocated */
-    void reserveCapacity(std::size_t newCapacity);
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        SpriteBatchNode();
+    void reserveCapacity(ssize_t newCapacity);
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    SpriteBatchNode();
     /**
      * @js NA
      * @lua NA
      */
-    ~SpriteBatchNode() override;
-
+    virtual ~SpriteBatchNode();
+    
     /** initializes a SpriteBatchNode with a texture2d and capacity of children.
      The capacity will be increased in 33% in runtime if it runs out of space.
      */
-    bool initWithTexture(Texture2D* tex, std::size_t capacity = DEFAULT_CAPACITY);
+    bool initWithTexture(Texture2D *tex, ssize_t capacity = DEFAULT_CAPACITY);
     /** initializes a SpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and a capacity of children.
      The capacity will be increased in 33% in runtime if it runs out of space.
      The file will be loaded using the TextureMgr.
      * @js init
      * @lua init
      */
-    bool initWithFile(const std::string& fileImage, std::size_t capacity = DEFAULT_CAPACITY);
+    bool initWithFile(const std::string& fileImage, ssize_t capacity = DEFAULT_CAPACITY);
     bool init() override;
-
+    
 protected:
     /** Updates a quad at a certain index into the texture atlas. The Sprite won't be added into the children array.
      This method should be called only when you are dealing with very big AtlasSprite and when most of the Sprite won't be updated.
      For example: a tile map (TMXMap) or a label with lots of characters (LabelBMFont)
      */
-    void updateQuadFromSprite(Sprite* sprite, std::size_t index);
+    void updateQuadFromSprite(Sprite *sprite, ssize_t index);   
 
-    void updateAtlasIndex(Sprite* sprite, std::size_t* curIndex);
-    void swap(std::size_t oldIndex, std::size_t newIndex);
+    void updateAtlasIndex(Sprite* sprite, ssize_t* curIndex);
+    void swap(ssize_t oldIndex, ssize_t newIndex);
     void updateBlendFunc();
+    
+    virtual void updateShaders(const std::string& vertexShader, const std::string& fragmentShader);
 
-    TextureAtlas* _textureAtlas;
+    TextureAtlas *_textureAtlas = nullptr;
     BlendFunc _blendFunc;
-    BatchCommand _batchCommand; // render command
+    QuadCommand _quadCommand;
+    
+    backend::UniformLocation _mvpMatrixLocaiton;
+    backend::UniformLocation _textureLocation;
+    backend::ProgramState* _programState = nullptr;
 
     // all descendants: children, grand children, etc...
     // There is not need to retain/release these objects, since they are already retained by _children
@@ -277,5 +280,3 @@ protected:
 /** @} */
 
 NS_CC_END
-
-#endif // CC_2D_SPRITEBATCHNODE_H
diff --git a/cocos2d/cocos/2d/CCSpriteFrame.cpp b/cocos2d/cocos/2d/CCSpriteFrame.cpp
index cafc31f037..9d4ae2558b 100644
--- a/cocos2d/cocos/2d/CCSpriteFrame.cpp
+++ b/cocos2d/cocos/2d/CCSpriteFrame.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2011 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,19 +26,10 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
+#include <cocos/renderer/CCTextureCache.h>
 #include <cocos/2d/CCSpriteFrame.h>
-
-#include <cocos/2d/CCAutoPolygon.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCTextureCache.h>
-#include <cocos/renderer/CCTrianglesCommand.h>
-
-#include <cmath>
-#include <new>
+#include <cocos/platform/CCFileUtils.h>
 
 NS_CC_BEGIN
 
@@ -45,38 +37,43 @@ NS_CC_BEGIN
 
 SpriteFrame* SpriteFrame::create(const std::string& filename, const Rect& rect)
 {
-    SpriteFrame* spriteFrame = new (std::nothrow) SpriteFrame();
+    SpriteFrame *spriteFrame = new (std::nothrow) SpriteFrame();
     spriteFrame->initWithTextureFilename(filename, rect);
     spriteFrame->autorelease();
 
     return spriteFrame;
 }
 
-SpriteFrame* SpriteFrame::createWithTexture(Texture2D* texture, const Rect& rect)
+SpriteFrame* SpriteFrame::createWithTexture(Texture2D *texture, const Rect& rect)
 {
-    SpriteFrame* spriteFrame = new (std::nothrow) SpriteFrame();
+    SpriteFrame *spriteFrame = new (std::nothrow) SpriteFrame();
     spriteFrame->initWithTexture(texture, rect);
     spriteFrame->autorelease();
-
+    
     return spriteFrame;
 }
 
 SpriteFrame* SpriteFrame::createWithTexture(Texture2D* texture, const Rect& rect, bool rotated, const Vec2& offset, const Size& originalSize)
 {
-    SpriteFrame* spriteFrame = new (std::nothrow) SpriteFrame();
-    spriteFrame->initWithTexture(texture, rect, rotated, offset, originalSize);
-    spriteFrame->autorelease();
+    SpriteFrame *spriteFrame = new (std::nothrow) SpriteFrame();
+    if (spriteFrame && spriteFrame->initWithTexture(texture, rect, rotated, offset, originalSize)) {
+        spriteFrame->autorelease();
+        return spriteFrame;
+    }
 
-    return spriteFrame;
+    delete spriteFrame;
+    return nullptr;
 }
 
 SpriteFrame* SpriteFrame::create(const std::string& filename, const Rect& rect, bool rotated, const Vec2& offset, const Size& originalSize)
 {
-    SpriteFrame* spriteFrame = new (std::nothrow) SpriteFrame();
-    spriteFrame->initWithTextureFilename(filename, rect, rotated, offset, originalSize);
-    spriteFrame->autorelease();
-
-    return spriteFrame;
+    SpriteFrame *spriteFrame = new (std::nothrow) SpriteFrame();
+    if (spriteFrame && spriteFrame->initWithTextureFilename(filename, rect, rotated, offset, originalSize)) {
+        spriteFrame->autorelease();
+        return spriteFrame;
+    }
+    delete spriteFrame;
+    return nullptr;
 }
 
 SpriteFrame::SpriteFrame()
@@ -93,7 +90,7 @@ bool SpriteFrame::initWithTexture(Texture2D* texture, const Rect& rect)
 
 bool SpriteFrame::initWithTextureFilename(const std::string& filename, const Rect& rect)
 {
-    Rect rectInPixels = CC_RECT_POINTS_TO_PIXELS(rect);
+    Rect rectInPixels = CC_RECT_POINTS_TO_PIXELS( rect );
     return initWithTextureFilename(filename, rectInPixels, false, Vec2::ZERO, rectInPixels.size);
 }
 
@@ -101,44 +98,54 @@ bool SpriteFrame::initWithTexture(Texture2D* texture, const Rect& rect, bool rot
 {
     _texture = texture;
 
+    if (texture)
+    {
+        texture->retain();
+    }
+
     _rectInPixels = rect;
     _rect = CC_RECT_PIXELS_TO_POINTS(rect);
     _offsetInPixels = offset;
-    _offset = CC_POINT_PIXELS_TO_POINTS(_offsetInPixels);
+    _offset = CC_POINT_PIXELS_TO_POINTS( _offsetInPixels );
     _originalSizeInPixels = originalSize;
-    _originalSize = CC_SIZE_PIXELS_TO_POINTS(_originalSizeInPixels);
+    _originalSize = CC_SIZE_PIXELS_TO_POINTS( _originalSizeInPixels );
     _rotated = rotated;
     _anchorPoint = Vec2(NAN, NAN);
+    _centerRect = Rect(NAN, NAN, NAN, NAN);
 
     return true;
 }
 
 bool SpriteFrame::initWithTextureFilename(const std::string& filename, const Rect& rect, bool rotated, const Vec2& offset, const Size& originalSize)
 {
-    _texture = nullptr;
-    _textureFilename = filename;
-    _rectInPixels = rect;
-    _rect = CC_RECT_PIXELS_TO_POINTS(rect);
-    _offsetInPixels = offset;
-    _offset = CC_POINT_PIXELS_TO_POINTS(_offsetInPixels);
-    _originalSizeInPixels = originalSize;
-    _originalSize = CC_SIZE_PIXELS_TO_POINTS(_originalSizeInPixels);
-    _rotated = rotated;
-    _anchorPoint = Vec2(NAN, NAN);
-
-    return true;
+    if (FileUtils::getInstance()->isFileExist(filename)) {
+        _texture = nullptr;
+        _textureFilename = filename;
+        _rectInPixels = rect;
+        _rect = CC_RECT_PIXELS_TO_POINTS( rect );
+        _offsetInPixels = offset;
+        _offset = CC_POINT_PIXELS_TO_POINTS( _offsetInPixels );
+        _originalSizeInPixels = originalSize;
+        _originalSize = CC_SIZE_PIXELS_TO_POINTS( _originalSizeInPixels );
+        _rotated = rotated;
+        _anchorPoint = Vec2(NAN, NAN);
+        _centerRect = Rect(NAN, NAN, NAN, NAN);
+        return true;
+    }
+    return false;
 }
 
 SpriteFrame::~SpriteFrame()
 {
     CCLOGINFO("deallocing SpriteFrame: %p", this);
+    CC_SAFE_RELEASE(_texture);
 }
 
 SpriteFrame* SpriteFrame::clone() const
 {
-    // no copy constructor
-    SpriteFrame* copy = new (std::nothrow) SpriteFrame();
-    copy->setTexture(_texture);
+	// no copy constructor	
+    SpriteFrame *copy = new (std::nothrow) SpriteFrame();
+    copy->initWithTexture(_texture, _rectInPixels, _rotated, _offsetInPixels, _originalSizeInPixels);
     copy->setPolygonInfo(_polygonInfo);
     copy->autorelease();
     return copy;
@@ -156,6 +163,16 @@ void SpriteFrame::setRectInPixels(const Rect& rectInPixels)
     _rect = CC_RECT_PIXELS_TO_POINTS(rectInPixels);
 }
 
+void SpriteFrame::setCenterRectInPixels(const Rect& centerRect)
+{
+    _centerRect = CC_RECT_PIXELS_TO_POINTS(centerRect);
+}
+
+bool SpriteFrame::hasCenterRect() const
+{
+    return !std::isnan(_centerRect.origin.x);
+}
+
 const Vec2& SpriteFrame::getOffset() const
 {
     return _offset;
@@ -164,7 +181,7 @@ const Vec2& SpriteFrame::getOffset() const
 void SpriteFrame::setOffset(const Vec2& offsets)
 {
     _offset = offsets;
-    _offsetInPixels = CC_POINT_POINTS_TO_PIXELS(_offset);
+    _offsetInPixels = CC_POINT_POINTS_TO_PIXELS( _offset );
 }
 
 const Vec2& SpriteFrame::getOffsetInPixels() const
@@ -175,7 +192,7 @@ const Vec2& SpriteFrame::getOffsetInPixels() const
 void SpriteFrame::setOffsetInPixels(const Vec2& offsetInPixels)
 {
     _offsetInPixels = offsetInPixels;
-    _offset = CC_POINT_PIXELS_TO_POINTS(_offsetInPixels);
+    _offset = CC_POINT_PIXELS_TO_POINTS( _offsetInPixels );
 }
 
 const Vec2& SpriteFrame::getAnchorPoint() const
@@ -193,30 +210,29 @@ bool SpriteFrame::hasAnchorPoint() const
     return !std::isnan(_anchorPoint.x);
 }
 
-void SpriteFrame::setTexture(Texture2D* texture)
+void SpriteFrame::setTexture(Texture2D * texture)
 {
-    if (_texture != texture)
-    {
+    if( _texture != texture ) {
+        CC_SAFE_RELEASE(_texture);
+        CC_SAFE_RETAIN(texture);
         _texture = texture;
     }
 }
 
 Texture2D* SpriteFrame::getTexture()
 {
-    if (_texture)
-    {
+    if( _texture ) {
         return _texture;
     }
 
-    if (!_textureFilename.empty())
-    {
+    if( !_textureFilename.empty()) {
         return Director::getInstance()->getTextureCache()->addImage(_textureFilename);
     }
     // no texture or texture filename
     return nullptr;
 }
 
-void SpriteFrame::setPolygonInfo(const PolygonInfo& polygonInfo)
+void SpriteFrame::setPolygonInfo(const PolygonInfo &polygonInfo)
 {
     _polygonInfo = polygonInfo;
 }
diff --git a/cocos2d/cocos/2d/CCSpriteFrame.h b/cocos2d/cocos/2d/CCSpriteFrame.h
index 5ac08d2ef5..58d4577430 100644
--- a/cocos2d/cocos/2d/CCSpriteFrame.h
+++ b/cocos2d/cocos/2d/CCSpriteFrame.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2011 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,18 +26,13 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_SPRITEFRAME_H
-#define CC_2D_SPRITEFRAME_H
+#ifndef __SPRITE_CCSPRITE_FRAME_H__
+#define __SPRITE_CCSPRITE_FRAME_H__
 
+#include <cocos/2d/CCNode.h>
 #include <cocos/2d/CCAutoPolygon.h>
 #include <cocos/base/CCRef.h>
-#include <cocos/base/ccConfig.h>
 #include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
 
 NS_CC_BEGIN
 
@@ -54,7 +50,7 @@ class Texture2D;
 
 
  You can modify the frame of a Sprite by doing:
-
+ 
  @code
     SpriteFrame* frame = SpriteFrame::createWithTexture(texture, rect);
     sprite->setSpriteFrame(frame);
@@ -63,6 +59,7 @@ class Texture2D;
 class CC_DLL SpriteFrame : public Ref, public Clonable
 {
 public:
+
     /** Create a SpriteFrame with a texture filename, rect in points.
      It is assumed that the frame was not trimmed.
      *
@@ -71,7 +68,7 @@ public:
      * @return An autoreleased SpriteFrame object.
      */
     static SpriteFrame* create(const std::string& filename, const Rect& rect);
-
+    
     /** Create a SpriteFrame with a texture filename, rect, rotated, offset and originalSize in pixels.
      The originalSize is the size in pixels of the frame before being trimmed.
      *
@@ -83,7 +80,7 @@ public:
      * @return An autoreleased SpriteFrame object.
      */
     static SpriteFrame* create(const std::string& filename, const Rect& rect, bool rotated, const Vec2& offset, const Size& originalSize);
-
+    
     /** Create a SpriteFrame with a texture, rect in points.
      It is assumed that the frame was not trimmed.
      * @param pobTexture The texture pointer.
@@ -137,13 +134,40 @@ public:
      */
     void setRect(const Rect& rect);
 
-    /** Get offset of the frame.
+    /** Get center rect of the frame.
      *
+     * Useful to create 9-slice sprites
+     *
+     * @return The center rect of the sprite frame in points
+     */
+    const Rect& getCenterRect() const { return _centerRect; }
+
+     /**
+     * setCenterRect
+     *
+     * Useful to implement "9 sliced" sprites.
+     * The sprite will be sliced into a 3 x 3 grid. The four corners of this grid are applied without
+     * performing any scaling. The upper- and lower-middle parts are scaled horizontally, and the left- and right-middle parts are scaled vertically.
+     * The center is scaled in both directions.
+     * Important: The scaling is based the Sprite's trimmed size.
+     *
+     * Limitations: Does not work when the sprite is part of `SpriteBatchNode`.
+     * @param centerRect the Rect in points
+     */
+    void setCenterRectInPixels(const Rect& centerRect);
+
+    /** hasCenterRect
+     @return Whether or not it has a centerRect
+     */
+    bool hasCenterRect() const;
+
+    /** Get offset of the frame.
+     * 
      * @return The offset of the sprite frame, in pixels.
      */
     const Vec2& getOffsetInPixels() const;
     /** Set offset of the frame.
-     *
+     * 
      * @param offsetInPixels The offset of the sprite frame, in pixels.
      */
     void setOffsetInPixels(const Vec2& offsetInPixels);
@@ -209,11 +233,13 @@ public:
     bool hasAnchorPoint() const;
 
     // Overrides
-    virtual SpriteFrame* clone() const override;
-    /**
+	virtual SpriteFrame *clone() const override;
+
+    /** Set the polygon info for polygon mesh sprites
+     *
      * @param polygonInfo triangle mesh of the sprite
      */
-    void setPolygonInfo(const PolygonInfo& polygonInfo);
+    void setPolygonInfo(const PolygonInfo &polygonInfo);
 
     /** Get the polygonInfo for this sprite
      *
@@ -227,35 +253,35 @@ public:
      */
     bool hasPolygonInfo() const;
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @lua NA
-         */
-        SpriteFrame();
-
+CC_CONSTRUCTOR_ACCESS:
     /**
      * @lua NA
      */
-    ~SpriteFrame() override;
-
+    SpriteFrame();
+    
+    /**
+     * @lua NA
+     */
+    virtual ~SpriteFrame();
+    
     /** Initializes a SpriteFrame with a texture, rect in points.
      It is assumed that the frame was not trimmed.
      */
     bool initWithTexture(Texture2D* pobTexture, const Rect& rect);
-
+    
     /** Initializes a SpriteFrame with a texture filename, rect in points;
      It is assumed that the frame was not trimmed.
      */
     bool initWithTextureFilename(const std::string& filename, const Rect& rect);
-
+    
     /** Initializes a SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
      The originalSize is the size in points of the frame before being trimmed.
      */
     bool initWithTexture(Texture2D* pobTexture, const Rect& rect, bool rotated, const Vec2& offset, const Size& originalSize);
-
+    
     /** Initializes a SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
      The originalSize is the size in pixels of the frame before being trimmed.
-
+     
      @since v1.1
      */
     bool initWithTextureFilename(const std::string& filename, const Rect& rect, bool rotated, const Vec2& offset, const Size& originalSize);
@@ -265,12 +291,13 @@ protected:
     Vec2 _anchorPoint;
     Size _originalSize;
     Rect _rectInPixels;
-    bool _rotated;
+    bool   _rotated;
     Rect _rect;
+    Rect _centerRect;
     Vec2 _offsetInPixels;
     Size _originalSizeInPixels;
-    Texture2D* _texture;
-    std::string _textureFilename;
+    Texture2D *_texture;
+    std::string  _textureFilename;
     PolygonInfo _polygonInfo;
 };
 
@@ -279,4 +306,4 @@ protected:
 
 NS_CC_END
 
-#endif // CC_2D_SPRITEFRAME_H
+#endif //__SPRITE_CCSPRITE_FRAME_H__
diff --git a/cocos2d/cocos/2d/CCSpriteFrameCache.cpp b/cocos2d/cocos/2d/CCSpriteFrameCache.cpp
index 836dbc0ad8..f8366cc0d4 100644
--- a/cocos2d/cocos/2d/CCSpriteFrameCache.cpp
+++ b/cocos2d/cocos/2d/CCSpriteFrameCache.cpp
@@ -5,6 +5,7 @@ Copyright (c) 2009      Robert J Payne
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -29,42 +30,30 @@ THE SOFTWARE.
 
 #include <cocos/2d/CCSpriteFrameCache.h>
 
+#include <vector>
+
+
+#include <cocos/2d/CCSprite.h>
 #include <cocos/2d/CCAutoPolygon.h>
-#include <cocos/2d/CCSpriteFrame.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/CCMap.h>
+#include <cocos/platform/CCFileUtils.h>
 #include <cocos/base/CCNS.h>
-#include <cocos/base/CCNinePatchImageParser.h>
-#include <cocos/base/CCValue.h>
 #include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
-#include <cocos/platform/CCFileUtils.h>
-#include <cocos/platform/CCImage.h>
-#include <cocos/platform/CCPlatformMacros.h>
+#include <cocos/base/ccUTF8.h>
+#include <cocos/base/ccUtils.h>
+#include <cocos/base/CCDirector.h>
 #include <cocos/renderer/CCTexture2D.h>
 #include <cocos/renderer/CCTextureCache.h>
-#include <cocos/renderer/CCTrianglesCommand.h>
-
-#include <algorithm>
-#include <cmath>
-#include <cstdlib>
-#include <new>
-#include <unordered_map>
-#include <utility>
-#include <vector>
+#include <cocos/base/CCNinePatchImageParser.h>
 
 using namespace std;
 
 NS_CC_BEGIN
 
-static SpriteFrameCache* _sharedSpriteFrameCache = nullptr;
+static SpriteFrameCache *_sharedSpriteFrameCache = nullptr;
 
 SpriteFrameCache* SpriteFrameCache::getInstance()
 {
-    if (!_sharedSpriteFrameCache)
+    if (! _sharedSpriteFrameCache)
     {
         _sharedSpriteFrameCache = new (std::nothrow) SpriteFrameCache();
         _sharedSpriteFrameCache->init();
@@ -80,55 +69,39 @@ void SpriteFrameCache::destroyInstance()
 
 bool SpriteFrameCache::init()
 {
-    _spriteFrames.reserve(20);
     _spriteFramesAliases.reserve(20);
-    _loadedFileNames = new std::set<std::string>();
+    _spriteFramesCache.init();
     return true;
 }
 
 SpriteFrameCache::~SpriteFrameCache()
 {
-    CC_SAFE_DELETE(_loadedFileNames);
-}
-
-void SpriteFrameCache::parseIntegerList(const std::string& string, std::vector<int>& res)
-{
-    std::string delim(" ");
-
-    size_t n = std::count(string.begin(), string.end(), ' ');
-    res.resize(n + 1);
-
-    size_t start = 0U;
-    size_t end = string.find(delim);
-
-    int i = 0;
-    while (end != std::string::npos)
-    {
-        res[i++] = atoi(string.substr(start, end - start).c_str());
-        start = end + delim.length();
-        end = string.find(delim, start);
-    }
-
-    res[i] = atoi(string.substr(start, end).c_str());
 }
 
-void SpriteFrameCache::initializePolygonInfo(const Size& textureSize, const Size& spriteSize, const std::vector<int>& vertices,
-                                             const std::vector<int>& verticesUV, const std::vector<int>& triangleIndices, PolygonInfo& info)
+void SpriteFrameCache::initializePolygonInfo(const Size &textureSize,
+                                             const Size &spriteSize,
+                                             const std::vector<int> &vertices,
+                                             const std::vector<int> &verticesUV,
+                                             const std::vector<int> &triangleIndices,
+                                             PolygonInfo &info)
 {
     size_t vertexCount = vertices.size();
     size_t indexCount = triangleIndices.size();
-
+    
     float scaleFactor = CC_CONTENT_SCALE_FACTOR();
 
-    V3F_C4B_T2F* vertexData = new (std::nothrow) V3F_C4B_T2F[vertexCount];
-    for (size_t i = 0; i < vertexCount / 2; i++)
+    V3F_C4B_T2F *vertexData = new (std::nothrow) V3F_C4B_T2F[vertexCount];
+    for (size_t i = 0; i < vertexCount/2; i++)
     {
         vertexData[i].colors = Color4B::WHITE;
-        vertexData[i].vertices = Vec3(vertices[i * 2] / scaleFactor, (spriteSize.height - vertices[i * 2 + 1]) / scaleFactor, 0);
-        vertexData[i].texCoords = Tex2F(verticesUV[i * 2] / textureSize.width, verticesUV[i * 2 + 1] / textureSize.height);
+        vertexData[i].vertices = Vec3(vertices[i*2] / scaleFactor,
+                                      (spriteSize.height - vertices[i*2+1]) / scaleFactor,
+                                      0);
+        vertexData[i].texCoords = Tex2F(verticesUV[i*2] / textureSize.width,
+                                        verticesUV[i*2+1] / textureSize.height);
     }
 
-    unsigned short* indexData = new unsigned short[indexCount];
+    unsigned short *indexData = new unsigned short[indexCount];
     for (size_t i = 0; i < indexCount; i++)
     {
         indexData[i] = static_cast<unsigned short>(triangleIndices[i]);
@@ -138,10 +111,10 @@ void SpriteFrameCache::initializePolygonInfo(const Size& textureSize, const Size
     info.triangles.verts = vertexData;
     info.triangles.indexCount = static_cast<int>(indexCount);
     info.triangles.indices = indexData;
-    info.rect = Rect(0, 0, spriteSize.width, spriteSize.height);
+    info.setRect(Rect(0, 0, spriteSize.width, spriteSize.height));
 }
 
-void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Texture2D* texture)
+void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Texture2D* texture, const std::string &plist)
 {
     /*
     Supported Zwoptex Formats:
@@ -163,34 +136,35 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Textu
     Size textureSize;
 
     // get the format
-    if (dictionary.find("metadata") != dictionary.end())
+    auto metaItr = dictionary.find("metadata");
+    if (metaItr != dictionary.end())
     {
-        ValueMap& metadataDict = dictionary["metadata"].asValueMap();
+        ValueMap& metadataDict = metaItr->second.asValueMap();
         format = metadataDict["format"].asInt();
 
-        if (metadataDict.find("size") != metadataDict.end())
+        if(metadataDict.find("size") != metadataDict.end())
         {
             textureSize = SizeFromString(metadataDict["size"].asString());
         }
     }
 
     // check the format
-    CCASSERT(format >= 0 && format <= 3, "format is not supported for SpriteFrameCache addSpriteFramesWithDictionary:textureFilename:");
+    CCASSERT(format >=0 && format <= 3, "format is not supported for SpriteFrameCache addSpriteFramesWithDictionary:textureFilename:");
 
     auto textureFileName = Director::getInstance()->getTextureCache()->getTextureFilePath(texture);
     Image* image = nullptr;
     NinePatchImageParser parser;
-    for (auto iter = framesDict.begin(); iter != framesDict.end(); ++iter)
+    for (auto& iter : framesDict)
     {
-        ValueMap& frameDict = iter->second.asValueMap();
-        std::string spriteFrameName = iter->first;
-        SpriteFrame* spriteFrame = _spriteFrames.at(spriteFrameName);
+        ValueMap& frameDict = iter.second.asValueMap();
+        std::string spriteFrameName = iter.first;
+        SpriteFrame* spriteFrame = _spriteFramesCache.at(spriteFrameName);
         if (spriteFrame)
         {
             continue;
         }
-
-        if (format == 0)
+        
+        if(format == 0) 
         {
             float x = frameDict["x"].asFloat();
             float y = frameDict["y"].asFloat();
@@ -201,7 +175,7 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Textu
             int ow = frameDict["originalWidth"].asInt();
             int oh = frameDict["originalHeight"].asInt();
             // check ow/oh
-            if (!ow || !oh)
+            if(!ow || !oh)
             {
                 CCLOGWARN("cocos2d: WARNING: originalWidth/Height not found on the SpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist");
             }
@@ -209,9 +183,14 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Textu
             ow = std::abs(ow);
             oh = std::abs(oh);
             // create frame
-            spriteFrame = SpriteFrame::createWithTexture(texture, Rect(x, y, w, h), false, Vec2(ox, oy), Size(static_cast<float>(ow), static_cast<float>(oh)));
-        }
-        else if (format == 1 || format == 2)
+            spriteFrame = SpriteFrame::createWithTexture(texture,
+                                                         Rect(x, y, w, h),
+                                                         false,
+                                                         Vec2(ox, oy),
+                                                         Size((float)ow, (float)oh)
+                                                         );
+        } 
+        else if(format == 1 || format == 2) 
         {
             Rect frame = RectFromString(frameDict["frame"].asString());
             bool rotated = false;
@@ -226,8 +205,13 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Textu
             Size sourceSize = SizeFromString(frameDict["sourceSize"].asString());
 
             // create frame
-            spriteFrame = SpriteFrame::createWithTexture(texture, frame, rotated, offset, sourceSize);
-        }
+            spriteFrame = SpriteFrame::createWithTexture(texture,
+                                                         frame,
+                                                         rotated,
+                                                         offset,
+                                                         sourceSize
+                                                         );
+        } 
         else if (format == 3)
         {
             // get values
@@ -240,8 +224,7 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Textu
             // get aliases
             ValueVector& aliases = frameDict["aliases"].asValueVector();
 
-            for (const auto& value : aliases)
-            {
+            for(const auto &value : aliases) {
                 std::string oneAlias = value.asString();
                 if (_spriteFramesAliases.find(oneAlias) != _spriteFramesAliases.end())
                 {
@@ -252,17 +235,18 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Textu
             }
 
             // create frame
-            spriteFrame = SpriteFrame::createWithTexture(texture, Rect(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
-                                                         textureRotated, spriteOffset, spriteSourceSize);
+            spriteFrame = SpriteFrame::createWithTexture(texture,
+                                                         Rect(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
+                                                         textureRotated,
+                                                         spriteOffset,
+                                                         spriteSourceSize);
 
-            if (frameDict.find("vertices") != frameDict.end())
+            if(frameDict.find("vertices") != frameDict.end())
             {
-                std::vector<int> vertices;
-                parseIntegerList(frameDict["vertices"].asString(), vertices);
-                std::vector<int> verticesUV;
-                parseIntegerList(frameDict["verticesUV"].asString(), verticesUV);
-                std::vector<int> indices;
-                parseIntegerList(frameDict["triangles"].asString(), indices);
+                using cocos2d::ccutils::parseIntegerList;
+                std::vector<int> vertices = parseIntegerList(frameDict["vertices"].asString());
+                std::vector<int> verticesUV = parseIntegerList(frameDict["verticesUV"].asString());
+                std::vector<int> indices = parseIntegerList(frameDict["triangles"].asString());
 
                 PolygonInfo info;
                 initializePolygonInfo(textureSize, spriteSourceSize, vertices, verticesUV, indices, info);
@@ -275,10 +259,9 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Textu
         }
 
         bool flag = NinePatchImageParser::isNinePatchImage(spriteFrameName);
-        if (flag)
+        if(flag)
         {
-            if (image == nullptr)
-            {
+            if (image == nullptr) {
                 image = new (std::nothrow) Image();
                 image->initWithImageFile(textureFileName);
             }
@@ -286,12 +269,13 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dictionary, Textu
             texture->addSpriteFrameCapInset(spriteFrame, parser.parseCapInset());
         }
         // add sprite frame
-        _spriteFrames.insert(spriteFrameName, spriteFrame);
+        _spriteFramesCache.insertFrame(plist, spriteFrameName, spriteFrame);
     }
+    _spriteFramesCache.markPlistFull(plist, true);
     CC_SAFE_DELETE(image);
 }
 
-void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dict, const std::string& texturePath)
+void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dict, const std::string &texturePath, const std::string &plist)
 {
     std::string pixelFormatName;
     if (dict.find("metadata") != dict.end())
@@ -302,27 +286,28 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dict, const std::
             pixelFormatName = metadataDict.at("pixelFormat").asString();
         }
     }
-
-    Texture2D* texture = nullptr;
-    static std::unordered_map<std::string, Texture2D::PixelFormat> pixelFormats = {{"RGBA8888", Texture2D::PixelFormat::RGBA8888},
-                                                                                   {"RGBA4444", Texture2D::PixelFormat::RGBA4444},
-                                                                                   {"RGB5A1", Texture2D::PixelFormat::RGB5A1},
-                                                                                   {"RGBA5551", Texture2D::PixelFormat::RGB5A1},
-                                                                                   {"RGB565", Texture2D::PixelFormat::RGB565},
-                                                                                   {"A8", Texture2D::PixelFormat::A8},
-                                                                                   {"ALPHA", Texture2D::PixelFormat::A8},
-                                                                                   {"I8", Texture2D::PixelFormat::I8},
-                                                                                   {"AI88", Texture2D::PixelFormat::AI88},
-                                                                                   {"ALPHA_INTENSITY", Texture2D::PixelFormat::AI88},
-                                                                                   //{"BGRA8888", Texture2D::PixelFormat::BGRA8888}, no Image conversion RGBA ->
-                                                                                   // BGRA
-                                                                                   {"RGB888", Texture2D::PixelFormat::RGB888}};
+    
+    Texture2D *texture = nullptr;
+    static std::unordered_map<std::string, backend::PixelFormat> pixelFormats = {
+        {"RGBA8888", backend::PixelFormat::RGBA8888},
+        {"RGBA4444", backend::PixelFormat::RGBA4444},
+        {"RGB5A1", backend::PixelFormat::RGB5A1},
+        {"RGBA5551", backend::PixelFormat::RGB5A1},
+        {"RGB565", backend::PixelFormat::RGB565},
+        {"A8", backend::PixelFormat::A8},
+        {"ALPHA", backend::PixelFormat::A8},
+        {"I8", backend::PixelFormat::I8},
+        {"AI88", backend::PixelFormat::AI88},
+        {"ALPHA_INTENSITY", backend::PixelFormat::AI88},
+        //{"BGRA8888", backend::PixelFormat::BGRA8888}, no Image conversion RGBA -> BGRA
+        {"RGB888", backend::PixelFormat::RGB888}
+    };
 
     auto pixelFormatIt = pixelFormats.find(pixelFormatName);
     if (pixelFormatIt != pixelFormats.end())
     {
-        const Texture2D::PixelFormat pixelFormat = (*pixelFormatIt).second;
-        const Texture2D::PixelFormat currentPixelFormat = Texture2D::getDefaultAlphaPixelFormat();
+        const backend::PixelFormat pixelFormat = (*pixelFormatIt).second;
+        const backend::PixelFormat currentPixelFormat = Texture2D::getDefaultAlphaPixelFormat();
         Texture2D::setDefaultAlphaPixelFormat(pixelFormat);
         texture = Director::getInstance()->getTextureCache()->addImage(texturePath);
         Texture2D::setDefaultAlphaPixelFormat(currentPixelFormat);
@@ -331,10 +316,10 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dict, const std::
     {
         texture = Director::getInstance()->getTextureCache()->addImage(texturePath);
     }
-
+    
     if (texture)
     {
-        addSpriteFramesWithDictionary(dict, texture);
+        addSpriteFramesWithDictionary(dict, texture, plist);
     }
     else
     {
@@ -342,160 +327,131 @@ void SpriteFrameCache::addSpriteFramesWithDictionary(ValueMap& dict, const std::
     }
 }
 
-void SpriteFrameCache::addSpriteFramesWithFile(const std::string& plist, Texture2D* texture)
+void SpriteFrameCache::addSpriteFramesWithFile(const std::string& plist, Texture2D *texture)
 {
-    if (_loadedFileNames->find(plist) != _loadedFileNames->end())
-    {
-        return; // We already added it
-    }
-
     std::string fullPath = FileUtils::getInstance()->fullPathForFilename(plist);
     ValueMap dict = FileUtils::getInstance()->getValueMapFromFile(fullPath);
 
-    addSpriteFramesWithDictionary(dict, texture);
-    _loadedFileNames->insert(plist);
+    addSpriteFramesWithDictionary(dict, texture, plist);
 }
 
-void SpriteFrameCache::addSpriteFramesWithFileContent(const std::string& plist_content, Texture2D* texture)
+void SpriteFrameCache::addSpriteFramesWithFileContent(const std::string& plist_content, Texture2D *texture)
 {
     ValueMap dict = FileUtils::getInstance()->getValueMapFromData(plist_content.c_str(), static_cast<int>(plist_content.size()));
-    addSpriteFramesWithDictionary(dict, texture);
+    addSpriteFramesWithDictionary(dict, texture, "by#addSpriteFramesWithFileContent()");
 }
 
 void SpriteFrameCache::addSpriteFramesWithFile(const std::string& plist, const std::string& textureFileName)
 {
-    CCASSERT(textureFileName.size() > 0, "texture name should not be null");
-    if (_loadedFileNames->find(plist) != _loadedFileNames->end())
-    {
-        return; // We already added it
-    }
-
+    CCASSERT(textureFileName.size()>0, "texture name should not be null");
     const std::string fullPath = FileUtils::getInstance()->fullPathForFilename(plist);
     ValueMap dict = FileUtils::getInstance()->getValueMapFromFile(fullPath);
-    addSpriteFramesWithDictionary(dict, textureFileName);
-    _loadedFileNames->insert(plist);
+    addSpriteFramesWithDictionary(dict, textureFileName, plist);
 }
 
 void SpriteFrameCache::addSpriteFramesWithFile(const std::string& plist)
 {
-    CCASSERT(plist.size() > 0, "plist filename should not be nullptr");
-
+    CCASSERT(!plist.empty(), "plist filename should not be nullptr");
+    
     std::string fullPath = FileUtils::getInstance()->fullPathForFilename(plist);
-    if (fullPath.size() == 0)
+    if (fullPath.empty())
     {
         // return if plist file doesn't exist
         CCLOG("cocos2d: SpriteFrameCache: can not find %s", plist.c_str());
         return;
     }
 
-    if (_loadedFileNames->find(plist) == _loadedFileNames->end())
-    {
-        ValueMap dict = FileUtils::getInstance()->getValueMapFromFile(fullPath);
+    ValueMap dict = FileUtils::getInstance()->getValueMapFromFile(fullPath);
 
-        string texturePath("");
+    string texturePath("");
 
-        if (dict.find("metadata") != dict.end())
-        {
-            ValueMap& metadataDict = dict["metadata"].asValueMap();
-            // try to read  texture file name from meta data
-            texturePath = metadataDict["textureFileName"].asString();
-        }
+    if (dict.find("metadata") != dict.end())
+    {
+        ValueMap& metadataDict = dict["metadata"].asValueMap();
+        // try to read  texture file name from meta data
+        texturePath = metadataDict["textureFileName"].asString();
+    }
 
-        if (!texturePath.empty())
-        {
-            // build texture path relative to plist file
-            texturePath = FileUtils::getInstance()->fullPathFromRelativeFile(texturePath, plist);
-        }
-        else
-        {
-            // build texture path by replacing file extension
-            texturePath = plist;
+    if (!texturePath.empty())
+    {
+        // build texture path relative to plist file
+        texturePath = FileUtils::getInstance()->fullPathFromRelativeFile(texturePath, plist);
+    }
+    else
+    {
+        // build texture path by replacing file extension
+        texturePath = plist;
 
-            // remove .xxx
-            size_t startPos = texturePath.find_last_of(".");
-            texturePath = texturePath.erase(startPos);
+        // remove .xxx
+        size_t startPos = texturePath.find_last_of('.'); 
+        texturePath = texturePath.erase(startPos);
 
-            // append .png
-            texturePath = texturePath.append(".png");
+        // append .png
+        texturePath = texturePath.append(".png");
 
-            CCLOG("cocos2d: SpriteFrameCache: Trying to use file %s as texture", texturePath.c_str());
-        }
-        addSpriteFramesWithDictionary(dict, texturePath);
-        _loadedFileNames->insert(plist);
+        CCLOG("cocos2d: SpriteFrameCache: Trying to use file %s as texture", texturePath.c_str());
     }
+    addSpriteFramesWithDictionary(dict, texturePath, plist);
 }
 
 bool SpriteFrameCache::isSpriteFramesWithFileLoaded(const std::string& plist) const
 {
-    bool result = false;
-
-    if (_loadedFileNames->find(plist) != _loadedFileNames->end())
-    {
-        result = true;
-    }
-
-    return result;
+    return _spriteFramesCache.isPlistUsed(plist) && _spriteFramesCache.isPlistFull(plist);
 }
 
 void SpriteFrameCache::addSpriteFrame(SpriteFrame* frame, const std::string& frameName)
 {
-    _spriteFrames.insert(frameName, frame);
+    CCASSERT(frame, "frame should not be nil");
+    _spriteFramesCache.insertFrame("by#addSpriteFrame()", frameName, frame);
 }
 
 void SpriteFrameCache::removeSpriteFrames()
 {
-    _spriteFrames.clear();
     _spriteFramesAliases.clear();
-    _loadedFileNames->clear();
+    _spriteFramesCache.clear();
 }
 
 void SpriteFrameCache::removeUnusedSpriteFrames()
 {
     bool removed = false;
     std::vector<std::string> toRemoveFrames;
-
-    for (auto iter = _spriteFrames.begin(); iter != _spriteFrames.end(); ++iter)
+    
+    for (auto& iter : _spriteFramesCache.getSpriteFrames())
     {
-        SpriteFrame* spriteFrame = iter->second;
-        if (spriteFrame->getReferenceCount() == 1)
+        SpriteFrame* spriteFrame = iter.second;
+        if( spriteFrame->getReferenceCount() == 1 )
         {
-            toRemoveFrames.push_back(iter->first);
+            toRemoveFrames.push_back(iter.first);
             spriteFrame->getTexture()->removeSpriteFrameCapInset(spriteFrame);
-            CCLOG("cocos2d: SpriteFrameCache: removing unused frame: %s", iter->first.c_str());
+            CCLOG("cocos2d: SpriteFrameCache: removing unused frame: %s", iter.first.c_str());
             removed = true;
         }
     }
 
-    _spriteFrames.erase(toRemoveFrames);
-
-    // FIXME:. Since we don't know the .plist file that originated the frame, we must remove all .plist from the cache
-    if (removed)
+ 
+    if( removed )
     {
-        _loadedFileNames->clear();
+        _spriteFramesCache.eraseFrames(toRemoveFrames);
     }
 }
 
+
 void SpriteFrameCache::removeSpriteFrameByName(const std::string& name)
 {
     // explicit nil handling
-    if (!(name.size() > 0))
+    if (name.empty())
         return;
 
     // Is this an alias ?
-    std::string key = _spriteFramesAliases[name].asString();
+    bool foundAlias = _spriteFramesAliases.find(name) != _spriteFramesAliases.end();
+    std::string key = foundAlias ? _spriteFramesAliases[name].asString() : "";
 
     if (!key.empty())
     {
-        _spriteFrames.erase(key);
         _spriteFramesAliases.erase(key);
     }
-    else
-    {
-        _spriteFrames.erase(name);
-    }
 
-    // FIXME:. Since we don't know the .plist file that originated the frame, we must remove all .plist from the cache
-    _loadedFileNames->clear();
+    _spriteFramesCache.eraseFrame(name);
 }
 
 void SpriteFrameCache::removeSpriteFramesFromFile(const std::string& plist)
@@ -504,17 +460,13 @@ void SpriteFrameCache::removeSpriteFramesFromFile(const std::string& plist)
     ValueMap dict = FileUtils::getInstance()->getValueMapFromFile(fullPath);
     if (dict.empty())
     {
-        CCLOG("cocos2d:SpriteFrameCache:removeSpriteFramesFromFile: create dict by %s fail.", plist.c_str());
+        CCLOG("cocos2d:SpriteFrameCache:removeSpriteFramesFromFile: create dict by %s fail.",plist.c_str());
         return;
     }
     removeSpriteFramesFromDictionary(dict);
 
     // remove it from the cache
-    set<string>::iterator ret = _loadedFileNames->find(plist);
-    if (ret != _loadedFileNames->end())
-    {
-        _loadedFileNames->erase(ret);
-    }
+    _spriteFramesCache.erasePlistIndex(plist);
 }
 
 void SpriteFrameCache::removeSpriteFramesFromFileContent(const std::string& plist_content)
@@ -533,67 +485,64 @@ void SpriteFrameCache::removeSpriteFramesFromDictionary(ValueMap& dictionary)
     if (dictionary["frames"].getType() != cocos2d::Value::Type::MAP)
         return;
 
-    ValueMap framesDict = dictionary["frames"].asValueMap();
+    const ValueMap& framesDict = dictionary["frames"].asValueMap();
     std::vector<std::string> keysToRemove;
 
-    for (auto iter = framesDict.cbegin(); iter != framesDict.cend(); ++iter)
+    for (const auto& iter : framesDict)
     {
-        if (_spriteFrames.at(iter->first))
+        if (_spriteFramesCache.at(iter.first))
         {
-#ifdef DEBUG
-            if (_spriteFrames.at(iter->first)->getReferenceCount() > 1)
-                CCLOG("cocos2d: SpriteFrameCache: Sprite frame: \"%s\" may be leaking: it is removed from cache but reference count is %d. Note that this situation can legally happen depending on the order of destructors (eg: when you are inheriting ILazyLoaded).",
-                      iter->first.c_str(), _spriteFrames.at(iter->first)->getReferenceCount());
-#endif
-            keysToRemove.push_back(iter->first);
+            keysToRemove.push_back(iter.first);
         }
     }
 
-    _spriteFrames.erase(keysToRemove);
+    _spriteFramesCache.eraseFrames(keysToRemove);
 }
 
 void SpriteFrameCache::removeSpriteFramesFromTexture(Texture2D* texture)
 {
     std::vector<std::string> keysToRemove;
 
-    for (auto iter = _spriteFrames.cbegin(); iter != _spriteFrames.cend(); ++iter)
+    for (auto& iter : _spriteFramesCache.getSpriteFrames())
     {
-        std::string key = iter->first;
-        SpriteFrame* frame = _spriteFrames.at(key);
+        std::string key = iter.first;
+        SpriteFrame* frame = _spriteFramesCache.at(key);
         if (frame && (frame->getTexture() == texture))
         {
-#ifdef DEBUG
-            if (_spriteFrames.at(key)->getReferenceCount() > 1)
-                CCLOG("cocos2d: SpriteFrameCache: Sprite frame: \"%s\" may be leaking: it is removed from cache but reference count is %d. Note that this situation can legally happen depending on the order of destructors (eg: when you are inheriting ILazyLoaded).",
-                      key.c_str(), _spriteFrames.at(key)->getReferenceCount());
-#endif
             keysToRemove.push_back(key);
         }
     }
 
-    _spriteFrames.erase(keysToRemove);
+    _spriteFramesCache.eraseFrames(keysToRemove);
 }
 
 SpriteFrame* SpriteFrameCache::getSpriteFrameByName(const std::string& name)
 {
-    SpriteFrame* frame = _spriteFrames.at(name);
+    SpriteFrame* frame = _spriteFramesCache.at(name);
     if (!frame)
     {
         // try alias dictionary
-        std::string key = _spriteFramesAliases[name].asString();
-        if (!key.empty())
+        if (_spriteFramesAliases.find(name) != _spriteFramesAliases.end())
         {
-            frame = _spriteFrames.at(key);
-            if (!frame)
+            std::string key = _spriteFramesAliases[name].asString();
+            if (!key.empty())
             {
-                CCLOG("cocos2d: SpriteFrameCache: Frame '%s' not found", name.c_str());
+                frame = _spriteFramesCache.at(key);
+                if (!frame)
+                {
+                    CCLOG("cocos2d: SpriteFrameCache: Frame aliases '%s' isn't found", key.c_str());
+                }
             }
         }
+        else
+        {
+            CCLOG("cocos2d: SpriteFrameCache: Frame '%s' isn't found", name.c_str());
+        }
     }
     return frame;
 }
 
-void SpriteFrameCache::reloadSpriteFramesWithDictionary(ValueMap& dictionary, Texture2D* texture)
+void SpriteFrameCache::reloadSpriteFramesWithDictionary(ValueMap& dictionary, Texture2D *texture, const std::string &plist)
 {
     ValueMap& framesDict = dictionary["frames"].asValueMap();
     int format = 0;
@@ -608,16 +557,12 @@ void SpriteFrameCache::reloadSpriteFramesWithDictionary(ValueMap& dictionary, Te
     // check the format
     CCASSERT(format >= 0 && format <= 3, "format is not supported for SpriteFrameCache addSpriteFramesWithDictionary:textureFilename:");
 
-    for (auto iter = framesDict.begin(); iter != framesDict.end(); ++iter)
+    for (auto& iter : framesDict)
     {
-        ValueMap& frameDict = iter->second.asValueMap();
-        std::string spriteFrameName = iter->first;
+        ValueMap& frameDict = iter.second.asValueMap();
+        std::string spriteFrameName = iter.first;
 
-        auto it = _spriteFrames.find(spriteFrameName);
-        if (it != _spriteFrames.end())
-        {
-            _spriteFrames.erase(it);
-        }
+        _spriteFramesCache.eraseFrame(spriteFrameName);
 
         SpriteFrame* spriteFrame = nullptr;
 
@@ -640,7 +585,12 @@ void SpriteFrameCache::reloadSpriteFramesWithDictionary(ValueMap& dictionary, Te
             ow = std::abs(ow);
             oh = std::abs(oh);
             // create frame
-            spriteFrame = SpriteFrame::createWithTexture(texture, Rect(x, y, w, h), false, Vec2(ox, oy), Size(static_cast<float>(ow), static_cast<float>(oh)));
+            spriteFrame = SpriteFrame::createWithTexture(texture,
+                Rect(x, y, w, h),
+                false,
+                Vec2(ox, oy),
+                Size((float)ow, (float)oh)
+                );
         }
         else if (format == 1 || format == 2)
         {
@@ -657,7 +607,12 @@ void SpriteFrameCache::reloadSpriteFramesWithDictionary(ValueMap& dictionary, Te
             Size sourceSize = SizeFromString(frameDict["sourceSize"].asString());
 
             // create frame
-            spriteFrame = SpriteFrame::createWithTexture(texture, frame, rotated, offset, sourceSize);
+            spriteFrame = SpriteFrame::createWithTexture(texture,
+                frame,
+                rotated,
+                offset,
+                sourceSize
+                );
         }
         else if (format == 3)
         {
@@ -671,8 +626,7 @@ void SpriteFrameCache::reloadSpriteFramesWithDictionary(ValueMap& dictionary, Te
             // get aliases
             ValueVector& aliases = frameDict["aliases"].asValueVector();
 
-            for (const auto& value : aliases)
-            {
+            for (const auto &value : aliases) {
                 std::string oneAlias = value.asString();
                 if (_spriteFramesAliases.find(oneAlias) != _spriteFramesAliases.end())
                 {
@@ -683,27 +637,28 @@ void SpriteFrameCache::reloadSpriteFramesWithDictionary(ValueMap& dictionary, Te
             }
 
             // create frame
-            spriteFrame = SpriteFrame::createWithTexture(texture, Rect(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
-                                                         textureRotated, spriteOffset, spriteSourceSize);
+            spriteFrame = SpriteFrame::createWithTexture(texture,
+                Rect(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
+                textureRotated,
+                spriteOffset,
+                spriteSourceSize);
         }
 
         // add sprite frame
-        _spriteFrames.insert(spriteFrameName, spriteFrame);
+        _spriteFramesCache.insertFrame(plist, spriteFrameName, spriteFrame);
     }
 }
 
 bool SpriteFrameCache::reloadTexture(const std::string& plist)
 {
-    CCASSERT(plist.size() > 0, "plist filename should not be nullptr");
+    CCASSERT(plist.size()>0, "plist filename should not be nullptr");
 
-    auto it = _loadedFileNames->find(plist);
-    if (it != _loadedFileNames->end())
-    {
-        _loadedFileNames->erase(it);
+    if (_spriteFramesCache.isPlistUsed(plist)) {
+        _spriteFramesCache.erasePlistIndex(plist);
     }
     else
     {
-        // If one plist has't be loaded, we don't load it here.
+        //If one plist has't be loaded, we don't load it here.
         return false;
     }
 
@@ -730,21 +685,20 @@ bool SpriteFrameCache::reloadTexture(const std::string& plist)
         texturePath = plist;
 
         // remove .xxx
-        size_t startPos = texturePath.find_last_of(".");
+        size_t startPos = texturePath.find_last_of('.');
         texturePath = texturePath.erase(startPos);
 
         // append .png
         texturePath = texturePath.append(".png");
     }
 
-    Texture2D* texture = nullptr;
+    Texture2D *texture = nullptr;
     if (Director::getInstance()->getTextureCache()->reloadTexture(texturePath))
         texture = Director::getInstance()->getTextureCache()->getTextureForKey(texturePath);
 
     if (texture)
     {
-        reloadSpriteFramesWithDictionary(dict, texture);
-        _loadedFileNames->insert(plist);
+        reloadSpriteFramesWithDictionary(dict, texture, plist);
     }
     else
     {
@@ -753,4 +707,90 @@ bool SpriteFrameCache::reloadTexture(const std::string& plist)
     return true;
 }
 
+
+void SpriteFrameCache::PlistFramesCache::insertFrame(const std::string &plist, const std::string &frame, SpriteFrame *spriteFrame)
+{
+    _spriteFrames.insert(frame, spriteFrame);   //add SpriteFrame
+
+    _indexPlist2Frames[plist].insert(frame);    //insert index plist->[frameName]
+    _indexFrame2plist[frame] = plist;           //insert index frameName->plist
+}
+
+bool SpriteFrameCache::PlistFramesCache::eraseFrame(const std::string &frame)
+{
+    _spriteFrames.erase(frame);                             //drop SpriteFrame
+    auto itFrame = _indexFrame2plist.find(frame);
+    if (itFrame != _indexFrame2plist.end())
+    {
+        auto plist = itFrame->second;
+        markPlistFull(plist, false);
+        _indexPlist2Frames[plist].erase(frame);             //update index plist->[frameNames]
+        _indexFrame2plist.erase(itFrame);                   //update index frame->plist
+        // erase plist index if all frames was erased
+        if (_indexFrame2plist.empty())
+        {
+            _indexPlist2Frames.erase(plist);
+        }
+        return true;
+    }
+    return false;
+}
+
+bool SpriteFrameCache::PlistFramesCache::eraseFrames(const std::vector<std::string> &frames)
+{
+    auto ret = false;
+    for (const auto & frame : frames)
+    {
+        ret |= eraseFrame(frame);
+    }
+    _indexPlist2Frames.clear();
+    _indexFrame2plist.clear();
+    return ret;
+}
+
+bool SpriteFrameCache::PlistFramesCache::erasePlistIndex(const std::string &plist)
+{
+    auto it = _indexPlist2Frames.find(plist);
+    if (it == _indexPlist2Frames.end()) return false;
+
+    auto &frames = it->second;
+    for (const auto& f : frames)
+    {
+        // !!do not!! call `_spriteFrames.erase(f);` to erase SpriteFrame
+        // only erase index here
+        _indexFrame2plist.erase(f);                             //erase plist frame frameName->plist
+    }
+    _indexPlist2Frames.erase(plist);                            //update index plist->[frameNames]
+    _isPlistFull.erase(plist);                                  //erase full status
+    return true;
+}
+
+void SpriteFrameCache::PlistFramesCache::clear()
+{
+    _indexPlist2Frames.clear();
+    _indexFrame2plist.clear();
+    _spriteFrames.clear();
+    _isPlistFull.clear();
+}
+
+bool SpriteFrameCache::PlistFramesCache::hasFrame(const std::string &frame) const
+{
+    return _indexFrame2plist.find(frame) != _indexFrame2plist.end();
+}
+
+bool SpriteFrameCache::PlistFramesCache::isPlistUsed(const std::string &plist) const
+{
+    auto frames = _indexPlist2Frames.find(plist);
+    return frames != _indexPlist2Frames.end() && frames->second.size() > 0;
+} 
+
+SpriteFrame * SpriteFrameCache::PlistFramesCache::at(const std::string &frame)
+{
+    return _spriteFrames.at(frame);
+}
+Map<std::string, SpriteFrame*>&  SpriteFrameCache::PlistFramesCache::getSpriteFrames()
+{
+    return _spriteFrames;
+}
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCSpriteFrameCache.h b/cocos2d/cocos/2d/CCSpriteFrameCache.h
index ba41255edd..02a5f7be4e 100644
--- a/cocos2d/cocos/2d/CCSpriteFrameCache.h
+++ b/cocos2d/cocos/2d/CCSpriteFrameCache.h
@@ -5,6 +5,7 @@ Copyright (c) 2009      Robert J Payne
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -27,24 +28,20 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_SPRITEFRAMECACHE_H
-#define CC_2D_SPRITEFRAMECACHE_H
+#ifndef __SPRITE_CCSPRITE_FRAME_CACHE_H__
+#define __SPRITE_CCSPRITE_FRAME_CACHE_H__
 
-#include <cocos/base/CCMap.h>
-#include <cocos/base/CCRef.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
 #include <set>
+#include <unordered_map>
 #include <string>
-#include <vector>
+#include <cocos/2d/CCSpriteFrame.h>
+#include <cocos/base/CCRef.h>
+#include <cocos/base/CCValue.h>
+#include <cocos/base/CCMap.h>
 
 NS_CC_BEGIN
 
-class SpriteFrame;
+class Sprite;
 class Texture2D;
 class PolygonInfo;
 
@@ -59,7 +56,7 @@ class PolygonInfo;
  The SpriteFrameCache loads SpriteFrames from a .plist file.
  A SpriteFrame contains information about how to use a sprite
  located in a sprite sheet.
-
+ 
  The .plist file contains the following elements:
 
  - `frames`:
@@ -75,22 +72,68 @@ class PolygonInfo;
     - `triangles`:        3 indices per triangle, pointing to vertices and verticesUV coordinates
     - `vertices`:         vertices in sprite coordinates, each vertex consists of a pair of x and y coordinates
     - `verticesUV`:       vertices in the sprite sheet, each vertex consists of a pair of x and y coordinates
-
+ 
  - `metadata`:
    Dictionary containing additional information about the sprite sheet:
      - `format`:          plist file format, currently 3
      - `size`:            size of the texture (optional)
      - `textureFileName`: name of the texture's image file
-
+ 
  Use one of the following tools to create the .plist file and sprite sheet:
  - [TexturePacker](https://www.codeandweb.com/texturepacker/cocos2d)
  - [Zwoptex](https://zwopple.com/zwoptex/)
-
+ 
  @since v0.9
  @js cc.spriteFrameCache
  */
 class CC_DLL SpriteFrameCache : public Ref
 {
+protected:
+    /**
+    * used to wrap plist & frame names & SpriteFrames
+    */
+    class PlistFramesCache {
+    public:
+        PlistFramesCache() { }
+        void init() {
+            _spriteFrames.reserve(20); clear();
+        }
+        /**  Record SpriteFrame with plist and frame name, add frame name 
+        *    and plist to index
+        */
+        void insertFrame(const std::string &plist, const std::string &frame, SpriteFrame *frameObj);
+        /** Delete frame from cache, rebuild index
+        */
+        bool eraseFrame(const std::string &frame);
+        /** Delete a list of frames from cache, rebuild index
+        */
+        bool eraseFrames(const std::vector<std::string> &frame);
+        /** Delete frame from index and SpriteFrame is kept.
+        */
+        bool erasePlistIndex(const std::string &frame);
+        /** Clear index and all SpriteFrames.
+        */
+        void clear();
+
+        inline bool hasFrame(const std::string &frame) const;
+        inline bool isPlistUsed(const std::string &plist) const;
+
+        inline SpriteFrame *at(const std::string &frame);
+        inline Map<std::string, SpriteFrame*>& getSpriteFrames();
+
+        void markPlistFull(const std::string &plist, bool full) { _isPlistFull[plist] = full; }
+        bool isPlistFull(const std::string &plist) const
+        {
+            auto it = _isPlistFull.find(plist);
+            return it == _isPlistFull.end() ? false : it->second;
+        }
+    private:
+        Map<std::string, SpriteFrame*> _spriteFrames;
+        std::unordered_map<std::string, std::set<std::string>> _indexPlist2Frames;
+        std::unordered_map<std::string, std::string> _indexFrame2plist;
+        std::unordered_map<std::string, bool> _isPlistFull;
+    };
+
 public:
     /** Returns the shared instance of the Sprite Frame cache.
      *
@@ -99,27 +142,17 @@ public:
      */
     static SpriteFrameCache* getInstance();
 
-    /** @deprecated Use getInstance() instead
-     @js NA
-    */
-    CC_DEPRECATED_ATTRIBUTE static SpriteFrameCache* sharedSpriteFrameCache() { return SpriteFrameCache::getInstance(); }
-
     /** Destroys the cache. It releases all the Sprite Frames and the retained instance.
-     * @js NA
+	 * @js NA
      */
     static void destroyInstance();
 
-    /** @deprecated Use destroyInstance() instead
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE static void purgeSharedSpriteFrameCache() { return SpriteFrameCache::destroyInstance(); }
-
     /** Destructor.
      * @js NA
      * @lua NA
      */
     virtual ~SpriteFrameCache();
-
+    
     /** Initialize method.
      *
      * @return if success return true.
@@ -146,23 +179,23 @@ public:
      */
     void addSpriteFramesWithFile(const std::string& plist, const std::string& textureFileName);
 
-    /** Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames.
+    /** Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames. 
      * @js addSpriteFrames
      * @lua addSpriteFrames
      *
      * @param plist Plist file name.
      * @param texture Texture pointer.
      */
-    void addSpriteFramesWithFile(const std::string& plist, Texture2D* texture);
+    void addSpriteFramesWithFile(const std::string&plist, Texture2D *texture);
 
-    /** Adds multiple Sprite Frames from a plist file content. The texture will be associated with the created sprite frames.
+    /** Adds multiple Sprite Frames from a plist file content. The texture will be associated with the created sprite frames. 
      * @js NA
      * @lua addSpriteFrames
      *
      * @param plist_content Plist file content string.
      * @param texture Texture pointer.
      */
-    void addSpriteFramesWithFileContent(const std::string& plist_content, Texture2D* texture);
+    void addSpriteFramesWithFileContent(const std::string& plist_content, Texture2D *texture);
 
     /** Adds an sprite frame with a given name.
      If the name already exists, then the contents of the old name will be replaced with the new one.
@@ -170,15 +203,15 @@ public:
      * @param frame A certain sprite frame.
      * @param frameName The name of the sprite frame.
      */
-    void addSpriteFrame(SpriteFrame* frame, const std::string& frameName);
+    void addSpriteFrame(SpriteFrame *frame, const std::string& frameName);
 
     /** Check if multiple Sprite Frames from a plist file have been loaded.
-     * @js NA
-     * @lua NA
-     *
-     * @param plist Plist file name.
-     * @return True if the file is loaded.
-     */
+    * @js NA
+    * @lua NA
+    *
+    * @param plist Plist file name.
+    * @return True if the file is loaded.
+    */
     bool isSpriteFramesWithFileLoaded(const std::string& plist) const;
 
     /** Purges the dictionary of loaded sprite frames.
@@ -192,32 +225,32 @@ public:
     /** Removes unused sprite frames.
      * Sprite Frames that have a retain count of 1 will be deleted.
      * It is convenient to call this method after when starting a new Scene.
-     * @js NA
+	 * @js NA
      */
     void removeUnusedSpriteFrames();
 
-    /** Deletes an sprite frame from the sprite frame cache.
+    /** Deletes an sprite frame from the sprite frame cache. 
      *
      * @param name The name of the sprite frame that needs to removed.
      */
     void removeSpriteFrameByName(const std::string& name);
 
     /** Removes multiple Sprite Frames from a plist file.
-     * Sprite Frames stored in this file will be removed.
-     * It is convenient to call this method when a specific texture needs to be removed.
-     * @since v0.99.5
-     *
-     * @param plist The name of the plist that needs to removed.
-     */
+    * Sprite Frames stored in this file will be removed.
+    * It is convenient to call this method when a specific texture needs to be removed.
+    * @since v0.99.5
+    *
+    * @param plist The name of the plist that needs to removed.
+    */
     void removeSpriteFramesFromFile(const std::string& plist);
 
     /** Removes multiple Sprite Frames from a plist file content.
-     * Sprite Frames stored in this file will be removed.
-     * It is convenient to call this method when a specific texture needs to be removed.
-     *
-     * @param plist_content The string of the plist content that needs to removed.
-     * @js NA
-     */
+    * Sprite Frames stored in this file will be removed.
+    * It is convenient to call this method when a specific texture needs to be removed.
+    *
+    * @param plist_content The string of the plist content that needs to removed.
+    * @js NA
+    */
     void removeSpriteFramesFromFileContent(const std::string& plist_content);
 
     /** Removes all Sprite Frames associated with the specified textures.
@@ -239,40 +272,37 @@ public:
      */
     SpriteFrame* getSpriteFrameByName(const std::string& name);
 
-    /** @deprecated use getSpriteFrameByName() instead */
-    CC_DEPRECATED_ATTRIBUTE SpriteFrame* spriteFrameByName(const std::string& name) { return getSpriteFrameByName(name); }
-
     bool reloadTexture(const std::string& plist);
 
 protected:
     // MARMALADE: Made this protected not private, as deriving from this class is pretty useful
-    SpriteFrameCache() {}
+    SpriteFrameCache(){}
 
     /*Adds multiple Sprite Frames with a dictionary. The texture will be associated with the created sprite frames.
      */
-    void addSpriteFramesWithDictionary(ValueMap& dictionary, Texture2D* texture);
-
+    void addSpriteFramesWithDictionary(ValueMap& dictionary, Texture2D *texture, const std::string &plist);
+    
     /*Adds multiple Sprite Frames with a dictionary. The texture will be associated with the created sprite frames.
      */
-    void addSpriteFramesWithDictionary(ValueMap& dictionary, const std::string& texturePath);
-
+    void addSpriteFramesWithDictionary(ValueMap& dictionary, const std::string &texturePath, const std::string &plist);
+    
     /** Removes multiple Sprite Frames from Dictionary.
-     * @since v0.99.5
-     */
+    * @since v0.99.5
+    */
     void removeSpriteFramesFromDictionary(ValueMap& dictionary);
 
-    /** Parses list of space-separated integers */
-    void parseIntegerList(const std::string& string, std::vector<int>& res);
-
     /** Configures PolygonInfo class with the passed sizes + triangles */
-    void initializePolygonInfo(const Size& textureSize, const Size& spriteSize, const std::vector<int>& vertices, const std::vector<int>& verticesUV,
-                               const std::vector<int>& triangleIndices, PolygonInfo& polygonInfo);
+    void initializePolygonInfo(const Size &textureSize,
+                               const Size &spriteSize,
+                               const std::vector<int> &vertices,
+                               const std::vector<int> &verticesUV,
+                               const std::vector<int> &triangleIndices,
+                               PolygonInfo &polygonInfo);
 
-    void reloadSpriteFramesWithDictionary(ValueMap& dictionary, Texture2D* texture);
+    void reloadSpriteFramesWithDictionary(ValueMap& dictionary, Texture2D *texture, const std::string &plist);
 
-    Map<std::string, SpriteFrame*> _spriteFrames;
     ValueMap _spriteFramesAliases;
-    std::set<std::string>* _loadedFileNames;
+    PlistFramesCache _spriteFramesCache;
 };
 
 // end of _2d group
@@ -280,4 +310,4 @@ protected:
 
 NS_CC_END
 
-#endif // CC_2D_SPRITEFRAMECACHE_H
+#endif // __SPRITE_CCSPRITE_FRAME_CACHE_H__
diff --git a/cocos2d/cocos/2d/CCTMXLayer.cpp b/cocos2d/cocos/2d/CCTMXLayer.cpp
index e58a1382ab..8a9b75cf97 100644
--- a/cocos2d/cocos/2d/CCTMXLayer.cpp
+++ b/cocos2d/cocos/2d/CCTMXLayer.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -26,42 +27,23 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCTMXLayer.h>
-
-#include <cocos/2d/CCSprite.h>
-#include <cocos/2d/CCSpriteBatchNode.h>
 #include <cocos/2d/CCTMXTiledMap.h>
-#include <cocos/2d/CCTMXXMLParser.h>
+#include <cocos/2d/CCSprite.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccCArray.h>
-#include <cocos/base/ccMacros.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCGL.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCGLProgram.h>
-#include <cocos/renderer/CCGLProgramState.h>
-#include <cocos/renderer/CCTexture2D.h>
-#include <cocos/renderer/CCTextureAtlas.h>
 #include <cocos/renderer/CCTextureCache.h>
-
-#include <cmath>
-#include <cstdlib>
-#include <new>
-#include <string>
-#include <unordered_map>
+#include <cocos/renderer/ccShaders.h>
+#include <cocos/renderer/backend/Program.h>
+#include <cocos/renderer/backend/ProgramState.h>
 
 NS_CC_BEGIN
 
-class Node;
 
 // TMXLayer - init & alloc & dealloc
 
-TMXLayer* TMXLayer::create(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
+TMXLayer * TMXLayer::create(TMXTilesetInfo *tilesetInfo, TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo)
 {
-    TMXLayer* ret = new (std::nothrow) TMXLayer();
+    TMXLayer *ret = new (std::nothrow) TMXLayer();
     if (ret->initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo))
     {
         ret->autorelease();
@@ -70,15 +52,15 @@ TMXLayer* TMXLayer::create(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo,
     CC_SAFE_DELETE(ret);
     return nullptr;
 }
-bool TMXLayer::initWithTilesetInfo(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
-{
+bool TMXLayer::initWithTilesetInfo(TMXTilesetInfo *tilesetInfo, TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo)
+{    
     // FIXME:: is 35% a good estimate ?
     Size size = layerInfo->_layerSize;
     float totalNumberOfTiles = size.width * size.height;
     float capacity = totalNumberOfTiles * 0.35f + 1; // 35 percent is occupied ?
 
-    Texture2D* texture = nullptr;
-    if (tilesetInfo)
+    Texture2D *texture = nullptr;
+    if( tilesetInfo )
     {
         texture = Director::getInstance()->getTextureCache()->addImage(tilesetInfo->_sourceImage);
     }
@@ -86,7 +68,7 @@ bool TMXLayer::initWithTilesetInfo(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* la
     if (nullptr == texture)
         return false;
 
-    if (SpriteBatchNode::initWithTexture(texture, static_cast<std::size_t>(capacity)))
+    if (SpriteBatchNode::initWithTexture(texture, static_cast<ssize_t>(capacity)))
     {
         // layerInfo
         _layerName = layerInfo->_name;
@@ -94,7 +76,7 @@ bool TMXLayer::initWithTilesetInfo(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* la
         _tiles = layerInfo->_tiles;
         _opacity = layerInfo->_opacity;
         setProperties(layerInfo->getProperties());
-        _contentScaleFactor = Director::getInstance()->getContentScaleFactor();
+        _contentScaleFactor = Director::getInstance()->getContentScaleFactor(); 
 
         // tilesetInfo
         _tileSet = tilesetInfo;
@@ -115,21 +97,15 @@ bool TMXLayer::initWithTilesetInfo(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* la
 
         float width = 0;
         float height = 0;
-        if (_layerOrientation == TMXOrientationHex)
-        {
-            if (_staggerAxis == TMXStaggerAxis_X)
-            {
+        if (_layerOrientation == TMXOrientationHex) {
+            if (_staggerAxis == TMXStaggerAxis_X) {
                 height = _mapTileSize.height * (_layerSize.height + 0.5);
                 width = (_mapTileSize.width + _hexSideLength) * ((int)(_layerSize.width / 2)) + _mapTileSize.width * ((int)_layerSize.width % 2);
-            }
-            else
-            {
+            } else {
                 width = _mapTileSize.width * (_layerSize.width + 0.5);
                 height = (_mapTileSize.height + _hexSideLength) * ((int)(_layerSize.height / 2)) + _mapTileSize.height * ((int)_layerSize.height % 2);
             }
-        }
-        else
-        {
+        } else {
             width = _layerSize.width * _mapTileSize.width;
             height = _layerSize.height * _mapTileSize.height;
         }
@@ -137,30 +113,29 @@ bool TMXLayer::initWithTilesetInfo(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* la
 
         _useAutomaticVertexZ = false;
         _vertexZvalue = 0;
-
+        
         return true;
     }
     return false;
 }
 
 TMXLayer::TMXLayer()
-: _layerName("")
-, _opacity(0)
-, _vertexZvalue(0)
-, _useAutomaticVertexZ(false)
-, _reusedTile(nullptr)
-, _atlasIndexArray(nullptr)
-, _contentScaleFactor(1.0f)
-, _layerSize(Size::ZERO)
-, _mapTileSize(Size::ZERO)
-, _tiles(nullptr)
-, _tileSet(nullptr)
-, _layerOrientation(TMXOrientationOrtho)
-, _staggerAxis(TMXStaggerAxis_Y)
-, _staggerIndex(TMXStaggerIndex_Even)
-, _hexSideLength(0)
-{
-}
+:_layerName("")
+,_opacity(0)
+,_vertexZvalue(0)
+,_useAutomaticVertexZ(false)
+,_reusedTile(nullptr)
+,_atlasIndexArray(nullptr)
+,_contentScaleFactor(1.0f)
+,_layerSize(Size::ZERO)
+,_mapTileSize(Size::ZERO)
+,_tiles(nullptr)
+,_tileSet(nullptr)
+,_layerOrientation(TMXOrientationOrtho)
+,_staggerAxis(TMXStaggerAxis_Y)
+,_staggerIndex(TMXStaggerIndex_Even)
+,_hexSideLength(0)
+{}
 
 TMXLayer::~TMXLayer()
 {
@@ -173,7 +148,7 @@ TMXLayer::~TMXLayer()
         _atlasIndexArray = nullptr;
     }
 
-    CC_SAFE_FREE(_tiles);
+    CC_SAFE_DELETE_ARRAY(_tiles);;
 }
 
 void TMXLayer::releaseMap()
@@ -193,7 +168,7 @@ void TMXLayer::releaseMap()
 
 // TMXLayer - setup Tiles
 void TMXLayer::setupTiles()
-{
+{    
     // Optimization: quick hack that sets the image size on the tileset
     _tileSet->_imageSize = _textureAtlas->getTexture()->getContentSizeInPixels();
 
@@ -204,14 +179,14 @@ void TMXLayer::setupTiles()
     //  - difficult to scale / rotate / etc.
     _textureAtlas->getTexture()->setAliasTexParameters();
 
-    // CFByteOrder o = CFByteOrderGetCurrent();
+    //CFByteOrder o = CFByteOrderGetCurrent();
 
     // Parse cocos2d properties
     this->parseInternalProperties();
 
-    for (int y = 0; y < _layerSize.height; y++)
+    for (int y=0; y < _layerSize.height; y++)
     {
-        for (int x = 0; x < _layerSize.width; x++)
+        for (int x=0; x < _layerSize.width; x++)
         {
             int newX = x;
             // fix correct render ordering in Hexagonal maps when stagger axis == x
@@ -219,32 +194,30 @@ void TMXLayer::setupTiles()
             {
                 if (_staggerIndex == TMXStaggerIndex_Odd)
                 {
-                    if (x >= _layerSize.width / 2)
-                        newX = (x - std::ceil(_layerSize.width / 2)) * 2 + 1;
+                    if (x >= _layerSize.width/2)
+                        newX = (x - std::ceil(_layerSize.width/2)) * 2 + 1;
                     else
                         newX = x * 2;
-                }
-                else
-                {
+                } else {
                     // TMXStaggerIndex_Even
-                    if (x >= static_cast<int>(_layerSize.width / 2))
-                        newX = (x - static_cast<int>(_layerSize.width / 2)) * 2;
+                    if (x >= static_cast<int>(_layerSize.width/2))
+                        newX = (x - static_cast<int>(_layerSize.width/2)) * 2;
                     else
                         newX = x * 2 + 1;
                 }
             }
 
             int pos = static_cast<int>(newX + _layerSize.width * y);
-            int gid = _tiles[pos];
+            int gid = _tiles[ pos ];
 
             // gid are stored in little endian.
             // if host is big endian, then swap
-            // if( o == CFByteOrderBigEndian )
+            //if( o == CFByteOrderBigEndian )
             //    gid = CFSwapInt32( gid );
             /* We support little endian.*/
 
             // FIXME:: gid == 0 --> empty tile
-            if (gid != 0)
+            if (gid != 0) 
             {
                 this->appendTileForGID(gid, Vec2(newX, y));
             }
@@ -257,7 +230,7 @@ Value TMXLayer::getProperty(const std::string& propertyName) const
 {
     if (_properties.find(propertyName) != _properties.end())
         return _properties.at(propertyName);
-
+    
     return Value();
 }
 
@@ -275,16 +248,12 @@ void TMXLayer::parseInternalProperties()
             _useAutomaticVertexZ = true;
             auto alphaFuncVal = getProperty("cc_alpha_func");
             float alphaFuncValue = alphaFuncVal.asFloat();
-            setGLProgramState(GLProgramState::getOrCreateWithGLProgramName(GLProgram::SHADER_NAME_POSITION_TEXTURE_ALPHA_TEST));
 
-            GLint alphaValueLocation = glGetUniformLocation(getGLProgram()->getProgram(), GLProgram::UNIFORM_NAME_ALPHA_TEST_VALUE);
-
-            // NOTE: alpha test shader is hard-coded to use the equivalent of a glAlphaFunc(GL_GREATER) comparison
-
-            // use shader program to set uniform
-            getGLProgram()->use();
-            getGLProgram()->setUniformLocationWith1f(alphaValueLocation, alphaFuncValue);
-            CHECK_GL_ERROR_DEBUG();
+            auto& pipelineDescriptor = _quadCommand.getPipelineDescriptor();
+            auto& vertexShader = pipelineDescriptor.programState->getProgram()->getVertexShader();
+            updateShaders(vertexShader, positionTextureColorAlphaTest_frag);
+            auto alphaValueLocation = pipelineDescriptor.programState->getUniformLocation("u_alpha_value");
+            pipelineDescriptor.programState->setUniform(alphaValueLocation, &alphaFuncValue, sizeof(alphaFuncValue));
         }
         else
         {
@@ -293,27 +262,28 @@ void TMXLayer::parseInternalProperties()
     }
 }
 
-void TMXLayer::setupTileSprite(Sprite* sprite, const Vec2& pos, int gid)
+void TMXLayer::setupTileSprite(Sprite* sprite, const Vec2& pos, uint32_t gid)
 {
     sprite->setPosition(getPositionAt(pos));
     sprite->setPositionZ((float)getVertexZForPos(pos));
     sprite->setAnchorPoint(Vec2::ZERO);
     sprite->setOpacity(_opacity);
 
-    // issue 1264, flip can be undone as well
+    //issue 1264, flip can be undone as well
     sprite->setFlippedX(false);
     sprite->setFlippedY(false);
     sprite->setRotation(0.0f);
-    sprite->setAnchorPoint(Vec2(0, 0));
+    sprite->setAnchorPoint(Vec2(0,0));
 
     // Rotation in tiled is achieved using 3 flipped states, flipping across the horizontal, vertical, and diagonal axes of the tiles.
     if (gid & kTMXTileDiagonalFlag)
     {
         // put the anchor in the middle for ease of rotation.
-        sprite->setAnchorPoint(Vec2(0.5f, 0.5f));
-        sprite->setPosition(getPositionAt(pos).x + sprite->getContentSize().height / 2, getPositionAt(pos).y + sprite->getContentSize().width / 2);
+        sprite->setAnchorPoint(Vec2(0.5f,0.5f));
+        sprite->setPosition(getPositionAt(pos).x + sprite->getContentSize().height/2,
+           getPositionAt(pos).y + sprite->getContentSize().width/2 );
 
-        int flag = gid & (kTMXTileHorizontalFlag | kTMXTileVerticalFlag);
+        auto flag = gid & (kTMXTileHorizontalFlag | kTMXTileVerticalFlag );
 
         // handle the 4 diagonally flipped states.
         if (flag == kTMXTileHorizontalFlag)
@@ -324,7 +294,7 @@ void TMXLayer::setupTileSprite(Sprite* sprite, const Vec2& pos, int gid)
         {
             sprite->setRotation(270.0f);
         }
-        else if (flag == (kTMXTileVerticalFlag | kTMXTileHorizontalFlag))
+        else if (flag == (kTMXTileVerticalFlag | kTMXTileHorizontalFlag) )
         {
             sprite->setRotation(90.0f);
             sprite->setFlippedX(true);
@@ -351,7 +321,7 @@ void TMXLayer::setupTileSprite(Sprite* sprite, const Vec2& pos, int gid)
 
 Sprite* TMXLayer::reusedTileWithRect(const Rect& rect)
 {
-    if (!_reusedTile)
+    if (! _reusedTile) 
     {
         _reusedTile = Sprite::createWithTexture(_textureAtlas->getTexture(), rect);
         _reusedTile->setBatchNode(this);
@@ -362,10 +332,10 @@ Sprite* TMXLayer::reusedTileWithRect(const Rect& rect)
         // FIXME: HACK: Needed because if "batch node" is nil,
         // then the Sprite'squad will be reset
         _reusedTile->setBatchNode(nullptr);
-
+        
         // Re-init the sprite
         _reusedTile->setTextureRect(rect, false, rect.size);
-
+        
         // restore the batch node
         _reusedTile->setBatchNode(this);
     }
@@ -374,22 +344,22 @@ Sprite* TMXLayer::reusedTileWithRect(const Rect& rect)
 }
 
 // TMXLayer - obtaining tiles/gids
-Sprite* TMXLayer::getTileAt(const Vec2& pos)
+Sprite * TMXLayer::getTileAt(const Vec2& pos)
 {
-    CCASSERT(pos.x < _layerSize.width && pos.y < _layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
+    CCASSERT(pos.x < _layerSize.width && pos.y < _layerSize.height && pos.x >=0 && pos.y >=0, "TMXLayer: invalid position");
     CCASSERT(_tiles && _atlasIndexArray, "TMXLayer: the tiles map has been released");
 
-    Sprite* tile = nullptr;
+    Sprite *tile = nullptr;
     int gid = this->getTileGIDAt(pos);
 
     // if GID == 0, then no tile is present
-    if (gid)
+    if (gid) 
     {
         int z = (int)(pos.x + pos.y * _layerSize.width);
         tile = static_cast<Sprite*>(this->getChildByTag(z));
 
         // tile not created yet. create it
-        if (!tile)
+        if (! tile) 
         {
             Rect rect = _tileSet->getRectForGID(gid);
             rect = CC_RECT_PIXELS_TO_POINTS(rect);
@@ -401,87 +371,85 @@ Sprite* TMXLayer::getTileAt(const Vec2& pos)
             tile->setAnchorPoint(Vec2::ZERO);
             tile->setOpacity(_opacity);
 
-            std::size_t indexForZ = atlasIndexForExistantZ(z);
+            ssize_t indexForZ = atlasIndexForExistantZ(z);
             this->addSpriteWithoutQuad(tile, static_cast<int>(indexForZ), z);
         }
     }
-
+    
     return tile;
 }
 
-uint32_t TMXLayer::getTileGIDAt(const Vec2& pos, TMXTileFlags* flags /* = nullptr*/)
+uint32_t TMXLayer::getTileGIDAt(const Vec2& pos, TMXTileFlags* flags/* = nullptr*/)
 {
-    CCASSERT(pos.x < _layerSize.width && pos.y < _layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
+    CCASSERT(pos.x < _layerSize.width && pos.y < _layerSize.height && pos.x >=0 && pos.y >=0, "TMXLayer: invalid position");
     CCASSERT(_tiles && _atlasIndexArray, "TMXLayer: the tiles map has been released");
 
-    std::size_t idx = static_cast<int>(((int)pos.x + (int)pos.y * _layerSize.width));
+    ssize_t idx = static_cast<int>(((int) pos.x + (int) pos.y * _layerSize.width));
     // Bits on the far end of the 32-bit global tile ID are used for tile flags
     uint32_t tile = _tiles[idx];
 
     // issue1264, flipped tiles can be changed dynamically
-    if (flags)
+    if (flags) 
     {
         *flags = (TMXTileFlags)(tile & kTMXFlipedAll);
     }
-
+    
     return (tile & kTMXFlippedMask);
 }
 
 // TMXLayer - adding helper methods
-Sprite* TMXLayer::insertTileForGID(uint32_t gid, const Vec2& pos)
+Sprite * TMXLayer::insertTileForGID(uint32_t gid, const Vec2& pos)
 {
     if (gid != 0 && (static_cast<int>((gid & kTMXFlippedMask)) - _tileSet->_firstGid) >= 0)
     {
         Rect rect = _tileSet->getRectForGID(gid);
         rect = CC_RECT_PIXELS_TO_POINTS(rect);
-
-        intptr_t z = (intptr_t)((int)pos.x + (int)pos.y * _layerSize.width);
-
-        Sprite* tile = reusedTileWithRect(rect);
-
+        
+        intptr_t z = (intptr_t)((int) pos.x + (int) pos.y * _layerSize.width);
+        
+        Sprite *tile = reusedTileWithRect(rect);
+        
         setupTileSprite(tile, pos, gid);
-
+        
         // get atlas index
-        std::size_t indexForZ = atlasIndexForNewZ(static_cast<int>(z));
-
+        ssize_t indexForZ = atlasIndexForNewZ(static_cast<int>(z));
+        
         // Optimization: add the quad without adding a child
         this->insertQuadFromSprite(tile, indexForZ);
-
+        
         // insert it into the local atlasindex array
         ccCArrayInsertValueAtIndex(_atlasIndexArray, (void*)z, indexForZ);
-
+        
         // update possible children
-
-        for (const auto& child : _children)
-        {
+        
+        for(const auto &child : _children) {
             Sprite* sp = static_cast<Sprite*>(child);
-            std::size_t ai = sp->getAtlasIndex();
-            if (ai >= indexForZ)
+            ssize_t ai = sp->getAtlasIndex();
+            if ( ai >= indexForZ )
             {
-                sp->setAtlasIndex(ai + 1);
+                sp->setAtlasIndex(ai+1);
             }
         }
-
+        
         _tiles[z] = gid;
         return tile;
     }
-
+    
     return nullptr;
 }
 
-Sprite* TMXLayer::updateTileForGID(uint32_t gid, const Vec2& pos)
+Sprite * TMXLayer::updateTileForGID(uint32_t gid, const Vec2& pos)
 {
     Rect rect = _tileSet->getRectForGID(gid);
-    rect = Rect(rect.origin.x / _contentScaleFactor, rect.origin.y / _contentScaleFactor, rect.size.width / _contentScaleFactor,
-                rect.size.height / _contentScaleFactor);
-    int z = (int)((int)pos.x + (int)pos.y * _layerSize.width);
+    rect = Rect(rect.origin.x / _contentScaleFactor, rect.origin.y / _contentScaleFactor, rect.size.width/ _contentScaleFactor, rect.size.height/ _contentScaleFactor);
+    int z = (int)((int) pos.x + (int) pos.y * _layerSize.width);
 
-    Sprite* tile = reusedTileWithRect(rect);
+    Sprite *tile = reusedTileWithRect(rect);
 
-    setupTileSprite(tile, pos, gid);
+    setupTileSprite(tile ,pos ,gid);
 
     // get atlas index
-    std::size_t indexForZ = atlasIndexForExistantZ(z);
+    ssize_t indexForZ = atlasIndexForExistantZ(z);
     tile->setAtlasIndex(indexForZ);
     tile->setDirty(true);
     tile->updateTransform();
@@ -502,9 +470,7 @@ intptr_t TMXLayer::getZForPos(const Vec2& pos) const
                 z = pos.x / 2 + pos.y * _layerSize.width;
             else
                 z = pos.x / 2 + std::ceil(_layerSize.width / 2) + pos.y * _layerSize.width;
-        }
-        else
-        {
+        } else {
             // TMXStaggerIndex_Even
             if (((int)pos.x % 2) == 1)
                 z = pos.x / 2 + pos.y * _layerSize.width;
@@ -523,7 +489,7 @@ intptr_t TMXLayer::getZForPos(const Vec2& pos) const
 
 // used only when parsing the map. useless after the map was parsed
 // since lot's of assumptions are no longer true
-Sprite* TMXLayer::appendTileForGID(uint32_t gid, const Vec2& pos)
+Sprite * TMXLayer::appendTileForGID(uint32_t gid, const Vec2& pos)
 {
     if (gid != 0 && (static_cast<int>((gid & kTMXFlippedMask)) - _tileSet->_firstGid) >= 0)
     {
@@ -537,63 +503,63 @@ Sprite* TMXLayer::appendTileForGID(uint32_t gid, const Vec2& pos)
         // a given Z. (github issue #16512)
         intptr_t z = getZForPos(pos);
 
-        Sprite* tile = reusedTileWithRect(rect);
-
-        setupTileSprite(tile, pos, gid);
-
+        Sprite *tile = reusedTileWithRect(rect);
+        
+        setupTileSprite(tile ,pos ,gid);
+        
         // optimization:
         // The difference between appendTileForGID and insertTileforGID is that append is faster, since
         // it appends the tile at the end of the texture atlas
-        std::size_t indexForZ = _atlasIndexArray->num;
-
+        ssize_t indexForZ = _atlasIndexArray->num;
+        
         // don't add it using the "standard" way.
         insertQuadFromSprite(tile, indexForZ);
-
+        
         // append should be after addQuadFromSprite since it modifies the quantity values
         ccCArrayInsertValueAtIndex(_atlasIndexArray, (void*)z, indexForZ);
 
         // Validation for issue #16512
-        CCASSERT(_atlasIndexArray->num == 1 || _atlasIndexArray->arr[_atlasIndexArray->num - 1] > _atlasIndexArray->arr[_atlasIndexArray->num - 2],
-                 "Invalid z for _atlasIndexArray");
+        CCASSERT(_atlasIndexArray->num == 1 ||
+                 _atlasIndexArray->arr[_atlasIndexArray->num-1] > _atlasIndexArray->arr[_atlasIndexArray->num-2], "Invalid z for _atlasIndexArray");
 
         return tile;
     }
-
+    
     return nullptr;
 }
 
 // TMXLayer - atlasIndex and Z
-static inline int compareInts(const void* a, const void* b)
+static inline int compareInts(const void * a, const void * b)
 {
     const int ia = *(int*)a;
     const int ib = *(int*)b;
-    return (ia - ib);
+    return (ia-ib);
 }
 
-std::size_t TMXLayer::atlasIndexForExistantZ(int z)
+ssize_t TMXLayer::atlasIndexForExistantZ(int z)
 {
-    int key = z;
-    int* item = (int*)bsearch((void*)&key, (void*)&_atlasIndexArray->arr[0], _atlasIndexArray->num, sizeof(void*), compareInts);
+    int key=z;
+    int *item = (int*)bsearch((void*)&key, (void*)&_atlasIndexArray->arr[0], _atlasIndexArray->num, sizeof(void*), compareInts);
 
     CCASSERT(item, "TMX atlas index not found. Shall not happen");
 
-    std::size_t index = ((size_t)item - (size_t)_atlasIndexArray->arr) / sizeof(void*);
+    ssize_t index = ((size_t)item - (size_t)_atlasIndexArray->arr) / sizeof(void*);
     return index;
 }
 
-std::size_t TMXLayer::atlasIndexForNewZ(int z)
+ssize_t TMXLayer::atlasIndexForNewZ(int z)
 {
     // FIXME:: This can be improved with a sort of binary search
-    std::size_t i = 0;
-    for (i = 0; i < _atlasIndexArray->num; i++)
+    ssize_t i=0;
+    for (i=0; i< _atlasIndexArray->num ; i++) 
     {
-        std::size_t val = (size_t)_atlasIndexArray->arr[i];
+        ssize_t val = (size_t) _atlasIndexArray->arr[i];
         if (z < val)
         {
             break;
         }
-    }
-
+    } 
+    
     return i;
 }
 
@@ -605,14 +571,14 @@ void TMXLayer::setTileGID(uint32_t gid, const Vec2& pos)
 
 void TMXLayer::setTileGID(uint32_t gid, const Vec2& pos, TMXTileFlags flags)
 {
-    CCASSERT(pos.x < _layerSize.width && pos.y < _layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
+    CCASSERT(pos.x < _layerSize.width && pos.y < _layerSize.height && pos.x >=0 && pos.y >=0, "TMXLayer: invalid position");
     CCASSERT(_tiles && _atlasIndexArray, "TMXLayer: the tiles map has been released");
-    CCASSERT(gid == 0 || (int)gid >= _tileSet->_firstGid, "TMXLayer: invalid gid");
+    CCASSERT(gid == 0 || (int)gid >= _tileSet->_firstGid, "TMXLayer: invalid gid" );
 
     TMXTileFlags currentFlags;
     uint32_t currentGID = getTileGIDAt(pos, &currentFlags);
 
-    if (currentGID != gid || currentFlags != flags)
+    if (currentGID != gid || currentFlags != flags) 
     {
         uint32_t gidAndFlags = gid | flags;
 
@@ -627,23 +593,23 @@ void TMXLayer::setTileGID(uint32_t gid, const Vec2& pos, TMXTileFlags flags)
             insertTileForGID(gidAndFlags, pos);
         }
         // modifying an existing tile with a non-empty tile
-        else
+        else 
         {
-            int z = (int)pos.x + (int)pos.y * _layerSize.width;
-            Sprite* sprite = static_cast<Sprite*>(getChildByTag(z));
+            int z = (int) pos.x + (int) pos.y * _layerSize.width;
+            Sprite *sprite = static_cast<Sprite*>(getChildByTag(z));
             if (sprite)
             {
                 Rect rect = _tileSet->getRectForGID(gid);
                 rect = CC_RECT_PIXELS_TO_POINTS(rect);
 
                 sprite->setTextureRect(rect, false, rect.size);
-                if (flags)
+                if (flags) 
                 {
                     setupTileSprite(sprite, sprite->getPosition(), gidAndFlags);
                 }
                 _tiles[z] = gidAndFlags;
-            }
-            else
+            } 
+            else 
             {
                 updateTileForGID(gidAndFlags, pos);
             }
@@ -651,24 +617,24 @@ void TMXLayer::setTileGID(uint32_t gid, const Vec2& pos, TMXTileFlags flags)
     }
 }
 
-void TMXLayer::addChild(Node*, int, int)
+void TMXLayer::addChild(Node* /*child*/, int /*zOrder*/, int /*tag*/)
 {
     CCASSERT(0, "addChild: is not supported on TMXLayer. Instead use setTileGID:at:/tileAt:");
 }
 
 void TMXLayer::removeChild(Node* node, bool cleanup)
 {
-    Sprite* sprite = (Sprite*)node;
+    Sprite *sprite = (Sprite*)node;
     // allows removing nil objects
-    if (!sprite)
+    if (! sprite)
     {
         return;
     }
 
     CCASSERT(_children.contains(sprite), "Tile does not belong to TMXLayer");
 
-    std::size_t atlasIndex = sprite->getAtlasIndex();
-    std::size_t zz = (std::size_t)_atlasIndexArray->arr[atlasIndex];
+    ssize_t atlasIndex = sprite->getAtlasIndex();
+    ssize_t zz = (ssize_t)_atlasIndexArray->arr[atlasIndex];
     _tiles[zz] = 0;
     ccCArrayRemoveValueAtIndex(_atlasIndexArray, atlasIndex);
     SpriteBatchNode::removeChild(sprite, cleanup);
@@ -676,15 +642,15 @@ void TMXLayer::removeChild(Node* node, bool cleanup)
 
 void TMXLayer::removeTileAt(const Vec2& pos)
 {
-    CCASSERT(pos.x < _layerSize.width && pos.y < _layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
+    CCASSERT(pos.x < _layerSize.width && pos.y < _layerSize.height && pos.x >=0 && pos.y >=0, "TMXLayer: invalid position");
     CCASSERT(_tiles && _atlasIndexArray, "TMXLayer: the tiles map has been released");
 
     int gid = getTileGIDAt(pos);
 
-    if (gid)
+    if (gid) 
     {
         int z = pos.x + pos.y * _layerSize.width;
-        std::size_t atlasIndex = atlasIndexForExistantZ(z);
+        ssize_t atlasIndex = atlasIndexForExistantZ(z);
 
         // remove tile from GID map
         _tiles[z] = 0;
@@ -693,51 +659,51 @@ void TMXLayer::removeTileAt(const Vec2& pos)
         ccCArrayRemoveValueAtIndex(_atlasIndexArray, atlasIndex);
 
         // remove it from sprites and/or texture atlas
-        Sprite* sprite = (Sprite*)getChildByTag(z);
+        Sprite *sprite = (Sprite*)getChildByTag(z);
         if (sprite)
         {
             SpriteBatchNode::removeChild(sprite, true);
         }
-        else
+        else 
         {
             _textureAtlas->removeQuadAtIndex(atlasIndex);
 
             // update possible children
-            for (const auto& obj : _children)
-            {
+            for(const auto &obj : _children) {
                 Sprite* child = static_cast<Sprite*>(obj);
-                std::size_t ai = child->getAtlasIndex();
-                if (ai >= atlasIndex)
+                ssize_t ai = child->getAtlasIndex();
+                if ( ai >= atlasIndex )
                 {
-                    child->setAtlasIndex(ai - 1);
+                    child->setAtlasIndex(ai-1);
                 }
             }
         }
     }
 }
 
-// CCTMXLayer - obtaining positions, offset
+//CCTMXLayer - obtaining positions, offset
 Vec2 TMXLayer::calculateLayerOffset(const Vec2& pos)
 {
     Vec2 ret;
     switch (_layerOrientation)
     {
         case TMXOrientationOrtho:
-            ret.set(pos.x * _mapTileSize.width, -pos.y * _mapTileSize.height);
+            ret.set( pos.x * _mapTileSize.width, -pos.y *_mapTileSize.height);
             break;
         case TMXOrientationIso:
-            ret.set((_mapTileSize.width / 2) * (pos.x - pos.y), (_mapTileSize.height / 2) * (-pos.x - pos.y));
+            ret.set((_mapTileSize.width /2) * (pos.x - pos.y),
+                  (_mapTileSize.height /2 ) * (-pos.x - pos.y));
             break;
         case TMXOrientationHex:
         {
-            if (_staggerAxis == TMXStaggerAxis_Y)
+            if(_staggerAxis == TMXStaggerAxis_Y)
             {
-                int diffX = (_staggerIndex == TMXStaggerIndex_Even) ? _mapTileSize.width / 2 : 0;
+                int diffX = (_staggerIndex == TMXStaggerIndex_Even) ? _mapTileSize.width/2 : 0;
                 ret.set(pos.x * _mapTileSize.width + diffX, -pos.y * (_mapTileSize.height - (_mapTileSize.width - _hexSideLength) / 2));
             }
-            else if (_staggerAxis == TMXStaggerAxis_X)
+            else if(_staggerAxis == TMXStaggerAxis_X)
             {
-                int diffY = (_staggerIndex == TMXStaggerIndex_Odd) ? _mapTileSize.height / 2 : 0;
+                int diffY = (_staggerIndex == TMXStaggerIndex_Odd) ? _mapTileSize.height/2 : 0;
                 ret.set(pos.x * (_mapTileSize.width - (_mapTileSize.width - _hexSideLength) / 2), -pos.y * _mapTileSize.height + diffY);
             }
             break;
@@ -747,13 +713,14 @@ Vec2 TMXLayer::calculateLayerOffset(const Vec2& pos)
             float diffX = 0;
             if ((int)std::abs(pos.y) % 2 == 1)
             {
-                diffX = _mapTileSize.width / 2;
+                diffX = _mapTileSize.width/2;
             }
-            ret.set(pos.x * _mapTileSize.width + diffX, (-pos.y) * _mapTileSize.height / 2);
+            ret.set(pos.x * _mapTileSize.width + diffX,
+                         (-pos.y) * _mapTileSize.height/2);
         }
         break;
     }
-    return ret;
+    return ret;    
 }
 
 Vec2 TMXLayer::getPositionAt(const Vec2& pos)
@@ -761,31 +728,33 @@ Vec2 TMXLayer::getPositionAt(const Vec2& pos)
     Vec2 ret;
     switch (_layerOrientation)
     {
-        case TMXOrientationOrtho:
-            ret = getPositionForOrthoAt(pos);
-            break;
-        case TMXOrientationIso:
-            ret = getPositionForIsoAt(pos);
-            break;
-        case TMXOrientationHex:
-            ret = getPositionForHexAt(pos);
-            break;
-        case TMXOrientationStaggered:
-            ret = getPositionForStaggeredAt(pos);
-            break;
+    case TMXOrientationOrtho:
+        ret = getPositionForOrthoAt(pos);
+        break;
+    case TMXOrientationIso:
+        ret = getPositionForIsoAt(pos);
+        break;
+    case TMXOrientationHex:
+        ret = getPositionForHexAt(pos);
+        break;
+    case TMXOrientationStaggered:
+        ret = getPositionForStaggeredAt(pos);
+        break;
     }
-    ret = CC_POINT_PIXELS_TO_POINTS(ret);
+    ret = CC_POINT_PIXELS_TO_POINTS( ret );
     return ret;
 }
 
 Vec2 TMXLayer::getPositionForOrthoAt(const Vec2& pos)
 {
-    return Vec2(pos.x * _mapTileSize.width, (_layerSize.height - pos.y - 1) * _mapTileSize.height);
+    return Vec2(pos.x * _mapTileSize.width,
+                            (_layerSize.height - pos.y - 1) * _mapTileSize.height);
 }
 
 Vec2 TMXLayer::getPositionForIsoAt(const Vec2& pos)
 {
-    return Vec2(_mapTileSize.width / 2 * (_layerSize.width + pos.x - pos.y - 1), _mapTileSize.height / 2 * ((_layerSize.height * 2 - pos.x - pos.y) - 2));
+    return Vec2(_mapTileSize.width /2 * (_layerSize.width + pos.x - pos.y - 1),
+                             _mapTileSize.height /2 * ((_layerSize.height * 2 - pos.x - pos.y) - 2));
 }
 
 Vec2 TMXLayer::getPositionForHexAt(const Vec2& pos)
@@ -801,37 +770,38 @@ Vec2 TMXLayer::getPositionForHexAt(const Vec2& pos)
             float diffX = 0;
             if ((int)pos.y % 2 == 1)
             {
-                diffX = _mapTileSize.width / 2 * odd_even;
+                diffX = _mapTileSize.width/2 * odd_even;
             }
-            xy = Vec2(pos.x * _mapTileSize.width + diffX + offset.x,
-                      (_layerSize.height - pos.y - 1) * (_mapTileSize.height - (_mapTileSize.height - _hexSideLength) / 2) - offset.y);
+            xy = Vec2(pos.x * _mapTileSize.width+diffX+offset.x,
+                      (_layerSize.height - pos.y - 1) * (_mapTileSize.height-(_mapTileSize.height-_hexSideLength)/2)-offset.y);
             break;
         }
-
+            
         case TMXStaggerAxis_X:
         {
             float diffY = 0;
             if ((int)pos.x % 2 == 1)
             {
-                diffY = _mapTileSize.height / 2 * -odd_even;
+                diffY = _mapTileSize.height/2 * -odd_even;
             }
-
-            xy = Vec2(pos.x * (_mapTileSize.width - (_mapTileSize.width - _hexSideLength) / 2) + offset.x,
-                      (_layerSize.height - pos.y - 1) * _mapTileSize.height + diffY - offset.y);
+            
+            xy = Vec2(pos.x * (_mapTileSize.width-(_mapTileSize.width-_hexSideLength)/2)+offset.x,
+                      (_layerSize.height - pos.y - 1) * _mapTileSize.height + diffY-offset.y);
             break;
         }
     }
     return xy;
 }
 
-Vec2 TMXLayer::getPositionForStaggeredAt(const Vec2& pos)
+Vec2 TMXLayer::getPositionForStaggeredAt(const Vec2 &pos)
 {
     float diffX = 0;
     if ((int)pos.y % 2 == 1)
     {
-        diffX = _mapTileSize.width / 2;
+        diffX = _mapTileSize.width/2;
     }
-    return Vec2(pos.x * _mapTileSize.width + diffX, (_layerSize.height - pos.y - 1) * _mapTileSize.height / 2);
+    return Vec2(pos.x * _mapTileSize.width + diffX,
+                (_layerSize.height - pos.y - 1) * _mapTileSize.height/2);
 }
 
 int TMXLayer::getVertexZForPos(const Vec2& pos)
@@ -840,31 +810,31 @@ int TMXLayer::getVertexZForPos(const Vec2& pos)
     int maxVal = 0;
     if (_useAutomaticVertexZ)
     {
-        switch (_layerOrientation)
+        switch (_layerOrientation) 
         {
-            case TMXOrientationIso:
-                maxVal = static_cast<int>(_layerSize.width + _layerSize.height);
-                ret = static_cast<int>(-(maxVal - (pos.x + pos.y)));
-                break;
-            case TMXOrientationOrtho:
-                ret = static_cast<int>(-(_layerSize.height - pos.y));
-                break;
-            case TMXOrientationStaggered:
-                ret = static_cast<int>(-(_layerSize.height - pos.y));
-                break;
-            case TMXOrientationHex:
-                ret = static_cast<int>(-(_layerSize.height - pos.y));
-                break;
-            default:
-                CCASSERT(0, "TMX invalid value");
-                break;
+        case TMXOrientationIso:
+            maxVal = static_cast<int>(_layerSize.width + _layerSize.height);
+            ret = static_cast<int>(-(maxVal - (pos.x + pos.y)));
+            break;
+        case TMXOrientationOrtho:
+            ret = static_cast<int>(-(_layerSize.height-pos.y));
+            break;
+        case TMXOrientationStaggered:
+            ret = static_cast<int>(-(_layerSize.height-pos.y));
+            break;
+        case TMXOrientationHex:
+            ret = static_cast<int>(-(_layerSize.height-pos.y));
+            break;
+        default:
+            CCASSERT(0, "TMX invalid value");
+            break;
         }
-    }
+    } 
     else
     {
         ret = _vertexZvalue;
     }
-
+    
     return ret;
 }
 
@@ -873,4 +843,5 @@ std::string TMXLayer::getDescription() const
     return StringUtils::format("<TMXLayer | tag = %d, size = %d,%d>", _tag, (int)_mapTileSize.width, (int)_mapTileSize.height);
 }
 
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCTMXLayer.h b/cocos2d/cocos/2d/CCTMXLayer.h
index 8ca99d779f..4e6dbe149a 100644
--- a/cocos2d/cocos/2d/CCTMXLayer.h
+++ b/cocos2d/cocos/2d/CCTMXLayer.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,25 +25,18 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_TMXLAYER_H
-#define CC_2D_TMXLAYER_H
+#ifndef __CCTMX_LAYER_H__
+#define __CCTMX_LAYER_H__
 
 #include <cocos/2d/CCSpriteBatchNode.h>
 #include <cocos/2d/CCTMXXMLParser.h>
-#include <cocos/base/CCValue.h>
 #include <cocos/base/ccCArray.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <cstddef>
-#include <cstdint>
-#include <iosfwd>
-
 NS_CC_BEGIN
 
-class Node;
-class Sprite;
+class TMXMapInfo;
+class TMXLayerInfo;
+class TMXTilesetInfo;
+struct _ccCArray;
 
 /**
  * @addtogroup _2d
@@ -65,8 +59,7 @@ class Sprite;
  * For further information, please see the programming guide:
  * http://www.cocos2d-iphone.org/wiki/doku.php/prog_guide:tiled_maps
  * @since v0.8.1
- * Tiles can have tile flags for additional properties. At the moment only flip horizontal and flip vertical are used. These bit flags are defined in
- * TMXXMLParser.h.
+ * Tiles can have tile flags for additional properties. At the moment only flip horizontal and flip vertical are used. These bit flags are defined in TMXXMLParser.h.
  * @since 1.1
  */
 
@@ -80,7 +73,7 @@ public:
      * @param mapInfo A map info.
      * @return An autorelease object.
      */
-    static TMXLayer* create(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo);
+    static TMXLayer * create(TMXTilesetInfo *tilesetInfo, TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo);
     /**
      * @js ctor
      */
@@ -89,7 +82,7 @@ public:
      * @js NA
      * @lua NA
      */
-    ~TMXLayer() override;
+    virtual ~TMXLayer();
 
     /** Initializes a TMXLayer with a tileset info, a layer info and a map info.
      *
@@ -98,7 +91,7 @@ public:
      * @param mapInfo A map info.
      * @return If initializes successfully, it will return true.
      */
-    bool initWithTilesetInfo(TMXTilesetInfo* tilesetInfo, TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo);
+    bool initWithTilesetInfo(TMXTilesetInfo *tilesetInfo, TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo);
 
     /** Dealloc the map that contains the tile position from memory.
      * Unless you want to know at runtime the tiles positions, you can safely call this method.
@@ -117,23 +110,15 @@ public:
      * @return Returns the tile (Sprite) at a given a tile coordinate.
      */
     Sprite* getTileAt(const Vec2& tileCoordinate);
-    /**
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE Sprite* tileAt(const Vec2& tileCoordinate) { return getTileAt(tileCoordinate); }
-
+    
     /** Returns the tile gid at a given tile coordinate. It also returns the tile flags.
      * This method requires the tile map has not been previously released (eg. don't call [layer releaseMap]).
-     *
+     * 
      * @param tileCoordinate The tile coordinate.
      * @param flags Tile flags.
      * @return Returns the tile gid at a given tile coordinate. It also returns the tile flags.
      */
-    uint32_t getTileGIDAt(const Vec2& tileCoordinate, TMXTileFlags* flags = nullptr);
-    /**
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE uint32_t tileGIDAt(const Vec2& tileCoordinate, TMXTileFlags* flags = nullptr) { return getTileGIDAt(tileCoordinate, flags); }
+	uint32_t getTileGIDAt(const Vec2& tileCoordinate, TMXTileFlags* flags = nullptr);
 
     /** Sets the tile gid (gid = tile global id) at a given tile coordinate.
      * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor -> Tileset Mgr +1.
@@ -148,7 +133,7 @@ public:
      * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor -> Tileset Mgr +1.
      * If a tile is already placed at that position, then it will be removed.
      * Use withFlags if the tile flags need to be changed as well.
-     *
+     * 
      * @param gid The tile gid.
      * @param tileCoordinate The tile coordinate.
      * @param flags The tile flags.
@@ -156,7 +141,7 @@ public:
 
     void setTileGID(uint32_t gid, const Vec2& tileCoordinate, TMXTileFlags flags);
 
-    /** Removes a tile at given tile coordinate.
+    /** Removes a tile at given tile coordinate. 
      *
      * @param tileCoordinate The tile coordinate.
      */
@@ -167,32 +152,24 @@ public:
      * @param tileCoordinate The tile coordinate.
      * @return The position in points of a given tile coordinate.
      */
-    Vec2 getPositionAt(const Vec2& tileCoordinate);
-    /**
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE Vec2 positionAt(const Vec2& tileCoordinate) { return getPositionAt(tileCoordinate); }
+	Vec2 getPositionAt(const Vec2& tileCoordinate);
 
     /** Return the value for the specific property name.
      *
      * @param propertyName The specific property name.
      * @return Return the value for the specific property name.
      */
-    Value getProperty(const std::string& propertyName) const;
-    /**
-     * @js NA
-     */
-    CC_DEPRECATED_ATTRIBUTE Value propertyNamed(const std::string& propertyName) const { return getProperty(propertyName); }
+	Value getProperty(const std::string& propertyName) const;
 
     /** Creates the tiles. */
     void setupTiles();
-
-    /** Get the layer name.
+    
+    /** Get the layer name. 
      *
      * @return The layer name.
      */
     const std::string& getLayerName() { return _layerName; }
-
+    
     /** Set the layer name.
      *
      * @param layerName The layer name.
@@ -204,85 +181,86 @@ public:
      * @return Size of the layer in tiles.
      */
     const Size& getLayerSize() const { return _layerSize; }
-
+    
     /** Set size of the layer in tiles.
      *
      * @param size Size of the layer in tiles.
      */
     void setLayerSize(const Size& size) { _layerSize = size; }
-
+    
     /** Size of the map's tile (could be different from the tile's size).
      *
      * @return The size of the map's tile.
      */
     const Size& getMapTileSize() const { return _mapTileSize; }
-
+    
     /** Set the size of the map's tile.
      *
      * @param size The size of the map's tile.
      */
     void setMapTileSize(const Size& size) { _mapTileSize = size; }
-
+    
     /** Pointer to the map of tiles.
      * @js NA
      * @lua NA
      * @return Pointer to the map of tiles.
      */
-    uint32_t* getTiles() const { return _tiles; }
-
+    uint32_t* getTiles() const { return _tiles; };
+    
     /** Set a pointer to the map of tiles.
      *
      * @param tiles A pointer to the map of tiles.
      */
-    void setTiles(uint32_t* tiles) { _tiles = tiles; }
-
-    /** Tileset information for the layer.
+    void setTiles(uint32_t* tiles) { _tiles = tiles; };
+    
+    /** Tileset information for the layer. 
      *
      * @return Tileset information for the layer.
      */
     TMXTilesetInfo* getTileSet() const { return _tileSet; }
-
+    
     /** Set tileset information for the layer.
      *
      * @param info The tileset information for the layer.
      * @js NA
      */
-    void setTileSet(TMXTilesetInfo* info)
-    {
+    void setTileSet(TMXTilesetInfo* info) {
         CC_SAFE_RETAIN(info);
         CC_SAFE_RELEASE(_tileSet);
         _tileSet = info;
     }
-
+    
     /** Layer orientation, which is the same as the map orientation.
      *
      * @return Layer orientation, which is the same as the map orientation.
      */
     int getLayerOrientation() const { return _layerOrientation; }
-
+    
     /** Set layer orientation, which is the same as the map orientation.
      *
      * @param orientation Layer orientation,which is the same as the map orientation.
      */
     void setLayerOrientation(int orientation) { _layerOrientation = orientation; }
-
+    
     /** Properties from the layer. They can be added using Tiled.
      *
      * @return Properties from the layer. They can be added using Tiled.
      */
     const ValueMap& getProperties() const { return _properties; }
-
+    
     /** Properties from the layer. They can be added using Tiled.
      *
      * @return Properties from the layer. They can be added using Tiled.
      */
     ValueMap& getProperties() { return _properties; }
-
+    
     /** Set an Properties from to layer.
      *
      * @param properties It is used to set the layer Properties.
      */
-    void setProperties(const ValueMap& properties) { _properties = properties; }
+    void setProperties(const ValueMap& properties) {
+        _properties = properties;
+    }
     //
     // Override
     //
@@ -290,12 +268,12 @@ public:
      @warning addChild(z, tag); is not supported on TMXLayer. Instead of setTileGID.
      */
     using SpriteBatchNode::addChild;
-    virtual void addChild(Node* child, int zOrder, int tag) override;
+    virtual void addChild(Node * child, int zOrder, int tag) override;
     // super method
     void removeChild(Node* child, bool cleanup) override;
     /**
-     * @js NA
-     */
+    * @js NA
+    */
     virtual std::string getDescription() const override;
 
 protected:
@@ -314,30 +292,31 @@ protected:
 
     /* The layer recognizes some special properties, like cc_vertexz */
     void parseInternalProperties();
-    void setupTileSprite(Sprite* sprite, const Vec2& pos, int gid);
+    void setupTileSprite(Sprite* sprite, const Vec2& pos, uint32_t gid);
     Sprite* reusedTileWithRect(const Rect& rect);
     int getVertexZForPos(const Vec2& pos);
 
     // index
-    std::size_t atlasIndexForExistantZ(int z);
-    std::size_t atlasIndexForNewZ(int z);
+    ssize_t atlasIndexForExistantZ(int z);
+    ssize_t atlasIndexForNewZ(int z);
+
 
     //! name of the layer
     std::string _layerName;
     //! TMX Layer supports opacity
     unsigned char _opacity;
-
+    
     //! Only used when vertexZ is used
     int _vertexZvalue;
     bool _useAutomaticVertexZ;
 
     //! used for optimization
-    Sprite* _reusedTile;
-    ccCArray* _atlasIndexArray;
-
+    Sprite *_reusedTile;
+    ccCArray *_atlasIndexArray;
+    
     // used for retina display
     float _contentScaleFactor;
-
+    
     /** size of the layer in tiles */
     Size _layerSize;
     /** size of the map's tile (could be different from the tile's size) */
@@ -363,4 +342,5 @@ protected:
 
 NS_CC_END
 
-#endif // CC_2D_TMXLAYER_H
+#endif //__CCTMX_LAYER_H__
+
diff --git a/cocos2d/cocos/2d/CCTMXObjectGroup.cpp b/cocos2d/cocos/2d/CCTMXObjectGroup.cpp
index 27f4521f17..b15edd3a2e 100644
--- a/cocos2d/cocos/2d/CCTMXObjectGroup.cpp
+++ b/cocos2d/cocos/2d/CCTMXObjectGroup.cpp
@@ -4,6 +4,7 @@ Copyright (c) 2010      Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -26,19 +27,14 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCTMXObjectGroup.h>
-
-#include <cocos/base/CCValue.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <string>
-#include <unordered_map>
+#include <cocos/base/ccMacros.h>
 
 NS_CC_BEGIN
 
-// implementation TMXObjectGroup
+//implementation TMXObjectGroup
 
 TMXObjectGroup::TMXObjectGroup()
-: _groupName("")
+    : _groupName("")
 {
 }
 
@@ -61,7 +57,7 @@ ValueMap TMXObjectGroup::getObject(const std::string& objectName) const
             }
         }
     }
-
+    
     // object not found
     return ValueMap();
 }
diff --git a/cocos2d/cocos/2d/CCTMXObjectGroup.h b/cocos2d/cocos/2d/CCTMXObjectGroup.h
index 79f8d25299..154fa62156 100644
--- a/cocos2d/cocos/2d/CCTMXObjectGroup.h
+++ b/cocos2d/cocos/2d/CCTMXObjectGroup.h
@@ -4,6 +4,7 @@ Copyright (c) 2010      Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,17 +26,12 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_TMXOBJECTGROUP_H
-#define CC_2D_TMXOBJECTGROUP_H
+#ifndef __CCTMX_OBJECT_GROUP_H__
+#define __CCTMX_OBJECT_GROUP_H__
 
-#include <cocos/base/CCRef.h>
+#include <cocos/math/CCGeometry.h>
 #include <cocos/base/CCValue.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
-#include <string>
+#include <cocos/base/CCRef.h>
 
 NS_CC_BEGIN
 
@@ -59,76 +55,76 @@ public:
      * @lua NA
      */
     virtual ~TMXObjectGroup();
-
-    /** Get the group name.
+    
+    /** Get the group name. 
      *
      * @return The group name.
      */
     const std::string& getGroupName() const { return _groupName; }
-
-    /** Set the group name.
+    
+    /** Set the group name. 
      *
      * @param groupName A string,it is used to set the group name.
      */
     void setGroupName(const std::string& groupName) { _groupName = groupName; }
 
-    /** Return the value for the specific property name.
+    /** Return the value for the specific property name. 
      *
      * @param propertyName The specific property name.
      * @return Return the value for the specific property name.
      * @js NA
      */
     Value getProperty(const std::string& propertyName) const;
-
-    CC_DEPRECATED_ATTRIBUTE Value propertyNamed(const std::string& propertyName) const { return getProperty(propertyName); }
-
+    
     /** Return the dictionary for the specific object name.
      * It will return the 1st object found on the array for the given name.
      *
      * @return Return the dictionary for the specific object name.
      */
     ValueMap getObject(const std::string& objectName) const;
-
-    CC_DEPRECATED_ATTRIBUTE ValueMap objectNamed(const std::string& objectName) const { return getObject(objectName); }
-
-    /** Gets the offset position of child objects.
+        
+    /** Gets the offset position of child objects. 
      *
      * @return The offset position of child objects.
      */
     const Vec2& getPositionOffset() const { return _positionOffset; }
-
-    /** Sets the offset position of child objects.
+    
+    /** Sets the offset position of child objects. 
      *
      * @param offset The offset position of child objects.
      */
     void setPositionOffset(const Vec2& offset) { _positionOffset = offset; }
-
-    /** Gets the list of properties stored in a dictionary.
+    
+    /** Gets the list of properties stored in a dictionary. 
      *
      * @return The list of properties stored in a dictionary.
      */
     const ValueMap& getProperties() const { return _properties; }
     ValueMap& getProperties() { return _properties; }
-
+    
     /** Sets the list of properties.
      *
      * @param properties The list of properties.
      */
-    void setProperties(const ValueMap& properties) { _properties = properties; }
-
-    /** Gets the array of the objects.
+    void setProperties(const ValueMap& properties) {
+        _properties = properties;
+    }
+    
+    /** Gets the array of the objects. 
      *
      * @return The array of the objects.
      */
     const ValueVector& getObjects() const { return _objects; }
     ValueVector& getObjects() { return _objects; }
-
+    
     /** Sets the array of the objects.
      *
      * @param objects The array of the objects.
      */
-    void setObjects(const ValueVector& objects) { _objects = objects; }
-
+    void setObjects(const ValueVector& objects) {
+        _objects = objects;
+    }
+    
 protected:
     /** name of the group */
     std::string _groupName;
@@ -145,4 +141,4 @@ protected:
 
 NS_CC_END
 
-#endif // CC_2D_TMXOBJECTGROUP_H
+#endif //__CCTMX_OBJECT_GROUP_H__
diff --git a/cocos2d/cocos/2d/CCTMXTiledMap.cpp b/cocos2d/cocos/2d/CCTMXTiledMap.cpp
index 9e7748cc92..b69df5a2ff 100644
--- a/cocos2d/cocos/2d/CCTMXTiledMap.cpp
+++ b/cocos2d/cocos/2d/CCTMXTiledMap.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2009-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,31 +26,18 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCTMXTiledMap.h>
-
-#include <cocos/2d/CCNode.h>
-#include <cocos/2d/CCTMXLayer.h>
-#include <cocos/2d/CCTMXObjectGroup.h>
 #include <cocos/2d/CCTMXXMLParser.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccMacros.h>
+#include <cocos/2d/CCTMXLayer.h>
+#include <cocos/2d/CCSprite.h>
 #include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <algorithm>
-#include <cstdint>
-#include <new>
-#include <string>
-#include <unordered_map>
 
 NS_CC_BEGIN
 
 // implementation TMXTiledMap
 
-TMXTiledMap* TMXTiledMap::create(const std::string& tmxFile)
+TMXTiledMap * TMXTiledMap::create(const std::string& tmxFile)
 {
-    TMXTiledMap* ret = new (std::nothrow) TMXTiledMap();
+    TMXTiledMap *ret = new (std::nothrow) TMXTiledMap();
     if (ret->initWithTMXFile(tmxFile))
     {
         ret->autorelease();
@@ -61,7 +49,7 @@ TMXTiledMap* TMXTiledMap::create(const std::string& tmxFile)
 
 TMXTiledMap* TMXTiledMap::createWithXML(const std::string& tmxString, const std::string& resourcePath)
 {
-    TMXTiledMap* ret = new (std::nothrow) TMXTiledMap();
+    TMXTiledMap *ret = new (std::nothrow) TMXTiledMap();
     if (ret->initWithXML(tmxString, resourcePath))
     {
         ret->autorelease();
@@ -73,19 +61,19 @@ TMXTiledMap* TMXTiledMap::createWithXML(const std::string& tmxString, const std:
 
 bool TMXTiledMap::initWithTMXFile(const std::string& tmxFile)
 {
-    CCASSERT(tmxFile.size() > 0, "TMXTiledMap: tmx file should not be empty");
+    CCASSERT(tmxFile.size()>0, "TMXTiledMap: tmx file should not be empty");
 
     _tmxFile = tmxFile;
 
     setContentSize(Size::ZERO);
 
-    TMXMapInfo* mapInfo = TMXMapInfo::create(tmxFile);
+    TMXMapInfo *mapInfo = TMXMapInfo::create(tmxFile);
 
-    if (!mapInfo)
+    if (! mapInfo)
     {
         return false;
     }
-    CCASSERT(!mapInfo->getTilesets().empty(), "TMXTiledMap: Map not found. Please check the filename.");
+    CCASSERT( !mapInfo->getTilesets().empty(), "TMXTiledMap: Map not found. Please check the filename.");
     buildWithMapInfo(mapInfo);
 
     return true;
@@ -97,19 +85,19 @@ bool TMXTiledMap::initWithXML(const std::string& tmxString, const std::string& r
 
     setContentSize(Size::ZERO);
 
-    TMXMapInfo* mapInfo = TMXMapInfo::createWithXML(tmxString, resourcePath);
+    TMXMapInfo *mapInfo = TMXMapInfo::createWithXML(tmxString, resourcePath);
 
-    CCASSERT(!mapInfo->getTilesets().empty(), "TMXTiledMap: Map not found. Please check the filename.");
+    CCASSERT( !mapInfo->getTilesets().empty(), "TMXTiledMap: Map not found. Please check the filename.");
     buildWithMapInfo(mapInfo);
 
     return true;
 }
 
 TMXTiledMap::TMXTiledMap()
-: _mapSize(Size::ZERO)
-, _tileSize(Size::ZERO)
-, _tmxFile("")
-, _tmxLayerNum(0)
+    :_mapSize(Size::ZERO)
+    ,_tileSize(Size::ZERO)        
+    ,_tmxFile("")
+    , _tmxLayerNum(0)
 {
 }
 
@@ -118,13 +106,13 @@ TMXTiledMap::~TMXTiledMap()
 }
 
 // private
-TMXLayer* TMXTiledMap::parseLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
+TMXLayer * TMXTiledMap::parseLayer(TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo)
 {
-    TMXTilesetInfo* tileset = tilesetForLayer(layerInfo, mapInfo);
+    TMXTilesetInfo *tileset = tilesetForLayer(layerInfo, mapInfo);
     if (tileset == nullptr)
         return nullptr;
-
-    TMXLayer* layer = TMXLayer::create(tileset, layerInfo, mapInfo);
+    
+    TMXLayer *layer = TMXLayer::create(tileset, layerInfo, mapInfo);
 
     if (nullptr != layer)
     {
@@ -136,47 +124,43 @@ TMXLayer* TMXTiledMap::parseLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
     return layer;
 }
 
-TMXTilesetInfo* TMXTiledMap::tilesetForLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo)
+TMXTilesetInfo * TMXTiledMap::tilesetForLayer(TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo)
 {
-    Size size = layerInfo->_layerSize;
+    auto height = static_cast<uint32_t>(layerInfo->_layerSize.height);
+    auto width  = static_cast<uint32_t>(layerInfo->_layerSize.width);
     auto& tilesets = mapInfo->getTilesets();
-    if (tilesets.size() > 0)
+
+    for (auto iter = tilesets.crbegin(), end = tilesets.crend(); iter != end; ++iter)
     {
-        TMXTilesetInfo* tileset = nullptr;
-        for (auto iter = tilesets.crbegin(); iter != tilesets.crend(); ++iter)
+        TMXTilesetInfo* tileset = *iter;
+
+        if (tileset)
         {
-            tileset = *iter;
-            if (tileset)
+            for (uint32_t y = 0; y < height; y++)
             {
-                for (int y = 0; y < size.height; y++)
+                for (uint32_t x = 0; x < width; x++)
                 {
-                    for (int x = 0; x < size.width; x++)
+                    auto pos = x + width * y;
+                    auto gid = layerInfo->_tiles[ pos ];
+
+                    // FIXME:: gid == 0 --> empty tile
+                    if (gid != 0)
                     {
-                        int pos = static_cast<int>(x + size.width * y);
-                        int gid = layerInfo->_tiles[pos];
-
-                        // gid are stored in little endian.
-                        // if host is big endian, then swap
-                        // if( o == CFByteOrderBigEndian )
-                        //    gid = CFSwapInt32( gid );
-                        /* We support little endian.*/
-
-                        // FIXME:: gid == 0 --> empty tile
-                        if (gid != 0)
-                        {
-                            // Optimization: quick return
-                            // if the layer is invalid (more than 1 tileset per layer) an CCAssert will be thrown later
-                            if ((gid & kTMXFlippedMask) >= tileset->_firstGid)
-                                return tileset;
-                        }
+                        // Optimization: quick return
+                        // if the layer is invalid (more than 1 tileset per layer)
+                        // an CCAssert will be thrown later
+                        if (tileset->_firstGid < 0 ||
+                            (gid & kTMXFlippedMask) >= static_cast<uint32_t>(tileset->_firstGid))
+                            return tileset;
                     }
                 }
-            }
+            }        
         }
     }
 
     // If all the tiles are 0, return empty tileset
     CCLOG("cocos2d: Warning: TMX Layer '%s' has no tiles", layerInfo->_name.c_str());
+
     return nullptr;
 }
 
@@ -195,13 +179,10 @@ void TMXTiledMap::buildWithMapInfo(TMXMapInfo* mapInfo)
     int idx = 0;
 
     auto& layers = mapInfo->getLayers();
-    for (const auto& layerInfo : layers)
-    {
-        if (layerInfo->_visible)
-        {
-            TMXLayer* child = parseLayer(layerInfo, mapInfo);
-            if (child == nullptr)
-            {
+    for (const auto &layerInfo : layers) {
+        if (layerInfo->_visible) {
+            TMXLayer *child = parseLayer(layerInfo, mapInfo);
+            if (child == nullptr) {
                 idx++;
                 continue;
             }
@@ -220,16 +201,16 @@ void TMXTiledMap::buildWithMapInfo(TMXMapInfo* mapInfo)
 }
 
 // public
-TMXLayer* TMXTiledMap::getLayer(const std::string& layerName) const
+TMXLayer * TMXTiledMap::getLayer(const std::string& layerName) const
 {
     CCASSERT(layerName.size() > 0, "Invalid layer name!");
-
+    
     for (auto& child : _children)
     {
         TMXLayer* layer = dynamic_cast<TMXLayer*>(child);
-        if (layer)
+        if(layer)
         {
-            if (layerName.compare(layer->getLayerName()) == 0)
+            if(layerName.compare( layer->getLayerName()) == 0)
             {
                 return layer;
             }
@@ -240,20 +221,15 @@ TMXLayer* TMXTiledMap::getLayer(const std::string& layerName) const
     return nullptr;
 }
 
-TMXObjectGroup* TMXTiledMap::getObjectGroup(const std::string& groupName) const
+TMXObjectGroup * TMXTiledMap::getObjectGroup(const std::string& groupName) const
 {
     CCASSERT(groupName.size() > 0, "Invalid group name!");
 
-    if (_objectGroups.size() > 0)
+    for (const auto objectGroup : _objectGroups)
     {
-        TMXObjectGroup* objectGroup = nullptr;
-        for (auto iter = _objectGroups.cbegin(); iter != _objectGroups.cend(); ++iter)
+        if (objectGroup && objectGroup->getGroupName() == groupName)
         {
-            objectGroup = *iter;
-            if (objectGroup && objectGroup->getGroupName() == groupName)
-            {
-                return objectGroup;
-            }
+            return objectGroup;
         }
     }
 
@@ -265,7 +241,7 @@ Value TMXTiledMap::getProperty(const std::string& propertyName) const
 {
     if (_properties.find(propertyName) != _properties.end())
         return _properties.at(propertyName);
-
+    
     return Value();
 }
 
@@ -273,19 +249,16 @@ Value TMXTiledMap::getPropertiesForGID(int GID) const
 {
     if (_tileProperties.find(GID) != _tileProperties.end())
         return _tileProperties.at(GID);
-
+    
     return Value();
 }
 
 bool TMXTiledMap::getPropertiesForGID(int GID, Value** value)
 {
-    if (_tileProperties.find(GID) != _tileProperties.end())
-    {
+    if (_tileProperties.find(GID) != _tileProperties.end()) {
         *value = &_tileProperties.at(GID);
         return true;
-    }
-    else
-    {
+    } else {
         return false;
     }
 }
diff --git a/cocos2d/cocos/2d/CCTMXTiledMap.h b/cocos2d/cocos/2d/CCTMXTiledMap.h
index b7a2cae027..60abcbf0a5 100644
--- a/cocos2d/cocos/2d/CCTMXTiledMap.h
+++ b/cocos2d/cocos/2d/CCTMXTiledMap.h
@@ -3,6 +3,7 @@ Copyright (c) 2009-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,20 +25,12 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_TMXTILEDMAP_H
-#define CC_2D_TMXTILEDMAP_H
+#ifndef __CCTMX_TILE_MAP_H__
+#define __CCTMX_TILE_MAP_H__
 
 #include <cocos/2d/CCNode.h>
 #include <cocos/2d/CCTMXObjectGroup.h>
 #include <cocos/base/CCValue.h>
-#include <cocos/base/CCVector.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
-#include <vector>
 
 NS_CC_BEGIN
 
@@ -62,7 +55,7 @@ enum
 
     /** Isometric orientation. */
     TMXOrientationIso,
-
+    
     /** Isometric staggered orientation. */
     TMXOrientationStaggered,
 };
@@ -72,7 +65,7 @@ enum
 {
     /** Stagger Axis x. */
     TMXStaggerAxis_X,
-
+    
     /** Stagger Axis y. */
     TMXStaggerAxis_Y,
 };
@@ -148,7 +141,7 @@ public:
      */
     static TMXTiledMap* create(const std::string& tmxFile);
 
-    /** Initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources.
+    /** Initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources. 
      *
      * @param tmxString A TMX formatted XML string.
      * @param resourcePath The path to TMX resources.
@@ -157,51 +150,35 @@ public:
      */
     static TMXTiledMap* createWithXML(const std::string& tmxString, const std::string& resourcePath);
 
-    /** Return the TMXLayer for the specific layer.
+    /** Return the TMXLayer for the specific layer. 
      *
      * @param layerName A specific layer.
      * @return The TMXLayer for the specific layer.
      */
     TMXLayer* getLayer(const std::string& layerName) const;
-    /**
-     * @js NA
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE TMXLayer* layerNamed(const std::string& layerName) const { return getLayer(layerName); }
 
-    /** Return the TMXObjectGroup for the specific group.
+    /** Return the TMXObjectGroup for the specific group. 
      *
      * @param groupName The group Name.
      * @return A Type of TMXObjectGroup.
      */
     TMXObjectGroup* getObjectGroup(const std::string& groupName) const;
-    /**
-     * @js NA
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE TMXObjectGroup* objectGroupNamed(const std::string& groupName) const { return getObjectGroup(groupName); }
 
-    /** Return the value for the specific property name.
+    /** Return the value for the specific property name. 
      *
      * @param propertyName The specific property name.
      * @return Return the value for the specific property name.
      */
     Value getProperty(const std::string& propertyName) const;
-    /**
-     * @js NA
-     * @lua NA
-     */
-    CC_DEPRECATED_ATTRIBUTE Value propertyNamed(const char* propertyName) const { return getProperty(propertyName); }
 
-    /** Return properties dictionary for tile GID.
+    /** Return properties dictionary for tile GID. 
      *
      * @param GID The tile GID.
      * @return Return properties dictionary for tile GID.
      */
     Value getPropertiesForGID(int GID) const;
-    CC_DEPRECATED_ATTRIBUTE Value propertiesForGID(int GID) const { return getPropertiesForGID(GID); }
 
-    /** Assigns properties to argument value, returns true if it did found properties
+    /** Assigns properties to argument value, returns true if it did found properties 
      * for that GID and did assigned a value, else it returns false.
      *
      * @param GID The tile GID.
@@ -210,95 +187,99 @@ public:
      */
     bool getPropertiesForGID(int GID, Value** value);
 
-    /** The map's size property measured in tiles.
+    /** The map's size property measured in tiles. 
      *
      * @return The map's size property measured in tiles.
      */
     const Size& getMapSize() const { return _mapSize; }
-
-    /** Set the map's size property measured in tiles.
+    
+    /** Set the map's size property measured in tiles. 
      *
      * @param mapSize The map's size property measured in tiles.
      */
     void setMapSize(const Size& mapSize) { _mapSize = mapSize; }
 
-    /** The tiles's size property measured in pixels.
+    /** The tiles's size property measured in pixels. 
      *
      * @return The tiles's size property measured in pixels.
      */
     const Size& getTileSize() const { return _tileSize; }
-
-    /** Set the tiles's size property measured in pixels.
+    
+    /** Set the tiles's size property measured in pixels. 
      *
      * @param tileSize The tiles's size property measured in pixels.
      */
     void setTileSize(const Size& tileSize) { _tileSize = tileSize; }
 
-    /** Map orientation.
+    /** Map orientation. 
      *
      * @return Map orientation.
      */
     int getMapOrientation() const { return _mapOrientation; }
-
-    /** Set map orientation.
+    
+    /** Set map orientation. 
      *
      * @param mapOrientation The map orientation.
      */
     void setMapOrientation(int mapOrientation) { _mapOrientation = mapOrientation; }
 
-    /** Get the Object groups.
+    /** Get the Object groups. 
      *
      * @return The object groups.
      */
     const Vector<TMXObjectGroup*>& getObjectGroups() const { return _objectGroups; }
     Vector<TMXObjectGroup*>& getObjectGroups() { return _objectGroups; }
-
-    /** Set the object groups.
+    
+    /** Set the object groups. 
      *
      * @param groups The object groups.
      */
-    void setObjectGroups(const Vector<TMXObjectGroup*>& groups) { _objectGroups = groups; }
-
-    /** Properties.
+    void setObjectGroups(const Vector<TMXObjectGroup*>& groups) {
+        _objectGroups = groups;
+    }
+    
+    /** Properties. 
      *
      * @return Properties.
      */
     ValueMap& getProperties() { return _properties; }
-
+    
     /** Set the properties.
      *
      * @param properties A  Type of ValueMap to set the properties.
      */
-    void setProperties(const ValueMap& properties) { _properties = properties; }
-
+    void setProperties(const ValueMap& properties) {
+        _properties = properties;
+    }
+    
     /** Get the description.
      * @js NA
      */
-    std::string getDescription() const override;
+    virtual std::string getDescription() const override;
 
-    int getLayerNum();
+    int  getLayerNum();
     const std::string& getResourceFile() const { return _tmxFile; }
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        TMXTiledMap();
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    TMXTiledMap();
     /**
      * @js NA
      * @lua NA
      */
-    ~TMXTiledMap() override;
-
+    virtual ~TMXTiledMap();
+    
     /** initializes a TMX Tiled Map with a TMX file */
     bool initWithTMXFile(const std::string& tmxFile);
-
+    
     /** initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources */
     bool initWithXML(const std::string& tmxString, const std::string& resourcePath);
 
 protected:
-    TMXLayer* parseLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo);
-    TMXTilesetInfo* tilesetForLayer(TMXLayerInfo* layerInfo, TMXMapInfo* mapInfo);
+    TMXLayer * parseLayer(TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo);
+    TMXTilesetInfo * tilesetForLayer(TMXLayerInfo *layerInfo, TMXMapInfo *mapInfo);
     void buildWithMapInfo(TMXMapInfo* mapInfo);
 
     /** the map's size property measured in tiles */
@@ -311,7 +292,7 @@ protected:
     Vector<TMXObjectGroup*> _objectGroups;
     /** properties */
     ValueMap _properties;
-
+    
     //! tile properties
     ValueMapIntKey _tileProperties;
 
@@ -321,7 +302,8 @@ protected:
     static const int TMXLayerTag = 32768;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TMXTiledMap)
+    CC_DISALLOW_COPY_AND_ASSIGN(TMXTiledMap);
+
 };
 
 // end of tilemap_parallax_nodes group
@@ -329,4 +311,6 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_TMXTILEDMAP_H
+#endif //__CCTMX_TILE_MAP_H__
+
+
diff --git a/cocos2d/cocos/2d/CCTMXXMLParser.cpp b/cocos2d/cocos/2d/CCTMXXMLParser.cpp
index 33a3bf9c67..d09d8a96b6 100644
--- a/cocos2d/cocos/2d/CCTMXXMLParser.cpp
+++ b/cocos2d/cocos/2d/CCTMXXMLParser.cpp
@@ -1,9 +1,10 @@
 /****************************************************************************
-Copyright (c) 2011      Максим Аксенов
+Copyright (c) 2011      Максим Аксенов 
 Copyright (c) 2009-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -27,28 +28,13 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCTMXXMLParser.h>
-
-#include <cocos/2d/CCTMXObjectGroup.h>
+#include <unordered_map>
+#include <sstream>
 #include <cocos/2d/CCTMXTiledMap.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/CCVector.h>
 #include <cocos/base/ZipUtils.h>
 #include <cocos/base/base64.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
+#include <cocos/base/CCDirector.h>
 #include <cocos/platform/CCFileUtils.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/platform/CCSAXParser.h>
-
-#include <cstdlib>
-#include <cstring>
-#include <new>
-#include <sstream>
-#include <string>
-#include <unordered_map>
-#include <utility>
 
 using namespace std;
 
@@ -84,11 +70,11 @@ void TMXLayerInfo::setProperties(ValueMap var)
 
 // implementation TMXTilesetInfo
 TMXTilesetInfo::TMXTilesetInfo()
-: _firstGid(0)
-, _tileSize(Size::ZERO)
-, _spacing(0)
-, _margin(0)
-, _imageSize(Size::ZERO)
+    :_firstGid(0)
+    ,_tileSize(Size::ZERO)
+    ,_spacing(0)
+    ,_margin(0)
+    ,_imageSize(Size::ZERO)
 {
 }
 
@@ -109,7 +95,7 @@ Rect TMXTilesetInfo::getRectForGID(uint32_t gid)
     // but in editor "Tiled", _margin variable only effect the left side
     // for compatible with "Tiled", change the max_x calculation
     int max_x = (int)((_imageSize.width - _margin + _spacing) / (_tileSize.width + _spacing));
-
+    
     rect.origin.x = (gid % max_x) * (_tileSize.width + _spacing) + _margin;
     rect.origin.y = (gid / max_x) * (_tileSize.height + _spacing) + _margin;
     return rect;
@@ -117,9 +103,9 @@ Rect TMXTilesetInfo::getRectForGID(uint32_t gid)
 
 // implementation TMXMapInfo
 
-TMXMapInfo* TMXMapInfo::create(const std::string& tmxFile)
+TMXMapInfo * TMXMapInfo::create(const std::string& tmxFile)
 {
-    TMXMapInfo* ret = new (std::nothrow) TMXMapInfo();
+    TMXMapInfo *ret = new (std::nothrow) TMXMapInfo();
     if (ret->initWithTMXFile(tmxFile))
     {
         ret->autorelease();
@@ -129,9 +115,9 @@ TMXMapInfo* TMXMapInfo::create(const std::string& tmxFile)
     return nullptr;
 }
 
-TMXMapInfo* TMXMapInfo::createWithXML(const std::string& tmxString, const std::string& resourcePath)
+TMXMapInfo * TMXMapInfo::createWithXML(const std::string& tmxString, const std::string& resourcePath)
 {
-    TMXMapInfo* ret = new (std::nothrow) TMXMapInfo();
+    TMXMapInfo *ret = new (std::nothrow) TMXMapInfo();
     if (ret->initWithXML(tmxString, resourcePath))
     {
         ret->autorelease();
@@ -147,12 +133,12 @@ void TMXMapInfo::internalInit(const std::string& tmxFileName, const std::string&
     {
         _TMXFileName = FileUtils::getInstance()->fullPathForFilename(tmxFileName);
     }
-
+    
     if (!resourcePath.empty())
     {
         _resources = resourcePath;
     }
-
+    
     _objectGroups.reserve(4);
 
     // tmp vars
@@ -180,10 +166,10 @@ TMXMapInfo::TMXMapInfo()
 , _staggerAxis(TMXStaggerAxis_Y)
 , _staggerIndex(TMXStaggerIndex_Even)
 , _hexSideLength(0)
-, _parentElement(0)
-, _parentGID(0)
 , _mapSize(Size::ZERO)
 , _tileSize(Size::ZERO)
+, _parentElement(0)
+, _parentGID(0)
 , _layerAttribs(0)
 , _storingCharacters(false)
 , _xmlTileIndex(0)
@@ -205,7 +191,7 @@ bool TMXMapInfo::parseXMLString(const std::string& xmlString)
 
     SAXParser parser;
 
-    if (false == parser.init("UTF-8"))
+    if (false == parser.init("UTF-8") )
     {
         return false;
     }
@@ -218,21 +204,21 @@ bool TMXMapInfo::parseXMLString(const std::string& xmlString)
 bool TMXMapInfo::parseXMLFile(const std::string& xmlFilename)
 {
     SAXParser parser;
-
-    if (false == parser.init("UTF-8"))
+    
+    if (false == parser.init("UTF-8") )
     {
         return false;
     }
-
+    
     parser.setDelegator(this);
 
     return parser.parse(FileUtils::getInstance()->fullPathForFilename(xmlFilename));
 }
 
 // the XML parser calls here with all the elements
-void TMXMapInfo::startElement(void*, const char* name, const char** atts)
-{
-    TMXMapInfo* tmxMapInfo = this;
+void TMXMapInfo::startElement(void* /*ctx*/, const char *name, const char **atts)
+{    
+    TMXMapInfo *tmxMapInfo = this;
     std::string elementName = name;
     ValueMap attributeDict;
     if (atts && atts[0])
@@ -240,59 +226,51 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
         for (int i = 0; atts[i]; i += 2)
         {
             std::string key = atts[i];
-            std::string value = atts[i + 1];
-            attributeDict.insert(std::make_pair(key, Value(value)));
+            std::string value = atts[i+1];
+            attributeDict.emplace(key, Value(value));
         }
     }
     if (elementName == "map")
     {
         std::string version = attributeDict["version"].asString();
-        if (version != "1.0")
+        if ( version != "1.0")
         {
             CCLOG("cocos2d: TMXFormat: Unsupported TMX version: %s", version.c_str());
         }
         std::string orientationStr = attributeDict["orientation"].asString();
-        if (orientationStr == "orthogonal")
-        {
+        if (orientationStr == "orthogonal") {
             tmxMapInfo->setOrientation(TMXOrientationOrtho);
         }
-        else if (orientationStr == "isometric")
-        {
+        else if (orientationStr  == "isometric") {
             tmxMapInfo->setOrientation(TMXOrientationIso);
         }
-        else if (orientationStr == "hexagonal")
-        {
+        else if (orientationStr == "hexagonal") {
             tmxMapInfo->setOrientation(TMXOrientationHex);
         }
-        else if (orientationStr == "staggered")
-        {
+        else if (orientationStr == "staggered") {
             tmxMapInfo->setOrientation(TMXOrientationStaggered);
         }
-        else
-        {
+        else {
             CCLOG("cocos2d: TMXFomat: Unsupported orientation: %d", tmxMapInfo->getOrientation());
         }
-
+        
         std::string staggerAxisStr = attributeDict["staggeraxis"].asString();
-        if (staggerAxisStr == "x")
-        {
+        if (staggerAxisStr == "x") {
             tmxMapInfo->setStaggerAxis(TMXStaggerAxis_X);
         }
-        else if (staggerAxisStr == "y")
-        {
+        else if (staggerAxisStr  == "y") {
             tmxMapInfo->setStaggerAxis(TMXStaggerAxis_Y);
         }
 
         std::string staggerIndex = attributeDict["staggerindex"].asString();
-        if (staggerIndex == "odd")
-        {
+        if (staggerIndex == "odd") {
             tmxMapInfo->setStaggerIndex(TMXStaggerIndex_Odd);
         }
-        else if (staggerIndex == "even")
-        {
+        else if (staggerIndex == "even") {
             tmxMapInfo->setStaggerIndex(TMXStaggerIndex_Even);
         }
 
+
         float hexSideLength = attributeDict["hexsidelength"].asFloat();
         tmxMapInfo->setHexSideLength(hexSideLength);
 
@@ -305,10 +283,12 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
         s.height = attributeDict["tileheight"].asFloat();
         tmxMapInfo->setTileSize(s);
 
+        
+
         // The parent element is now "map"
         tmxMapInfo->setParentElement(TMXPropertyMap);
-    }
-    else if (elementName == "tileset")
+    } 
+    else if (elementName == "tileset") 
     {
         // If this is an external tileset then start parsing that
         std::string externalTilesetFilename = attributeDict["source"].asString();
@@ -317,36 +297,36 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
             _externalTilesetFilename = externalTilesetFilename;
 
             // Tileset file will be relative to the map file. So we need to convert it to an absolute path
-            if (_TMXFileName.find_last_of("/") != string::npos)
+            if (_TMXFileName.find_last_of('/') != string::npos)
             {
-                string dir = _TMXFileName.substr(0, _TMXFileName.find_last_of("/") + 1);
+                string dir = _TMXFileName.substr(0, _TMXFileName.find_last_of('/') + 1);
                 externalTilesetFilename = dir + externalTilesetFilename;
             }
-            else
+            else 
             {
                 externalTilesetFilename = _resources + "/" + externalTilesetFilename;
             }
             externalTilesetFilename = FileUtils::getInstance()->fullPathForFilename(externalTilesetFilename);
-
+            
             _currentFirstGID = attributeDict["firstgid"].asInt();
             if (_currentFirstGID < 0)
             {
                 _currentFirstGID = 0;
             }
             _recordFirstGID = false;
-
+            
             tmxMapInfo->parseXMLFile(externalTilesetFilename);
         }
         else
         {
-            TMXTilesetInfo* tileset = new (std::nothrow) TMXTilesetInfo();
+            TMXTilesetInfo *tileset = new (std::nothrow) TMXTilesetInfo();
             tileset->_name = attributeDict["name"].asString();
-
+            
             if (_recordFirstGID)
             {
                 // unset before, so this is tmx file.
                 tileset->_firstGid = attributeDict["firstgid"].asInt();
-
+                
                 if (tileset->_firstGid < 0)
                 {
                     tileset->_firstGid = 0;
@@ -357,7 +337,7 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
                 tileset->_firstGid = _currentFirstGID;
                 _currentFirstGID = 0;
             }
-
+            
             tileset->_spacing = attributeDict["spacing"].asInt();
             tileset->_margin = attributeDict["margin"].asInt();
             Size s;
@@ -375,9 +355,9 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
         {
             TMXLayerInfo* layer = tmxMapInfo->getLayers().back();
             Size layerSize = layer->_layerSize;
-            uint32_t gid = static_cast<uint32_t>(attributeDict["gid"].asInt());
-            int tilesAmount = layerSize.width * layerSize.height;
-
+            uint32_t gid = static_cast<uint32_t>(attributeDict["gid"].asUnsignedInt());
+            int tilesAmount = layerSize.width*layerSize.height;
+            
             if (_xmlTileIndex < tilesAmount)
             {
                 layer->_tiles[_xmlTileIndex++] = gid;
@@ -393,7 +373,7 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
     }
     else if (elementName == "layer")
     {
-        TMXLayerInfo* layer = new (std::nothrow) TMXLayerInfo();
+        TMXLayerInfo *layer = new (std::nothrow) TMXLayerInfo();
         layer->_name = attributeDict["name"].asString();
 
         Size s;
@@ -416,10 +396,10 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
 
         // The parent element is now "layer"
         tmxMapInfo->setParentElement(TMXPropertyLayer);
-    }
+    } 
     else if (elementName == "objectgroup")
     {
-        TMXObjectGroup* objectGroup = new (std::nothrow) TMXObjectGroup();
+        TMXObjectGroup *objectGroup = new (std::nothrow) TMXObjectGroup();
         objectGroup->setGroupName(attributeDict["name"].asString());
         Vec2 positionOffset;
         positionOffset.x = attributeDict["x"].asFloat() * tmxMapInfo->getTileSize().width;
@@ -435,12 +415,13 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
     else if (elementName == "tileoffset")
     {
         TMXTilesetInfo* tileset = tmxMapInfo->getTilesets().back();
-
-        double tileOffsetX = attributeDict["x"].asDouble();
-
-        double tileOffsetY = attributeDict["y"].asDouble();
-
+        
+        float tileOffsetX = attributeDict["x"].asFloat();
+        
+        float tileOffsetY = attributeDict["y"].asFloat();
+        
         tileset->_tileOffset = Vec2(tileOffsetX, tileOffsetY);
+        
     }
     else if (elementName == "image")
     {
@@ -450,16 +431,16 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
         std::string imagename = attributeDict["source"].asString();
         tileset->_originSourceImage = imagename;
 
-        if (_TMXFileName.find_last_of("/") != string::npos)
+        if (_TMXFileName.find_last_of('/') != string::npos)
         {
-            string dir = _TMXFileName.substr(0, _TMXFileName.find_last_of("/") + 1);
+            string dir = _TMXFileName.substr(0, _TMXFileName.find_last_of('/') + 1);
             tileset->_sourceImage = dir + imagename;
         }
-        else
+        else 
         {
             tileset->_sourceImage = _resources + (_resources.size() ? "/" : "") + imagename;
         }
-    }
+    } 
     else if (elementName == "data")
     {
         std::string encoding = attributeDict["encoding"].asString();
@@ -468,14 +449,14 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
         if (encoding == "")
         {
             tmxMapInfo->setLayerAttribs(tmxMapInfo->getLayerAttribs() | TMXLayerAttribNone);
-
+            
             TMXLayerInfo* layer = tmxMapInfo->getLayers().back();
             Size layerSize = layer->_layerSize;
-            int tilesAmount = layerSize.width * layerSize.height;
+            int tilesAmount = layerSize.width*layerSize.height;
 
-            uint32_t* tiles = (uint32_t*)malloc(tilesAmount * sizeof(uint32_t));
+            uint32_t *tiles = (uint32_t*) malloc(tilesAmount*sizeof(uint32_t));
             // set all value to 0
-            memset(tiles, 0, tilesAmount * sizeof(int));
+            memset(tiles, 0, tilesAmount*sizeof(int));
 
             layer->_tiles = tiles;
         }
@@ -489,13 +470,13 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
             {
                 layerAttribs = tmxMapInfo->getLayerAttribs();
                 tmxMapInfo->setLayerAttribs(layerAttribs | TMXLayerAttribGzip);
-            }
-            else if (compression == "zlib")
+            } else
+            if (compression == "zlib")
             {
                 layerAttribs = tmxMapInfo->getLayerAttribs();
                 tmxMapInfo->setLayerAttribs(layerAttribs | TMXLayerAttribZlib);
             }
-            CCASSERT(compression == "" || compression == "gzip" || compression == "zlib", "TMX: unsupported compression method");
+            CCASSERT( compression == "" || compression == "gzip" || compression == "zlib", "TMX: unsupported compression method" );
         }
         else if (encoding == "csv")
         {
@@ -513,7 +494,7 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
         ValueMap dict;
         // Parse everything automatically
         const char* keys[] = {"name", "type", "width", "height", "gid", "id"};
-
+        
         for (const auto& key : keys)
         {
             Value value = attributeDict[key];
@@ -525,13 +506,12 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
         int x = attributeDict["x"].asInt();
         // Y
         int y = attributeDict["y"].asInt();
-
-        Vec2 p(x + objectGroup->getPositionOffset().x,
-               _mapSize.height * _tileSize.height - y - objectGroup->getPositionOffset().y - attributeDict["height"].asInt());
+        
+        Vec2 p(x + objectGroup->getPositionOffset().x, _mapSize.height * _tileSize.height - y  - objectGroup->getPositionOffset().y - attributeDict["height"].asInt());
         p = CC_POINT_PIXELS_TO_POINTS(p);
         dict["x"] = Value(p.x);
         dict["y"] = Value(p.y);
-
+        
         int width = attributeDict["width"].asInt();
         int height = attributeDict["height"].asInt();
         Size s(width, height);
@@ -539,44 +519,46 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
         dict["width"] = Value(s.width);
         dict["height"] = Value(s.height);
 
+        dict["rotation"] = attributeDict["rotation"].asDouble();
+
         // Add the object to the objectGroup
         objectGroup->getObjects().push_back(Value(dict));
 
         // The parent element is now "object"
         tmxMapInfo->setParentElement(TMXPropertyObject);
-    }
+    } 
     else if (elementName == "property")
     {
-        if (tmxMapInfo->getParentElement() == TMXPropertyNone)
+        if ( tmxMapInfo->getParentElement() == TMXPropertyNone ) 
         {
-            CCLOG("TMX tile map: Parent element is unsupported. Cannot add property named '%s' with value '%s'", attributeDict["name"].asString().c_str(),
-                  attributeDict["value"].asString().c_str());
-        }
-        else if (tmxMapInfo->getParentElement() == TMXPropertyMap)
+            CCLOG( "TMX tile map: Parent element is unsupported. Cannot add property named '%s' with value '%s'",
+                  attributeDict["name"].asString().c_str(), attributeDict["value"].asString().c_str() );
+        } 
+        else if ( tmxMapInfo->getParentElement() == TMXPropertyMap )
         {
             // The parent element is the map
             Value value = attributeDict["value"];
             std::string key = attributeDict["name"].asString();
-            tmxMapInfo->getProperties().insert(std::make_pair(key, value));
+            tmxMapInfo->getProperties().emplace(key, value);
         }
-        else if (tmxMapInfo->getParentElement() == TMXPropertyLayer)
+        else if ( tmxMapInfo->getParentElement() == TMXPropertyLayer )
         {
             // The parent element is the last layer
             TMXLayerInfo* layer = tmxMapInfo->getLayers().back();
             Value value = attributeDict["value"];
             std::string key = attributeDict["name"].asString();
             // Add the property to the layer
-            layer->getProperties().insert(std::make_pair(key, value));
+            layer->getProperties().emplace(key, value);
         }
-        else if (tmxMapInfo->getParentElement() == TMXPropertyObjectGroup)
+        else if ( tmxMapInfo->getParentElement() == TMXPropertyObjectGroup ) 
         {
             // The parent element is the last object group
             TMXObjectGroup* objectGroup = tmxMapInfo->getObjectGroups().back();
             Value value = attributeDict["value"];
             std::string key = attributeDict["name"].asString();
-            objectGroup->getProperties().insert(std::make_pair(key, value));
+            objectGroup->getProperties().emplace(key, value);
         }
-        else if (tmxMapInfo->getParentElement() == TMXPropertyObject)
+        else if ( tmxMapInfo->getParentElement() == TMXPropertyObject )
         {
             // The parent element is the last object
             TMXObjectGroup* objectGroup = tmxMapInfo->getObjectGroups().back();
@@ -585,7 +567,7 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
             std::string propertyName = attributeDict["name"].asString();
             dict[propertyName] = attributeDict["value"];
         }
-        else if (tmxMapInfo->getParentElement() == TMXPropertyTile)
+        else if ( tmxMapInfo->getParentElement() == TMXPropertyTile ) 
         {
             ValueMap& dict = tmxMapInfo->getTileProperties().at(tmxMapInfo->getParentGID()).asValueMap();
 
@@ -593,7 +575,7 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
             dict[propertyName] = attributeDict["value"];
         }
     }
-    else if (elementName == "polygon")
+    else if (elementName == "polygon") 
     {
         // find parent object's dict and add polygon-points to it
         TMXObjectGroup* objectGroup = _objectGroups.back();
@@ -614,7 +596,7 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
                 // parse each point combo into a comma-separated x,y point
                 stringstream pointStream(pointPair);
                 string xStr, yStr;
-
+                
                 ValueMap pointDict;
 
                 // set x
@@ -630,27 +612,27 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
                     int y = atoi(yStr.c_str()) + (int)objectGroup->getPositionOffset().y;
                     pointDict["y"] = Value(y);
                 }
-
+                
                 // add to points array
                 pointsArray.push_back(Value(pointDict));
             }
-
+            
             dict["points"] = Value(pointsArray);
         }
-    }
+    } 
     else if (elementName == "polyline")
     {
         // find parent object's dict and add polyline-points to it
         TMXObjectGroup* objectGroup = _objectGroups.back();
         ValueMap& dict = objectGroup->getObjects().rbegin()->asValueMap();
-
+        
         // get points value string
         std::string value = attributeDict["points"].asString();
         if (!value.empty())
         {
             ValueVector pointsArray;
             pointsArray.reserve(10);
-
+            
             // parse points string into a space-separated set of points
             stringstream pointsStream(value);
             string pointPair;
@@ -659,35 +641,35 @@ void TMXMapInfo::startElement(void*, const char* name, const char** atts)
                 // parse each point combo into a comma-separated x,y point
                 stringstream pointStream(pointPair);
                 string xStr, yStr;
-
+                
                 ValueMap pointDict;
-
+                
                 // set x
                 if (std::getline(pointStream, xStr, ','))
                 {
                     int x = atoi(xStr.c_str()) + (int)objectGroup->getPositionOffset().x;
                     pointDict["x"] = Value(x);
                 }
-
+                
                 // set y
                 if (std::getline(pointStream, yStr, ','))
                 {
                     int y = atoi(yStr.c_str()) + (int)objectGroup->getPositionOffset().y;
                     pointDict["y"] = Value(y);
                 }
-
+                
                 // add to points array
                 pointsArray.push_back(Value(pointDict));
             }
-
+            
             dict["polylinePoints"] = Value(pointsArray);
         }
     }
 }
 
-void TMXMapInfo::endElement(void*, const char* name)
+void TMXMapInfo::endElement(void* /*ctx*/, const char *name)
 {
-    TMXMapInfo* tmxMapInfo = this;
+    TMXMapInfo *tmxMapInfo = this;
     std::string elementName = name;
 
     if (elementName == "data")
@@ -695,49 +677,49 @@ void TMXMapInfo::endElement(void*, const char* name)
         if (tmxMapInfo->getLayerAttribs() & TMXLayerAttribBase64)
         {
             tmxMapInfo->setStoringCharacters(false);
-
+            
             TMXLayerInfo* layer = tmxMapInfo->getLayers().back();
-
+            
             std::string currentString = tmxMapInfo->getCurrentString();
-            unsigned char* buffer;
+            unsigned char *buffer;
             auto len = base64Decode((unsigned char*)currentString.c_str(), (unsigned int)currentString.length(), &buffer);
             if (!buffer)
             {
                 CCLOG("cocos2d: TiledMap: decode data error");
                 return;
             }
-
+            
             if (tmxMapInfo->getLayerAttribs() & (TMXLayerAttribGzip | TMXLayerAttribZlib))
             {
-                unsigned char* deflated = nullptr;
+                unsigned char *deflated = nullptr;
                 Size s = layer->_layerSize;
                 // int sizeHint = s.width * s.height * sizeof(uint32_t);
-                std::size_t sizeHint = s.width * s.height * sizeof(unsigned int);
-
-                std::size_t CC_UNUSED inflatedLen = ZipUtils::inflateMemoryWithHint(buffer, len, &deflated, sizeHint);
+                ssize_t sizeHint = s.width * s.height * sizeof(unsigned int);
+                
+                ssize_t CC_UNUSED inflatedLen = ZipUtils::inflateMemoryWithHint(buffer, len, &deflated, sizeHint);
                 CCASSERT(inflatedLen == sizeHint, "inflatedLen should be equal to sizeHint!");
-
+                
                 free(buffer);
                 buffer = nullptr;
-
+                
                 if (!deflated)
                 {
                     CCLOG("cocos2d: TiledMap: inflate data error");
                     return;
                 }
-
+                
                 layer->_tiles = reinterpret_cast<uint32_t*>(deflated);
             }
             else
             {
                 layer->_tiles = reinterpret_cast<uint32_t*>(buffer);
             }
-
+            
             tmxMapInfo->setCurrentString("");
         }
         else if (tmxMapInfo->getLayerAttribs() & TMXLayerAttribCSV)
         {
-            unsigned char* buffer;
+            unsigned char *buffer;
 
             TMXLayerInfo* layer = tmxMapInfo->getLayers().back();
 
@@ -747,12 +729,10 @@ void TMXMapInfo::endElement(void*, const char* name)
             vector<string> gidTokens;
             istringstream filestr(currentString);
             string sRow;
-            while (getline(filestr, sRow, '\n'))
-            {
+            while(getline(filestr, sRow, '\n')) {
                 string sGID;
                 istringstream rowstr(sRow);
-                while (getline(rowstr, sGID, ','))
-                {
+                while (getline(rowstr, sGID, ',')) {
                     gidTokens.push_back(sGID);
                 }
             }
@@ -766,9 +746,8 @@ void TMXMapInfo::endElement(void*, const char* name)
             }
 
             uint32_t* bufferPtr = reinterpret_cast<uint32_t*>(buffer);
-            for (auto gidToken : gidTokens)
-            {
-                auto tileGid = (uint32_t)strtol(gidToken.c_str(), nullptr, 10);
+            for(const auto& gidToken : gidTokens) {
+                auto tileGid = (uint32_t)strtoul(gidToken.c_str(), nullptr, 10);
                 *bufferPtr = tileGid;
                 bufferPtr++;
             }
@@ -786,7 +765,7 @@ void TMXMapInfo::endElement(void*, const char* name)
     {
         // The map element has ended
         tmxMapInfo->setParentElement(TMXPropertyNone);
-    }
+    }    
     else if (elementName == "layer")
     {
         // The layer element has ended
@@ -796,8 +775,8 @@ void TMXMapInfo::endElement(void*, const char* name)
     {
         // The objectgroup element has ended
         tmxMapInfo->setParentElement(TMXPropertyNone);
-    }
-    else if (elementName == "object")
+    } 
+    else if (elementName == "object") 
     {
         // The object element has ended
         tmxMapInfo->setParentElement(TMXPropertyNone);
@@ -808,9 +787,9 @@ void TMXMapInfo::endElement(void*, const char* name)
     }
 }
 
-void TMXMapInfo::textHandler(void*, const char* ch, size_t len)
+void TMXMapInfo::textHandler(void* /*ctx*/, const char *ch, size_t len)
 {
-    TMXMapInfo* tmxMapInfo = this;
+    TMXMapInfo *tmxMapInfo = this;
     std::string text(ch, 0, len);
 
     if (tmxMapInfo->isStoringCharacters())
diff --git a/cocos2d/cocos/2d/CCTMXXMLParser.h b/cocos2d/cocos/2d/CCTMXXMLParser.h
index d91c2d7faf..ac7c8cdd4f 100644
--- a/cocos2d/cocos/2d/CCTMXXMLParser.h
+++ b/cocos2d/cocos/2d/CCTMXXMLParser.h
@@ -3,6 +3,7 @@ Copyright (c) 2009-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,25 +26,19 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_TMXXMLPARSER_H
-#define CC_2D_TMXXMLPARSER_H
+
+#ifndef __CC_TM_XML_PARSER__
+#define __CC_TM_XML_PARSER__
 
 /// @cond DO_NOT_SHOW
 
-#include <cocos/2d/CCTMXObjectGroup.h>
-#include <cocos/base/CCRef.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/CCVector.h>
 #include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
 #include <cocos/platform/CCSAXParser.h>
+#include <cocos/base/CCVector.h>
+#include <cocos/base/CCValue.h>
+#include <cocos/2d/CCTMXObjectGroup.h> // needed for Vector<TMXObjectGroup*> for binding
 
-#include <cstddef>
-#include <cstdint>
-#include <iosfwd>
-#include <vector>
+#include <string>
 
 NS_CC_BEGIN
 
@@ -51,20 +46,19 @@ class TMXLayerInfo;
 class TMXTilesetInfo;
 
 /** @file
- * Internal TMX parser
- *
- * IMPORTANT: These classed should not be documented using doxygen strings
- * since the user should not use them.
- *
- */
+* Internal TMX parser
+*
+* IMPORTANT: These classed should not be documented using doxygen strings
+* since the user should not use them.
+*
+*/
 
 /**
  * @addtogroup tilemap_parallax_nodes
  * @{
  */
 
-enum
-{
+enum {
     TMXLayerAttribNone = 1 << 0,
     TMXLayerAttribBase64 = 1 << 1,
     TMXLayerAttribGzip = 1 << 2,
@@ -72,8 +66,7 @@ enum
     TMXLayerAttribCSV = 1 << 4,
 };
 
-enum
-{
+enum {
     TMXPropertyNone,
     TMXPropertyMap,
     TMXPropertyLayer,
@@ -82,13 +75,12 @@ enum
     TMXPropertyTile
 };
 
-typedef enum TMXTileFlags_
-{
-    kTMXTileHorizontalFlag = 0x80000000,
-    kTMXTileVerticalFlag = 0x40000000,
-    kTMXTileDiagonalFlag = 0x20000000,
-    kTMXFlipedAll = (kTMXTileHorizontalFlag | kTMXTileVerticalFlag | kTMXTileDiagonalFlag),
-    kTMXFlippedMask = ~(kTMXFlipedAll)
+typedef enum TMXTileFlags_ {
+    kTMXTileHorizontalFlag  = 0x80000000,
+    kTMXTileVerticalFlag    = 0x40000000,
+    kTMXTileDiagonalFlag    = 0x20000000,
+    kTMXFlipedAll           = (kTMXTileHorizontalFlag|kTMXTileVerticalFlag|kTMXTileDiagonalFlag),
+    kTMXFlippedMask         = ~(kTMXFlipedAll)
 } TMXTileFlags;
 
 // Bits on the far end of the 32-bit global tile ID (GID's) are used for tile flags
@@ -117,14 +109,14 @@ public:
     void setProperties(ValueMap properties);
     ValueMap& getProperties();
 
-    ValueMap _properties;
-    std::string _name;
-    Size _layerSize;
-    uint32_t* _tiles;
-    bool _visible;
-    unsigned char _opacity;
-    bool _ownTiles;
-    Vec2 _offset;
+    ValueMap            _properties;
+    std::string         _name;
+    Size                _layerSize;
+    uint32_t            *_tiles;
+    bool                _visible;
+    unsigned char       _opacity;
+    bool                _ownTiles;
+    Vec2               _offset;
 };
 
 /** @brief TMXTilesetInfo contains the information about the tilesets like:
@@ -135,22 +127,22 @@ public:
 - Image used for the tiles
 - Image size
 
-This information is obtained from the TMX file.
+This information is obtained from the TMX file. 
 */
 class CC_DLL TMXTilesetInfo : public Ref
 {
 public:
-    std::string _name;
-    int _firstGid;
-    Size _tileSize;
-    int _spacing;
-    int _margin;
-    Vec2 _tileOffset;
+    std::string     _name;
+    int             _firstGid;
+    Size            _tileSize;
+    int             _spacing;
+    int             _margin;
+    Vec2            _tileOffset;
     //! filename containing the tiles (should be spritesheet / texture atlas)
-    std::string _sourceImage;
+    std::string     _sourceImage;
     //! size in pixels of the image
-    Size _imageSize;
-    std::string _originSourceImage;
+    Size            _imageSize;
+    std::string     _originSourceImage;
 
 public:
     /**
@@ -179,20 +171,13 @@ This information is obtained from the TMX file.
 
 */
 class CC_DLL TMXMapInfo : public Ref, public SAXDelegator
-{
-public:
+{    
+public:    
     /** creates a TMX Format with a tmx file */
-    static TMXMapInfo* create(const std::string& tmxFile);
+    static TMXMapInfo * create(const std::string& tmxFile);
     /** creates a TMX Format with an XML string and a TMX resource path */
-    static TMXMapInfo* createWithXML(const std::string& tmxString, const std::string& resourcePath);
-
-    /** creates a TMX Format with a tmx file */
-    CC_DEPRECATED_ATTRIBUTE static TMXMapInfo* formatWithTMXFile(const char* tmxFile) { return TMXMapInfo::create(tmxFile); }
-    /** creates a TMX Format with an XML string and a TMX resource path */
-    CC_DEPRECATED_ATTRIBUTE static TMXMapInfo* formatWithXML(const char* tmxString, const char* resourcePath)
-    {
-        return TMXMapInfo::createWithXML(tmxString, resourcePath);
-    }
+    static TMXMapInfo * createWithXML(const std::string& tmxString, const std::string& resourcePath);
+    
     /**
      * @js ctor
      */
@@ -201,8 +186,8 @@ public:
      * @js NA
      * @lua NA
      */
-    ~TMXMapInfo() override;
-
+    virtual ~TMXMapInfo();
+    
     /** initializes a TMX format with a  tmx file */
     bool initWithTMXFile(const std::string& tmxFile);
     /** initializes a TMX format with an XML string and a TMX resource path */
@@ -212,13 +197,15 @@ public:
     /* initializes parsing of an XML string, either a tmx (Map) string or tsx (Tileset) string */
     bool parseXMLString(const std::string& xmlString);
 
-    ValueMapIntKey& getTileProperties() { return _tileProperties; }
-    void setTileProperties(const ValueMapIntKey& tileProperties) { _tileProperties = tileProperties; }
+    ValueMapIntKey& getTileProperties() { return _tileProperties; };
+    void setTileProperties(const ValueMapIntKey& tileProperties) {
+        _tileProperties = tileProperties;
+    }
 
     /// map orientation
     int getOrientation() const { return _orientation; }
     void setOrientation(int orientation) { _orientation = orientation; }
-
+    
     /// map staggeraxis
     int getStaggerAxis() const { return _staggerAxis; }
     void setStaggerAxis(int staggerAxis) { _staggerAxis = staggerAxis; }
@@ -238,21 +225,27 @@ public:
     /// tiles width & height
     const Size& getTileSize() const { return _tileSize; }
     void setTileSize(const Size& tileSize) { _tileSize = tileSize; }
-
+    
     /// Layers
     const Vector<TMXLayerInfo*>& getLayers() const { return _layers; }
     Vector<TMXLayerInfo*>& getLayers() { return _layers; }
-    void setLayers(const Vector<TMXLayerInfo*>& layers) { _layers = layers; }
+    void setLayers(const Vector<TMXLayerInfo*>& layers) {
+        _layers = layers;
+    }
 
     /// tilesets
     const Vector<TMXTilesetInfo*>& getTilesets() const { return _tilesets; }
     Vector<TMXTilesetInfo*>& getTilesets() { return _tilesets; }
-    void setTilesets(const Vector<TMXTilesetInfo*>& tilesets) { _tilesets = tilesets; }
+    void setTilesets(const Vector<TMXTilesetInfo*>& tilesets) {
+        _tilesets = tilesets;
+    }
 
     /// ObjectGroups
     const Vector<TMXObjectGroup*>& getObjectGroups() const { return _objectGroups; }
     Vector<TMXObjectGroup*>& getObjectGroups() { return _objectGroups; }
-    void setObjectGroups(const Vector<TMXObjectGroup*>& groups) { _objectGroups = groups; }
+    void setObjectGroups(const Vector<TMXObjectGroup*>& groups) {
+        _objectGroups = groups;
+    }
 
     /// parent element
     int getParentElement() const { return _parentElement; }
@@ -268,48 +261,49 @@ public:
 
     /// is storing characters?
     bool isStoringCharacters() const { return _storingCharacters; }
-    CC_DEPRECATED_ATTRIBUTE bool getStoringCharacters() const { return isStoringCharacters(); }
     void setStoringCharacters(bool storingCharacters) { _storingCharacters = storingCharacters; }
 
     /// properties
     const ValueMap& getProperties() const { return _properties; }
     ValueMap& getProperties() { return _properties; }
-    void setProperties(const ValueMap& properties) { _properties = properties; }
-
+    void setProperties(const ValueMap& properties) {
+        _properties = properties;
+    }
+    
     // implement pure virtual methods of SAXDelegator
     /**
      * @js NA
      * @lua NA
      */
-    void startElement(void* ctx, const char* name, const char** atts) override;
+    void startElement(void *ctx, const char *name, const char **atts) override;
     /**
      * @js NA
      * @lua NA
      */
-    void endElement(void* ctx, const char* name) override;
+    void endElement(void *ctx, const char *name) override;
     /**
      * @js NA
      * @lua NA
      */
-    void textHandler(void* ctx, const char* ch, size_t len) override;
-
+    void textHandler(void *ctx, const char *ch, size_t len) override;
+    
     const std::string& getCurrentString() const { return _currentString; }
-    void setCurrentString(const std::string& currentString) { _currentString = currentString; }
+    void setCurrentString(const std::string& currentString){ _currentString = currentString; }
     const std::string& getTMXFileName() const { return _TMXFileName; }
-    void setTMXFileName(const std::string& fileName) { _TMXFileName = fileName; }
+    void setTMXFileName(const std::string& fileName){ _TMXFileName = fileName; }
     const std::string& getExternalTilesetFileName() const { return _externalTilesetFilename; }
 
 protected:
     void internalInit(const std::string& tmxFileName, const std::string& resourcePath);
 
     /// map orientation
-    int _orientation;
-    /// map staggerAxis
-    int _staggerAxis;
-    /// map staggerIndex
-    int _staggerIndex;
-    /// map hexsidelength
-    int _hexSideLength;
+    int    _orientation;
+    ///map staggerAxis
+    int    _staggerAxis;
+    ///map staggerIndex
+    int    _staggerIndex;
+    ///map hexsidelength
+    int    _hexSideLength;
     /// map width & height
     Size _mapSize;
     /// tiles width & height
@@ -332,7 +326,7 @@ protected:
     ValueMap _properties;
     //! xml format tile index
     int _xmlTileIndex;
-
+    
     //! tmx filename
     std::string _TMXFileName;
     // tmx resource path
@@ -352,4 +346,4 @@ protected:
 NS_CC_END
 
 /// @endcond
-#endif // CC_2D_TMXXMLPARSER_H
+#endif
diff --git a/cocos2d/cocos/2d/CCTextFieldTTF.cpp b/cocos2d/cocos/2d/CCTextFieldTTF.cpp
index 8a162358c0..9dae196fe4 100644
--- a/cocos2d/cocos/2d/CCTextFieldTTF.cpp
+++ b/cocos2d/cocos/2d/CCTextFieldTTF.cpp
@@ -1,6 +1,7 @@
 /****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,44 +26,23 @@ THE SOFTWARE.
 
 #include <cocos/2d/CCTextFieldTTF.h>
 
-#include <cocos/2d/CCLabel.h>
-#include <cocos/2d/CCNode.h>
-#include <cocos/2d/CCSprite.h>
 #include <cocos/base/CCDirector.h>
-#include <cocos/base/CCEventKeyboard.h>
-#include <cocos/base/CCIMEDelegate.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
 #include <cocos/platform/CCFileUtils.h>
-#include <cocos/platform/CCGLView.h>
-#include <cocos/platform/CCPlatformConfig.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <new>
-#include <string>
-#include <vector>
-
-namespace cocos2d
-{
-    class Camera;
-    class Renderer;
-} // namespace cocos2d
+#include <cocos/base/ccUTF8.h>
+#include <cocos/2d/CCSprite.h>
 
 NS_CC_BEGIN
 
 #define CURSOR_TIME_SHOW_HIDE 0.5f
 #define CURSOR_DEFAULT_CHAR '|'
 #define PASSWORD_STYLE_TEXT_DEFAULT "\xe2\x80\xa2"
-static int _calcCharCount(const char* text)
+static std::size_t _calcCharCount(const char * text)
 {
     int n = 0;
     char ch = 0;
     while ((ch = *text))
     {
-        CC_BREAK_IF(!ch);
+        CC_SAFE_DELETE_ARRAY(! ch);;
 
         if (0x80 != (0xC0 & ch))
         {
@@ -73,44 +53,40 @@ static int _calcCharCount(const char* text)
     return n;
 }
 
-// TextFieldDelegate
-
-TextFieldDelegate::~TextFieldDelegate()
-{
-}
-
-bool TextFieldDelegate::onTextFieldAttachWithIME(TextFieldTTF*)
+bool TextFieldDelegate::onTextFieldAttachWithIME(TextFieldTTF* /*sender*/)
 {
     return false;
 }
 
-bool TextFieldDelegate::onTextFieldDetachWithIME(TextFieldTTF*)
+bool TextFieldDelegate::onTextFieldDetachWithIME(TextFieldTTF* /*sender*/)
 {
     return false;
 }
 
-bool TextFieldDelegate::onTextFieldInsertText(TextFieldTTF*, const char*, size_t)
+bool TextFieldDelegate::onTextFieldInsertText(TextFieldTTF* /*sender*/, const char* /*text*/, size_t /*nLen*/)
 {
     return false;
 }
 
-bool TextFieldDelegate::onTextFieldDeleteBackward(TextFieldTTF*, const char*, size_t)
+bool TextFieldDelegate::onTextFieldDeleteBackward(TextFieldTTF* /*sender*/, const char* /*delText*/, size_t /*nLen*/)
 {
     return false;
 }
 
-bool TextFieldDelegate::onVisit(TextFieldTTF*, Renderer*, const Mat4&, uint32_t)
+bool TextFieldDelegate::onVisit(TextFieldTTF* /*sender*/, Renderer* /*renderer*/, const Mat4& /*transform*/, uint32_t /*flags*/)
 {
     return false;
 }
 
-// TextFieldTTF
+//////////////////////////////////////////////////////////////////////////
+// constructor and destructor
+//////////////////////////////////////////////////////////////////////////
 
 TextFieldTTF::TextFieldTTF()
-: _delegate(nullptr)
+: _delegate(0)
 , _charCount(0)
 , _inputText("")
-, _placeHolder("") // prevent Label initWithString assertion
+, _placeHolder("")   // prevent Label initWithString assertion
 , _colorText(Color4B::WHITE)
 , _secureTextEntry(false)
 , _passwordStyleText(PASSWORD_STYLE_TEXT_DEFAULT)
@@ -132,14 +108,13 @@ TextFieldTTF::~TextFieldTTF()
 // static constructor
 //////////////////////////////////////////////////////////////////////////
 
-TextFieldTTF* TextFieldTTF::textFieldWithPlaceHolder(const std::string& placeholder, const Size& dimensions, TextHAlignment alignment,
-                                                     const std::string& fontName, float fontSize)
+TextFieldTTF * TextFieldTTF::textFieldWithPlaceHolder(const std::string& placeholder, const Size& dimensions, TextHAlignment alignment, const std::string& fontName, float fontSize)
 {
-    TextFieldTTF* ret = new (std::nothrow) TextFieldTTF();
-    if (ret && ret->initWithPlaceHolder("", dimensions, alignment, fontName, fontSize))
+    TextFieldTTF *ret = new (std::nothrow) TextFieldTTF();
+    if(ret && ret->initWithPlaceHolder("", dimensions, alignment, fontName, fontSize))
     {
         ret->autorelease();
-        if (placeholder.size() > 0)
+        if (placeholder.size()>0)
         {
             ret->setPlaceHolder(placeholder);
         }
@@ -149,13 +124,13 @@ TextFieldTTF* TextFieldTTF::textFieldWithPlaceHolder(const std::string& placehol
     return nullptr;
 }
 
-TextFieldTTF* TextFieldTTF::textFieldWithPlaceHolder(const std::string& placeholder, const std::string& fontName, float fontSize)
+TextFieldTTF * TextFieldTTF::textFieldWithPlaceHolder(const std::string& placeholder, const std::string& fontName, float fontSize)
 {
-    TextFieldTTF* ret = new (std::nothrow) TextFieldTTF();
-    if (ret && ret->initWithPlaceHolder("", fontName, fontSize))
+    TextFieldTTF *ret = new (std::nothrow) TextFieldTTF();
+    if(ret && ret->initWithPlaceHolder("", fontName, fontSize))
     {
         ret->autorelease();
-        if (placeholder.size() > 0)
+        if (placeholder.size()>0)
         {
             ret->setPlaceHolder(placeholder);
         }
@@ -180,7 +155,7 @@ bool TextFieldTTF::initWithPlaceHolder(const std::string& placeholder, const std
 {
     _placeHolder = placeholder;
 
-    do
+    do 
     {
         // If fontName is ttf file and it corrected, use TTFConfig
         if (FileUtils::getInstance()->isFileExist(fontName))
@@ -196,8 +171,8 @@ bool TextFieldTTF::initWithPlaceHolder(const std::string& placeholder, const std
         setSystemFontSize(fontSize);
 
     } while (false);
-
-    Label::setTextColor(_colorSpaceHolder);
+    
+    setTextColorInternally(_colorSpaceHolder);
     Label::setString(_placeHolder);
 
 #if (CC_TARGET_PLATFORM == CC_PLATFORM_MAC || CC_TARGET_PLATFORM == CC_PLATFORM_WIN32 || CC_TARGET_PLATFORM == CC_PLATFORM_LINUX)
@@ -257,21 +232,21 @@ void TextFieldTTF::didDetachWithIME()
 
 bool TextFieldTTF::canAttachWithIME()
 {
-    return (_delegate) ? (!_delegate->onTextFieldAttachWithIME(this)) : true;
+    return (_delegate) ? (! _delegate->onTextFieldAttachWithIME(this)) : true;
 }
 
 bool TextFieldTTF::canDetachWithIME()
 {
-    return (_delegate) ? (!_delegate->onTextFieldDetachWithIME(this)) : true;
+    return (_delegate) ? (! _delegate->onTextFieldDetachWithIME(this)) : true;
 }
 
-void TextFieldTTF::insertText(const char* text, size_t len)
+void TextFieldTTF::insertText(const char * text, size_t len)
 {
     std::string insert(text, len);
 
     // insert \n means input end
-    int pos = static_cast<int>(insert.find(static_cast<char>(TextFormatter::NewLine)));
-    if (static_cast<int>(insert.npos) != pos)
+    int pos = static_cast<int>(insert.find(StringUtils::AsciiCharacters::NewLine));
+    if ((int)insert.npos != pos)
     {
         len = pos;
         insert.erase(pos);
@@ -285,7 +260,7 @@ void TextFieldTTF::insertText(const char* text, size_t len)
             return;
         }
 
-        int countInsertChar = _calcCharCount(insert.c_str());
+        std::size_t countInsertChar = _calcCharCount(insert.c_str());
         _charCount += countInsertChar;
 
         if (_cursorEnabled)
@@ -307,8 +282,7 @@ void TextFieldTTF::insertText(const char* text, size_t len)
         }
     }
 
-    if ((int)insert.npos == pos)
-    {
+    if ((int)insert.npos == pos) {
         return;
     }
 
@@ -325,16 +299,16 @@ void TextFieldTTF::insertText(const char* text, size_t len)
 void TextFieldTTF::deleteBackward()
 {
     size_t len = _inputText.length();
-    if (!len)
+    if (! len)
     {
         // there is no string
         return;
     }
 
     // get the delete byte number
-    size_t deleteLen = 1; // default, erase 1 byte
+    size_t deleteLen = 1;    // default, erase 1 byte
 
-    while (0x80 == (0xC0 & _inputText.at(len - deleteLen)))
+    while(0x80 == (0xC0 & _inputText.at(len - deleteLen)))
     {
         ++deleteLen;
     }
@@ -378,21 +352,21 @@ void TextFieldTTF::deleteBackward()
     }
 }
 
-const std::string& TextFieldTTF::getContentText() const
+const std::string& TextFieldTTF::getContentText()
 {
     return _inputText;
 }
 
 void TextFieldTTF::setCursorPosition(std::size_t cursorPosition)
 {
-    if (_cursorEnabled && cursorPosition <= static_cast<std::size_t>(_charCount))
+    if (_cursorEnabled && cursorPosition <= (std::size_t)_charCount)
     {
         _cursorPosition = cursorPosition;
         _cursorShowingTime = CURSOR_TIME_SHOW_HIDE * 2.0f;
     }
 }
 
-void TextFieldTTF::setCursorFromPoint(const Vec2& point, const Camera* camera)
+void TextFieldTTF::setCursorFromPoint(const Vec2 &point, const Camera* camera)
 {
     if (_cursorEnabled)
     {
@@ -408,14 +382,17 @@ void TextFieldTTF::setCursorFromPoint(const Vec2& point, const Camera* camera)
             int latterPosition = 0;
             for (; latterPosition < _lengthOfString; ++latterPosition)
             {
-                if (_lettersInfo[latterPosition].valid)
+                if (_lettersInfo[latterPosition].valid && _lettersInfo[latterPosition].atlasIndex >= 0)
                 {
                     auto sprite = getLetter(latterPosition);
-                    rect.size = sprite->getContentSize();
-                    if (isScreenPointInRect(point, camera, sprite->getWorldToNodeTransform(), rect, nullptr))
+                    if (sprite)
                     {
-                        setCursorPosition(latterPosition);
-                        break;
+                        rect.size = Size(sprite->getContentSize().width, _lineHeight);
+                        if (isScreenPointInRect(point, camera, sprite->getWorldToNodeTransform(), rect, nullptr))
+                        {
+                            setCursorPosition(latterPosition);
+                            break;
+                        }
                     }
                 }
             }
@@ -445,22 +422,32 @@ void TextFieldTTF::setAttachWithIME(bool isAttachWithIME)
     }
 }
 
-void TextFieldTTF::setTextColor(const Color4B& color)
+void TextFieldTTF::setTextColorInternally(const Color4B& color)
+{
+    if (_currentLabelType == LabelType::BMFONT) {
+        Label::setColor(Color3B(color));
+        return;
+    }
+    
+    Label::setTextColor(color);
+}
+
+void TextFieldTTF::setTextColor(const Color4B &color)
 {
     _colorText = color;
     if (!_inputText.empty())
     {
-        Label::setTextColor(_colorText);
+        setTextColorInternally(color);
     }
 }
 
-void TextFieldTTF::visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags)
+void TextFieldTTF::visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags)
 {
-    if (_delegate && _delegate->onVisit(this, renderer, parentTransform, parentFlags))
+    if (_delegate && _delegate->onVisit(this,renderer,parentTransform,parentFlags))
     {
         return;
     }
-    Label::visit(renderer, parentTransform, parentFlags);
+    Label::visit(renderer,parentTransform,parentFlags);
 }
 
 void TextFieldTTF::update(float delta)
@@ -473,10 +460,13 @@ void TextFieldTTF::update(float delta)
             _cursorShowingTime = CURSOR_TIME_SHOW_HIDE;
         }
         // before cursor inserted '\b', need next letter
-        auto sprite = getLetter(static_cast<int>(_cursorPosition) + 1);
+        auto sprite = getLetter((int)_cursorPosition + 1);
 
         if (sprite)
         {
+            if (_currentLabelType == LabelType::BMFONT) {
+                sprite->setColor(getColor());
+            }
             if (_cursorShowingTime >= 0.0f)
             {
                 sprite->setOpacity(255);
@@ -497,14 +487,7 @@ const Color4B& TextFieldTTF::getColorSpaceHolder()
 
 void TextFieldTTF::setColorSpaceHolder(const Color3B& color)
 {
-    _colorSpaceHolder.r = color.r;
-    _colorSpaceHolder.g = color.g;
-    _colorSpaceHolder.b = color.b;
-    _colorSpaceHolder.a = 255;
-    if (_inputText.empty())
-    {
-        Label::setTextColor(_colorSpaceHolder);
-    }
+    setColorSpaceHolder(Color4B(color));
 }
 
 void TextFieldTTF::setColorSpaceHolder(const Color4B& color)
@@ -512,7 +495,7 @@ void TextFieldTTF::setColorSpaceHolder(const Color4B& color)
     _colorSpaceHolder = color;
     if (_inputText.empty())
     {
-        Label::setTextColor(_colorSpaceHolder);
+        setTextColorInternally(_colorSpaceHolder);
     }
 }
 
@@ -521,11 +504,12 @@ void TextFieldTTF::setColorSpaceHolder(const Color4B& color)
 //////////////////////////////////////////////////////////////////////////
 
 // input text property
-void TextFieldTTF::setString(const std::string& text)
+void TextFieldTTF::setString(const std::string &text)
 {
     std::string displayText;
 
     std::size_t charCount = 0;
+
     if (!text.empty())
     {
         _inputText = text;
@@ -534,7 +518,7 @@ void TextFieldTTF::setString(const std::string& text)
         if (_secureTextEntry)
         {
             displayText = "";
-            int length = static_cast<int>(charCount);
+            size_t length = charCount;
             while (length)
             {
                 displayText.append(_passwordStyleText);
@@ -561,19 +545,20 @@ void TextFieldTTF::setString(const std::string& text)
     // if there is no input text, display placeholder instead
     if (_inputText.empty() && (!_cursorEnabled || !_isAttachWithIME))
     {
-        Label::setTextColor(_colorSpaceHolder);
+        setTextColorInternally(_colorSpaceHolder);
         Label::setString(_placeHolder);
     }
     else
     {
         makeStringSupportCursor(displayText);
-
-        Label::setTextColor(_colorText);
+        setTextColorInternally(_colorText);
         Label::setString(displayText);
     }
     _charCount = charCount;
 }
 
+
+
 void TextFieldTTF::appendString(const std::string& text)
 {
     insertText(text.c_str(), text.length());
@@ -586,7 +571,8 @@ void TextFieldTTF::makeStringSupportCursor(std::string& displayText)
         if (displayText.empty())
         {
             // \b - Next char not change x position
-            displayText.push_back(static_cast<char>(TextFormatter::NextCharNoChangeX));
+            if (_currentLabelType == LabelType::TTF || _currentLabelType == LabelType::BMFONT)
+                displayText.push_back(StringUtils::AsciiCharacters::NextCharNoChangeX);
             displayText.push_back(_cursorChar);
         }
         else
@@ -601,7 +587,8 @@ void TextFieldTTF::makeStringSupportCursor(std::string& displayText)
             }
             std::string cursorChar;
             // \b - Next char not change x position
-            cursorChar.push_back(static_cast<char>(TextFormatter::NextCharNoChangeX));
+            if (_currentLabelType == LabelType::TTF || _currentLabelType == LabelType::BMFONT)
+                cursorChar.push_back(StringUtils::AsciiCharacters::NextCharNoChangeX);
             cursorChar.push_back(_cursorChar);
             stringUTF8.insert(_cursorPosition, cursorChar);
 
@@ -631,47 +618,47 @@ void TextFieldTTF::controlKey(EventKeyboard::KeyCode keyCode)
     {
         switch (keyCode)
         {
-            case EventKeyboard::KeyCode::KEY_HOME:
-            case EventKeyboard::KeyCode::KEY_KP_HOME:
-                setCursorPosition(0);
+        case EventKeyboard::KeyCode::KEY_HOME:
+        case EventKeyboard::KeyCode::KEY_KP_HOME:
+            setCursorPosition(0);
+            updateCursorDisplayText();
+            break;
+        case EventKeyboard::KeyCode::KEY_END:
+            setCursorPosition(_charCount);
+            updateCursorDisplayText();
+            break;
+        case EventKeyboard::KeyCode::KEY_DELETE:
+        case EventKeyboard::KeyCode::KEY_KP_DELETE:
+            if (_cursorPosition < (std::size_t)_charCount)
+            {
+                StringUtils::StringUTF8 stringUTF8;
+
+                stringUTF8.replace(_inputText);
+                stringUTF8.deleteChar(_cursorPosition);
+                setCursorPosition(_cursorPosition);
+                _charCount = stringUTF8.length();
+                setString(stringUTF8.getAsCharSequence());
+            }
+            break;
+        case EventKeyboard::KeyCode::KEY_LEFT_ARROW:
+            if (_cursorPosition)
+            {
+                setCursorPosition(_cursorPosition - 1);
                 updateCursorDisplayText();
-                break;
-            case EventKeyboard::KeyCode::KEY_END:
-                setCursorPosition(_charCount);
+            }
+            break;
+        case EventKeyboard::KeyCode::KEY_RIGHT_ARROW:
+            if (_cursorPosition < (std::size_t)_charCount)
+            {
+                setCursorPosition(_cursorPosition + 1);
                 updateCursorDisplayText();
-                break;
-            case EventKeyboard::KeyCode::KEY_DELETE:
-            case EventKeyboard::KeyCode::KEY_KP_DELETE:
-                if (_cursorPosition < _charCount)
-                {
-                    StringUtils::StringUTF8 stringUTF8;
-
-                    stringUTF8.replace(_inputText);
-                    stringUTF8.deleteChar(_cursorPosition);
-                    setCursorPosition(_cursorPosition);
-                    _charCount = stringUTF8.length();
-                    setString(stringUTF8.getAsCharSequence());
-                }
-                break;
-            case EventKeyboard::KeyCode::KEY_LEFT_ARROW:
-                if (_cursorPosition)
-                {
-                    setCursorPosition(_cursorPosition - 1);
-                    updateCursorDisplayText();
-                }
-                break;
-            case EventKeyboard::KeyCode::KEY_RIGHT_ARROW:
-                if (_cursorPosition < _charCount)
-                {
-                    setCursorPosition(_cursorPosition + 1);
-                    updateCursorDisplayText();
-                }
-                break;
-            case EventKeyboard::KeyCode::KEY_ESCAPE:
-                detachWithIME();
-                break;
-            default:
-                break;
+            }
+            break;
+        case EventKeyboard::KeyCode::KEY_ESCAPE:
+            detachWithIME();
+            break;
+        default:
+            break;
         }
     }
 }
@@ -685,9 +672,9 @@ const std::string& TextFieldTTF::getString() const
 void TextFieldTTF::setPlaceHolder(const std::string& text)
 {
     _placeHolder = text;
-    if (_inputText.empty())
+    if (_inputText.empty() && !_isAttachWithIME)
     {
-        Label::setTextColor(_colorSpaceHolder);
+        setTextColorInternally(_colorSpaceHolder);
         Label::setString(_placeHolder);
     }
 }
@@ -699,28 +686,24 @@ const std::string& TextFieldTTF::getPlaceHolder() const
 
 void TextFieldTTF::setCursorEnabled(bool enabled)
 {
-    if (_currentLabelType == LabelType::TTF)
+    if (_cursorEnabled == enabled)
     {
-        if (_cursorEnabled != enabled)
-        {
-            _cursorEnabled = enabled;
-            if (_cursorEnabled)
-            {
-                _cursorPosition = _charCount;
-
-                scheduleUpdate();
-            }
-            else
-            {
-                _cursorPosition = 0;
-
-                unscheduleUpdate();
-            }
-        }
+        return;
     }
-    else
+    
+    _cursorEnabled = enabled;
+    if (_cursorEnabled)
     {
-        CCLOG("TextFieldTTF cursor worked only LabelType::TTF");
+        _cursorPosition = _charCount;
+        if (_currentLabelType == LabelType::TTF || _currentLabelType == LabelType::BMFONT) {
+            scheduleUpdate();
+        }
+        return;
+    }
+    
+    _cursorPosition = 0;
+    if (_currentLabelType == LabelType::TTF || _currentLabelType == LabelType::BMFONT) {
+        unscheduleUpdate();
     }
 }
 
@@ -734,15 +717,14 @@ void TextFieldTTF::setSecureTextEntry(bool value)
     }
 }
 
-void TextFieldTTF::setPasswordTextStyle(const std::string& text)
+void TextFieldTTF::setPasswordTextStyle(const std::string &text)
 {
     if (text.length() < 1)
     {
         return;
     }
 
-    if (text != _passwordStyleText)
-    {
+    if (text != _passwordStyleText) {
         _passwordStyleText = text;
         setString(_inputText);
     }
@@ -759,3 +741,4 @@ bool TextFieldTTF::isSecureTextEntry() const
 }
 
 NS_CC_END
+
diff --git a/cocos2d/cocos/2d/CCTextFieldTTF.h b/cocos2d/cocos/2d/CCTextFieldTTF.h
index 9acae1001c..8dd4855e71 100644
--- a/cocos2d/cocos/2d/CCTextFieldTTF.h
+++ b/cocos2d/cocos/2d/CCTextFieldTTF.h
@@ -1,6 +1,7 @@
 /****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -23,22 +24,11 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_TEXTFIELDTTF_H
-#define CC_2D_TEXTFIELDTTF_H
+#ifndef __CC_TEXT_FIELD_H__
+#define __CC_TEXT_FIELD_H__
 
 #include <cocos/2d/CCLabel.h>
-#include <cocos/base/CCEventKeyboard.h>
 #include <cocos/base/CCIMEDelegate.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Mat4.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <cstddef>
-#include <cstdint>
-#include <iosfwd>
 
 /**
  * @addtogroup ui
@@ -46,10 +36,9 @@ THE SOFTWARE.
  */
 NS_CC_BEGIN
 
-class Camera;
-class Renderer;
 class TextFieldTTF;
 
+
 /**
  * A input protocol for TextField.
  */
@@ -60,33 +49,32 @@ public:
      * Destructor for TextFieldDelegate.
      * @js NA
      */
-    virtual ~TextFieldDelegate();
+    virtual ~TextFieldDelegate() {}
 
     /**
      *@brief    If the sender doesn't want to attach to the IME, return true.
      */
-    virtual bool onTextFieldAttachWithIME(TextFieldTTF*);
-
+    virtual bool onTextFieldAttachWithIME(TextFieldTTF* sender);
     /**
      *@brief    If the sender doesn't want to detach from the IME, return true.
      */
-    virtual bool onTextFieldDetachWithIME(TextFieldTTF*);
+    virtual bool onTextFieldDetachWithIME(TextFieldTTF* sender);
 
     /**
      *@brief    If the sender doesn't want to insert the text, return true.
      */
-    virtual bool onTextFieldInsertText(TextFieldTTF*, const char*, size_t);
+    virtual bool onTextFieldInsertText(TextFieldTTF* sender, const char* text, size_t nLen);
 
     /**
      *@brief    If the sender doesn't want to delete the delText, return true.
      */
-    virtual bool onTextFieldDeleteBackward(TextFieldTTF*, const char*, size_t);
+    virtual bool onTextFieldDeleteBackward(TextFieldTTF* sender, const char* delText, size_t nLen);
 
     /**
      *@brief    If the sender doesn't want to draw, return true.
      * @js NA
      */
-    virtual bool onVisit(TextFieldTTF*, Renderer*, const Mat4&, uint32_t);
+    virtual bool onVisit(TextFieldTTF* sender, Renderer* renderer, const Mat4& transform, uint32_t flags);
 };
 
 /**
@@ -100,40 +88,39 @@ public:
      * @js ctor
      */
     TextFieldTTF();
-
+    
     /**
      * Default destructor.
      * @js NA
      * @lua NA
      */
-    ~TextFieldTTF() override;
+    virtual ~TextFieldTTF();
 
     /** Creates a TextFieldTTF from a fontname, alignment, dimension and font size.
-     * @js NA
-     */
-    static TextFieldTTF*
-    textFieldWithPlaceHolder(const std::string& placeholder, const Size& dimensions, TextHAlignment alignment, const std::string& fontName, float fontSize);
-
+    * @js NA
+    */
+    static TextFieldTTF * textFieldWithPlaceHolder(const std::string& placeholder, const Size& dimensions, TextHAlignment alignment, const std::string& fontName, float fontSize);
+    
     /** Creates a TextFieldTTF from a fontname and font size.
-     * @js NA
-     */
-    static TextFieldTTF* textFieldWithPlaceHolder(const std::string& placeholder, const std::string& fontName, float fontSize);
-
+    * @js NA
+    */
+    static TextFieldTTF * textFieldWithPlaceHolder(const std::string& placeholder, const std::string& fontName, float fontSize);
+    
     /** Initializes the TextFieldTTF with a font name, alignment, dimension and font size. */
     bool initWithPlaceHolder(const std::string& placeholder, const Size& dimensions, TextHAlignment alignment, const std::string& fontName, float fontSize);
-
+    
     /** Initializes the TextFieldTTF with a font name and font size. */
     bool initWithPlaceHolder(const std::string& placeholder, const std::string& fontName, float fontSize);
 
     /**
      *@brief    Open keyboard and receive input text.
      */
-    bool attachWithIME() override;
+    virtual bool attachWithIME() override;
 
     /**
      *@brief    End text input and close keyboard.
      */
-    bool detachWithIME() override;
+    virtual bool detachWithIME() override;
 
     //////////////////////////////////////////////////////////////////////////
     // properties
@@ -141,18 +128,18 @@ public:
     /**
      * @lua NA
      */
-    inline TextFieldDelegate* getDelegate() const noexcept { return _delegate; }
+    TextFieldDelegate* getDelegate() const { return _delegate; }
     /**
      * @lua NA
      */
-    inline void setDelegate(TextFieldDelegate* delegate) noexcept { _delegate = delegate; }
+    void setDelegate(TextFieldDelegate* delegate) { _delegate = delegate; }
 
     /**
      * Query the currently inputed character count.
      *@return The total input character count.
      */
-    inline std::size_t getCharCount() const noexcept { return _charCount; }
-
+    std::size_t getCharCount() const { return _charCount; }
+    
     /**
      * Query the color of place holder.
      *@return The place holder color.
@@ -175,25 +162,25 @@ public:
      * Change the color of input text.
      *@param textColor The text color in Color4B.
      */
-    void setTextColor(const Color4B& textColor) override;
+    virtual void setTextColor(const Color4B& textColor) override;
 
     /**
      * Change input text of TextField.
      *@param text The input text of TextField.
      */
-    void setString(const std::string& text) override;
+    virtual void setString(const std::string& text) override;
 
     /**
-     * Append to input text of TextField.
-     *@param text The append text of TextField.
-     */
+    * Append to input text of TextField.
+    *@param text The append text of TextField.
+    */
     virtual void appendString(const std::string& text);
 
     /**
      * Query the input text of TextField.
      *@return Get the input text of TextField.
      */
-    const std::string& getString() const override;
+    virtual const std::string& getString() const override;
 
     /**
      * Change placeholder text.
@@ -223,51 +210,51 @@ public:
      *@return Whether current text is displayed as secure text entry.
      * @js NA
      */
-    virtual bool isSecureTextEntry() const;
+    virtual bool isSecureTextEntry()const;
 
-    void visit(Renderer* renderer, const Mat4& parentTransform, uint32_t parentFlags) override;
+    virtual void visit(Renderer *renderer, const Mat4 &parentTransform, uint32_t parentFlags) override;
 
-    void update(float delta) override;
+    virtual void update(float delta) override;
 
     /**
-     * Set enable cursor use.
-     * @js NA
-     */
+    * Set enable cursor use.
+    * @js NA
+    */
     void setCursorEnabled(bool enabled);
 
     /**
-     * Set char showing cursor.
-     * @js NA
-     */
+    * Set char showing cursor.
+    * @js NA
+    */
     void setCursorChar(char cursor);
 
     /**
-     * Set cursor position, if enabled
-     * @js NA
-     */
+    * Set cursor position, if enabled
+    * @js NA
+    */
     void setCursorPosition(std::size_t cursorPosition);
 
     /**
-     * Set cursor position to hit letter, if enabled
-     * @js NA
-     */
-    void setCursorFromPoint(const Vec2& point, const Camera* camera);
+    * Set cursor position to hit letter, if enabled
+    * @js NA
+    */
+    void setCursorFromPoint(const Vec2 &point, const Camera* camera);
 
 protected:
     //////////////////////////////////////////////////////////////////////////
     // IMEDelegate interface
     //////////////////////////////////////////////////////////////////////////
 
-    bool canAttachWithIME() override;
-    bool canDetachWithIME() override;
-    void didAttachWithIME() override;
-    void didDetachWithIME() override;
-    void insertText(const char* text, size_t len) override;
-    void deleteBackward() override;
-    std::string const& getContentText() const override;
-    void controlKey(EventKeyboard::KeyCode keyCode) override;
+    virtual bool canAttachWithIME() override;
+    virtual bool canDetachWithIME() override;
+    virtual void didAttachWithIME() override;
+    virtual void didDetachWithIME() override;
+    virtual void insertText(const char * text, size_t len) override;
+    virtual void deleteBackward() override;
+    virtual const std::string& getContentText() override;
+    virtual void controlKey(EventKeyboard::KeyCode keyCode) override;
 
-    TextFieldDelegate* _delegate;
+    TextFieldDelegate * _delegate;
     std::size_t _charCount;
 
     std::string _inputText;
@@ -293,14 +280,15 @@ protected:
     void makeStringSupportCursor(std::string& displayText);
     void updateCursorDisplayText();
     void setAttachWithIME(bool isAttachWithIME);
+    void setTextColorInternally(const Color4B& color);
 
 private:
     class LengthStack;
-    LengthStack* _lens;
+    LengthStack * _lens;
 };
 
 NS_CC_END
 // end of ui group
 /// @}
 
-#endif // CC_2D_TEXTFIELDTTF_H
+#endif    // __CC_TEXT_FIELD_H__
diff --git a/cocos2d/cocos/2d/CCTileMapAtlas.cpp b/cocos2d/cocos/2d/CCTileMapAtlas.cpp
index 558cc9892d..65911659f5 100644
--- a/cocos2d/cocos/2d/CCTileMapAtlas.cpp
+++ b/cocos2d/cocos/2d/CCTileMapAtlas.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,35 +26,19 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 #include <cocos/2d/CCTileMapAtlas.h>
-
-#include <cocos/2d/CCAtlasNode.h>
-#include <cocos/base/CCDirector.h>
-#include <cocos/base/CCValue.h>
-#include <cocos/base/TGAlib.h>
-#include <cocos/base/ccConfig.h>
-#include <cocos/base/ccMacros.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/base/ccUTF8.h>
-#include <cocos/math/CCGeometry.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/math/Vec3.h>
 #include <cocos/platform/CCFileUtils.h>
-#include <cocos/platform/CCPlatformMacros.h>
-#include <cocos/renderer/CCTexture2D.h>
 #include <cocos/renderer/CCTextureAtlas.h>
-
-#include <cstddef>
-#include <new>
-#include <string>
-#include <unordered_map>
+#include <cocos/base/TGAlib.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/base/ccUTF8.h>
 
 NS_CC_BEGIN
 
 // implementation TileMapAtlas
 
-TileMapAtlas* TileMapAtlas::create(const std::string& tile, const std::string& mapFile, int tileWidth, int tileHeight)
+TileMapAtlas * TileMapAtlas::create(const std::string& tile, const std::string& mapFile, int tileWidth, int tileHeight)
 {
-    TileMapAtlas* ret = new (std::nothrow) TileMapAtlas();
+    TileMapAtlas *ret = new (std::nothrow) TileMapAtlas();
     if (ret->initWithTileFile(tile, mapFile, tileWidth, tileHeight))
     {
         ret->autorelease();
@@ -68,18 +53,19 @@ bool TileMapAtlas::initWithTileFile(const std::string& tile, const std::string&
     this->loadTGAfile(mapFile);
     this->calculateItemsToRender();
 
-    if (AtlasNode::initWithTileFile(tile, tileWidth, tileHeight, _itemsToRender))
+    if( AtlasNode::initWithTileFile(tile, tileWidth, tileHeight, _itemsToRender) )
     {
         this->updateAtlasValues();
-        this->setContentSize(Size((float)(_TGAInfo->width * _itemWidth), (float)(_TGAInfo->height * _itemHeight)));
+        this->setContentSize(Size((float)(_TGAInfo->width*_itemWidth),
+                                        (float)(_TGAInfo->height*_itemHeight)));
         return true;
     }
     return false;
 }
 
 TileMapAtlas::TileMapAtlas()
-: _itemsToRender(0)
-, _TGAInfo(nullptr)
+ : _itemsToRender(0)
+ , _TGAInfo(nullptr)
 {
 }
 
@@ -102,16 +88,16 @@ void TileMapAtlas::releaseMap()
 
 void TileMapAtlas::calculateItemsToRender()
 {
-    CCASSERT(_TGAInfo != nullptr, "tgaInfo must be non-nil");
+    CCASSERT( _TGAInfo != nullptr, "tgaInfo must be non-nil");
 
     _itemsToRender = 0;
-    for (int x = 0; x < _TGAInfo->width; x++)
+    for(int x=0;x < _TGAInfo->width; x++ ) 
     {
-        for (int y = 0; y < _TGAInfo->height; y++)
+        for( int y=0; y < _TGAInfo->height; y++ ) 
         {
-            Color3B* ptr = (Color3B*)_TGAInfo->imageData;
+            Color3B *ptr = (Color3B*) _TGAInfo->imageData;
             Color3B value = ptr[x + y * _TGAInfo->width];
-            if (value.r)
+            if( value.r )
             {
                 ++_itemsToRender;
             }
@@ -128,9 +114,9 @@ void TileMapAtlas::loadTGAfile(const std::string& file)
     //    String *resourcePath = [mainBndl resourcePath];
     //    String * path = [resourcePath stringByAppendingPathComponent:file];
 
-    _TGAInfo = tgaLoad(fullPath.c_str());
+    _TGAInfo = tgaLoad( fullPath.c_str() );
 #if 1
-    if (_TGAInfo->status != TGA_OK)
+    if( _TGAInfo->status != TGA_OK ) 
     {
         CCASSERT(0, "TileMapAtlasLoadTGA : TileMapAtlas cannot load TGA file");
     }
@@ -145,12 +131,12 @@ void TileMapAtlas::setTile(const Color3B& tile, const Vec2& position)
     CCASSERT(position.y < _TGAInfo->height, "Invalid position.x");
     CCASSERT(tile.r != 0, "R component must be non 0");
 
-    Color3B* ptr = (Color3B*)_TGAInfo->imageData;
+    Color3B *ptr = (Color3B*)_TGAInfo->imageData;
     Color3B value = ptr[(unsigned int)(position.x + position.y * _TGAInfo->width)];
-    if (value.r == 0)
+    if( value.r == 0 )
     {
         CCLOG("cocos2d: Value.r must be non 0.");
-    }
+    } 
     else
     {
         ptr[(unsigned int)(position.x + position.y * _TGAInfo->width)] = tile;
@@ -161,48 +147,48 @@ void TileMapAtlas::setTile(const Color3B& tile, const Vec2& position)
         int num = _posToAtlasIndex[key].asInt();
 
         this->updateAtlasValueAt(position, tile, num);
-    }
+    }    
 }
 
 Color3B TileMapAtlas::getTileAt(const Vec2& position) const
 {
-    CCASSERT(_TGAInfo != nullptr, "tgaInfo must not be nil");
-    CCASSERT(position.x < _TGAInfo->width, "Invalid position.x");
-    CCASSERT(position.y < _TGAInfo->height, "Invalid position.y");
+    CCASSERT( _TGAInfo != nullptr, "tgaInfo must not be nil");
+    CCASSERT( position.x < _TGAInfo->width, "Invalid position.x");
+    CCASSERT( position.y < _TGAInfo->height, "Invalid position.y");
 
-    Color3B* ptr = (Color3B*)_TGAInfo->imageData;
+    Color3B *ptr = (Color3B*)_TGAInfo->imageData;
     Color3B value = ptr[(unsigned int)(position.x + position.y * _TGAInfo->width)];
 
-    return value;
+    return value;    
 }
 
 void TileMapAtlas::updateAtlasValueAt(const Vec2& pos, const Color3B& value, int index)
 {
-    CCASSERT(index >= 0 && index < _textureAtlas->getCapacity(), "updateAtlasValueAt: Invalid index");
+    CCASSERT( index >= 0 && index < _textureAtlas->getCapacity(), "updateAtlasValueAt: Invalid index");
 
     V3F_C4B_T2F_Quad* quad = &((_textureAtlas->getQuads())[index]);
 
     int x = pos.x;
     int y = pos.y;
-    float row = (float)(value.r % _itemsPerRow);
-    float col = (float)(value.r / _itemsPerRow);
+    float row = (float) (value.r % _itemsPerRow);
+    float col = (float) (value.r / _itemsPerRow);
 
-    float textureWide = (float)(_textureAtlas->getTexture()->getPixelsWide());
-    float textureHigh = (float)(_textureAtlas->getTexture()->getPixelsHigh());
+    float textureWide = (float) (_textureAtlas->getTexture()->getPixelsWide());
+    float textureHigh = (float) (_textureAtlas->getTexture()->getPixelsHigh());
 
     float itemWidthInPixels = _itemWidth * CC_CONTENT_SCALE_FACTOR();
     float itemHeightInPixels = _itemHeight * CC_CONTENT_SCALE_FACTOR();
 
 #if CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
-    float left = (2 * row * itemWidthInPixels + 1) / (2 * textureWide);
-    float right = left + (itemWidthInPixels * 2 - 2) / (2 * textureWide);
-    float top = (2 * col * itemHeightInPixels + 1) / (2 * textureHigh);
-    float bottom = top + (itemHeightInPixels * 2 - 2) / (2 * textureHigh);
+    float left        = (2 * row * itemWidthInPixels + 1) / (2 * textureWide);
+    float right       = left + (itemWidthInPixels * 2 - 2) / (2 * textureWide);
+    float top         = (2 * col * itemHeightInPixels + 1) / (2 * textureHigh);
+    float bottom      = top + (itemHeightInPixels * 2 - 2) / (2 * textureHigh);
 #else
-    float left = (row * itemWidthInPixels) / textureWide;
-    float right = left + itemWidthInPixels / textureWide;
-    float top = (col * itemHeightInPixels) / textureHigh;
-    float bottom = top + itemHeightInPixels / textureHigh;
+    float left        = (row * itemWidthInPixels) / textureWide;
+    float right       = left + itemWidthInPixels / textureWide;
+    float top         = (col * itemHeightInPixels) / textureHigh;
+    float bottom      = top + itemHeightInPixels / textureHigh;
 #endif
 
     quad->tl.texCoords.u = left;
@@ -214,8 +200,8 @@ void TileMapAtlas::updateAtlasValueAt(const Vec2& pos, const Color3B& value, int
     quad->br.texCoords.u = right;
     quad->br.texCoords.v = bottom;
 
-    quad->bl.vertices.x = (float)(x * _itemWidth);
-    quad->bl.vertices.y = (float)(y * _itemHeight);
+    quad->bl.vertices.x = (float) (x * _itemWidth);
+    quad->bl.vertices.y = (float) (y * _itemHeight);
     quad->bl.vertices.z = 0.0f;
     quad->br.vertices.x = (float)(x * _itemWidth + _itemWidth);
     quad->br.vertices.y = (float)(y * _itemHeight);
@@ -234,31 +220,30 @@ void TileMapAtlas::updateAtlasValueAt(const Vec2& pos, const Color3B& value, int
     quad->bl.colors = color;
 
     _textureAtlas->setDirty(true);
-    std::size_t totalQuads = _textureAtlas->getTotalQuads();
-    if (index + 1 > totalQuads)
-    {
+    ssize_t totalQuads = _textureAtlas->getTotalQuads();
+    if (index + 1 > totalQuads) {
         _textureAtlas->increaseTotalQuadsWith(index + 1 - totalQuads);
     }
 }
 
 void TileMapAtlas::updateAtlasValues()
 {
-    CCASSERT(_TGAInfo != nullptr, "tgaInfo must be non-nil");
+    CCASSERT( _TGAInfo != nullptr, "tgaInfo must be non-nil");
 
     int total = 0;
 
-    for (int x = 0; x < _TGAInfo->width; x++)
+    for(int x=0;x < _TGAInfo->width; x++ ) 
     {
-        for (int y = 0; y < _TGAInfo->height; y++)
+        for( int y=0; y < _TGAInfo->height; y++ ) 
         {
-            if (total < _itemsToRender)
+            if( total < _itemsToRender ) 
             {
-                Color3B* ptr = (Color3B*)_TGAInfo->imageData;
+                Color3B *ptr = (Color3B*) _TGAInfo->imageData;
                 Color3B value = ptr[x + y * _TGAInfo->width];
 
-                if (value.r != 0)
+                if( value.r != 0 )
                 {
-                    this->updateAtlasValueAt(Vec2(x, y), value, total);
+                    this->updateAtlasValueAt(Vec2(x,y), value, total);
 
                     std::string key = StringUtils::toString(x) + "," + StringUtils::toString(y);
                     _posToAtlasIndex[key] = total;
@@ -270,4 +255,5 @@ void TileMapAtlas::updateAtlasValues()
     }
 }
 
+
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCTileMapAtlas.h b/cocos2d/cocos/2d/CCTileMapAtlas.h
index 24f555443a..15fd324712 100644
--- a/cocos2d/cocos/2d/CCTileMapAtlas.h
+++ b/cocos2d/cocos/2d/CCTileMapAtlas.h
@@ -3,6 +3,7 @@ Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,17 +25,11 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
-#ifndef CC_2D_TILEMAPATLAS_H
-#define CC_2D_TILEMAPATLAS_H
+#ifndef __CCTILE_MAP_ATLAS__
+#define __CCTILE_MAP_ATLAS__
 
 #include <cocos/2d/CCAtlasNode.h>
 #include <cocos/base/CCValue.h>
-#include <cocos/base/ccTypes.h>
-#include <cocos/math/Vec2.h>
-#include <cocos/platform/CCPlatformDefine.h>
-#include <cocos/platform/CCPlatformMacros.h>
-
-#include <iosfwd>
 
 NS_CC_BEGIN
 
@@ -58,13 +53,13 @@ You SHOULD not use this class.
 Instead, use the newer TMX file format: TMXTiledMap
 @js NA
 */
-class CC_DLL TileMapAtlas : public AtlasNode
+class CC_DLL TileMapAtlas : public AtlasNode 
 {
 public:
     /** creates a TileMap with a tile file (atlas) with a map file and the width and height of each tile in points.
      The tile file will be loaded using the TextureMgr.
      */
-    static TileMapAtlas* create(const std::string& tile, const std::string& mapFile, int tileWidth, int tileHeight);
+    static TileMapAtlas * create(const std::string& tile, const std::string& mapFile, int tileWidth, int tileHeight);
     /**
      * @js ctor
      */
@@ -74,7 +69,7 @@ public:
      * @lua NA
      */
     virtual ~TileMapAtlas();
-
+    
     /** initializes a TileMap with a tile file (atlas) with a map file and the width and height of each tile in points.
     The file will be loaded using the TextureMgr.
     */
@@ -84,18 +79,14 @@ public:
      *For the moment only channel R is used
      */
     Color3B getTileAt(const Vec2& position) const;
-    /**
-     * Returns a tile from position x,y.
-     *For the moment only channel R is used
-     */
-    CC_DEPRECATED_ATTRIBUTE Color3B tileAt(const Vec2& position) const { return getTileAt(position); }
+
     /** sets a tile at position x,y.
     For the moment only channel R is used
     */
     void setTile(const Color3B& tile, const Vec2& position);
     /** dealloc the map from memory */
     void releaseMap();
-
+    
     /**
      * Query TGA image info.
      *@return The TGA image info.
@@ -114,6 +105,7 @@ protected:
     void updateAtlasValueAt(const Vec2& pos, const Color3B& value, int index);
     void updateAtlasValues();
 
+
     //! x,y to atlas dictionary
     ValueMap _posToAtlasIndex;
     //! numbers of tiles to render
@@ -126,4 +118,5 @@ protected:
 
 NS_CC_END
 
-#endif // CC_2D_TILEMAPATLAS_H
+#endif //__CCTILE_MAP_ATLAS__
+
diff --git a/cocos2d/cocos/2d/CCTransition.cpp b/cocos2d/cocos/2d/CCTransition.cpp
index 3d6d75ee11..e2615eed64 100644
--- a/cocos2d/cocos/2d/CCTransition.cpp
+++ b/cocos2d/cocos/2d/CCTransition.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2009-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -26,29 +27,23 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCTransition.h>
-
-#include <cocos/2d/CCActionCamera.h>
-#include <cocos/2d/CCActionEase.h>
-#include <cocos/2d/CCActionGrid.h>
-#include <cocos/2d/CCActionInstant.h>
 #include <cocos/2d/CCActionInterval.h>
+#include <cocos/2d/CCActionInstant.h>
+#include <cocos/2d/CCActionEase.h>
+#include <cocos/2d/CCActionCamera.h>
 #include <cocos/2d/CCActionTiledGrid.h>
+#include <cocos/2d/CCActionGrid.h>
 #include <cocos/2d/CCLayer.h>
-#include <cocos/2d/CCNodeGrid.h>
 #include <cocos/2d/CCRenderTexture.h>
+#include <cocos/2d/CCNodeGrid.h>
 #include <cocos/base/CCDirector.h>
 #include <cocos/base/CCEventDispatcher.h>
-
 using namespace std::chrono_literals;
 
 NS_CC_BEGIN
 
 const unsigned int kSceneFade = 0xFADEFADE;
 
-TransitionEaseScene::~TransitionEaseScene()
-{
-}
-
 TransitionScene::TransitionScene()
 : _inScene(nullptr)
 , _outScene(nullptr)
@@ -64,10 +59,10 @@ TransitionScene::~TransitionScene()
     CC_SAFE_RELEASE(_outScene);
 }
 
-TransitionScene* TransitionScene::create(std::chrono::milliseconds t, Scene* scene)
+TransitionScene * TransitionScene::create(std::chrono::milliseconds t, Scene *scene)
 {
-    TransitionScene* pScene = new (std::nothrow) TransitionScene();
-    if (pScene && pScene->initWithDuration(t, scene))
+    TransitionScene * pScene = new (std::nothrow) TransitionScene();
+    if(pScene && pScene->initWithDuration(t,scene))
     {
         pScene->autorelease();
         return pScene;
@@ -76,7 +71,7 @@ TransitionScene* TransitionScene::create(std::chrono::milliseconds t, Scene* sce
     return nullptr;
 }
 
-bool TransitionScene::initWithDuration(std::chrono::milliseconds t, Scene* scene)
+bool TransitionScene::initWithDuration(std::chrono::milliseconds t, Scene *scene)
 {
     CCASSERT(scene != nullptr, "Argument scene must be non-nil");
 
@@ -98,11 +93,14 @@ bool TransitionScene::initWithDuration(std::chrono::milliseconds t, Scene* scene
         if (_outScene == nullptr)
         {
             _outScene = Scene::create();
+            // just change its state is running that can run actions later
+            // issue: https://github.com/cocos2d/cocos2d-x/issues/17442
+            _outScene->onEnter();
         }
         _outScene->retain();
 
-        CCASSERT(_inScene != _outScene, "Incoming scene must be different from the outgoing scene");
-
+        CCASSERT( _inScene != _outScene, "Incoming scene must be different from the outgoing scene" );
+        
         sceneOrder();
 
         return true;
@@ -118,17 +116,14 @@ void TransitionScene::sceneOrder()
     _isInSceneOnTop = true;
 }
 
-void TransitionScene::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void TransitionScene::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
     Scene::draw(renderer, transform, flags);
 
-    if (_isInSceneOnTop)
-    {
+    if( _isInSceneOnTop ) {
         _outScene->visit(renderer, transform, flags);
         _inScene->visit(renderer, transform, flags);
-    }
-    else
-    {
+    } else {
         _inScene->visit(renderer, transform, flags);
         _outScene->visit(renderer, transform, flags);
     }
@@ -138,29 +133,29 @@ void TransitionScene::finish()
 {
     // clean up
     _inScene->setVisible(true);
-    _inScene->setPosition(0, 0);
+    _inScene->setPosition(0,0);
     _inScene->setScale(1.0f);
     _inScene->setRotation(0.0f);
     _inScene->setAdditionalTransform(nullptr);
 
     _outScene->setVisible(false);
-    _outScene->setPosition(0, 0);
+    _outScene->setPosition(0,0);
     _outScene->setScale(1.0f);
     _outScene->setRotation(0.0f);
     _outScene->setAdditionalTransform(nullptr);
 
     //[self schedule:@selector(setNewScene:) interval:0];
-    this->schedule(CC_SCHEDULE_SELECTOR(TransitionScene::setNewScene), 0ms);
+    this->schedule(CC_SCHEDULE_SELECTOR(TransitionScene::setNewScene), 0);
 }
 
-void TransitionScene::setNewScene(float)
-{
+void TransitionScene::setNewScene(float /*dt*/)
+{    
     this->unschedule(CC_SCHEDULE_SELECTOR(TransitionScene::setNewScene));
-
+    
     // Before replacing, save the "send cleanup to scene"
-    Director* director = Director::getInstance();
+    Director *director = Director::getInstance();
     _isSendCleanupToScene = director->isSendCleanupToScene();
-
+    
     director->replaceScene(_inScene);
 #if CC_ENABLE_GC_FOR_NATIVE_OBJECTS
     auto sEngine = ScriptEngineManager::getInstance()->getScriptEngine();
@@ -169,7 +164,7 @@ void TransitionScene::setNewScene(float)
         sEngine->releaseScriptObject(this, _inScene);
     }
 #endif // CC_ENABLE_GC_FOR_NATIVE_OBJECTS
-
+    
     // issue #267
     _outScene->setVisible(true);
 }
@@ -180,6 +175,7 @@ void TransitionScene::hideOutShowIn()
     _outScene->setVisible(false);
 }
 
+
 // custom onEnter
 void TransitionScene::onEnter()
 {
@@ -190,16 +186,16 @@ void TransitionScene::onEnter()
             return;
     }
 #endif // #if CC_ENABLE_SCRIPT_BINDING
-
+    
     Scene::onEnter();
-
+    
     // disable events while transitions
     _eventDispatcher->setEnabled(false);
-
+    
     // outScene should not receive the onEnter callback
     // only the onExitTransitionDidStart
     _outScene->onExitTransitionDidStart();
-
+    
     _inScene->onEnter();
 }
 
@@ -213,9 +209,9 @@ void TransitionScene::onExit()
             return;
     }
 #endif // #if CC_ENABLE_SCRIPT_BINDING
-
+    
     Scene::onExit();
-
+    
     // enable events while transitions
     _eventDispatcher->setEnabled(true);
     _outScene->onExit();
@@ -240,10 +236,10 @@ void TransitionScene::cleanup()
             return;
     }
 #endif // #if CC_ENABLE_SCRIPT_BINDING
-
+    
     Scene::cleanup();
 
-    if (_isSendCleanupToScene)
+    if( _isSendCleanupToScene )
         _outScene->cleanup();
 }
 
@@ -259,17 +255,17 @@ TransitionSceneOriented::~TransitionSceneOriented()
 {
 }
 
-TransitionSceneOriented* TransitionSceneOriented::create(std::chrono::milliseconds t, Scene* scene, Orientation orientation)
+TransitionSceneOriented * TransitionSceneOriented::create(std::chrono::milliseconds t, Scene *scene, Orientation orientation)
 {
-    TransitionSceneOriented* newScene = new (std::nothrow) TransitionSceneOriented();
-    newScene->initWithDuration(t, scene, orientation);
+    TransitionSceneOriented * newScene = new (std::nothrow) TransitionSceneOriented();
+    newScene->initWithDuration(t,scene,orientation);
     newScene->autorelease();
     return newScene;
 }
 
-bool TransitionSceneOriented::initWithDuration(std::chrono::milliseconds t, Scene* scene, Orientation orientation)
+bool TransitionSceneOriented::initWithDuration(std::chrono::milliseconds t, Scene *scene, Orientation orientation)
 {
-    if (TransitionScene::initWithDuration(t, scene))
+    if ( TransitionScene::initWithDuration(t, scene) )
     {
         _orientation = orientation;
     }
@@ -284,22 +280,22 @@ TransitionRotoZoom::TransitionRotoZoom()
 }
 
 TransitionRotoZoom* TransitionRotoZoom::create(std::chrono::milliseconds t, Scene* scene)
-{
+{                                                               
     TransitionRotoZoom* newScene = new (std::nothrow) TransitionRotoZoom();
-    if (newScene && newScene->initWithDuration(t, scene))
-    {
+    if(newScene && newScene->initWithDuration(t, scene))
+    {                                                           
         newScene->autorelease();
         return newScene;
-    }
-    CC_SAFE_DELETE(newScene);
-    return nullptr;
+    }                                                           
+    CC_SAFE_DELETE(newScene);                                     
+    return nullptr;                                                
 }
 
 TransitionRotoZoom::~TransitionRotoZoom()
 {
 }
 
-void TransitionRotoZoom::onEnter()
+void TransitionRotoZoom:: onEnter()
 {
     TransitionScene::onEnter();
 
@@ -309,11 +305,25 @@ void TransitionRotoZoom::onEnter()
     _inScene->setAnchorPoint(Vec2(0.5f, 0.5f));
     _outScene->setAnchorPoint(Vec2(0.5f, 0.5f));
 
-    auto rotozoom = Sequence::create(
-        {Spawn::create({ScaleBy::create(_duration / 2, 0.001f), RotateBy::create(_duration / 2, 360.f * 2.f)}), DelayTime::create(_duration / 2)});
+    auto rotozoom = Sequence::create
+    ({
+        Spawn::create
+     ({
+            ScaleBy::create(_duration/2, 0.001f),
+            RotateBy::create(_duration/2, 360 * 2)
+    }),
+        DelayTime::create(_duration/2)
+    });
 
     _outScene->runAction(rotozoom);
-    _inScene->runAction(Sequence::create({rotozoom->reverse(), CallFunc::create([this]() { finish(); })}));
+    _inScene->runAction
+    (
+        Sequence::create
+     ({
+            rotozoom->reverse(),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    })
+    );
 }
 
 //
@@ -329,7 +339,7 @@ TransitionJumpZoom::~TransitionJumpZoom()
 TransitionJumpZoom* TransitionJumpZoom::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionJumpZoom* newScene = new (std::nothrow) TransitionJumpZoom();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -348,17 +358,25 @@ void TransitionJumpZoom::onEnter()
     _inScene->setAnchorPoint(Vec2(0.5f, 0.5f));
     _outScene->setAnchorPoint(Vec2(0.5f, 0.5f));
 
-    ActionInterval* jump = JumpBy::create(_duration / 4, Vec2(-s.width, 0), s.width / 4, 2);
-    ActionInterval* scaleIn = ScaleTo::create(_duration / 4, 1.0f);
-    ActionInterval* scaleOut = ScaleTo::create(_duration / 4, 0.5f);
+    ActionInterval *jump = JumpBy::create(_duration/4, Vec2(-s.width,0.0f), s.width/4, 2);
+    ActionInterval *scaleIn = ScaleTo::create(_duration/4, 1.0f);
+    ActionInterval *scaleOut = ScaleTo::create(_duration/4, 0.5f);
 
     auto jumpZoomOut = Sequence::create({scaleOut, jump});
     auto jumpZoomIn = Sequence::create({jump, scaleIn});
 
-    ActionInterval* delay = DelayTime::create(_duration / 2);
+    ActionInterval *delay = DelayTime::create(_duration/2);
 
     _outScene->runAction(jumpZoomOut);
-    _inScene->runAction(Sequence::create({delay, jumpZoomIn, CallFunc::create([this]() { finish(); })}));
+    _inScene->runAction
+    (
+        Sequence::create
+     ({
+            delay,
+            jumpZoomIn,
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    })
+    );
 }
 
 //
@@ -375,7 +393,7 @@ TransitionMoveInL::~TransitionMoveInL()
 TransitionMoveInL* TransitionMoveInL::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionMoveInL* newScene = new (std::nothrow) TransitionMoveInL();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -389,26 +407,33 @@ void TransitionMoveInL::onEnter()
     TransitionScene::onEnter();
     this->initScenes();
 
-    ActionInterval* a = this->action();
+    ActionInterval *a = this->action();
 
-    _inScene->runAction(Sequence::create({this->easeActionWithAction(a), CallFunc::create([this]() { finish(); })}));
+    _inScene->runAction
+    (
+        Sequence::create
+     ({
+            this->easeActionWithAction(a),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    })
+    );
 }
-
+ 
 ActionInterval* TransitionMoveInL::action()
 {
-    return MoveTo::create(_duration, Vec2(0, 0));
+    return MoveTo::create(_duration, Vec2(0.0f,0.0f));
 }
 
 ActionInterval* TransitionMoveInL::easeActionWithAction(ActionInterval* action)
 {
     return EaseOut::create(action, 2.0f);
-    //    return [EaseElasticOut actionWithAction:action period:0.4f];
+//    return [EaseElasticOut actionWithAction:action period:0.4f];
 }
 
 void TransitionMoveInL::initScenes()
 {
     Size s = Director::getInstance()->getWinSize();
-    _inScene->setPosition(-s.width, 0);
+    _inScene->setPosition(-s.width,0);
 }
 
 //
@@ -424,7 +449,7 @@ TransitionMoveInR::~TransitionMoveInR()
 TransitionMoveInR* TransitionMoveInR::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionMoveInR* newScene = new (std::nothrow) TransitionMoveInR();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -436,7 +461,7 @@ TransitionMoveInR* TransitionMoveInR::create(std::chrono::milliseconds t, Scene*
 void TransitionMoveInR::initScenes()
 {
     Size s = Director::getInstance()->getWinSize();
-    _inScene->setPosition(s.width, 0);
+    _inScene->setPosition(s.width,0);
 }
 
 //
@@ -452,7 +477,7 @@ TransitionMoveInT::~TransitionMoveInT()
 TransitionMoveInT* TransitionMoveInT::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionMoveInT* newScene = new (std::nothrow) TransitionMoveInT();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -464,7 +489,7 @@ TransitionMoveInT* TransitionMoveInT::create(std::chrono::milliseconds t, Scene*
 void TransitionMoveInT::initScenes()
 {
     Size s = Director::getInstance()->getWinSize();
-    _inScene->setPosition(0, s.height);
+    _inScene->setPosition(0,s.height);
 }
 
 //
@@ -480,7 +505,7 @@ TransitionMoveInB::~TransitionMoveInB()
 TransitionMoveInB* TransitionMoveInB::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionMoveInB* newScene = new (std::nothrow) TransitionMoveInB();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -492,9 +517,10 @@ TransitionMoveInB* TransitionMoveInB::create(std::chrono::milliseconds t, Scene*
 void TransitionMoveInB::initScenes()
 {
     Size s = Director::getInstance()->getWinSize();
-    _inScene->setPosition(0, -s.height);
+    _inScene->setPosition(0,-s.height);
 }
 
+
 //
 // SlideInL
 //
@@ -517,11 +543,15 @@ void TransitionSlideInL::onEnter()
     TransitionScene::onEnter();
     this->initScenes();
 
-    ActionInterval* in = this->action();
-    ActionInterval* out = this->action();
+    ActionInterval *in = this->action();
+    ActionInterval *out = this->action();
 
     ActionInterval* inAction = easeActionWithAction(in);
-    ActionInterval* outAction = Sequence::create({easeActionWithAction(out), CallFunc::create([this]() { finish(); })});
+    ActionInterval* outAction = Sequence::create
+    ({
+        easeActionWithAction(out),
+        CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    });
     _inScene->runAction(inAction);
     _outScene->runAction(outAction);
 }
@@ -531,16 +561,16 @@ void TransitionSlideInL::sceneOrder()
     _isInSceneOnTop = false;
 }
 
-void TransitionSlideInL::initScenes()
+void TransitionSlideInL:: initScenes()
 {
     Size s = Director::getInstance()->getWinSize();
-    _inScene->setPosition(-(s.width - ADJUST_FACTOR), 0);
+    _inScene->setPosition(-(s.width-ADJUST_FACTOR),0.0f);
 }
 
 ActionInterval* TransitionSlideInL::action()
 {
     Size s = Director::getInstance()->getWinSize();
-    return MoveBy::create(_duration, Vec2(s.width - ADJUST_FACTOR, 0));
+    return MoveBy::create(_duration, Vec2(s.width-ADJUST_FACTOR,0.0f));
 }
 
 ActionInterval* TransitionSlideInL::easeActionWithAction(ActionInterval* action)
@@ -551,7 +581,7 @@ ActionInterval* TransitionSlideInL::easeActionWithAction(ActionInterval* action)
 TransitionSlideInL* TransitionSlideInL::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionSlideInL* newScene = new (std::nothrow) TransitionSlideInL();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -573,7 +603,7 @@ TransitionSlideInR::~TransitionSlideInR()
 TransitionSlideInR* TransitionSlideInR::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionSlideInR* newScene = new (std::nothrow) TransitionSlideInR();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -590,15 +620,17 @@ void TransitionSlideInR::sceneOrder()
 void TransitionSlideInR::initScenes()
 {
     Size s = Director::getInstance()->getWinSize();
-    _inScene->setPosition(s.width - ADJUST_FACTOR, 0);
+    _inScene->setPosition(s.width-ADJUST_FACTOR,0);
 }
 
-ActionInterval* TransitionSlideInR::action()
+
+ActionInterval* TransitionSlideInR:: action()
 {
     Size s = Director::getInstance()->getWinSize();
-    return MoveBy::create(_duration, Vec2(-(s.width - ADJUST_FACTOR), 0));
+    return MoveBy::create(_duration, Vec2(-(s.width-ADJUST_FACTOR),0.0f));
 }
 
+
 //
 // SlideInT
 //
@@ -612,7 +644,7 @@ TransitionSlideInT::~TransitionSlideInT()
 TransitionSlideInT* TransitionSlideInT::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionSlideInT* newScene = new (std::nothrow) TransitionSlideInT();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -629,13 +661,14 @@ void TransitionSlideInT::sceneOrder()
 void TransitionSlideInT::initScenes()
 {
     Size s = Director::getInstance()->getWinSize();
-    _inScene->setPosition(0, s.height - ADJUST_FACTOR);
+    _inScene->setPosition(0,s.height-ADJUST_FACTOR);
 }
 
+
 ActionInterval* TransitionSlideInT::action()
 {
     Size s = Director::getInstance()->getWinSize();
-    return MoveBy::create(_duration, Vec2(0, -(s.height - ADJUST_FACTOR)));
+    return MoveBy::create(_duration, Vec2(0.0f,-(s.height-ADJUST_FACTOR)));
 }
 
 //
@@ -651,7 +684,7 @@ TransitionSlideInB::~TransitionSlideInB()
 TransitionSlideInB* TransitionSlideInB::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionSlideInB* newScene = new (std::nothrow) TransitionSlideInB();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -665,16 +698,17 @@ void TransitionSlideInB::sceneOrder()
     _isInSceneOnTop = true;
 }
 
-void TransitionSlideInB::initScenes()
+void TransitionSlideInB:: initScenes()
 {
     Size s = Director::getInstance()->getWinSize();
-    _inScene->setPosition(0, -(s.height - ADJUST_FACTOR));
+    _inScene->setPosition(0,-(s.height-ADJUST_FACTOR));
 }
 
-ActionInterval* TransitionSlideInB::action()
+
+ActionInterval* TransitionSlideInB:: action()
 {
     Size s = Director::getInstance()->getWinSize();
-    return MoveBy::create(_duration, Vec2(0, s.height - ADJUST_FACTOR));
+    return MoveBy::create(_duration, Vec2(0.0f,s.height-ADJUST_FACTOR));
 }
 
 //
@@ -690,7 +724,7 @@ TransitionShrinkGrow::~TransitionShrinkGrow()
 TransitionShrinkGrow* TransitionShrinkGrow::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionShrinkGrow* newScene = new (std::nothrow) TransitionShrinkGrow();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -706,19 +740,26 @@ void TransitionShrinkGrow::onEnter()
     _inScene->setScale(0.001f);
     _outScene->setScale(1.0f);
 
-    _inScene->setAnchorPoint(Vec2(2 / 3.0f, 0.5f));
-    _outScene->setAnchorPoint(Vec2(1 / 3.0f, 0.5f));
+    _inScene->setAnchorPoint(Vec2(2/3.0f,0.5f));
+    _outScene->setAnchorPoint(Vec2(1/3.0f,0.5f));    
 
     ActionInterval* scaleOut = ScaleTo::create(_duration, 0.01f);
     ActionInterval* scaleIn = ScaleTo::create(_duration, 1.0f);
 
     _inScene->runAction(this->easeActionWithAction(scaleIn));
-    _outScene->runAction(Sequence::create({this->easeActionWithAction(scaleOut), CallFunc::create([this]() { finish(); })}));
+    _outScene->runAction
+    ({
+        Sequence::create
+        ({
+            this->easeActionWithAction(scaleOut),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+        })
+    });
 }
-ActionInterval* TransitionShrinkGrow::easeActionWithAction(ActionInterval* action)
+ActionInterval* TransitionShrinkGrow:: easeActionWithAction(ActionInterval* action)
 {
     return EaseOut::create(action, 2.0f);
-    //    return [EaseElasticOut actionWithAction:action period:0.3f];
+//    return [EaseElasticOut actionWithAction:action period:0.3f];
 }
 
 //
@@ -740,7 +781,7 @@ void TransitionFlipX::onEnter()
     float inDeltaZ, inAngleZ;
     float outDeltaZ, outAngleZ;
 
-    if (_orientation == TransitionScene::Orientation::RIGHT_OVER)
+    if( _orientation == TransitionScene::Orientation::RIGHT_OVER )
     {
         inDeltaZ = 90;
         inAngleZ = 270;
@@ -755,10 +796,20 @@ void TransitionFlipX::onEnter()
         outAngleZ = 0;
     }
 
-    auto inA = Sequence::create({DelayTime::create(_duration / 2), Show::create(), OrbitCamera::create(_duration / 2, 1, 0, inAngleZ, inDeltaZ, 0, 0),
-                                 CallFunc::create([this]() { finish(); })});
-
-    auto outA = Sequence::create({OrbitCamera::create(_duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0), Hide::create(), DelayTime::create(_duration / 2)});
+    auto inA = Sequence::create
+    ({
+            DelayTime::create(_duration/2),
+            Show::create(),
+            OrbitCamera::create(_duration/2, 1, 0, inAngleZ, inDeltaZ, 0, 0),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    });
+
+    auto outA = Sequence::create
+    ({
+            OrbitCamera::create(_duration/2, 1, 0, outAngleZ, outDeltaZ, 0, 0),
+            Hide::create(),
+            DelayTime::create(_duration/2)
+    });
 
     _inScene->runAction(inA);
     _outScene->runAction(outA);
@@ -797,14 +848,14 @@ void TransitionFlipY::onEnter()
     float inDeltaZ, inAngleZ;
     float outDeltaZ, outAngleZ;
 
-    if (_orientation == TransitionScene::Orientation::UP_OVER)
+    if( _orientation == TransitionScene::Orientation::UP_OVER ) 
     {
         inDeltaZ = 90;
         inAngleZ = 270;
         outDeltaZ = 90;
         outAngleZ = 0;
-    }
-    else
+    } 
+    else 
     {
         inDeltaZ = -90;
         inAngleZ = 90;
@@ -812,12 +863,23 @@ void TransitionFlipY::onEnter()
         outAngleZ = 0;
     }
 
-    auto inA = Sequence::create({DelayTime::create(_duration / 2), Show::create(), OrbitCamera::create(_duration / 2, 1, 0, inAngleZ, inDeltaZ, 90, 0),
-                                 CallFunc::create([this]() { finish(); })});
-    auto outA = Sequence::create({OrbitCamera::create(_duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0), Hide::create(), DelayTime::create(_duration / 2)});
+    auto inA = Sequence::create
+    ({
+            DelayTime::create(_duration/2),
+            Show::create(),
+            OrbitCamera::create(_duration/2, 1, 0, inAngleZ, inDeltaZ, 90, 0),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    });
+    auto outA = Sequence::create
+    ({
+            OrbitCamera::create(_duration/2, 1, 0, outAngleZ, outDeltaZ, 90, 0),
+            Hide::create(),
+            DelayTime::create(_duration/2)
+    });
 
     _inScene->runAction(inA);
     _outScene->runAction(outA);
+
 }
 
 TransitionFlipY* TransitionFlipY::create(std::chrono::milliseconds t, Scene* s, Orientation o)
@@ -854,14 +916,14 @@ void TransitionFlipAngular::onEnter()
     float inDeltaZ, inAngleZ;
     float outDeltaZ, outAngleZ;
 
-    if (_orientation == TransitionScene::Orientation::RIGHT_OVER)
+    if( _orientation == TransitionScene::Orientation::RIGHT_OVER ) 
     {
         inDeltaZ = 90;
         inAngleZ = 270;
         outDeltaZ = 90;
         outAngleZ = 0;
-    }
-    else
+    } 
+    else 
     {
         inDeltaZ = -90;
         inAngleZ = 90;
@@ -869,9 +931,19 @@ void TransitionFlipAngular::onEnter()
         outAngleZ = 0;
     }
 
-    auto inA = Sequence::create({DelayTime::create(_duration / 2), Show::create(), OrbitCamera::create(_duration / 2, 1, 0, inAngleZ, inDeltaZ, -45, 0),
-                                 CallFunc::create([this]() { finish(); })});
-    auto outA = Sequence::create({OrbitCamera::create(_duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0), Hide::create(), DelayTime::create(_duration / 2)});
+    auto inA = Sequence::create
+    ({
+            DelayTime::create(_duration/2),
+            Show::create(),
+            OrbitCamera::create(_duration/2, 1, 0, inAngleZ, inDeltaZ, -45, 0),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    });
+    auto outA = Sequence::create
+    ({
+            OrbitCamera::create(_duration/2, 1, 0, outAngleZ, outDeltaZ, 45, 0),
+            Hide::create(),
+            DelayTime::create(_duration/2)
+    });
 
     _inScene->runAction(inA);
     _outScene->runAction(outA);
@@ -910,26 +982,40 @@ void TransitionZoomFlipX::onEnter()
     float inDeltaZ, inAngleZ;
     float outDeltaZ, outAngleZ;
 
-    if (_orientation == TransitionScene::Orientation::RIGHT_OVER)
-    {
+    if( _orientation == TransitionScene::Orientation::RIGHT_OVER ) {
         inDeltaZ = 90;
         inAngleZ = 270;
         outDeltaZ = 90;
         outAngleZ = 0;
-    }
-    else
+    } 
+    else 
     {
         inDeltaZ = -90;
         inAngleZ = 90;
         outDeltaZ = -90;
         outAngleZ = 0;
     }
-    auto inA =
-        Sequence::create({DelayTime::create(_duration / 2),
-                          Spawn::create({OrbitCamera::create(_duration / 2, 1, 0, inAngleZ, inDeltaZ, 0, 0), ScaleTo::create(_duration / 2, 1), Show::create()}),
-                          CallFunc::create([this]() { finish(); })});
-    auto outA = Sequence::create({Spawn::create({OrbitCamera::create(_duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0), ScaleTo::create(_duration / 2, 0.5f)}),
-                                  Hide::create(), DelayTime::create(_duration / 2)});
+    auto inA = Sequence::create
+    ({
+            DelayTime::create(_duration/2),
+            Spawn::create
+         ({
+                OrbitCamera::create(_duration/2, 1, 0, inAngleZ, inDeltaZ, 0, 0),
+                ScaleTo::create(_duration/2, 1),
+                Show::create()
+        }),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    });
+    auto outA = Sequence::create
+    ({
+            Spawn::create
+        ({
+                OrbitCamera::create(_duration/2, 1, 0, outAngleZ, outDeltaZ, 0, 0),
+                ScaleTo::create(_duration/2, 0.5f)
+        }),
+            Hide::create(),
+            DelayTime::create(_duration/2)
+    });
 
     _inScene->setScale(0.5f);
     _inScene->runAction(inA);
@@ -970,28 +1056,38 @@ void TransitionZoomFlipY::onEnter()
     float inDeltaZ, inAngleZ;
     float outDeltaZ, outAngleZ;
 
-    if (_orientation == TransitionScene::Orientation::UP_OVER)
-    {
+    if( _orientation== TransitionScene::Orientation::UP_OVER ) {
         inDeltaZ = 90;
         inAngleZ = 270;
         outDeltaZ = 90;
         outAngleZ = 0;
-    }
-    else
-    {
+    } else {
         inDeltaZ = -90;
         inAngleZ = 90;
         outDeltaZ = -90;
         outAngleZ = 0;
     }
 
-    auto inA =
-        Sequence::create({DelayTime::create(_duration / 2),
-                          Spawn::create({OrbitCamera::create(_duration / 2, 1, 0, inAngleZ, inDeltaZ, 90, 0), ScaleTo::create(_duration / 2, 1), Show::create()}),
-                          CallFunc::create([this]() { finish(); })});
-
-    auto outA = Sequence::create({Spawn::create({OrbitCamera::create(_duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0), ScaleTo::create(_duration / 2, 0.5f)}),
-                                  Hide::create(), DelayTime::create(_duration / 2)});
+    auto inA = Sequence::create
+    ({
+            DelayTime::create(_duration/2),
+            Spawn::create
+        ({
+                OrbitCamera::create(_duration/2, 1, 0, inAngleZ, inDeltaZ, 90, 0),
+                ScaleTo::create(_duration/2, 1),
+                Show::create()
+        }),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    });
+
+    auto outA = Sequence::create
+        ({
+            Spawn::create
+            ({
+                OrbitCamera::create(_duration/2, 1, 0, outAngleZ, outDeltaZ, 90, 0),
+                ScaleTo::create(_duration/2, 0.5f)            }),
+            Hide::create(),
+            DelayTime::create(_duration/2)});
 
     _inScene->setScale(0.5f);
     _inScene->runAction(inA);
@@ -1022,6 +1118,7 @@ TransitionZoomFlipAngular::~TransitionZoomFlipAngular()
 {
 }
 
+
 void TransitionZoomFlipAngular::onEnter()
 {
     TransitionSceneOriented::onEnter();
@@ -1031,14 +1128,13 @@ void TransitionZoomFlipAngular::onEnter()
     float inDeltaZ, inAngleZ;
     float outDeltaZ, outAngleZ;
 
-    if (_orientation == TransitionScene::Orientation::RIGHT_OVER)
-    {
+    if( _orientation == TransitionScene::Orientation::RIGHT_OVER ) {
         inDeltaZ = 90;
         inAngleZ = 270;
         outDeltaZ = 90;
         outAngleZ = 0;
-    }
-    else
+    } 
+    else 
     {
         inDeltaZ = -90;
         inAngleZ = 90;
@@ -1046,12 +1142,24 @@ void TransitionZoomFlipAngular::onEnter()
         outAngleZ = 0;
     }
 
-    auto inA = Sequence::create(
-        {DelayTime::create(_duration / 2),
-         Spawn::create({OrbitCamera::create(_duration / 2, 1, 0, inAngleZ, inDeltaZ, -45, 0), ScaleTo::create(_duration / 2, 1), Show::create()}),
-         Show::create(), CallFunc::create([this]() { finish(); })});
-    auto outA = Sequence::create({Spawn::create({OrbitCamera::create(_duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0), ScaleTo::create(_duration / 2, 0.5f)}),
-                                  Hide::create(), DelayTime::create(_duration / 2)});
+    auto inA = Sequence::create
+        ({
+            DelayTime::create(_duration/2),
+            Spawn::create
+            ({
+                OrbitCamera::create(_duration/2, 1, 0, inAngleZ, inDeltaZ, -45, 0),
+                ScaleTo::create(_duration/2, 1),
+                Show::create()            }),
+            Show::create(),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))});
+    auto outA = Sequence::create
+        ({
+            Spawn::create
+            ({
+                OrbitCamera::create(_duration/2, 1, 0 , outAngleZ, outDeltaZ, 45, 0),
+                ScaleTo::create(_duration/2, 0.5f)            }),
+            Hide::create(),
+            DelayTime::create(_duration/2)        });
 
     _inScene->setScale(0.5f);
     _inScene->runAction(inA);
@@ -1082,20 +1190,20 @@ TransitionFade::~TransitionFade()
 {
 }
 
-TransitionFade* TransitionFade::create(std::chrono::milliseconds duration, Scene* scene, const Color3B& color)
+TransitionFade * TransitionFade::create(std::chrono::milliseconds duration, Scene *scene, const Color3B& color)
 {
-    TransitionFade* transition = new (std::nothrow) TransitionFade();
+    TransitionFade * transition = new (std::nothrow) TransitionFade();
     transition->initWithDuration(duration, scene, color);
     transition->autorelease();
     return transition;
 }
 
-TransitionFade* TransitionFade::create(std::chrono::milliseconds duration, Scene* scene)
+TransitionFade* TransitionFade::create(std::chrono::milliseconds duration,Scene* scene)
 {
     return TransitionFade::create(duration, scene, Color3B::BLACK);
 }
 
-bool TransitionFade::initWithDuration(std::chrono::milliseconds duration, Scene* scene, const Color3B& color)
+bool TransitionFade::initWithDuration(std::chrono::milliseconds duration, Scene *scene, const Color3B& color)
 {
     if (TransitionScene::initWithDuration(duration, scene))
     {
@@ -1107,13 +1215,13 @@ bool TransitionFade::initWithDuration(std::chrono::milliseconds duration, Scene*
     return true;
 }
 
-bool TransitionFade::initWithDuration(std::chrono::milliseconds t, Scene* scene)
+bool TransitionFade::initWithDuration(std::chrono::milliseconds t, Scene *scene)
 {
     this->initWithDuration(t, scene, Color3B::BLACK);
     return true;
 }
 
-void TransitionFade ::onEnter()
+void TransitionFade :: onEnter()
 {
     TransitionScene::onEnter();
 
@@ -1123,8 +1231,14 @@ void TransitionFade ::onEnter()
     addChild(l, 2, kSceneFade);
     Node* f = getChildByTag(kSceneFade);
 
-    auto a = Sequence::create({FadeIn::create(_duration / 2), CallFunc::create([this]() { hideOutShowIn(); }), FadeOut::create(_duration / 2),
-                               CallFunc::create([this]() { finish(); })});
+    auto a = Sequence::create
+        ({
+            FadeIn::create(_duration/2),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::hideOutShowIn,this)),
+            FadeOut::create(_duration/2),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this)),
+
+                } );
     f->runAction(a);
 }
 
@@ -1147,7 +1261,7 @@ TransitionCrossFade::~TransitionCrossFade()
 TransitionCrossFade* TransitionCrossFade::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionCrossFade* newScene = new (std::nothrow) TransitionCrossFade();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -1156,7 +1270,7 @@ TransitionCrossFade* TransitionCrossFade::create(std::chrono::milliseconds t, Sc
     return nullptr;
 }
 
-void TransitionCrossFade::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void TransitionCrossFade::draw(Renderer* /*renderer*/, const Mat4 &/*transform*/, uint32_t /*flags*/)
 {
     // override draw since both scenes (textures) are rendered in 1 scene
 }
@@ -1167,22 +1281,21 @@ void TransitionCrossFade::onEnter()
 
     // create a transparent color layer
     // in which we are going to add our rendertextures
-    Color4B color(0, 0, 0, 0);
+    Color4B  color(0,0,0,0);
     Size size = Director::getInstance()->getWinSize();
     LayerColor* layer = LayerColor::create(color);
 
     // create the first render texture for inScene
-    RenderTexture* inTexture =
-        RenderTexture::create(static_cast<int>(size.width), static_cast<int>(size.height), Texture2D::PixelFormat::RGBA8888, GL_DEPTH24_STENCIL8);
+    RenderTexture* inTexture = RenderTexture::create((int)size.width, (int)size.height,backend::PixelFormat::RGBA8888, PixelFormat::D24S8);
 
     if (nullptr == inTexture)
     {
         return;
     }
 
-    inTexture->getSprite()->setAnchorPoint(Vec2(0.5f, 0.5f));
-    inTexture->setPosition(size.width / 2, size.height / 2);
-    inTexture->setAnchorPoint(Vec2(0.5f, 0.5f));
+    inTexture->getSprite()->setAnchorPoint( Vec2(0.5f,0.5f) );
+    inTexture->setPosition(size.width/2, size.height/2);
+    inTexture->setAnchorPoint( Vec2(0.5f,0.5f) );
 
     // render inScene to its texturebuffer
     inTexture->begin();
@@ -1190,11 +1303,10 @@ void TransitionCrossFade::onEnter()
     inTexture->end();
 
     // create the second render texture for outScene
-    RenderTexture* outTexture =
-        RenderTexture::create(static_cast<int>(size.width), static_cast<int>(size.height), Texture2D::PixelFormat::RGBA8888, GL_DEPTH24_STENCIL8);
-    outTexture->getSprite()->setAnchorPoint(Vec2(0.5f, 0.5f));
-    outTexture->setPosition(size.width / 2, size.height / 2);
-    outTexture->setAnchorPoint(Vec2(0.5f, 0.5f));
+    RenderTexture* outTexture = RenderTexture::create((int)size.width, (int)size.height,backend::PixelFormat::RGBA8888, PixelFormat::D24S8);
+    outTexture->getSprite()->setAnchorPoint( Vec2(0.5f,0.5f) );
+    outTexture->setPosition(size.width/2, size.height/2);
+    outTexture->setAnchorPoint( Vec2(0.5f,0.5f) );
 
     // render outScene to its texturebuffer
     outTexture->begin();
@@ -1203,12 +1315,9 @@ void TransitionCrossFade::onEnter()
 
     // create blend functions
 
-    BlendFunc blend1 = {GL_ONE, GL_ONE}; // inScene will lay on background and will not be used with alpha
-    BlendFunc blend2 = {GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA}; // we are going to blend outScene via alpha
-
     // set blendfunctions
-    inTexture->getSprite()->setBlendFunc(blend1);
-    outTexture->getSprite()->setBlendFunc(blend2);
+    inTexture->getSprite()->setBlendFunc(BlendFunc::DISABLE);
+    outTexture->getSprite()->setBlendFunc(BlendFunc::ALPHA_PREMULTIPLIED);    
 
     // add render textures to the layer
     layer->addChild(inTexture);
@@ -1219,11 +1328,16 @@ void TransitionCrossFade::onEnter()
     outTexture->getSprite()->setOpacity(255);
 
     // create the blend action
-    Action* layerAction =
-        Sequence::create({FadeTo::create(_duration, 0), CallFunc::create([this]() { hideOutShowIn(); }), CallFunc::create([this]() { finish(); })});
+    Action* layerAction = Sequence::create
+    ({
+        FadeTo::create(_duration, 0),
+        CallFunc::create(CC_CALLBACK_0(TransitionScene::hideOutShowIn,this)),
+        CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this)),
+               } );
+
 
     // run the blend action
-    outTexture->getSprite()->runAction(layerAction);
+    outTexture->getSprite()->runAction( layerAction );
 
     // add the layer (which contains our two rendertextures) to the scene
     addChild(layer, 2, kSceneFade);
@@ -1232,7 +1346,7 @@ void TransitionCrossFade::onEnter()
 // clean up on exit
 void TransitionCrossFade::onExit()
 {
-    // remove our layer and release all containing objects
+    // remove our layer and release all containing objects 
     this->removeChildByTag(kSceneFade, false);
     TransitionScene::onExit();
 }
@@ -1254,7 +1368,7 @@ TransitionTurnOffTiles::~TransitionTurnOffTiles()
 TransitionTurnOffTiles* TransitionTurnOffTiles::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionTurnOffTiles* newScene = new (std::nothrow) TransitionTurnOffTiles();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -1277,12 +1391,20 @@ void TransitionTurnOffTiles::onEnter()
 
     Size s = Director::getInstance()->getWinSize();
     float aspect = s.width / s.height;
-    int x = static_cast<int>(12 * aspect);
+    int x = (int)(12 * aspect);
     int y = 12;
 
-    TurnOffTiles* toff = TurnOffTiles::create(_duration, Size(x, y));
+    TurnOffTiles* toff = TurnOffTiles::create(_duration, Size(x,y));
     ActionInterval* action = easeActionWithAction(toff);
-    _outSceneProxy->runAction(Sequence::create({action, CallFunc::create([this]() { finish(); }), StopGrid::create()}));
+    _outSceneProxy->runAction
+    ({
+        Sequence::create
+     ({
+            action,
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this)),
+            StopGrid::create()
+    })
+    });
 }
 
 void TransitionTurnOffTiles::onExit()
@@ -1292,15 +1414,15 @@ void TransitionTurnOffTiles::onExit()
     TransitionScene::onExit();
 }
 
-void TransitionTurnOffTiles::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void TransitionTurnOffTiles::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
     Scene::draw(renderer, transform, flags);
-
-    if (_isInSceneOnTop)
+    
+    if( _isInSceneOnTop )
     {
         _outSceneProxy->visit(renderer, transform, flags);
         _inScene->visit(renderer, transform, flags);
-    }
+    } 
     else
     {
         _inScene->visit(renderer, transform, flags);
@@ -1308,7 +1430,8 @@ void TransitionTurnOffTiles::draw(Renderer* renderer, const Mat4& transform, uin
     }
 }
 
-ActionInterval* TransitionTurnOffTiles::easeActionWithAction(ActionInterval* action)
+
+ActionInterval* TransitionTurnOffTiles:: easeActionWithAction(ActionInterval* action)
 {
     return action;
 }
@@ -1329,7 +1452,7 @@ TransitionSplitCols::~TransitionSplitCols()
 TransitionSplitCols* TransitionSplitCols::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionSplitCols* newScene = new (std::nothrow) TransitionSplitCols();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -1346,9 +1469,21 @@ void TransitionSplitCols::onEnter()
     _gridProxy->onEnter();
 
     ActionInterval* split = action();
-    auto seq = Sequence::create({split, CallFunc::create([this]() { switchTargetToInscene(); }), split->reverse()});
-
-    _gridProxy->runAction(Sequence::create({easeActionWithAction(seq), CallFunc::create([this]() { finish(); }), StopGrid::create()}));
+    auto seq = Sequence::create
+    ({
+        split,
+        CallFunc::create(CC_CALLBACK_0(TransitionSplitCols::switchTargetToInscene,this)),
+        split->reverse(),
+               } );
+
+    _gridProxy->runAction
+    ( 
+        Sequence::create
+        ({
+            easeActionWithAction(seq),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this)),
+            StopGrid::create()})
+    );
 }
 
 void TransitionSplitCols::switchTargetToInscene()
@@ -1356,7 +1491,7 @@ void TransitionSplitCols::switchTargetToInscene()
     _gridProxy->setTarget(_inScene);
 }
 
-void TransitionSplitCols::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void TransitionSplitCols::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
     Scene::draw(renderer, transform, flags);
     _gridProxy->visit(renderer, transform, flags);
@@ -1369,16 +1504,18 @@ void TransitionSplitCols::onExit()
     TransitionScene::onExit();
 }
 
-ActionInterval* TransitionSplitCols::action()
+ActionInterval* TransitionSplitCols:: action()
 {
     return SplitCols::create(_duration / 2, 3);
 }
 
-ActionInterval* TransitionSplitCols::easeActionWithAction(ActionInterval* action)
+
+ActionInterval* TransitionSplitCols::easeActionWithAction(ActionInterval * action)
 {
     return EaseInOut::create(action, 3.0f);
 }
 
+
 //
 // SplitRows Transition
 //
@@ -1392,13 +1529,13 @@ TransitionSplitRows::~TransitionSplitRows()
 
 ActionInterval* TransitionSplitRows::action()
 {
-    return SplitRows::create(_duration / 2, 3);
+    return SplitRows::create(_duration /2, 3);
 }
 
 TransitionSplitRows* TransitionSplitRows::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionSplitRows* newScene = new (std::nothrow) TransitionSplitRows();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -1423,7 +1560,7 @@ TransitionFadeTR::~TransitionFadeTR()
 TransitionFadeTR* TransitionFadeTR::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionFadeTR* newScene = new (std::nothrow) TransitionFadeTR();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -1446,12 +1583,19 @@ void TransitionFadeTR::onEnter()
 
     Size s = Director::getInstance()->getWinSize();
     float aspect = s.width / s.height;
-    int x = static_cast<int>(12 * aspect);
+    int x = (int)(12 * aspect);
     int y = 12;
 
-    ActionInterval* action = actionWithSize(Size(x, y));
+    ActionInterval* action  = actionWithSize(Size(x,y));
 
-    _outSceneProxy->runAction(Sequence::create({easeActionWithAction(action), CallFunc::create([this]() { finish(); }), StopGrid::create()}));
+    _outSceneProxy->runAction
+    (
+        Sequence::create
+        ({
+            easeActionWithAction(action),
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this)),
+            StopGrid::create()})
+    );
 }
 
 void TransitionFadeTR::onExit()
@@ -1461,15 +1605,15 @@ void TransitionFadeTR::onExit()
     TransitionScene::onExit();
 }
 
-void TransitionFadeTR::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void TransitionFadeTR::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
     Scene::draw(renderer, transform, flags);
-
-    if (_isInSceneOnTop)
+    
+    if( _isInSceneOnTop )
     {
         _outSceneProxy->visit(renderer, transform, flags);
         _inScene->visit(renderer, transform, flags);
-    }
+    } 
     else
     {
         _inScene->visit(renderer, transform, flags);
@@ -1477,16 +1621,17 @@ void TransitionFadeTR::draw(Renderer* renderer, const Mat4& transform, uint32_t
     }
 }
 
-ActionInterval* TransitionFadeTR::actionWithSize(const Size& size)
+ActionInterval*  TransitionFadeTR::actionWithSize(const Size& size)
 {
     return FadeOutTRTiles::create(_duration, size);
 }
 
-ActionInterval* TransitionFadeTR::easeActionWithAction(ActionInterval* action)
+ActionInterval* TransitionFadeTR:: easeActionWithAction(ActionInterval* action)
 {
     return action;
 }
 
+
 //
 // FadeBL Transition
 //
@@ -1501,7 +1646,7 @@ TransitionFadeBL::~TransitionFadeBL()
 TransitionFadeBL* TransitionFadeBL::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionFadeBL* newScene = new (std::nothrow) TransitionFadeBL();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -1510,7 +1655,7 @@ TransitionFadeBL* TransitionFadeBL::create(std::chrono::milliseconds t, Scene* s
     return nullptr;
 }
 
-ActionInterval* TransitionFadeBL::actionWithSize(const Size& size)
+ActionInterval*  TransitionFadeBL::actionWithSize(const Size& size)
 {
     return FadeOutBLTiles::create(_duration, size);
 }
@@ -1529,7 +1674,7 @@ TransitionFadeUp::~TransitionFadeUp()
 TransitionFadeUp* TransitionFadeUp::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionFadeUp* newScene = new (std::nothrow) TransitionFadeUp();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -1556,7 +1701,7 @@ TransitionFadeDown::~TransitionFadeDown()
 TransitionFadeDown* TransitionFadeDown::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionFadeDown* newScene = new (std::nothrow) TransitionFadeDown();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
diff --git a/cocos2d/cocos/2d/CCTransition.h b/cocos2d/cocos/2d/CCTransition.h
index bba58eadb0..6bc5442d8d 100644
--- a/cocos2d/cocos/2d/CCTransition.h
+++ b/cocos2d/cocos/2d/CCTransition.h
@@ -3,6 +3,7 @@ Copyright (c) 2009-2010 Ricardo Quesada
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,14 +26,11 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_TRANSITION_H
-#define CC_2D_TRANSITION_H
+#ifndef __CCTRANSITION_H__
+#define __CCTRANSITION_H__
 
 #include <cocos/2d/CCScene.h>
 
-#include <chrono>
-#include <cstdint>
-
 NS_CC_BEGIN
 
 /**
@@ -40,9 +38,9 @@ NS_CC_BEGIN
  * @{
  */
 
-// static creation function macro
-// c/c++ don't support object creation of using class name
-// so, all classes need creation method.
+//static creation function macro
+//c/c++ don't support object creation of using class name
+//so, all classes need creation method.
 
 class ActionInterval;
 class Node;
@@ -53,12 +51,12 @@ class NodeGrid;
 @since v0.8.2
 @js NA
 */
-class CC_DLL TransitionEaseScene // : public Ref
+class CC_DLL TransitionEaseScene// : public Ref
 {
 public:
     /** Constructor.
      */
-    virtual ~TransitionEaseScene();
+    virtual ~TransitionEaseScene() {}
 
     /** Returns the Ease action that will be performed on a linear action.
     @since v0.8.2
@@ -66,18 +64,18 @@ public:
      * @param action A given interval action.
      * @return The Ease action that will be performed on a linear action.
      */
-    virtual ActionInterval* easeActionWithAction(ActionInterval* action) = 0;
+    virtual ActionInterval * easeActionWithAction(ActionInterval * action) = 0;
 };
 
 /** @class TransitionScene
  * @brief Base class for Transition scenes.
- */
+*/
 class CC_DLL TransitionScene : public Scene
 {
 public:
     /** Orientation Type used by some transitions.
      */
-    enum struct Orientation : std::uint8_t
+    enum class Orientation
     {
         /// An horizontal orientation where the Left is nearer
         LEFT_OVER = 0,
@@ -88,51 +86,52 @@ public:
         /// A vertical orientation where the Bottom is nearer
         DOWN_OVER = 1,
     };
-
+    
     /** Creates a base transition with duration and incoming scene.
      *
      * @param t Duration time, in seconds.
      * @param scene A given scene.
      * @return A autoreleased TransitionScene object.
      */
-    static TransitionScene* create(std::chrono::milliseconds t, Scene* scene);
+    static TransitionScene * create(std::chrono::milliseconds t, Scene *scene);
 
     /** Called after the transition finishes.
      */
-    void finish(void);
+    void finish();
 
     /** Used by some transitions to hide the outer scene.
      */
-    void hideOutShowIn(void);
+    void hideOutShowIn();
 
-    inline Scene* getInScene() const noexcept { return _inScene; }
-    inline std::chrono::milliseconds getDuration() const noexcept { return _duration; }
+    Scene* getInScene() const{ return _inScene; }
+    std::chrono::milliseconds getDuration() const { return _duration; }
     //
     // Overrides
     //
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
-    void onEnter() override;
-    void onExit() override;
-    void cleanup() override;
-
-    CC_CONSTRUCTOR_ACCESS : TransitionScene();
-    ~TransitionScene() override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
+    virtual void onEnter() override;
+    virtual void onExit() override;
+    virtual void cleanup() override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    TransitionScene();
+    virtual ~TransitionScene();
 
     /** initializes a transition with duration and incoming scene */
-    bool initWithDuration(std::chrono::milliseconds t, Scene* scene);
-
+    bool initWithDuration(std::chrono::milliseconds t,Scene* scene);
+    
 protected:
     virtual void sceneOrder();
     void setNewScene(float dt);
 
-    Scene* _inScene;
-    Scene* _outScene;
+    Scene *_inScene;
+    Scene *_outScene;
     std::chrono::milliseconds _duration;
     bool _isInSceneOnTop;
     bool _isSendCleanupToScene;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionScene)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionScene);
 };
 
 /** @class TransitionSceneOriented
@@ -143,30 +142,31 @@ class CC_DLL TransitionSceneOriented : public TransitionScene
 {
 public:
     /** Creates a transition with duration, incoming scene and orientation.
-     *
+     * 
      * @param t Duration time, in seconds.
      * @param scene A given scene.
      * @param orientation A given orientation: LeftOver, RightOver, UpOver, DownOver.
      * @return A autoreleased TransitionSceneOriented object.
      */
-    static TransitionSceneOriented* create(std::chrono::milliseconds t, Scene* scene, Orientation orientation);
-
-    CC_CONSTRUCTOR_ACCESS : TransitionSceneOriented();
-    ~TransitionSceneOriented() override;
+    static TransitionSceneOriented * create(std::chrono::milliseconds t,Scene* scene, Orientation orientation);
+    
+CC_CONSTRUCTOR_ACCESS:
+    TransitionSceneOriented();
+    virtual ~TransitionSceneOriented();
 
     /** initializes a transition with duration and incoming scene */
-    bool initWithDuration(std::chrono::milliseconds t, Scene* scene, Orientation orientation);
+    bool initWithDuration(std::chrono::milliseconds t,Scene* scene,Orientation orientation);
 
 protected:
     Orientation _orientation;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSceneOriented)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSceneOriented);
 };
 
 /** @class TransitionRotoZoom
  * @brief TransitionRotoZoom:
-Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming
+Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming 
 */
 class CC_DLL TransitionRotoZoom : public TransitionScene
 {
@@ -182,18 +182,20 @@ public:
     //
     // Overrides
     //
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionRotoZoom();
-    ~TransitionRotoZoom() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionRotoZoom();
+    virtual ~TransitionRotoZoom();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionRotoZoom)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionRotoZoom);
+
 };
 
 /** @class TransitionJumpZoom
  * @brief TransitionJumpZoom:
-Zoom out and jump the outgoing scene, and then jump and zoom in the incoming
+Zoom out and jump the outgoing scene, and then jump and zoom in the incoming 
 */
 class CC_DLL TransitionJumpZoom : public TransitionScene
 {
@@ -209,13 +211,14 @@ public:
     //
     // Overrides
     //
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionJumpZoom();
-    ~TransitionJumpZoom() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionJumpZoom();
+    virtual ~TransitionJumpZoom();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionJumpZoom)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionJumpZoom);
 };
 
 /** @class TransitionMoveInL
@@ -233,28 +236,29 @@ public:
      */
     static TransitionMoveInL* create(std::chrono::milliseconds t, Scene* scene);
 
-    /** Returns the action that will be performed.
-     *
+    /** Returns the action that will be performed. 
+     * 
      * @return The action that will be performed.
      */
     virtual ActionInterval* action();
 
-    ActionInterval* easeActionWithAction(ActionInterval* action) override;
+    virtual ActionInterval* easeActionWithAction(ActionInterval * action) override;
 
     //
     // Overrides
     //
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionMoveInL();
-    ~TransitionMoveInL() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionMoveInL();
+    virtual ~TransitionMoveInL();
 
 protected:
     /** initializes the scenes */
     virtual void initScenes();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionMoveInL)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionMoveInL);
 };
 
 /** @class TransitionMoveInR
@@ -272,21 +276,22 @@ public:
      */
     static TransitionMoveInR* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS : TransitionMoveInR();
-    ~TransitionMoveInR() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionMoveInR();
+    virtual ~TransitionMoveInR();
 
 protected:
-    void initScenes() override;
+    virtual void initScenes();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionMoveInR)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionMoveInR);
 };
 
 /** @class TransitionMoveInT
  * @brief TransitionMoveInT:
 Move in from to the top the incoming scene.
 */
-class CC_DLL TransitionMoveInT : public TransitionMoveInL
+class CC_DLL TransitionMoveInT : public TransitionMoveInL 
 {
 public:
     /** Creates a transition with duration and incoming scene.
@@ -297,14 +302,15 @@ public:
      */
     static TransitionMoveInT* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS : TransitionMoveInT();
-    ~TransitionMoveInT() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionMoveInT();
+    virtual ~TransitionMoveInT();
 
 protected:
-    void initScenes() override;
+    virtual void initScenes();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionMoveInT)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionMoveInT);
 };
 
 /** @class TransitionMoveInB
@@ -322,14 +328,15 @@ public:
      */
     static TransitionMoveInB* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS : TransitionMoveInB();
-    ~TransitionMoveInB() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionMoveInB();
+    virtual ~TransitionMoveInB();
 
 protected:
-    void initScenes() override;
+    virtual void initScenes();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionMoveInB)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionMoveInB);
 };
 
 /** @class TransitionSlideInL
@@ -347,7 +354,7 @@ public:
      */
     static TransitionSlideInL* create(std::chrono::milliseconds t, Scene* scene);
 
-    ActionInterval* easeActionWithAction(ActionInterval* action) override;
+    virtual ActionInterval* easeActionWithAction(ActionInterval * action) override;
 
     /** Returns the action that will be performed by the incoming and outgoing scene.
      *
@@ -358,26 +365,27 @@ public:
     //
     // Overrides
     //
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionSlideInL();
-    ~TransitionSlideInL() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionSlideInL();
+    virtual ~TransitionSlideInL();
 
 protected:
     /** initializes the scenes */
     virtual void initScenes();
 
-    void sceneOrder() override;
+    virtual void sceneOrder() override;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSlideInL)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSlideInL);
 };
 
 /** @class TransitionSlideInR
  *@brief TransitionSlideInR:
 Slide in the incoming scene from the right border.
 */
-class CC_DLL TransitionSlideInR : public TransitionSlideInL
+class CC_DLL TransitionSlideInR : public TransitionSlideInL 
 {
 public:
     /** Creates a transition with duration and incoming scene.
@@ -389,19 +397,20 @@ public:
     static TransitionSlideInR* create(std::chrono::milliseconds t, Scene* scene);
 
     /** Returns the action that will be performed by the incoming and outgoing scene. */
-    ActionInterval* action(void) override;
+    virtual ActionInterval* action() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionSlideInR();
-    ~TransitionSlideInR() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionSlideInR();
+    virtual ~TransitionSlideInR();
 
 protected:
     /** initializes the scenes */
-    void initScenes() override;
+    virtual void initScenes() override;
 
-    void sceneOrder() override;
+    virtual void sceneOrder() override;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSlideInR)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSlideInR);
 };
 
 /** @class TransitionSlideInB
@@ -420,19 +429,20 @@ public:
     static TransitionSlideInB* create(std::chrono::milliseconds t, Scene* scene);
 
     /** returns the action that will be performed by the incoming and outgoing scene */
-    ActionInterval* action() override;
+    virtual ActionInterval* action() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionSlideInB();
-    ~TransitionSlideInB() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionSlideInB();
+    virtual ~TransitionSlideInB();
 
 protected:
     /** initializes the scenes */
-    void initScenes() override;
+    virtual void initScenes() override;
 
-    void sceneOrder() override;
+    virtual void sceneOrder() override;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSlideInB)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSlideInB);
 };
 
 /** @class TransitionSlideInT
@@ -451,25 +461,26 @@ public:
     static TransitionSlideInT* create(std::chrono::milliseconds t, Scene* scene);
 
     /** returns the action that will be performed by the incoming and outgoing scene */
-    ActionInterval* action(void) override;
+    virtual ActionInterval* action() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionSlideInT();
-    ~TransitionSlideInT() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionSlideInT();
+    virtual ~TransitionSlideInT();
 
 protected:
     /** initializes the scenes */
-    void initScenes(void) override;
+    virtual void initScenes() override;
 
-    void sceneOrder() override;
+    virtual void sceneOrder() override;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSlideInT)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSlideInT);
 };
 
 /** @class TransitionShrinkGrow
- * @brief Shrink the outgoing scene while grow the incoming scene
- */
-class CC_DLL TransitionShrinkGrow : public TransitionScene, public TransitionEaseScene
+* @brief Shrink the outgoing scene while grow the incoming scene
+*/
+class CC_DLL TransitionShrinkGrow : public TransitionScene , public TransitionEaseScene
 {
 public:
     /** Creates a transition with duration and incoming scene.
@@ -486,14 +497,15 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
-    ActionInterval* easeActionWithAction(ActionInterval* action) override;
+    virtual void onEnter() override;
+    virtual ActionInterval* easeActionWithAction(ActionInterval * action) override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionShrinkGrow();
-    ~TransitionShrinkGrow() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionShrinkGrow();
+    virtual ~TransitionShrinkGrow();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionShrinkGrow)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionShrinkGrow);
 };
 
 /** @class TransitionFlipX
@@ -526,13 +538,14 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionFlipX();
-    ~TransitionFlipX() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionFlipX();
+    virtual ~TransitionFlipX();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFlipX)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFlipX);
 };
 
 /** @class TransitionFlipY
@@ -565,13 +578,14 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionFlipY();
-    ~TransitionFlipY() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionFlipY();
+    virtual ~TransitionFlipY();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFlipY)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFlipY);
 };
 
 /** @class TransitionFlipAngular
@@ -604,13 +618,14 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionFlipAngular();
-    ~TransitionFlipAngular() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionFlipAngular();
+    virtual ~TransitionFlipAngular();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFlipAngular)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFlipAngular);
 };
 
 /** @class TransitionZoomFlipX
@@ -643,13 +658,14 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionZoomFlipX();
-    ~TransitionZoomFlipX() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionZoomFlipX();
+    virtual ~TransitionZoomFlipX();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionZoomFlipX)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionZoomFlipX);
 };
 
 /** @class TransitionZoomFlipY
@@ -682,13 +698,14 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionZoomFlipY();
-    ~TransitionZoomFlipY() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionZoomFlipY();
+    virtual ~TransitionZoomFlipY();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionZoomFlipY)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionZoomFlipY);
 };
 
 /** @class TransitionZoomFlipAngular
@@ -721,13 +738,14 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionZoomFlipAngular();
-    ~TransitionZoomFlipAngular() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionZoomFlipAngular();
+    virtual ~TransitionZoomFlipAngular();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionZoomFlipAngular)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionZoomFlipAngular);
 };
 
 /** @class TransitionFade
@@ -757,24 +775,26 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
     /**
      * @lua NA
      */
-    void onExit() override;
-
-    CC_CONSTRUCTOR_ACCESS : TransitionFade();
-    ~TransitionFade() override;
+    virtual void onExit() override;
+    
+CC_CONSTRUCTOR_ACCESS:
+    TransitionFade();
+    virtual ~TransitionFade();
 
     /** initializes the transition with a duration and with an RGB color */
-    bool initWithDuration(std::chrono::milliseconds t, Scene* scene, const Color3B& color);
+    bool initWithDuration(std::chrono::milliseconds t, Scene*scene, const Color3B& color);
     bool initWithDuration(std::chrono::milliseconds t, Scene* scene);
 
 protected:
     Color4B _color;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFade)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFade);
+
 };
 
 class RenderTexture;
@@ -784,7 +804,7 @@ Cross fades two scenes using the RenderTexture object.
 */
 class CC_DLL TransitionCrossFade : public TransitionScene
 {
-public:
+public :
     /** Creates a transition with duration and incoming scene.
      *
      * @param t Duration time, in seconds.
@@ -799,30 +819,31 @@ public:
     /**
      * @lua NA
      */
-    virtual void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
     /**
      * @lua NA
      */
-    void onEnter() override;
+    virtual void onEnter() override;
     /**
      * @lua NA
      */
-    void onExit() override;
+    virtual void onExit() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionCrossFade();
-    ~TransitionCrossFade() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionCrossFade();
+    virtual ~TransitionCrossFade();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionCrossFade)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionCrossFade);
 };
 
 /** @class TransitionTurnOffTiles
  * @brief TransitionTurnOffTiles:
 Turn off the tiles of the outgoing scene in random order
 */
-class CC_DLL TransitionTurnOffTiles : public TransitionScene, public TransitionEaseScene
+class CC_DLL TransitionTurnOffTiles : public TransitionScene ,public TransitionEaseScene
 {
-public:
+public :
     /** Creates a transition with duration and incoming scene.
      *
      * @param t Duration time, in seconds.
@@ -837,33 +858,34 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
-    /**
-     * @js NA
-     */
-    void onExit() override;
-    ActionInterval* easeActionWithAction(ActionInterval* action) override;
+    virtual void onEnter() override;
     /**
      * @js NA
      */
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual void onExit() override;
+	virtual ActionInterval * easeActionWithAction(ActionInterval * action) override;
+	/**
+	* @js NA
+	*/
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionTurnOffTiles();
-    ~TransitionTurnOffTiles() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionTurnOffTiles();
+    virtual ~TransitionTurnOffTiles();
 
 protected:
-    void sceneOrder() override;
+    virtual void sceneOrder() override;
     NodeGrid* _outSceneProxy;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionTurnOffTiles)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionTurnOffTiles);
 };
 
 /** @class TransitionSplitCols
  * @brief TransitionSplitCols:
 The odd columns goes upwards while the even columns goes downwards.
 */
-class CC_DLL TransitionSplitCols : public TransitionScene, public TransitionEaseScene
+class CC_DLL TransitionSplitCols : public TransitionScene , public TransitionEaseScene
 {
 public:
     /** Creates a transition with duration and incoming scene.
@@ -886,20 +908,20 @@ public:
     /**
      * @lua NA
      */
-    void onEnter() override;
-    ActionInterval* easeActionWithAction(ActionInterval* action) override;
-    void onExit() override;
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual void onEnter() override;
+    virtual ActionInterval * easeActionWithAction(ActionInterval * action) override;
+    virtual void onExit() override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionSplitCols();
-    ~TransitionSplitCols() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionSplitCols();
+    virtual ~TransitionSplitCols();
 
 protected:
     void switchTargetToInscene();
     NodeGrid* _gridProxy;
-
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSplitCols)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSplitCols);
 };
 
 /** @class TransitionSplitRows
@@ -920,20 +942,21 @@ public:
     //
     // Overrides
     //
-    ActionInterval* action(void) override;
+    virtual ActionInterval* action() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionSplitRows();
-    ~TransitionSplitRows() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionSplitRows();
+    virtual ~TransitionSplitRows();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSplitRows)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionSplitRows);
 };
 
 /** @class TransitionFadeTR
  * @brief TransitionFadeTR:
 Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner.
 */
-class CC_DLL TransitionFadeTR : public TransitionScene, public TransitionEaseScene
+class CC_DLL TransitionFadeTR : public TransitionScene , public TransitionEaseScene
 {
 public:
     /** Creates a transition with duration and incoming scene.
@@ -958,21 +981,22 @@ public:
      * @js NA
      * @lua NA
      */
-    void onEnter() override;
-    ActionInterval* easeActionWithAction(ActionInterval* action) override;
-    void onExit() override;
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual void onEnter() override;
+    virtual ActionInterval* easeActionWithAction(ActionInterval * action) override;
+    virtual void onExit() override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionFadeTR();
-    ~TransitionFadeTR() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionFadeTR();
+    virtual ~TransitionFadeTR();
 
 protected:
-    void sceneOrder() override;
+    virtual void sceneOrder() override;
 
     NodeGrid* _outSceneProxy;
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFadeTR)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFadeTR);
 };
 
 /** @class TransitionFadeBL
@@ -993,19 +1017,20 @@ public:
     //
     // Overrides
     //
-    ActionInterval* actionWithSize(const Size& size) override;
+    virtual ActionInterval* actionWithSize(const Size& size) override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionFadeBL();
-    ~TransitionFadeBL() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionFadeBL();
+    virtual ~TransitionFadeBL();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFadeBL)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFadeBL);
 };
 
 /** @class TransitionFadeUp
  * @brief TransitionFadeUp:
- * Fade the tiles of the outgoing scene from the bottom to the top.
- */
+* Fade the tiles of the outgoing scene from the bottom to the top.
+*/
 class CC_DLL TransitionFadeUp : public TransitionFadeTR
 {
 public:
@@ -1020,19 +1045,20 @@ public:
     //
     // Overrides
     //
-    ActionInterval* actionWithSize(const Size& size) override;
+    virtual ActionInterval* actionWithSize(const Size& size) override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionFadeUp();
-    ~TransitionFadeUp() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionFadeUp();
+    virtual ~TransitionFadeUp();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFadeUp)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFadeUp);
 };
 
 /** @class TransitionFadeDown
  * @brief TransitionFadeDown:
- * Fade the tiles of the outgoing scene from the top to the bottom.
- */
+* Fade the tiles of the outgoing scene from the top to the bottom.
+*/
 class CC_DLL TransitionFadeDown : public TransitionFadeTR
 {
 public:
@@ -1047,13 +1073,15 @@ public:
     //
     // Overrides
     //
-    ActionInterval* actionWithSize(const Size& size) override;
+    virtual ActionInterval* actionWithSize(const Size& size) override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionFadeDown();
-    ~TransitionFadeDown() override;
+CC_CONSTRUCTOR_ACCESS:
+    TransitionFadeDown();
+    virtual ~TransitionFadeDown();
 
 private:
-    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFadeDown)
+    CC_DISALLOW_COPY_AND_ASSIGN(TransitionFadeDown);
+
 };
 
 // end of _2d group
@@ -1061,4 +1089,5 @@ private:
 
 NS_CC_END
 
-#endif // CC_2D_TRANSITION_H
+#endif // __CCTRANSITION_H__
+
diff --git a/cocos2d/cocos/2d/CCTransitionPageTurn.cpp b/cocos2d/cocos/2d/CCTransitionPageTurn.cpp
index dcda0ec833..9873612cdf 100644
--- a/cocos2d/cocos/2d/CCTransitionPageTurn.cpp
+++ b/cocos2d/cocos/2d/CCTransitionPageTurn.cpp
@@ -2,6 +2,7 @@
 Copyright (c) 2009      Sindesso Pty Ltd http://www.sindesso.com/
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,10 +26,9 @@ THE SOFTWARE.
 ****************************************************************************/
 
 #include <cocos/2d/CCTransitionPageTurn.h>
-
+#include <cocos/base/CCDirector.h>
 #include <cocos/2d/CCActionPageTurn3D.h>
 #include <cocos/2d/CCNodeGrid.h>
-#include <cocos/base/CCDirector.h>
 #include <cocos/renderer/CCRenderer.h>
 
 NS_CC_BEGIN
@@ -37,7 +37,7 @@ TransitionPageTurn::TransitionPageTurn()
 {
     _inSceneProxy = NodeGrid::create();
     _outSceneProxy = NodeGrid::create();
-
+    
     _inSceneProxy->retain();
     _outSceneProxy->retain();
 }
@@ -49,16 +49,16 @@ TransitionPageTurn::~TransitionPageTurn()
 }
 
 /** creates a base transition with duration and incoming scene */
-TransitionPageTurn* TransitionPageTurn::create(std::chrono::milliseconds t, Scene* scene, bool backwards)
+TransitionPageTurn * TransitionPageTurn::create(std::chrono::milliseconds t, Scene *scene, bool backwards)
 {
-    TransitionPageTurn* transition = new (std::nothrow) TransitionPageTurn();
-    transition->initWithDuration(t, scene, backwards);
+    TransitionPageTurn * transition = new (std::nothrow) TransitionPageTurn();
+    transition->initWithDuration(t,scene,backwards);
     transition->autorelease();
     return transition;
 }
 
 /** initializes a transition with duration and incoming scene */
-bool TransitionPageTurn::initWithDuration(std::chrono::milliseconds t, Scene* scene, bool backwards)
+bool TransitionPageTurn::initWithDuration(std::chrono::milliseconds t, Scene *scene, bool backwards)
 {
     // FIXME:: needed before [super init]
     _back = backwards;
@@ -75,19 +75,17 @@ void TransitionPageTurn::sceneOrder()
     _isInSceneOnTop = _back;
 }
 
-void TransitionPageTurn::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
+void TransitionPageTurn::draw(Renderer *renderer, const Mat4 &transform, uint32_t flags)
 {
     Scene::draw(renderer, transform, flags);
-
-    if (_isInSceneOnTop)
-    {
+    
+    if( _isInSceneOnTop ) {
         _outSceneProxy->visit(renderer, transform, flags);
         _inSceneProxy->visit(renderer, transform, flags);
-    }
-    else
-    {
+    } else {
         _inSceneProxy->visit(renderer, transform, flags);
         _outSceneProxy->visit(renderer, transform, flags);
+        
     }
 }
 
@@ -100,31 +98,49 @@ void TransitionPageTurn::onEnter()
 
     _inSceneProxy->onEnter();
     _outSceneProxy->onEnter();
-
+    
     Size s = Director::getInstance()->getWinSize();
-    int x, y;
+    int x,y;
     if (s.width > s.height)
     {
-        x = 16;
-        y = 12;
+        x=16;
+        y=12;
     }
     else
     {
-        x = 12;
-        y = 16;
+        x=12;
+        y=16;
     }
 
-    ActionInterval* action = this->actionWithSize(Size(x, y));
+    ActionInterval *action  = this->actionWithSize(Size(x,y));
 
-    if (!_back)
+    if (! _back )
     {
-        _outSceneProxy->runAction(Sequence::create({action, CallFunc::create([this]() { finish(); }), StopGrid::create()}));
+        _outSceneProxy->runAction
+        (
+            Sequence::create
+         ({
+            action,
+            CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this)),
+            StopGrid::create()
+            
+        })
+        );
     }
     else
     {
         // to prevent initial flicker
         _inSceneProxy->setVisible(false);
-        _inSceneProxy->runAction(Sequence::create({Show::create(), action, CallFunc::create([this]() { finish(); }), StopGrid::create()}));
+        _inSceneProxy->runAction
+        (
+            Sequence::create
+         ({
+                Show::create(),
+                action,
+                CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this)),
+                StopGrid::create()
+        })
+        );
     }
 }
 void TransitionPageTurn::onExit()
@@ -133,16 +149,19 @@ void TransitionPageTurn::onExit()
     _outSceneProxy->setTarget(nullptr);
     _outSceneProxy->onExit();
     _inSceneProxy->onExit();
-
+    
     TransitionScene::onExit();
 }
 
-ActionInterval* TransitionPageTurn::actionWithSize(const Size& vector)
+ActionInterval* TransitionPageTurn:: actionWithSize(const Size& vector)
 {
     if (_back)
     {
         // Get hold of the PageTurn3DAction
-        return ReverseTime::create(PageTurn3D::create(_duration, vector));
+        return ReverseTime::create
+        (
+            PageTurn3D::create(_duration, vector)
+        );
     }
     else
     {
diff --git a/cocos2d/cocos/2d/CCTransitionPageTurn.h b/cocos2d/cocos/2d/CCTransitionPageTurn.h
index 1266bdfcfb..46fc2b6a2f 100644
--- a/cocos2d/cocos/2d/CCTransitionPageTurn.h
+++ b/cocos2d/cocos/2d/CCTransitionPageTurn.h
@@ -2,6 +2,7 @@
 Copyright (c) 2009      Sindesso Pty Ltd http://www.sindesso.com/
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,14 +25,12 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_TRANSITIONPAGETURN_H
-#define CC_2D_TRANSITIONPAGETURN_H
+#ifndef __CCPAGE_TURN_TRANSITION_H__
+#define __CCPAGE_TURN_TRANSITION_H__
 
 #include <cocos/2d/CCTransition.h>
 #include <cocos/renderer/CCCustomCommand.h>
 
-#include <chrono>
-
 NS_CC_BEGIN
 
 class NodeGrid;
@@ -65,13 +64,13 @@ public:
      * @param backwards If back is true then the effect is reversed to appear as if the incoming scene is being turned from left over the outgoing scene.
      * @return An autoreleased TransitionPageTurn object.
      */
-    static TransitionPageTurn* create(std::chrono::milliseconds t, Scene* scene, bool backwards);
-
+    static TransitionPageTurn* create(std::chrono::milliseconds t,Scene* scene,bool backwards);
+    
     //
     // Overrides
     // @js NA
     //
-    void draw(Renderer* renderer, const Mat4& transform, uint32_t flags) override;
+    virtual void draw(Renderer *renderer, const Mat4 &transform, uint32_t flags) override;
 
     /**
      * Creates a base transition with duration and incoming scene.
@@ -83,7 +82,7 @@ public:
      * @param backwards If back is true then the effect is reversed to appear as if the incoming scene is being turned from left over the outgoing scene.
      * @return True if initialize success.
      */
-    bool initWithDuration(std::chrono::milliseconds t, Scene* scene, bool backwards);
+    bool initWithDuration(std::chrono::milliseconds t,Scene* scene,bool backwards);
 
     /** Returns the action that will be performed with size.
      *
@@ -95,27 +94,27 @@ public:
     //
     // Overrides
     //
-    void onEnter() override;
-    void onExit() override;
-
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        TransitionPageTurn();
+    virtual void onEnter() override;
+    virtual void onExit() override;
+
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    TransitionPageTurn();
     /**
      * @js NA
      * @lua NA
      */
-    ~TransitionPageTurn() override;
+    virtual ~TransitionPageTurn();
 
 protected:
-    void sceneOrder() override;
+    virtual void sceneOrder() override;
 
 protected:
     NodeGrid* _inSceneProxy;
     NodeGrid* _outSceneProxy;
-    bool _back;
+    bool    _back;
 };
 
 // end of _2d group
@@ -123,4 +122,5 @@ protected:
 
 NS_CC_END
 
-#endif // CC_2D_TRANSITIONPAGETURN_H
+#endif // __CCPAGE_TURN_TRANSITION_H__
+
diff --git a/cocos2d/cocos/2d/CCTransitionProgress.cpp b/cocos2d/cocos/2d/CCTransitionProgress.cpp
index 10f7f1928b..d365648704 100644
--- a/cocos2d/cocos/2d/CCTransitionProgress.cpp
+++ b/cocos2d/cocos/2d/CCTransitionProgress.cpp
@@ -3,6 +3,7 @@ Copyright (c) 2009      Lam Pham
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2012      Ricardo Quesada
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,18 +26,17 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#include <cocos/2d/CCTransitionProgress.h>
 
+#include <cocos/2d/CCTransitionProgress.h>
+#include <cocos/base/CCDirector.h>
+#include <cocos/2d/CCRenderTexture.h>
+#include <cocos/2d/CCProgressTimer.h>
 #include <cocos/2d/CCActionInstant.h>
 #include <cocos/2d/CCActionProgressTimer.h>
-#include <cocos/2d/CCProgressTimer.h>
-#include <cocos/2d/CCRenderTexture.h>
-#include <cocos/base/CCDirector.h>
 
 NS_CC_BEGIN
 
-enum
-{
+enum {
     kSceneRadial = 0xc001,
 };
 
@@ -45,12 +45,13 @@ TransitionProgress::TransitionProgress()
 , _from(0.0f)
 , _sceneToBeModified(nullptr)
 {
+
 }
 
 TransitionProgress* TransitionProgress::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionProgress* newScene = new (std::nothrow) TransitionProgress();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -65,33 +66,36 @@ void TransitionProgress::onEnter()
     TransitionScene::onEnter();
 
     setupTransition();
-
+    
     // create a transparent color layer
     // in which we are going to add our rendertextures
     Size size = Director::getInstance()->getWinSize();
 
     // create the second render texture for outScene
-    RenderTexture* texture =
-        RenderTexture::create(static_cast<int>(size.width), static_cast<int>(size.height), Texture2D::PixelFormat::RGBA8888, GL_DEPTH24_STENCIL8);
-    texture->getSprite()->setAnchorPoint(Vec2(0.5f, 0.5f));
-    texture->setPosition(size.width / 2, size.height / 2);
-    texture->setAnchorPoint(Vec2(0.5f, 0.5f));
+    RenderTexture *texture = RenderTexture::create((int)size.width, (int)size.height,backend::PixelFormat::RGBA8888, backend::PixelFormat::D24S8);
+    texture->getSprite()->setAnchorPoint(Vec2(0.5f,0.5f));
+    texture->setPosition(size.width/2, size.height/2);
+    texture->setAnchorPoint(Vec2(0.5f,0.5f));
 
     // render outScene to its texturebuffer
     texture->beginWithClear(0, 0, 0, 1);
     _sceneToBeModified->visit();
     texture->end();
 
+
     //    Since we've passed the outScene to the texture we don't need it.
     if (_sceneToBeModified == _outScene)
     {
         hideOutShowIn();
     }
     //    We need the texture in RenderTexture.
-    ProgressTimer* node = progressTimerNodeWithRenderTexture(texture);
+    ProgressTimer *node = progressTimerNodeWithRenderTexture(texture);
 
     // create the blend action
-    auto layerAction = Sequence::create({ProgressFromTo::create(_duration, _from, _to), CallFunc::create([this]() { finish(); })});
+    auto layerAction = Sequence::create({
+        ProgressFromTo::create(_duration, _from, _to),
+        CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this))
+    });
     // run the blend action
     node->runAction(layerAction);
 
@@ -119,12 +123,13 @@ void TransitionProgress::setupTransition()
     _to = 0;
 }
 
-ProgressTimer* TransitionProgress::progressTimerNodeWithRenderTexture(RenderTexture* texture)
+ProgressTimer* TransitionProgress::progressTimerNodeWithRenderTexture(RenderTexture* /*texture*/)
 {
     CCASSERT(false, "override me - abstract class");
     return nullptr;
 }
 
+
 // TransitionProgressRadialCCW
 
 ProgressTimer* TransitionProgressRadialCCW::progressTimerNodeWithRenderTexture(RenderTexture* texture)
@@ -134,22 +139,22 @@ ProgressTimer* TransitionProgressRadialCCW::progressTimerNodeWithRenderTexture(R
     ProgressTimer* node = ProgressTimer::create(texture->getSprite());
 
     // but it is flipped upside down so we flip the sprite
-    node->getSprite()->setFlippedY(true);
+    // node->getSprite()->setFlippedY(true);
     node->setType(ProgressTimer::Type::RADIAL);
 
     //    Return the radial type that we want to use
     node->setReverseDirection(false);
     node->setPercentage(100);
-    node->setPosition(size.width / 2, size.height / 2);
-    node->setAnchorPoint(Vec2(0.5f, 0.5f));
-
+    node->setPosition(size.width/2, size.height/2);
+    node->setAnchorPoint(Vec2(0.5f,0.5f));
+    
     return node;
 }
 
 TransitionProgressRadialCCW* TransitionProgressRadialCCW::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionProgressRadialCCW* newScene = new (std::nothrow) TransitionProgressRadialCCW();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -162,7 +167,7 @@ TransitionProgressRadialCCW* TransitionProgressRadialCCW::create(std::chrono::mi
 TransitionProgressRadialCW* TransitionProgressRadialCW::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionProgressRadialCW* newScene = new (std::nothrow) TransitionProgressRadialCW();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -174,19 +179,19 @@ TransitionProgressRadialCW* TransitionProgressRadialCW::create(std::chrono::mill
 ProgressTimer* TransitionProgressRadialCW::progressTimerNodeWithRenderTexture(RenderTexture* texture)
 {
     Size size = Director::getInstance()->getWinSize();
-
+    
     ProgressTimer* node = ProgressTimer::create(texture->getSprite());
-
+    
     // but it is flipped upside down so we flip the sprite
-    node->getSprite()->setFlippedY(true);
-    node->setType(ProgressTimer::Type::RADIAL);
-
+    // node->getSprite()->setFlippedY(true);
+    node->setType( ProgressTimer::Type::RADIAL );
+    
     //    Return the radial type that we want to use
     node->setReverseDirection(true);
     node->setPercentage(100);
-    node->setPosition(size.width / 2, size.height / 2);
-    node->setAnchorPoint(Vec2(0.5f, 0.5f));
-
+    node->setPosition(size.width/2, size.height/2);
+    node->setAnchorPoint(Vec2(0.5f,0.5f));
+    
     return node;
 }
 
@@ -194,7 +199,7 @@ ProgressTimer* TransitionProgressRadialCW::progressTimerNodeWithRenderTexture(Re
 TransitionProgressHorizontal* TransitionProgressHorizontal::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionProgressHorizontal* newScene = new (std::nothrow) TransitionProgressHorizontal();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -204,21 +209,21 @@ TransitionProgressHorizontal* TransitionProgressHorizontal::create(std::chrono::
 }
 
 ProgressTimer* TransitionProgressHorizontal::progressTimerNodeWithRenderTexture(RenderTexture* texture)
-{
+{    
     Size size = Director::getInstance()->getWinSize();
 
     ProgressTimer* node = ProgressTimer::create(texture->getSprite());
-
+    
     // but it is flipped upside down so we flip the sprite
-    node->getSprite()->setFlippedY(true);
-    node->setType(ProgressTimer::Type::BAR);
-
+    // node->getSprite()->setFlippedY(true);
+    node->setType( ProgressTimer::Type::BAR);
+    
     node->setMidpoint(Vec2(1, 0));
-    node->setBarChangeRate(Vec2(1, 0));
-
+    node->setBarChangeRate(Vec2(1,0));
+    
     node->setPercentage(100);
-    node->setPosition(size.width / 2, size.height / 2);
-    node->setAnchorPoint(Vec2(0.5f, 0.5f));
+    node->setPosition(size.width/2, size.height/2);
+    node->setAnchorPoint(Vec2(0.5f,0.5f));
 
     return node;
 }
@@ -227,7 +232,7 @@ ProgressTimer* TransitionProgressHorizontal::progressTimerNodeWithRenderTexture(
 TransitionProgressVertical* TransitionProgressVertical::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionProgressVertical* newScene = new (std::nothrow) TransitionProgressVertical();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -237,30 +242,31 @@ TransitionProgressVertical* TransitionProgressVertical::create(std::chrono::mill
 }
 
 ProgressTimer* TransitionProgressVertical::progressTimerNodeWithRenderTexture(RenderTexture* texture)
-{
+{    
     Size size = Director::getInstance()->getWinSize();
-
+    
     ProgressTimer* node = ProgressTimer::create(texture->getSprite());
-
+    
     // but it is flipped upside down so we flip the sprite
-    node->getSprite()->setFlippedY(true);
+    // node->getSprite()->setFlippedY(true);
     node->setType(ProgressTimer::Type::BAR);
-
+    
     node->setMidpoint(Vec2(0, 0));
-    node->setBarChangeRate(Vec2(0, 1));
-
+    node->setBarChangeRate(Vec2(0,1));
+    
     node->setPercentage(100);
-    node->setPosition(size.width / 2, size.height / 2);
-    node->setAnchorPoint(Vec2(0.5f, 0.5f));
-
+    node->setPosition(size.width/2, size.height/2);
+    node->setAnchorPoint(Vec2(0.5f,0.5f));
+    
     return node;
 }
 
+
 // TransitionProgressInOut
 TransitionProgressInOut* TransitionProgressInOut::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionProgressInOut* newScene = new (std::nothrow) TransitionProgressInOut();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -278,34 +284,35 @@ void TransitionProgressInOut::setupTransition()
 {
     _sceneToBeModified = _inScene;
     _from = 0;
-    _to = 100;
+    _to = 100;    
 }
 
 ProgressTimer* TransitionProgressInOut::progressTimerNodeWithRenderTexture(RenderTexture* texture)
-{
+{    
     Size size = Director::getInstance()->getWinSize();
-
+    
     ProgressTimer* node = ProgressTimer::create(texture->getSprite());
-
+    
     // but it is flipped upside down so we flip the sprite
-    node->getSprite()->setFlippedY(true);
-    node->setType(ProgressTimer::Type::BAR);
-
+    // node->getSprite()->setFlippedY(true);
+    node->setType( ProgressTimer::Type::BAR);
+    
     node->setMidpoint(Vec2(0.5f, 0.5f));
     node->setBarChangeRate(Vec2(1, 1));
-
+    
     node->setPercentage(0);
-    node->setPosition(size.width / 2, size.height / 2);
-    node->setAnchorPoint(Vec2(0.5f, 0.5f));
-
+    node->setPosition(size.width/2, size.height/2);
+    node->setAnchorPoint(Vec2(0.5f,0.5f));
+    
     return node;
 }
 
+
 // TransitionProgressOutIn
 TransitionProgressOutIn* TransitionProgressOutIn::create(std::chrono::milliseconds t, Scene* scene)
 {
     TransitionProgressOutIn* newScene = new (std::nothrow) TransitionProgressOutIn();
-    if (newScene && newScene->initWithDuration(t, scene))
+    if(newScene && newScene->initWithDuration(t, scene))
     {
         newScene->autorelease();
         return newScene;
@@ -315,22 +322,22 @@ TransitionProgressOutIn* TransitionProgressOutIn::create(std::chrono::millisecon
 }
 
 ProgressTimer* TransitionProgressOutIn::progressTimerNodeWithRenderTexture(RenderTexture* texture)
-{
+{    
     Size size = Director::getInstance()->getWinSize();
-
+    
     ProgressTimer* node = ProgressTimer::create(texture->getSprite());
-
+    
     // but it is flipped upside down so we flip the sprite
-    node->getSprite()->setFlippedY(true);
-    node->setType(ProgressTimer::Type::BAR);
-
+    // node->getSprite()->setFlippedY(true);
+    node->setType( ProgressTimer::Type::BAR );
+    
     node->setMidpoint(Vec2(0.5f, 0.5f));
     node->setBarChangeRate(Vec2(1, 1));
-
+    
     node->setPercentage(100);
-    node->setPosition(size.width / 2, size.height / 2);
-    node->setAnchorPoint(Vec2(0.5f, 0.5f));
-
+    node->setPosition(size.width/2, size.height/2);
+    node->setAnchorPoint(Vec2(0.5f,0.5f));
+    
     return node;
 }
 
diff --git a/cocos2d/cocos/2d/CCTransitionProgress.h b/cocos2d/cocos/2d/CCTransitionProgress.h
index 0ad9dd3424..27cc71fcd1 100644
--- a/cocos2d/cocos/2d/CCTransitionProgress.h
+++ b/cocos2d/cocos/2d/CCTransitionProgress.h
@@ -3,6 +3,7 @@ Copyright (c) 2009      Lam Pham
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2012      Ricardo Quesada
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -25,13 +26,11 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_TRANSITIONPROGRESS_H
-#define CC_2D_TRANSITIONPROGRESS_H
+#ifndef __CCTRANSITIONPROGRESS_H__
+#define __CCTRANSITIONPROGRESS_H__
 
 #include <cocos/2d/CCTransition.h>
 
-#include <chrono>
-
 NS_CC_BEGIN
 
 class ProgressTimer;
@@ -58,14 +57,15 @@ public:
     //
     // Overrides
     //
-    void onEnter() override;
-    void onExit() override;
+    virtual void onEnter() override;
+    virtual void onExit() override;
 
-    CC_CONSTRUCTOR_ACCESS : TransitionProgress();
-    ~TransitionProgress() override {}
+CC_CONSTRUCTOR_ACCESS:
+    TransitionProgress();
+    virtual ~TransitionProgress(){}
 
 protected:
-    void sceneOrder() override;
+    virtual void sceneOrder() override;
 
 protected:
     virtual ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture);
@@ -77,6 +77,7 @@ protected:
     Scene* _sceneToBeModified;
 };
 
+
 /** @class TransitionProgressRadialCCW
  * @brief TransitionRadialCCW transition.
  A counter clock-wise radial transition to the next scene
@@ -92,22 +93,22 @@ public:
      */
     static TransitionProgressRadialCCW* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        TransitionProgressRadialCCW()
-    {
-    }
-    ~TransitionProgressRadialCCW() override {}
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    TransitionProgressRadialCCW(){}
+    virtual ~TransitionProgressRadialCCW(){}
 
 protected:
     //
     // Overrides
     //
-    ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+    virtual ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+  
 };
 
+
 /** @class TransitionProgressRadialCW
  * @brief TransitionRadialCW transition.
  A counter clock-wise radial transition to the next scene.
@@ -123,20 +124,19 @@ public:
      */
     static TransitionProgressRadialCW* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        TransitionProgressRadialCW()
-    {
-    }
-    ~TransitionProgressRadialCW() override {}
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    TransitionProgressRadialCW(){}
+    virtual ~TransitionProgressRadialCW(){}
 
 protected:
     //
     // Overrides
     //
-    ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+    virtual ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+
 };
 
 /** @class TransitionProgressHorizontal
@@ -154,20 +154,18 @@ public:
      */
     static TransitionProgressHorizontal* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        TransitionProgressHorizontal()
-    {
-    }
-    ~TransitionProgressHorizontal() override {}
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    TransitionProgressHorizontal(){}
+    virtual ~TransitionProgressHorizontal(){}
 
 protected:
     //
     // Overrides
     //
-    ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+    virtual ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
 };
 
 /** @class TransitionProgressVertical
@@ -184,20 +182,18 @@ public:
      */
     static TransitionProgressVertical* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        TransitionProgressVertical()
-    {
-    }
-    ~TransitionProgressVertical() override {}
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    TransitionProgressVertical(){}
+    virtual ~TransitionProgressVertical(){}
 
 protected:
     //
     // Overrides
     //
-    ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+    virtual ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
 };
 
 /** @class TransitionProgressInOut
@@ -214,22 +210,20 @@ public:
      */
     static TransitionProgressInOut* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        TransitionProgressInOut()
-    {
-    }
-    ~TransitionProgressInOut() override {}
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    TransitionProgressInOut(){}
+    virtual ~TransitionProgressInOut(){}
 
 protected:
     //
     // Overrides
     //
-    ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
-    void sceneOrder() override;
-    void setupTransition() override;
+    virtual ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+    virtual void sceneOrder() override;
+    virtual void setupTransition() override;
 };
 
 /** @class TransitionProgressOutIn
@@ -246,20 +240,19 @@ public:
      */
     static TransitionProgressOutIn* create(std::chrono::milliseconds t, Scene* scene);
 
-    CC_CONSTRUCTOR_ACCESS :
-        /**
-         * @js ctor
-         */
-        TransitionProgressOutIn()
-    {
-    }
-    ~TransitionProgressOutIn() override {}
+CC_CONSTRUCTOR_ACCESS:
+    /**
+     * @js ctor
+     */
+    TransitionProgressOutIn(){}
+    virtual ~TransitionProgressOutIn(){}
 
 protected:
     //
     // Overrides
     //
-    ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+    virtual ProgressTimer* progressTimerNodeWithRenderTexture(RenderTexture* texture) override;
+
 };
 
 // end of _2d group
@@ -267,4 +260,5 @@ protected:
 
 NS_CC_END
 
-#endif // CC_2D_TRANSITIONPROGRESS_H
+#endif /* __CCTRANSITIONPROGRESS_H__ */
+
diff --git a/cocos2d/cocos/2d/CCTweenFunction.cpp b/cocos2d/cocos/2d/CCTweenFunction.cpp
index 0b401e6e13..54018de7b5 100644
--- a/cocos2d/cocos/2d/CCTweenFunction.cpp
+++ b/cocos2d/cocos/2d/CCTweenFunction.cpp
@@ -1,5 +1,6 @@
 /****************************************************************************
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -24,466 +25,525 @@ THE SOFTWARE.
 
 #include <cocos/2d/CCTweenFunction.h>
 
-#include <cocos/platform/CCPlatformMacros.h>
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wreserved-id-macro"
 #define _USE_MATH_DEFINES // needed for M_PI and M_PI2
-#include <cmath> // M_PI
+#include <math.h> // M_PI
 #undef _USE_MATH_DEFINES
-#pragma clang diagnostic pop
-
-#include <limits>
 
 NS_CC_BEGIN
 
-namespace tweenfunc
-{
+namespace tweenfunc {
+    
+
 #ifndef M_PI_X_2
-#    define M_PI_X_2 static_cast<float>(M_PI) * 2.0f
+#define M_PI_X_2 (float)M_PI * 2.0f
 #endif
 
-    float tweenTo(float time, TweenType type, float* easingParam)
-    {
-        float delta = 0.0f;
 
-        switch (type)
+
+
+float tweenTo(float time, TweenType type, float *easingParam)
+{
+    float delta = 0;
+
+    switch (type)
+    {
+        case CUSTOM_EASING:
+            delta = customEase(time, easingParam);
+            break;
+            
+        case Linear:
+            delta = linear(time);
+            break;
+            
+        case Sine_EaseIn:
+            delta = sineEaseIn(time);
+            break;
+        case Sine_EaseOut:
+            delta = sineEaseOut(time);
+            break;
+        case Sine_EaseInOut:
+            delta = sineEaseInOut(time);
+            break;
+            
+        case Quad_EaseIn:
+            delta = quadEaseIn(time);
+            break;
+        case Quad_EaseOut:
+            delta = quadEaseOut(time);
+            break;
+        case Quad_EaseInOut:
+            delta = quadEaseInOut(time);
+            break;
+            
+        case Cubic_EaseIn:
+            delta = cubicEaseIn(time);
+            break;
+        case Cubic_EaseOut:
+            delta = cubicEaseOut(time);
+            break;
+        case Cubic_EaseInOut:
+            delta = cubicEaseInOut(time);
+            break;
+            
+        case Quart_EaseIn:
+            delta = quartEaseIn(time);
+            break;
+        case Quart_EaseOut:
+            delta = quartEaseOut(time);
+            break;
+        case Quart_EaseInOut:
+            delta = quartEaseInOut(time);
+            break;
+            
+        case Quint_EaseIn:
+            delta = quintEaseIn(time);
+            break;
+        case Quint_EaseOut:
+            delta = quintEaseOut(time);
+            break;
+        case Quint_EaseInOut:
+            delta = quintEaseInOut(time);
+            break;
+            
+        case Expo_EaseIn:
+            delta = expoEaseIn(time);
+            break;
+        case Expo_EaseOut:
+            delta = expoEaseOut(time);
+            break;
+        case Expo_EaseInOut:
+            delta = expoEaseInOut(time);
+            break;
+            
+        case Circ_EaseIn:
+            delta = circEaseIn(time);
+            break;
+        case Circ_EaseOut:
+            delta = circEaseOut(time);
+            break;
+        case Circ_EaseInOut:
+            delta = circEaseInOut(time);
+            break;
+            
+        case Elastic_EaseIn:
         {
-            case CUSTOM_EASING:
-                delta = customEase(time, easingParam);
-                break;
-
-            case Linear:
-                delta = linear(time);
-                break;
-
-            case Sine_EaseIn:
-                delta = sineEaseIn(time);
-                break;
-            case Sine_EaseOut:
-                delta = sineEaseOut(time);
-                break;
-            case Sine_EaseInOut:
-                delta = sineEaseInOut(time);
-                break;
-
-            case Quad_EaseIn:
-                delta = quadEaseIn(time);
-                break;
-            case Quad_EaseOut:
-                delta = quadEaseOut(time);
-                break;
-            case Quad_EaseInOut:
-                delta = quadEaseInOut(time);
-                break;
-
-            case Cubic_EaseIn:
-                delta = cubicEaseIn(time);
-                break;
-            case Cubic_EaseOut:
-                delta = cubicEaseOut(time);
-                break;
-            case Cubic_EaseInOut:
-                delta = cubicEaseInOut(time);
-                break;
-
-            case Quart_EaseIn:
-                delta = quartEaseIn(time);
-                break;
-            case Quart_EaseOut:
-                delta = quartEaseOut(time);
-                break;
-            case Quart_EaseInOut:
-                delta = quartEaseInOut(time);
-                break;
-
-            case Quint_EaseIn:
-                delta = quintEaseIn(time);
-                break;
-            case Quint_EaseOut:
-                delta = quintEaseOut(time);
-                break;
-            case Quint_EaseInOut:
-                delta = quintEaseInOut(time);
-                break;
-
-            case Expo_EaseIn:
-                delta = expoEaseIn(time);
-                break;
-            case Expo_EaseOut:
-                delta = expoEaseOut(time);
-                break;
-            case Expo_EaseInOut:
-                delta = expoEaseInOut(time);
-                break;
-
-            case Circ_EaseIn:
-                delta = circEaseIn(time);
-                break;
-            case Circ_EaseOut:
-                delta = circEaseOut(time);
-                break;
-            case Circ_EaseInOut:
-                delta = circEaseInOut(time);
-                break;
-
-            case Elastic_EaseIn:
-            {
-                float period = 0.3f;
-                if (easingParam != nullptr)
-                {
-                    period = easingParam[0];
-                }
-                delta = elasticEaseIn(time, period);
+            float period = 0.3f;
+            if (nullptr != easingParam) {
+                period = easingParam[0];
             }
+            delta = elasticEaseIn(time, period);
+        }
             break;
-            case Elastic_EaseOut:
-            {
-                float period = 0.3f;
-                if (easingParam != nullptr)
-                {
-                    period = easingParam[0];
-                }
-                delta = elasticEaseOut(time, period);
+        case Elastic_EaseOut:
+        {
+            float period = 0.3f;
+            if (nullptr != easingParam) {
+                period = easingParam[0];
             }
+            delta = elasticEaseOut(time, period);
+        }
             break;
-            case Elastic_EaseInOut:
-            {
-                float period = 0.3f;
-                if (easingParam != nullptr)
-                {
-                    period = easingParam[0];
-                }
-                delta = elasticEaseInOut(time, period);
+        case Elastic_EaseInOut:
+        {
+            float period = 0.3f;
+            if (nullptr != easingParam) {
+                period = easingParam[0];
             }
+            delta = elasticEaseInOut(time, period);
+        }
+            break;
+            
+            
+        case Back_EaseIn:
+            delta = backEaseIn(time);
+            break;
+        case Back_EaseOut:
+            delta = backEaseOut(time);
+            break;
+        case Back_EaseInOut:
+            delta = backEaseInOut(time);
             break;
+            
+        case Bounce_EaseIn:
+            delta = bounceEaseIn(time);
+            break;
+        case Bounce_EaseOut:
+            delta = bounceEaseOut(time);
+            break;
+        case Bounce_EaseInOut:
+            delta = bounceEaseInOut(time);
+            break;
+            
+        default:
+            delta = sineEaseInOut(time);
+            break;
+    }
 
-            case Back_EaseIn:
-                delta = backEaseIn(time);
-                break;
-            case Back_EaseOut:
-                delta = backEaseOut(time);
-                break;
-            case Back_EaseInOut:
-                delta = backEaseInOut(time);
-                break;
-
-            case Bounce_EaseIn:
-                delta = bounceEaseIn(time);
-                break;
-            case Bounce_EaseOut:
-                delta = bounceEaseOut(time);
-                break;
-            case Bounce_EaseInOut:
-                delta = bounceEaseInOut(time);
-                break;
-
-            case TWEEN_EASING_MAX:
-                break;
-
-            default:
-                delta = sineEaseInOut(time);
-                break;
-        }
+    return delta;
+}
 
-        return delta;
-    }
+// Linear
+float linear(float time)
+{
+    return time;
+}
 
-    // Linear
-    float linear(float time) { return time; }
 
-    // Sine Ease
-    float sineEaseIn(float time) { return -1.0f * std::cos(time * static_cast<float>(M_PI_2)) + 1.0f; }
+// Sine Ease
+float sineEaseIn(float time)
+{
+    return -1 * cosf(time * (float)M_PI_2) + 1;
+}
+    
+float sineEaseOut(float time)
+{
+    return sinf(time * (float)M_PI_2);
+}
+    
+float sineEaseInOut(float time)
+{
+    return -0.5f * (cosf((float)M_PI * time) - 1);
+}
 
-    float sineEaseOut(float time) { return std::sin(time * static_cast<float>(M_PI_2)); }
 
-    float sineEaseInOut(float time) { return -0.5f * (std::cos(static_cast<float>(M_PI) * time) - 1.0f); }
+// Quad Ease
+float quadEaseIn(float time)
+{
+    return time * time;
+}
+    
+float quadEaseOut(float time)
+{
+    return -1 * time * (time - 2);
+}
+    
+float quadEaseInOut(float time)
+{
+    time = time*2;
+    if (time < 1)
+        return 0.5f * time * time;
+    --time;
+    return -0.5f * (time * (time - 2) - 1);
+}
 
-    // Quad Ease
-    float quadEaseIn(float time) { return time * time; }
 
-    float quadEaseOut(float time) { return -1.0f * time * (time - 2.0f); }
 
-    float quadEaseInOut(float time)
-    {
-        time = time * 2.0f;
-        if (time < 1.0f)
-            return 0.5f * time * time;
-        time -= 1.0f;
-        return -0.5f * (time * (time - 2.0f) - 1.0f);
-    }
+// Cubic Ease
+float cubicEaseIn(float time)
+{
+    return time * time * time;
+}
+float cubicEaseOut(float time)
+{
+    time -= 1;
+    return (time * time * time + 1);
+}
+float cubicEaseInOut(float time)
+{
+    time = time*2;
+    if (time < 1)
+        return 0.5f * time * time * time;
+    time -= 2;
+    return 0.5f * (time * time * time + 2);
+}
 
-    // Cubic Ease
-    float cubicEaseIn(float time) { return time * time * time; }
-    float cubicEaseOut(float time)
-    {
-        time -= 1.0f;
-        return (time * time * time) + 1.0f;
-    }
-    float cubicEaseInOut(float time)
-    {
-        time = time * 2.0f;
-        if (time < 1.0f)
-            return 0.5f * time * time * time;
-        time -= 2.0f;
-        return 0.5f * (time * time * time + 2.0f);
-    }
 
-    // Quart Ease
-    float quartEaseIn(float time) { return time * time * time * time; }
+// Quart Ease
+float quartEaseIn(float time)
+{
+    return time * time * time * time;
+}
+    
+float quartEaseOut(float time)
+{
+    time -= 1;
+    return -(time * time * time * time - 1);
+}
+    
+float quartEaseInOut(float time)
+{
+    time = time*2;
+    if (time < 1)
+        return 0.5f * time * time * time * time;
+    time -= 2;
+    return -0.5f * (time * time * time * time - 2);
+}
 
-    float quartEaseOut(float time)
-    {
-        time -= 1.0f;
-        return -(time * time * time * time - 1.0f);
-    }
 
-    float quartEaseInOut(float time)
-    {
-        time = time * 2.0f;
-        if (time < 1.0f)
-            return 0.5f * time * time * time * time;
-        time -= 2.0f;
-        return -0.5f * (time * time * time * time - 2.0f);
-    }
+// Quint Ease
+float quintEaseIn(float time)
+{
+    return time * time * time * time * time;
+}
+    
+float quintEaseOut(float time)
+{
+    time -=1;
+    return (time * time * time * time * time + 1);
+}
+    
+float quintEaseInOut(float time)
+{
+    time = time*2;
+    if (time < 1)
+        return 0.5f * time * time * time * time * time;
+    time -= 2;
+    return 0.5f * (time * time * time * time * time + 2);
+}
 
-    // Quint Ease
-    float quintEaseIn(float time) { return time * time * time * time * time; }
 
-    float quintEaseOut(float time)
-    {
-        time -= 1.0f;
-        return (time * time * time * time * time + 1.0f);
-    }
+// Expo Ease
+float expoEaseIn(float time)
+{
+    return time == 0 ? 0 : powf(2, 10 * (time/1 - 1)) - 1 * 0.001f;
+}
+float expoEaseOut(float time)
+{
+    return time == 1 ? 1 : (-powf(2, -10 * time / 1) + 1);
+}
+float expoEaseInOut(float time)
+{
+    if(time == 0 || time == 1) 
+        return time;
+    
+    if (time < 0.5f)
+        return 0.5f * powf(2, 10 * (time * 2 - 1));
 
-    float quintEaseInOut(float time)
+    return 0.5f * (-powf(2, -10 * (time * 2 - 1)) + 2);
+}
+
+
+// Circ Ease
+float circEaseIn(float time)
+{
+    return -1 * (sqrt(1 - time * time) - 1);
+}
+float circEaseOut(float time)
+{
+    time = time - 1;
+    return sqrt(1 - time * time);
+}
+float circEaseInOut(float time)
+{
+    time = time * 2;
+    if (time < 1)
+        return -0.5f * (sqrt(1 - time * time) - 1);
+    time -= 2;
+    return 0.5f * (sqrt(1 - time * time) + 1);
+}
+
+
+// Elastic Ease
+float elasticEaseIn(float time, float period)
+{
+
+    float newT = 0;
+    if (time == 0 || time == 1)
     {
-        time = time * 2.0f;
-        if (time < 1.0f)
-            return 0.5f * time * time * time * time * time;
-        time -= 2.0f;
-        return 0.5f * (time * time * time * time * time + 2.0f);
+        newT = time;
     }
-
-    // Expo Ease
-    float expoEaseIn(float time) { return std::abs(time) < std::numeric_limits<float>::epsilon() ? 0.0f : pow(2.0f, 10.0f * (time - 1.0f)) - 1.0f * 0.001f; }
-    float expoEaseOut(float time) { return std::abs(time - 1.f) < std::numeric_limits<float>::epsilon() ? 1.0f : (-std::pow(2.0f, -10.0f * time) + 1.0f); }
-    float expoEaseInOut(float time)
+    else
     {
-        time /= 0.5f;
-        if (time < 1.0f)
-        {
-            time = 0.5f * std::pow(2.0f, 10.0f * (time - 1.0f));
-        }
-        else
-        {
-            time = 0.5f * (-std::pow(2.0f, -10.0f * (time - 1.0f)) + 2.0f);
-        }
-
-        return time;
+        float s = period / 4;
+        time = time - 1;
+        newT = -powf(2, 10 * time) * sinf((time - s) * M_PI_X_2 / period);
     }
 
-    // Circ Ease
-    float circEaseIn(float time) { return -1.0f * (std::sqrt(1.0f - time * time) - 1.0f); }
-    float circEaseOut(float time)
+    return newT;
+}
+float elasticEaseOut(float time, float period)
+{
+
+    float newT = 0;
+    if (time == 0 || time == 1)
     {
-        time = time - 1.0f;
-        return std::sqrt(1.0f - time * time);
+        newT = time;
     }
-    float circEaseInOut(float time)
+    else
     {
-        time = time * 2.0f;
-        if (time < 1.0f)
-            return -0.5f * (std::sqrt(1.0f - time * time) - 1.0f);
-        time -= 2.0f;
-        return 0.5f * (std::sqrt(1.0f - time * time) + 1.0f);
+        float s = period / 4;
+        newT = powf(2, -10 * time) * sinf((time - s) * M_PI_X_2 / period) + 1;
     }
 
-    // Elastic Ease
-    float elasticEaseIn(float time, float period)
+    return newT;
+}
+float elasticEaseInOut(float time, float period)
+{
+
+    float newT = 0;
+    if (time == 0 || time == 1)
     {
-        float newT = 0.0f;
-        if (std::abs(time) < std::numeric_limits<float>::epsilon() || std::abs(time - 1.0f) < std::numeric_limits<float>::epsilon())
-        {
-            newT = time;
-        }
-        else
-        {
-            float s = period * 0.25f;
-            time = time - 1.0f;
-            newT = -std::pow(2.0f, 10.0f * time) * std::sin((time - s) * M_PI_X_2 / period);
-        }
-        return newT;
+        newT = time;
     }
-    float elasticEaseOut(float time, float period)
+    else
     {
-        float newT = 0.0f;
-        if (std::abs(time) < std::numeric_limits<float>::epsilon() || std::abs(time - 1.0f) < std::numeric_limits<float>::epsilon())
-        {
-            newT = time;
-        }
-        else
+        time = time * 2;
+        if (! period)
         {
-            float s = period * 0.25f;
-            newT = std::pow(2.0f, -10.0f * time) * std::sin((time - s) * M_PI_X_2 / period) + 1.0f;
+            period = 0.3f * 1.5f;
         }
 
-        return newT;
-    }
-    float elasticEaseInOut(float time, float period)
-    {
-        float newT = 0.0f;
-        if (std::abs(time) < std::numeric_limits<float>::epsilon() || std::abs(time - 1.f) < std::numeric_limits<float>::epsilon())
+        float s = period / 4;
+
+        time = time - 1;
+        if (time < 0)
         {
-            newT = time;
+            newT = -0.5f * powf(2, 10 * time) * sinf((time -s) * M_PI_X_2 / period);
         }
         else
         {
-            time = time * 2.0f;
-            if (std::abs(period) < std::numeric_limits<float>::epsilon())
-            {
-                period = 0.3f * 1.5f;
-            }
-
-            float s = period * 0.25f;
-
-            time = time - 1.0f;
-            if (time < 0.0f)
-            {
-                newT = -0.5f * std::pow(2.0f, 10.0f * time) * std::sin((time - s) * M_PI_X_2 / period);
-            }
-            else
-            {
-                newT = std::pow(2.0f, -10.0f * time) * std::sin((time - s) * M_PI_X_2 / period) * 0.5f + 1.0f;
-            }
+            newT = powf(2, -10 * time) * sinf((time - s) * M_PI_X_2 / period) * 0.5f + 1;
         }
-        return newT;
     }
+    return newT;
+}
 
-    // Back Ease
-    float backEaseIn(float time)
+
+// Back Ease
+float backEaseIn(float time)
+{
+    float overshoot = 1.70158f;
+    return time * time * ((overshoot + 1) * time - overshoot);
+}
+float backEaseOut(float time)
+{
+    float overshoot = 1.70158f;
+
+    time = time - 1;
+    return time * time * ((overshoot + 1) * time + overshoot) + 1;
+}
+float backEaseInOut(float time)
+{
+    float overshoot = 1.70158f * 1.525f;
+
+    time = time * 2;
+    if (time < 1)
     {
-        float overshoot = 1.70158f;
-        return time * time * ((overshoot + 1.0f) * time - overshoot);
+        return (time * time * ((overshoot + 1) * time - overshoot)) / 2;
     }
-    float backEaseOut(float time)
+    else
     {
-        float overshoot = 1.70158f;
+        time = time - 2;
+        return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;
+    }
+}
+
 
-        time = time - 1.0f;
-        return time * time * ((overshoot + 1.0f) * time + overshoot) + 1.0f;
+
+// Bounce Ease
+float bounceTime(float time)
+{
+    if (time < 1 / 2.75f)
+    {
+        return 7.5625f * time * time;
     }
-    float backEaseInOut(float time)
+    else if (time < 2 / 2.75f)
     {
-        float overshoot = 1.70158f * 1.525f;
-
-        time = time * 2.0f;
-        if (time < 1.0f)
-        {
-            return (time * time * ((overshoot + 1.0f) * time - overshoot)) * 0.5f;
-        }
-        else
-        {
-            time = time - 2.0f;
-            return (time * time * ((overshoot + 1.0f) * time + overshoot)) * 0.5f + 1.0f;
-        }
+        time -= 1.5f / 2.75f;
+        return 7.5625f * time * time + 0.75f;
     }
-
-    // Bounce Ease
-    float bounceTime(float time)
+    else if(time < 2.5f / 2.75f)
     {
-        if (time < 1.0f / 2.75f)
-        {
-            return 7.5625f * time * time;
-        }
-        else if (time < 2.0f / 2.75f)
-        {
-            time -= 1.5f / 2.75f;
-            return 7.5625f * time * time + 0.75f;
-        }
-        else if (time < 2.5f / 2.75f)
-        {
-            time -= 2.25f / 2.75f;
-            return 7.5625f * time * time + 0.9375f;
-        }
-
-        time -= 2.625f / 2.75f;
-        return 7.5625f * time * time + 0.984375f;
+        time -= 2.25f / 2.75f;
+        return 7.5625f * time * time + 0.9375f;
     }
-    float bounceEaseIn(float time) { return 1.0f - bounceTime(1.0f - time); }
 
-    float bounceEaseOut(float time) { return bounceTime(time); }
+    time -= 2.625f / 2.75f;
+    return 7.5625f * time * time + 0.984375f;
+}
+float bounceEaseIn(float time)
+{
+    return 1 - bounceTime(1 - time);
+}
 
-    float bounceEaseInOut(float time)
-    {
-        float newT = 0.0f;
-        if (time < 0.5f)
-        {
-            time = time * 2.0f;
-            newT = (1.0f - bounceTime(1.0f - time)) * 0.5f;
-        }
-        else
-        {
-            newT = bounceTime(time * 2.0f - 1.0f) * 0.5f + 0.5f;
-        }
+float bounceEaseOut(float time)
+{
+    return bounceTime(time);
+}
 
-        return newT;
+float bounceEaseInOut(float time)
+{
+    float newT = 0;
+    if (time < 0.5f)
+    {
+        time = time * 2;
+        newT = (1 - bounceTime(1 - time)) * 0.5f;
     }
-
-    // Custom Ease
-    float customEase(float time, float* easingParam)
+    else
     {
-        if (easingParam != nullptr)
-        {
-            float tt = 1.0f - time;
-            return easingParam[1] * tt * tt * tt + 3.0f * easingParam[3] * time * tt * tt + 3.0f * easingParam[5] * time * time * tt +
-                easingParam[7] * time * time * time;
-        }
-        return time;
+        newT = bounceTime(time * 2 - 1) * 0.5f + 0.5f;
     }
 
-    float easeIn(float time, float rate) { return std::pow(time, rate); }
+    return newT;
+}
 
-    float easeOut(float time, float rate) { return 1 - std::pow(1 - time, rate); }
 
-    float easeInOut(float time, float rate)
+// Custom Ease
+float customEase(float time, float *easingParam)
+{
+    if (easingParam)
     {
-        time *= 2.0f;
-        if (time < 1.0f)
-        {
-            return 0.5f * std::pow(time, rate);
-        }
-        else
-        {
-            return (1.0f - 0.5f * std::pow(2.f - time, rate));
-        }
+        float tt = 1-time;
+        return easingParam[1]*tt*tt*tt + 3*easingParam[3]*time*tt*tt + 3*easingParam[5]*time*time*tt + easingParam[7]*time*time*time;
     }
+    return time;
+}
 
-    float quadraticIn(float time) { return std::pow(time, 2.0f); }
-
-    float quadraticOut(float time) { return -time * (time - 2.0f); }
+float easeIn(float time, float rate)
+{
+    return powf(time, rate);
+}
 
-    float quadraticInOut(float time)
+float easeOut(float time, float rate)
+{
+    return powf(time, 1 / rate);
+}
+    
+float easeInOut(float time, float rate)
+{
+    time *= 2;
+    if (time < 1)
     {
-        float resultTime = time;
-        time = time * 2.0f;
-        if (time < 1.0f)
-        {
-            resultTime = time * time * 0.5f;
-        }
-        else
-        {
-            --time;
-            resultTime = -0.5f * (time * (time - 2.0f) - 1.0f);
-        }
-        return resultTime;
+        return 0.5f * powf(time, rate);
     }
-
-    float bezieratFunction(float a, float b, float c, float d, float t)
+    else
     {
-        return (std::pow(1.0f - t, 3.0f) * a + 3.0f * t * (std::pow(1.0f - t, 2.0f)) * b + 3.0f * std::pow(t, 2.0f) * (1.0f - t) * c + std::pow(t, 3.0f) * d);
+        return (1.0f - 0.5f * powf(2 - time, rate));
     }
-
-} // namespace tweenfunc
+}
+    
+float quadraticIn(float time)
+{
+    return   powf(time,2);
+}
+    
+float quadraticOut(float time)
+{
+    return -time*(time-2);
+}
+    
+float quadraticInOut(float time)
+{
+    
+    float resultTime = time;
+    time = time*2;
+    if (time < 1)
+    {
+        resultTime = time * time * 0.5f;
+    }
+    else
+    {
+        --time;
+        resultTime = -0.5f * (time * (time - 2) - 1);
+    }
+    return resultTime;
+}
+    
+float bezieratFunction( float a, float b, float c, float d, float t )
+{
+    return (powf(1-t,3) * a + 3*t*(powf(1-t,2))*b + 3*powf(t,2)*(1-t)*c + powf(t,3)*d );
+}
+    
+}
 
 NS_CC_END
diff --git a/cocos2d/cocos/2d/CCTweenFunction.h b/cocos2d/cocos/2d/CCTweenFunction.h
index ee10be49f8..dc7792c71e 100644
--- a/cocos2d/cocos/2d/CCTweenFunction.h
+++ b/cocos2d/cocos/2d/CCTweenFunction.h
@@ -1,5 +1,6 @@
 /****************************************************************************
 Copyright (c) 2013-2016 Chukong Technologies Inc.
+Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
 
 http://www.cocos2d-x.org
 
@@ -22,278 +23,278 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
 
-#ifndef CC_2D_TWEENFUNCTION_H
-#define CC_2D_TWEENFUNCTION_H
+#ifndef __CCTWEENFUNCTION_H__
+#define __CCTWEENFUNCTION_H__
 
 /// @cond DO_NOT_SHOW
 
-#include <cocos/platform/CCPlatformDefine.h>
 #include <cocos/platform/CCPlatformMacros.h>
 
 NS_CC_BEGIN
 
-namespace tweenfunc
-{
+namespace tweenfunc {
     enum TweenType
     {
         CUSTOM_EASING = -1,
-
+        
         Linear,
-
+        
         Sine_EaseIn,
         Sine_EaseOut,
         Sine_EaseInOut,
-
+        
+        
         Quad_EaseIn,
         Quad_EaseOut,
         Quad_EaseInOut,
-
+        
         Cubic_EaseIn,
         Cubic_EaseOut,
         Cubic_EaseInOut,
-
+        
         Quart_EaseIn,
         Quart_EaseOut,
         Quart_EaseInOut,
-
+        
         Quint_EaseIn,
         Quint_EaseOut,
         Quint_EaseInOut,
-
+        
         Expo_EaseIn,
         Expo_EaseOut,
         Expo_EaseInOut,
-
+        
         Circ_EaseIn,
         Circ_EaseOut,
         Circ_EaseInOut,
-
+        
         Elastic_EaseIn,
         Elastic_EaseOut,
         Elastic_EaseInOut,
-
+        
         Back_EaseIn,
         Back_EaseOut,
         Back_EaseInOut,
-
+        
         Bounce_EaseIn,
         Bounce_EaseOut,
         Bounce_EaseInOut,
-
+        
         TWEEN_EASING_MAX = 10000
     };
-
-    // tween functions for CCActionEase
+    
+    
+    //tween functions for CCActionEase
     /**
      * @param time in seconds.
      */
     float CC_DLL easeIn(float time, float rate);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL easeOut(float time, float rate);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL easeInOut(float time, float rate);
-
+    
     /**
      * @param time in seconds.
      */
-    float CC_DLL bezieratFunction(float a, float b, float c, float d, float t);
-
+    float CC_DLL bezieratFunction( float a, float b, float c, float d, float t );
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quadraticIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quadraticOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quadraticInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quadraticInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
-    float CC_DLL tweenTo(float time, TweenType type, float* easingParam);
-
+    float CC_DLL tweenTo(float time, TweenType type, float *easingParam);
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL linear(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL sineEaseIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL sineEaseOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL sineEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quadEaseIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quadEaseOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quadEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL cubicEaseIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL cubicEaseOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL cubicEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quartEaseIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quartEaseOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quartEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quintEaseIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL quintEaseOut(float time);
-
+    
     /**
-         @param time in seconds.
-         */
+     @param time in seconds.
+     */
     float CC_DLL quintEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL expoEaseIn(float time);
-
+    
     /**
-         @param time in seconds.
-         */
+     @param time in seconds.
+     */
     float CC_DLL expoEaseOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL expoEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL circEaseIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL circEaseOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL circEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      * @param period in seconds.
      */
     float CC_DLL elasticEaseIn(float time, float period);
-
+    
     /**
      * @param time in seconds.
      * @param period in seconds.
      */
     float CC_DLL elasticEaseOut(float time, float period);
-
+    
     /**
      * @param time in seconds.
      * @param period in seconds.
      */
     float CC_DLL elasticEaseInOut(float time, float period);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL backEaseIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL backEaseOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL backEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL bounceEaseIn(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL bounceEaseOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
     float CC_DLL bounceEaseInOut(float time);
-
+    
     /**
      * @param time in seconds.
      */
-    float CC_DLL customEase(float time, float* easingParam);
-} // namespace tweenfunc
+    float CC_DLL customEase(float time, float *easingParam);
+}
 
 NS_CC_END
 
 /// @endcond
-#endif // CC_2D_TWEENFUNCTION_H
+#endif /*__CCTWEENFUNCTION_H__*/
diff --git a/cocos2d/cocos/2d/CMakeLists.txt b/cocos2d/cocos/2d/CMakeLists.txt
index f58926e617..1e91e009eb 100644
--- a/cocos2d/cocos/2d/CMakeLists.txt
+++ b/cocos2d/cocos/2d/CMakeLists.txt
@@ -1,84 +1,139 @@
-include_directories(
-  ../external/ConvertUTF
-  ../external/poly2tri
-  ../external/poly2tri/common
-  ../external/poly2tri/sweep
-)
+set(COCOS_2D_HEADER
 
-set(COCOS_2D_SRC
+    2d/CCActionPageTurn3D.h
+    2d/CCActionTween.h
+    2d/CCGrid.h
+    2d/CCSpriteFrameCache.h
+    2d/CCTMXTiledMap.h
+    2d/CCLayer.h
+    2d/CCActionCamera.h
+    2d/CCParticleExamples.h
+    2d/CCSprite.h
+    2d/CCNode.h
+    2d/CCComponentContainer.h
+    2d/CCActionProgressTimer.h
+    2d/CCTweenFunction.h
+    2d/CCLight.h
+    2d/CCAutoPolygon.h
+    2d/CCFontAtlas.h
+    2d/CCAtlasNode.h
+    2d/CCClippingNode.h
+    2d/CCRenderTexture.h
+    2d/CCActionInterval.h
+    2d/CCTMXXMLParser.h
+    2d/CCActionInstant.h
+    2d/CCLabel.h
+    2d/CCComponent.h
+    2d/CCLabelAtlas.h
+    2d/CCActionCatmullRom.h
+    2d/CCActionGrid.h
+    2d/CCParticleBatchNode.h
+    2d/CCClippingRectangleNode.h
+    2d/CCActionEase.h
+    2d/CCScene.h
+    2d/CCProtectedNode.h
+    2d/CCTextFieldTTF.h
+    2d/CCAnimationCache.h
+    2d/CCFastTMXLayer.h
+    2d/CCFontAtlasCache.h
+    2d/CCFont.h
+    2d/CCParticleSystemQuad.h
+    2d/CCActionGrid3D.h
+    2d/CCCameraBackgroundBrush.h
+    2d/CCFastTMXTiledMap.h
+    2d/CCLabelTextFormatter.h
+    2d/CCMenuItem.h
+    2d/CCFontFNT.h
+    2d/CCSpriteBatchNode.h
+    2d/CCTransitionProgress.h
+    2d/CCSpriteFrame.h
+    2d/CCTMXObjectGroup.h
+    2d/CCAnimation.h
+    2d/CCNodeGrid.h
+    2d/CCFontFreeType.h
+    2d/CCAction.h
+    2d/CCTransition.h
+    2d/CCTransitionPageTurn.h
+    2d/CCFontCharMap.h
+    2d/CCParticleSystem.h
+    2d/CCProgressTimer.h
+    2d/CCTileMapAtlas.h
+    2d/CCActionTiledGrid.h
+    2d/CCActionManager.h
+    2d/CCMotionStreak.h
+    2d/CCMenu.h
+    2d/CCDrawNode.h
+    2d/CCTMXLayer.h
+    2d/CCCamera.h
+    2d/CCParallaxNode.h
+    )
 
-  2d/CCActionCamera.cpp
-  2d/CCActionCatmullRom.cpp
-  2d/CCAction.cpp
-  2d/CCActionEase.cpp
-  2d/CCActionGrid3D.cpp
-  2d/CCActionGrid.cpp
-  2d/CCActionInstant.cpp
-  2d/CCActionInterval.cpp
-  2d/CCActionManager.cpp
-  2d/CCActionManagerData.cpp
-  2d/CCActionPageTurn3D.cpp
-  2d/CCActionProgressTimer.cpp
-  2d/CCActionTiledGrid.cpp
-  2d/CCActionTween.cpp
-  2d/CCAnimationCache.cpp
-  2d/CCAnimation.cpp
-  2d/CCAtlasNode.cpp
-  2d/CCCamera.cpp
-  2d/CCCameraBackgroundBrush.cpp
-  2d/CCClippingNode.cpp
-  2d/CCClippingRectangleNode.cpp
-  2d/CCComponentContainer.cpp
-  2d/CCComponent.cpp
-  2d/CCDrawingPrimitives.cpp
-  2d/CCDrawNode.cpp
-  2d/CCFastTMXLayer.cpp
-  2d/CCFastTMXTiledMap.cpp
-  2d/CCFontAtlasCache.cpp
-  2d/CCFontAtlas.cpp
-  2d/CCFontCharMap.cpp
-  2d/CCFont.cpp
-  2d/CCFontFNT.cpp
-  2d/CCFontFreeType.cpp
-  2d/CCGLBufferedNode.cpp
-  2d/CCGrabber.cpp
-  2d/CCGrid.cpp
-  2d/CCLabelAtlas.cpp
-  2d/CCLabelBMFont.cpp
-  2d/CCLabel.cpp
-  2d/CCLabelTextFormatter.cpp
-  2d/CCLabelTTF.cpp
-  2d/CCLayer.cpp
-  2d/CCLight.cpp
-  2d/CCMenu.cpp
-  2d/CCMenuItem.cpp
-  2d/CCMotionStreak.cpp
-  2d/CCNode.cpp
-  2d/CCNodeGrid.cpp
-  2d/CCParallaxNode.cpp
-  2d/CCParticleBatchNode.cpp
-  2d/CCParticleExamples.cpp
-  2d/CCParticleSystem.cpp
-  2d/CCParticleSystemQuad.cpp
-  2d/CCProgressTimer.cpp
-  2d/CCProtectedNode.cpp
-  2d/CCRenderTexture.cpp
-  2d/CCScene.cpp
-  2d/CCSpriteBatchNode.cpp
-  2d/CCSprite.cpp
-  2d/CCSpriteFrameCache.cpp
-  2d/CCSpriteFrame.cpp
-  2d/CCAutoPolygon.cpp
-  ../external/clipper/clipper.cpp
-  2d/CCTextFieldTTF.cpp
-  2d/CCTileMapAtlas.cpp
-  2d/CCTMXLayer.cpp
-  2d/CCTMXObjectGroup.cpp
-  2d/CCTMXTiledMap.cpp
-  2d/CCTMXXMLParser.cpp
-  2d/CCTransition.cpp
-  2d/CCTransitionPageTurn.cpp
-  2d/CCTransitionProgress.cpp
-  2d/CCTweenFunction.cpp
+set(COCOS_2D_SRC
 
-)
+    2d/CCActionCamera.cpp
+    2d/CCActionCatmullRom.cpp
+    2d/CCAction.cpp
+    2d/CCActionEase.cpp
+    2d/CCActionGrid3D.cpp
+    2d/CCActionGrid.cpp
+    2d/CCActionInstant.cpp
+    2d/CCActionInterval.cpp
+    2d/CCActionManager.cpp
+    2d/CCActionPageTurn3D.cpp
+    2d/CCActionProgressTimer.cpp
+    2d/CCActionTiledGrid.cpp
+    2d/CCActionTween.cpp
+    2d/CCAnimationCache.cpp
+    2d/CCAnimation.cpp
+    2d/CCAtlasNode.cpp
+    2d/CCCamera.cpp
+    2d/CCCameraBackgroundBrush.cpp
+    2d/CCClippingNode.cpp
+    2d/CCClippingRectangleNode.cpp
+    2d/CCComponentContainer.cpp
+    2d/CCComponent.cpp
+    2d/CCDrawNode.cpp
+    2d/CCFastTMXLayer.cpp
+    2d/CCFastTMXTiledMap.cpp
+    2d/CCFontAtlasCache.cpp
+    2d/CCFontAtlas.cpp
+    2d/CCFontCharMap.cpp
+    2d/CCFont.cpp
+    2d/CCFontFNT.cpp
+    2d/CCFontFreeType.cpp
+    2d/CCGrid.cpp
+    2d/CCLabelAtlas.cpp
+    2d/CCLabel.cpp
+    2d/CCLabelTextFormatter.cpp
+    2d/CCLayer.cpp
+    2d/CCLight.cpp
+    2d/CCMenu.cpp
+    2d/CCMenuItem.cpp
+    2d/CCMotionStreak.cpp
+    2d/CCNode.cpp
+    2d/CCNodeGrid.cpp
+    2d/CCParallaxNode.cpp
+    2d/CCParticleBatchNode.cpp
+    2d/CCParticleExamples.cpp
+    2d/CCParticleSystem.cpp
+    2d/CCParticleSystemQuad.cpp
+    2d/CCProgressTimer.cpp
+    2d/CCProtectedNode.cpp
+    2d/CCRenderTexture.cpp
+    2d/CCScene.cpp
+    2d/CCSpriteBatchNode.cpp
+    2d/CCSprite.cpp
+    2d/CCSpriteFrameCache.cpp
+    2d/CCSpriteFrame.cpp
+    2d/CCAutoPolygon.cpp
+    2d/CCTextFieldTTF.cpp
+    2d/CCTileMapAtlas.cpp
+    2d/CCTMXLayer.cpp
+    2d/CCTMXObjectGroup.cpp
+    2d/CCTMXTiledMap.cpp
+    2d/CCTMXXMLParser.cpp
+    2d/CCTransition.cpp
+    2d/CCTransitionPageTurn.cpp
+    2d/CCTransitionProgress.cpp
+    2d/CCTweenFunction.cpp
+    )
